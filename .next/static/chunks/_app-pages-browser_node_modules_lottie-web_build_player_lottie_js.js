"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["_app-pages-browser_node_modules_lottie-web_build_player_lottie_js"],{

/***/ "(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js":
/*!********************************************************!*\
  !*** ./node_modules/lottie-web/build/player/lottie.js ***!
  \********************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval(__webpack_require__.ts("\ntypeof document !== \"undefined\" && typeof navigator !== \"undefined\" && function(global, factory) {\n     true ? module.exports = factory() : 0;\n}(void 0, function() {\n    'use strict';\n    var svgNS = 'http://www.w3.org/2000/svg';\n    var locationHref = '';\n    var _useWebWorker = false;\n    var initialDefaultFrame = -999999;\n    var setWebWorker = function setWebWorker(flag) {\n        _useWebWorker = !!flag;\n    };\n    var getWebWorker = function getWebWorker() {\n        return _useWebWorker;\n    };\n    var setLocationHref = function setLocationHref(value) {\n        locationHref = value;\n    };\n    var getLocationHref = function getLocationHref() {\n        return locationHref;\n    };\n    function createTag(type) {\n        // return {appendChild:function(){},setAttribute:function(){},style:{}}\n        return document.createElement(type);\n    }\n    function extendPrototype(sources, destination) {\n        var i;\n        var len = sources.length;\n        var sourcePrototype;\n        for(i = 0; i < len; i += 1){\n            sourcePrototype = sources[i].prototype;\n            for(var attr in sourcePrototype){\n                if (Object.prototype.hasOwnProperty.call(sourcePrototype, attr)) destination.prototype[attr] = sourcePrototype[attr];\n            }\n        }\n    }\n    function getDescriptor(object, prop) {\n        return Object.getOwnPropertyDescriptor(object, prop);\n    }\n    function createProxyFunction(prototype) {\n        function ProxyFunction() {}\n        ProxyFunction.prototype = prototype;\n        return ProxyFunction;\n    }\n    // import Howl from '../../3rd_party/howler';\n    var audioControllerFactory = function() {\n        function AudioController(audioFactory) {\n            this.audios = [];\n            this.audioFactory = audioFactory;\n            this._volume = 1;\n            this._isMuted = false;\n        }\n        AudioController.prototype = {\n            addAudio: function addAudio(audio) {\n                this.audios.push(audio);\n            },\n            pause: function pause() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].pause();\n                }\n            },\n            resume: function resume() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].resume();\n                }\n            },\n            setRate: function setRate(rateValue) {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].setRate(rateValue);\n                }\n            },\n            createAudio: function createAudio(assetPath) {\n                if (this.audioFactory) {\n                    return this.audioFactory(assetPath);\n                }\n                if (window.Howl) {\n                    return new window.Howl({\n                        src: [\n                            assetPath\n                        ]\n                    });\n                }\n                return {\n                    isPlaying: false,\n                    play: function play() {\n                        this.isPlaying = true;\n                    },\n                    seek: function seek() {\n                        this.isPlaying = false;\n                    },\n                    playing: function playing() {},\n                    rate: function rate() {},\n                    setVolume: function setVolume() {}\n                };\n            },\n            setAudioFactory: function setAudioFactory(audioFactory) {\n                this.audioFactory = audioFactory;\n            },\n            setVolume: function setVolume(value) {\n                this._volume = value;\n                this._updateVolume();\n            },\n            mute: function mute() {\n                this._isMuted = true;\n                this._updateVolume();\n            },\n            unmute: function unmute() {\n                this._isMuted = false;\n                this._updateVolume();\n            },\n            getVolume: function getVolume() {\n                return this._volume;\n            },\n            _updateVolume: function _updateVolume() {\n                var i;\n                var len = this.audios.length;\n                for(i = 0; i < len; i += 1){\n                    this.audios[i].volume(this._volume * (this._isMuted ? 0 : 1));\n                }\n            }\n        };\n        return function() {\n            return new AudioController();\n        };\n    }();\n    var createTypedArray = function() {\n        function createRegularArray(type, len) {\n            var i = 0;\n            var arr = [];\n            var value;\n            switch(type){\n                case 'int16':\n                case 'uint8c':\n                    value = 1;\n                    break;\n                default:\n                    value = 1.1;\n                    break;\n            }\n            for(i = 0; i < len; i += 1){\n                arr.push(value);\n            }\n            return arr;\n        }\n        function createTypedArrayFactory(type, len) {\n            if (type === 'float32') {\n                return new Float32Array(len);\n            }\n            if (type === 'int16') {\n                return new Int16Array(len);\n            }\n            if (type === 'uint8c') {\n                return new Uint8ClampedArray(len);\n            }\n            return createRegularArray(type, len);\n        }\n        if (typeof Uint8ClampedArray === 'function' && typeof Float32Array === 'function') {\n            return createTypedArrayFactory;\n        }\n        return createRegularArray;\n    }();\n    function createSizedArray(len) {\n        return Array.apply(null, {\n            length: len\n        });\n    }\n    function _typeof$6(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof$6 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof$6(o);\n    }\n    var subframeEnabled = true;\n    var expressionsPlugin = null;\n    var expressionsInterfaces = null;\n    var idPrefix$1 = '';\n    var isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);\n    var _shouldRoundValues = false;\n    var bmPow = Math.pow;\n    var bmSqrt = Math.sqrt;\n    var bmFloor = Math.floor;\n    var bmMax = Math.max;\n    var bmMin = Math.min;\n    var BMMath = {};\n    (function() {\n        var propertyNames = [\n            'abs',\n            'acos',\n            'acosh',\n            'asin',\n            'asinh',\n            'atan',\n            'atanh',\n            'atan2',\n            'ceil',\n            'cbrt',\n            'expm1',\n            'clz32',\n            'cos',\n            'cosh',\n            'exp',\n            'floor',\n            'fround',\n            'hypot',\n            'imul',\n            'log',\n            'log1p',\n            'log2',\n            'log10',\n            'max',\n            'min',\n            'pow',\n            'random',\n            'round',\n            'sign',\n            'sin',\n            'sinh',\n            'sqrt',\n            'tan',\n            'tanh',\n            'trunc',\n            'E',\n            'LN10',\n            'LN2',\n            'LOG10E',\n            'LOG2E',\n            'PI',\n            'SQRT1_2',\n            'SQRT2'\n        ];\n        var i;\n        var len = propertyNames.length;\n        for(i = 0; i < len; i += 1){\n            BMMath[propertyNames[i]] = Math[propertyNames[i]];\n        }\n    })();\n    function ProjectInterface$1() {\n        return {};\n    }\n    BMMath.random = Math.random;\n    BMMath.abs = function(val) {\n        var tOfVal = _typeof$6(val);\n        if (tOfVal === 'object' && val.length) {\n            var absArr = createSizedArray(val.length);\n            var i;\n            var len = val.length;\n            for(i = 0; i < len; i += 1){\n                absArr[i] = Math.abs(val[i]);\n            }\n            return absArr;\n        }\n        return Math.abs(val);\n    };\n    var defaultCurveSegments = 150;\n    var degToRads = Math.PI / 180;\n    var roundCorner = 0.5519;\n    function roundValues(flag) {\n        _shouldRoundValues = !!flag;\n    }\n    function bmRnd(value) {\n        if (_shouldRoundValues) {\n            return Math.round(value);\n        }\n        return value;\n    }\n    function styleDiv(element) {\n        element.style.position = 'absolute';\n        element.style.top = 0;\n        element.style.left = 0;\n        element.style.display = 'block';\n        element.style.transformOrigin = '0 0';\n        element.style.webkitTransformOrigin = '0 0';\n        element.style.backfaceVisibility = 'visible';\n        element.style.webkitBackfaceVisibility = 'visible';\n        element.style.transformStyle = 'preserve-3d';\n        element.style.webkitTransformStyle = 'preserve-3d';\n        element.style.mozTransformStyle = 'preserve-3d';\n    }\n    function BMEnterFrameEvent(type, currentTime, totalTime, frameMultiplier) {\n        this.type = type;\n        this.currentTime = currentTime;\n        this.totalTime = totalTime;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMCompleteEvent(type, frameMultiplier) {\n        this.type = type;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMCompleteLoopEvent(type, totalLoops, currentLoop, frameMultiplier) {\n        this.type = type;\n        this.currentLoop = currentLoop;\n        this.totalLoops = totalLoops;\n        this.direction = frameMultiplier < 0 ? -1 : 1;\n    }\n    function BMSegmentStartEvent(type, firstFrame, totalFrames) {\n        this.type = type;\n        this.firstFrame = firstFrame;\n        this.totalFrames = totalFrames;\n    }\n    function BMDestroyEvent(type, target) {\n        this.type = type;\n        this.target = target;\n    }\n    function BMRenderFrameErrorEvent(nativeError, currentTime) {\n        this.type = 'renderFrameError';\n        this.nativeError = nativeError;\n        this.currentTime = currentTime;\n    }\n    function BMConfigErrorEvent(nativeError) {\n        this.type = 'configError';\n        this.nativeError = nativeError;\n    }\n    function BMAnimationConfigErrorEvent(type, nativeError) {\n        this.type = type;\n        this.nativeError = nativeError;\n    }\n    var createElementID = function() {\n        var _count = 0;\n        return function createID() {\n            _count += 1;\n            return idPrefix$1 + '__lottie_element_' + _count;\n        };\n    }();\n    function HSVtoRGB(h, s, v) {\n        var r;\n        var g;\n        var b;\n        var i;\n        var f;\n        var p;\n        var q;\n        var t;\n        i = Math.floor(h * 6);\n        f = h * 6 - i;\n        p = v * (1 - s);\n        q = v * (1 - f * s);\n        t = v * (1 - (1 - f) * s);\n        switch(i % 6){\n            case 0:\n                r = v;\n                g = t;\n                b = p;\n                break;\n            case 1:\n                r = q;\n                g = v;\n                b = p;\n                break;\n            case 2:\n                r = p;\n                g = v;\n                b = t;\n                break;\n            case 3:\n                r = p;\n                g = q;\n                b = v;\n                break;\n            case 4:\n                r = t;\n                g = p;\n                b = v;\n                break;\n            case 5:\n                r = v;\n                g = p;\n                b = q;\n                break;\n            default:\n                break;\n        }\n        return [\n            r,\n            g,\n            b\n        ];\n    }\n    function RGBtoHSV(r, g, b) {\n        var max = Math.max(r, g, b);\n        var min = Math.min(r, g, b);\n        var d = max - min;\n        var h;\n        var s = max === 0 ? 0 : d / max;\n        var v = max / 255;\n        switch(max){\n            case min:\n                h = 0;\n                break;\n            case r:\n                h = g - b + d * (g < b ? 6 : 0);\n                h /= 6 * d;\n                break;\n            case g:\n                h = b - r + d * 2;\n                h /= 6 * d;\n                break;\n            case b:\n                h = r - g + d * 4;\n                h /= 6 * d;\n                break;\n            default:\n                break;\n        }\n        return [\n            h,\n            s,\n            v\n        ];\n    }\n    function addSaturationToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[1] += offset;\n        if (hsv[1] > 1) {\n            hsv[1] = 1;\n        } else if (hsv[1] <= 0) {\n            hsv[1] = 0;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    function addBrightnessToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[2] += offset;\n        if (hsv[2] > 1) {\n            hsv[2] = 1;\n        } else if (hsv[2] < 0) {\n            hsv[2] = 0;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    function addHueToRGB(color, offset) {\n        var hsv = RGBtoHSV(color[0] * 255, color[1] * 255, color[2] * 255);\n        hsv[0] += offset / 360;\n        if (hsv[0] > 1) {\n            hsv[0] -= 1;\n        } else if (hsv[0] < 0) {\n            hsv[0] += 1;\n        }\n        return HSVtoRGB(hsv[0], hsv[1], hsv[2]);\n    }\n    var rgbToHex = function() {\n        var colorMap = [];\n        var i;\n        var hex;\n        for(i = 0; i < 256; i += 1){\n            hex = i.toString(16);\n            colorMap[i] = hex.length === 1 ? '0' + hex : hex;\n        }\n        return function(r, g, b) {\n            if (r < 0) {\n                r = 0;\n            }\n            if (g < 0) {\n                g = 0;\n            }\n            if (b < 0) {\n                b = 0;\n            }\n            return '#' + colorMap[r] + colorMap[g] + colorMap[b];\n        };\n    }();\n    var setSubframeEnabled = function setSubframeEnabled(flag) {\n        subframeEnabled = !!flag;\n    };\n    var getSubframeEnabled = function getSubframeEnabled() {\n        return subframeEnabled;\n    };\n    var setExpressionsPlugin = function setExpressionsPlugin(value) {\n        expressionsPlugin = value;\n    };\n    var getExpressionsPlugin = function getExpressionsPlugin() {\n        return expressionsPlugin;\n    };\n    var setExpressionInterfaces = function setExpressionInterfaces(value) {\n        expressionsInterfaces = value;\n    };\n    var getExpressionInterfaces = function getExpressionInterfaces() {\n        return expressionsInterfaces;\n    };\n    var setDefaultCurveSegments = function setDefaultCurveSegments(value) {\n        defaultCurveSegments = value;\n    };\n    var getDefaultCurveSegments = function getDefaultCurveSegments() {\n        return defaultCurveSegments;\n    };\n    var setIdPrefix = function setIdPrefix(value) {\n        idPrefix$1 = value;\n    };\n    var getIdPrefix = function getIdPrefix() {\n        return idPrefix$1;\n    };\n    function createNS(type) {\n        // return {appendChild:function(){},setAttribute:function(){},style:{}}\n        return document.createElementNS(svgNS, type);\n    }\n    function _typeof$5(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof$5 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof$5(o);\n    }\n    var dataManager = function() {\n        var _counterId = 1;\n        var processes = [];\n        var workerFn;\n        var workerInstance;\n        var workerProxy = {\n            onmessage: function onmessage() {},\n            postMessage: function postMessage(path) {\n                workerFn({\n                    data: path\n                });\n            }\n        };\n        var _workerSelf = {\n            postMessage: function postMessage(data) {\n                workerProxy.onmessage({\n                    data: data\n                });\n            }\n        };\n        function createWorker(fn) {\n            if (window.Worker && window.Blob && getWebWorker()) {\n                var blob = new Blob([\n                    'var _workerSelf = self; self.onmessage = ',\n                    fn.toString()\n                ], {\n                    type: 'text/javascript'\n                });\n                // var blob = new Blob(['self.onmessage = ', fn.toString()], { type: 'text/javascript' });\n                var url = URL.createObjectURL(blob);\n                return new Worker(url);\n            }\n            workerFn = fn;\n            return workerProxy;\n        }\n        function setupWorker() {\n            if (!workerInstance) {\n                workerInstance = createWorker(function workerStart(e) {\n                    function dataFunctionManager() {\n                        function completeLayers(layers, comps) {\n                            var layerData;\n                            var i;\n                            var len = layers.length;\n                            var j;\n                            var jLen;\n                            var k;\n                            var kLen;\n                            for(i = 0; i < len; i += 1){\n                                layerData = layers[i];\n                                if ('ks' in layerData && !layerData.completed) {\n                                    layerData.completed = true;\n                                    if (layerData.hasMask) {\n                                        var maskProps = layerData.masksProperties;\n                                        jLen = maskProps.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (maskProps[j].pt.k.i) {\n                                                convertPathsToAbsoluteValues(maskProps[j].pt.k);\n                                            } else {\n                                                kLen = maskProps[j].pt.k.length;\n                                                for(k = 0; k < kLen; k += 1){\n                                                    if (maskProps[j].pt.k[k].s) {\n                                                        convertPathsToAbsoluteValues(maskProps[j].pt.k[k].s[0]);\n                                                    }\n                                                    if (maskProps[j].pt.k[k].e) {\n                                                        convertPathsToAbsoluteValues(maskProps[j].pt.k[k].e[0]);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    if (layerData.ty === 0) {\n                                        layerData.layers = findCompLayers(layerData.refId, comps);\n                                        completeLayers(layerData.layers, comps);\n                                    } else if (layerData.ty === 4) {\n                                        completeShapes(layerData.shapes);\n                                    } else if (layerData.ty === 5) {\n                                        completeText(layerData);\n                                    }\n                                }\n                            }\n                        }\n                        function completeChars(chars, assets) {\n                            if (chars) {\n                                var i = 0;\n                                var len = chars.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (chars[i].t === 1) {\n                                        // var compData = findComp(chars[i].data.refId, assets);\n                                        chars[i].data.layers = findCompLayers(chars[i].data.refId, assets);\n                                        // chars[i].data.ip = 0;\n                                        // chars[i].data.op = 99999;\n                                        // chars[i].data.st = 0;\n                                        // chars[i].data.sr = 1;\n                                        // chars[i].w = compData.w;\n                                        // chars[i].data.ks = {\n                                        //   a: { k: [0, 0, 0], a: 0 },\n                                        //   p: { k: [0, -compData.h, 0], a: 0 },\n                                        //   r: { k: 0, a: 0 },\n                                        //   s: { k: [100, 100], a: 0 },\n                                        //   o: { k: 100, a: 0 },\n                                        // };\n                                        completeLayers(chars[i].data.layers, assets);\n                                    }\n                                }\n                            }\n                        }\n                        function findComp(id, comps) {\n                            var i = 0;\n                            var len = comps.length;\n                            while(i < len){\n                                if (comps[i].id === id) {\n                                    return comps[i];\n                                }\n                                i += 1;\n                            }\n                            return null;\n                        }\n                        function findCompLayers(id, comps) {\n                            var comp = findComp(id, comps);\n                            if (comp) {\n                                if (!comp.layers.__used) {\n                                    comp.layers.__used = true;\n                                    return comp.layers;\n                                }\n                                return JSON.parse(JSON.stringify(comp.layers));\n                            }\n                            return null;\n                        }\n                        function completeShapes(arr) {\n                            var i;\n                            var len = arr.length;\n                            var j;\n                            var jLen;\n                            for(i = len - 1; i >= 0; i -= 1){\n                                if (arr[i].ty === 'sh') {\n                                    if (arr[i].ks.k.i) {\n                                        convertPathsToAbsoluteValues(arr[i].ks.k);\n                                    } else {\n                                        jLen = arr[i].ks.k.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (arr[i].ks.k[j].s) {\n                                                convertPathsToAbsoluteValues(arr[i].ks.k[j].s[0]);\n                                            }\n                                            if (arr[i].ks.k[j].e) {\n                                                convertPathsToAbsoluteValues(arr[i].ks.k[j].e[0]);\n                                            }\n                                        }\n                                    }\n                                } else if (arr[i].ty === 'gr') {\n                                    completeShapes(arr[i].it);\n                                }\n                            }\n                        }\n                        function convertPathsToAbsoluteValues(path) {\n                            var i;\n                            var len = path.i.length;\n                            for(i = 0; i < len; i += 1){\n                                path.i[i][0] += path.v[i][0];\n                                path.i[i][1] += path.v[i][1];\n                                path.o[i][0] += path.v[i][0];\n                                path.o[i][1] += path.v[i][1];\n                            }\n                        }\n                        function checkVersion(minimum, animVersionString) {\n                            var animVersion = animVersionString ? animVersionString.split('.') : [\n                                100,\n                                100,\n                                100\n                            ];\n                            if (minimum[0] > animVersion[0]) {\n                                return true;\n                            }\n                            if (animVersion[0] > minimum[0]) {\n                                return false;\n                            }\n                            if (minimum[1] > animVersion[1]) {\n                                return true;\n                            }\n                            if (animVersion[1] > minimum[1]) {\n                                return false;\n                            }\n                            if (minimum[2] > animVersion[2]) {\n                                return true;\n                            }\n                            if (animVersion[2] > minimum[2]) {\n                                return false;\n                            }\n                            return null;\n                        }\n                        var checkText = function() {\n                            var minimumVersion = [\n                                4,\n                                4,\n                                14\n                            ];\n                            function updateTextLayer(textLayer) {\n                                var documentData = textLayer.t.d;\n                                textLayer.t.d = {\n                                    k: [\n                                        {\n                                            s: documentData,\n                                            t: 0\n                                        }\n                                    ]\n                                };\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 5) {\n                                        updateTextLayer(layers[i]);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkChars = function() {\n                            var minimumVersion = [\n                                4,\n                                7,\n                                99\n                            ];\n                            return function(animationData) {\n                                if (animationData.chars && !checkVersion(minimumVersion, animationData.v)) {\n                                    var i;\n                                    var len = animationData.chars.length;\n                                    for(i = 0; i < len; i += 1){\n                                        var charData = animationData.chars[i];\n                                        if (charData.data && charData.data.shapes) {\n                                            completeShapes(charData.data.shapes);\n                                            charData.data.ip = 0;\n                                            charData.data.op = 99999;\n                                            charData.data.st = 0;\n                                            charData.data.sr = 1;\n                                            charData.data.ks = {\n                                                p: {\n                                                    k: [\n                                                        0,\n                                                        0\n                                                    ],\n                                                    a: 0\n                                                },\n                                                s: {\n                                                    k: [\n                                                        100,\n                                                        100\n                                                    ],\n                                                    a: 0\n                                                },\n                                                a: {\n                                                    k: [\n                                                        0,\n                                                        0\n                                                    ],\n                                                    a: 0\n                                                },\n                                                r: {\n                                                    k: 0,\n                                                    a: 0\n                                                },\n                                                o: {\n                                                    k: 100,\n                                                    a: 0\n                                                }\n                                            };\n                                            if (!animationData.chars[i].t) {\n                                                charData.data.shapes.push({\n                                                    ty: 'no'\n                                                });\n                                                charData.data.shapes[0].it.push({\n                                                    p: {\n                                                        k: [\n                                                            0,\n                                                            0\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    s: {\n                                                        k: [\n                                                            100,\n                                                            100\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    a: {\n                                                        k: [\n                                                            0,\n                                                            0\n                                                        ],\n                                                        a: 0\n                                                    },\n                                                    r: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    o: {\n                                                        k: 100,\n                                                        a: 0\n                                                    },\n                                                    sk: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    sa: {\n                                                        k: 0,\n                                                        a: 0\n                                                    },\n                                                    ty: 'tr'\n                                                });\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkPathProperties = function() {\n                            var minimumVersion = [\n                                5,\n                                7,\n                                15\n                            ];\n                            function updateTextLayer(textLayer) {\n                                var pathData = textLayer.t.p;\n                                if (typeof pathData.a === 'number') {\n                                    pathData.a = {\n                                        a: 0,\n                                        k: pathData.a\n                                    };\n                                }\n                                if (typeof pathData.p === 'number') {\n                                    pathData.p = {\n                                        a: 0,\n                                        k: pathData.p\n                                    };\n                                }\n                                if (typeof pathData.r === 'number') {\n                                    pathData.r = {\n                                        a: 0,\n                                        k: pathData.r\n                                    };\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 5) {\n                                        updateTextLayer(layers[i]);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkColors = function() {\n                            var minimumVersion = [\n                                4,\n                                1,\n                                9\n                            ];\n                            function iterateShapes(shapes) {\n                                var i;\n                                var len = shapes.length;\n                                var j;\n                                var jLen;\n                                for(i = 0; i < len; i += 1){\n                                    if (shapes[i].ty === 'gr') {\n                                        iterateShapes(shapes[i].it);\n                                    } else if (shapes[i].ty === 'fl' || shapes[i].ty === 'st') {\n                                        if (shapes[i].c.k && shapes[i].c.k[0].i) {\n                                            jLen = shapes[i].c.k.length;\n                                            for(j = 0; j < jLen; j += 1){\n                                                if (shapes[i].c.k[j].s) {\n                                                    shapes[i].c.k[j].s[0] /= 255;\n                                                    shapes[i].c.k[j].s[1] /= 255;\n                                                    shapes[i].c.k[j].s[2] /= 255;\n                                                    shapes[i].c.k[j].s[3] /= 255;\n                                                }\n                                                if (shapes[i].c.k[j].e) {\n                                                    shapes[i].c.k[j].e[0] /= 255;\n                                                    shapes[i].c.k[j].e[1] /= 255;\n                                                    shapes[i].c.k[j].e[2] /= 255;\n                                                    shapes[i].c.k[j].e[3] /= 255;\n                                                }\n                                            }\n                                        } else {\n                                            shapes[i].c.k[0] /= 255;\n                                            shapes[i].c.k[1] /= 255;\n                                            shapes[i].c.k[2] /= 255;\n                                            shapes[i].c.k[3] /= 255;\n                                        }\n                                    }\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var i;\n                                var len = layers.length;\n                                for(i = 0; i < len; i += 1){\n                                    if (layers[i].ty === 4) {\n                                        iterateShapes(layers[i].shapes);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        var checkShapes = function() {\n                            var minimumVersion = [\n                                4,\n                                4,\n                                18\n                            ];\n                            function completeClosingShapes(arr) {\n                                var i;\n                                var len = arr.length;\n                                var j;\n                                var jLen;\n                                for(i = len - 1; i >= 0; i -= 1){\n                                    if (arr[i].ty === 'sh') {\n                                        if (arr[i].ks.k.i) {\n                                            arr[i].ks.k.c = arr[i].closed;\n                                        } else {\n                                            jLen = arr[i].ks.k.length;\n                                            for(j = 0; j < jLen; j += 1){\n                                                if (arr[i].ks.k[j].s) {\n                                                    arr[i].ks.k[j].s[0].c = arr[i].closed;\n                                                }\n                                                if (arr[i].ks.k[j].e) {\n                                                    arr[i].ks.k[j].e[0].c = arr[i].closed;\n                                                }\n                                            }\n                                        }\n                                    } else if (arr[i].ty === 'gr') {\n                                        completeClosingShapes(arr[i].it);\n                                    }\n                                }\n                            }\n                            function iterateLayers(layers) {\n                                var layerData;\n                                var i;\n                                var len = layers.length;\n                                var j;\n                                var jLen;\n                                var k;\n                                var kLen;\n                                for(i = 0; i < len; i += 1){\n                                    layerData = layers[i];\n                                    if (layerData.hasMask) {\n                                        var maskProps = layerData.masksProperties;\n                                        jLen = maskProps.length;\n                                        for(j = 0; j < jLen; j += 1){\n                                            if (maskProps[j].pt.k.i) {\n                                                maskProps[j].pt.k.c = maskProps[j].cl;\n                                            } else {\n                                                kLen = maskProps[j].pt.k.length;\n                                                for(k = 0; k < kLen; k += 1){\n                                                    if (maskProps[j].pt.k[k].s) {\n                                                        maskProps[j].pt.k[k].s[0].c = maskProps[j].cl;\n                                                    }\n                                                    if (maskProps[j].pt.k[k].e) {\n                                                        maskProps[j].pt.k[k].e[0].c = maskProps[j].cl;\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    if (layerData.ty === 4) {\n                                        completeClosingShapes(layerData.shapes);\n                                    }\n                                }\n                            }\n                            return function(animationData) {\n                                if (checkVersion(minimumVersion, animationData.v)) {\n                                    iterateLayers(animationData.layers);\n                                    if (animationData.assets) {\n                                        var i;\n                                        var len = animationData.assets.length;\n                                        for(i = 0; i < len; i += 1){\n                                            if (animationData.assets[i].layers) {\n                                                iterateLayers(animationData.assets[i].layers);\n                                            }\n                                        }\n                                    }\n                                }\n                            };\n                        }();\n                        function completeData(animationData) {\n                            if (animationData.__complete) {\n                                return;\n                            }\n                            checkColors(animationData);\n                            checkText(animationData);\n                            checkChars(animationData);\n                            checkPathProperties(animationData);\n                            checkShapes(animationData);\n                            completeLayers(animationData.layers, animationData.assets);\n                            completeChars(animationData.chars, animationData.assets);\n                            animationData.__complete = true;\n                        }\n                        function completeText(data) {\n                            if (data.t.a.length === 0 && !('m' in data.t.p)) {\n                            // data.singleShape = true;\n                            }\n                        }\n                        var moduleOb = {};\n                        moduleOb.completeData = completeData;\n                        moduleOb.checkColors = checkColors;\n                        moduleOb.checkChars = checkChars;\n                        moduleOb.checkPathProperties = checkPathProperties;\n                        moduleOb.checkShapes = checkShapes;\n                        moduleOb.completeLayers = completeLayers;\n                        return moduleOb;\n                    }\n                    if (!_workerSelf.dataManager) {\n                        _workerSelf.dataManager = dataFunctionManager();\n                    }\n                    if (!_workerSelf.assetLoader) {\n                        _workerSelf.assetLoader = function() {\n                            function formatResponse(xhr) {\n                                // using typeof doubles the time of execution of this method,\n                                // so if available, it's better to use the header to validate the type\n                                var contentTypeHeader = xhr.getResponseHeader('content-type');\n                                if (contentTypeHeader && xhr.responseType === 'json' && contentTypeHeader.indexOf('json') !== -1) {\n                                    return xhr.response;\n                                }\n                                if (xhr.response && _typeof$5(xhr.response) === 'object') {\n                                    return xhr.response;\n                                }\n                                if (xhr.response && typeof xhr.response === 'string') {\n                                    return JSON.parse(xhr.response);\n                                }\n                                if (xhr.responseText) {\n                                    return JSON.parse(xhr.responseText);\n                                }\n                                return null;\n                            }\n                            function loadAsset(path, fullPath, callback, errorCallback) {\n                                var response;\n                                var xhr = new XMLHttpRequest();\n                                // set responseType after calling open or IE will break.\n                                try {\n                                    // This crashes on Android WebView prior to KitKat\n                                    xhr.responseType = 'json';\n                                } catch (err) {} // eslint-disable-line no-empty\n                                xhr.onreadystatechange = function() {\n                                    if (xhr.readyState === 4) {\n                                        if (xhr.status === 200) {\n                                            response = formatResponse(xhr);\n                                            callback(response);\n                                        } else {\n                                            try {\n                                                response = formatResponse(xhr);\n                                                callback(response);\n                                            } catch (err) {\n                                                if (errorCallback) {\n                                                    errorCallback(err);\n                                                }\n                                            }\n                                        }\n                                    }\n                                };\n                                try {\n                                    // Hack to workaround banner validation\n                                    xhr.open([\n                                        'G',\n                                        'E',\n                                        'T'\n                                    ].join(''), path, true);\n                                } catch (error) {\n                                    // Hack to workaround banner validation\n                                    xhr.open([\n                                        'G',\n                                        'E',\n                                        'T'\n                                    ].join(''), fullPath + '/' + path, true);\n                                }\n                                xhr.send();\n                            }\n                            return {\n                                load: loadAsset\n                            };\n                        }();\n                    }\n                    if (e.data.type === 'loadAnimation') {\n                        _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {\n                            _workerSelf.dataManager.completeData(data);\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                payload: data,\n                                status: 'success'\n                            });\n                        }, function() {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                status: 'error'\n                            });\n                        });\n                    } else if (e.data.type === 'complete') {\n                        var animation = e.data.animation;\n                        _workerSelf.dataManager.completeData(animation);\n                        _workerSelf.postMessage({\n                            id: e.data.id,\n                            payload: animation,\n                            status: 'success'\n                        });\n                    } else if (e.data.type === 'loadData') {\n                        _workerSelf.assetLoader.load(e.data.path, e.data.fullPath, function(data) {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                payload: data,\n                                status: 'success'\n                            });\n                        }, function() {\n                            _workerSelf.postMessage({\n                                id: e.data.id,\n                                status: 'error'\n                            });\n                        });\n                    }\n                });\n                workerInstance.onmessage = function(event) {\n                    var data = event.data;\n                    var id = data.id;\n                    var process = processes[id];\n                    processes[id] = null;\n                    if (data.status === 'success') {\n                        process.onComplete(data.payload);\n                    } else if (process.onError) {\n                        process.onError();\n                    }\n                };\n            }\n        }\n        function createProcess(onComplete, onError) {\n            _counterId += 1;\n            var id = 'processId_' + _counterId;\n            processes[id] = {\n                onComplete: onComplete,\n                onError: onError\n            };\n            return id;\n        }\n        function loadAnimation(path, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: 'loadAnimation',\n                path: path,\n                fullPath: window.location.origin + window.location.pathname,\n                id: processId\n            });\n        }\n        function loadData(path, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: 'loadData',\n                path: path,\n                fullPath: window.location.origin + window.location.pathname,\n                id: processId\n            });\n        }\n        function completeAnimation(anim, onComplete, onError) {\n            setupWorker();\n            var processId = createProcess(onComplete, onError);\n            workerInstance.postMessage({\n                type: 'complete',\n                animation: anim,\n                id: processId\n            });\n        }\n        return {\n            loadAnimation: loadAnimation,\n            loadData: loadData,\n            completeAnimation: completeAnimation\n        };\n    }();\n    var ImagePreloader = function() {\n        var proxyImage = function() {\n            var canvas = createTag('canvas');\n            canvas.width = 1;\n            canvas.height = 1;\n            var ctx = canvas.getContext('2d');\n            ctx.fillStyle = 'rgba(0,0,0,0)';\n            ctx.fillRect(0, 0, 1, 1);\n            return canvas;\n        }();\n        function imageLoaded() {\n            this.loadedAssets += 1;\n            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n                if (this.imagesLoadedCb) {\n                    this.imagesLoadedCb(null);\n                }\n            }\n        }\n        function footageLoaded() {\n            this.loadedFootagesCount += 1;\n            if (this.loadedAssets === this.totalImages && this.loadedFootagesCount === this.totalFootages) {\n                if (this.imagesLoadedCb) {\n                    this.imagesLoadedCb(null);\n                }\n            }\n        }\n        function getAssetsPath(assetData, assetsPath, originalPath) {\n            var path = '';\n            if (assetData.e) {\n                path = assetData.p;\n            } else if (assetsPath) {\n                var imagePath = assetData.p;\n                if (imagePath.indexOf('images/') !== -1) {\n                    imagePath = imagePath.split('/')[1];\n                }\n                path = assetsPath + imagePath;\n            } else {\n                path = originalPath;\n                path += assetData.u ? assetData.u : '';\n                path += assetData.p;\n            }\n            return path;\n        }\n        function testImageLoaded(img) {\n            var _count = 0;\n            var intervalId = setInterval((function() {\n                var box = img.getBBox();\n                if (box.width || _count > 500) {\n                    this._imageLoaded();\n                    clearInterval(intervalId);\n                }\n                _count += 1;\n            }).bind(this), 50);\n        }\n        function createImageData(assetData) {\n            var path = getAssetsPath(assetData, this.assetsPath, this.path);\n            var img = createNS('image');\n            if (isSafari) {\n                this.testImageLoaded(img);\n            } else {\n                img.addEventListener('load', this._imageLoaded, false);\n            }\n            img.addEventListener('error', (function() {\n                ob.img = proxyImage;\n                this._imageLoaded();\n            }).bind(this), false);\n            img.setAttributeNS('http://www.w3.org/1999/xlink', 'href', path);\n            if (this._elementHelper.append) {\n                this._elementHelper.append(img);\n            } else {\n                this._elementHelper.appendChild(img);\n            }\n            var ob = {\n                img: img,\n                assetData: assetData\n            };\n            return ob;\n        }\n        function createImgData(assetData) {\n            var path = getAssetsPath(assetData, this.assetsPath, this.path);\n            var img = createTag('img');\n            img.crossOrigin = 'anonymous';\n            img.addEventListener('load', this._imageLoaded, false);\n            img.addEventListener('error', (function() {\n                ob.img = proxyImage;\n                this._imageLoaded();\n            }).bind(this), false);\n            img.src = path;\n            var ob = {\n                img: img,\n                assetData: assetData\n            };\n            return ob;\n        }\n        function createFootageData(data) {\n            var ob = {\n                assetData: data\n            };\n            var path = getAssetsPath(data, this.assetsPath, this.path);\n            dataManager.loadData(path, (function(footageData) {\n                ob.img = footageData;\n                this._footageLoaded();\n            }).bind(this), (function() {\n                ob.img = {};\n                this._footageLoaded();\n            }).bind(this));\n            return ob;\n        }\n        function loadAssets(assets, cb) {\n            this.imagesLoadedCb = cb;\n            var i;\n            var len = assets.length;\n            for(i = 0; i < len; i += 1){\n                if (!assets[i].layers) {\n                    if (!assets[i].t || assets[i].t === 'seq') {\n                        this.totalImages += 1;\n                        this.images.push(this._createImageData(assets[i]));\n                    } else if (assets[i].t === 3) {\n                        this.totalFootages += 1;\n                        this.images.push(this.createFootageData(assets[i]));\n                    }\n                }\n            }\n        }\n        function setPath(path) {\n            this.path = path || '';\n        }\n        function setAssetsPath(path) {\n            this.assetsPath = path || '';\n        }\n        function getAsset(assetData) {\n            var i = 0;\n            var len = this.images.length;\n            while(i < len){\n                if (this.images[i].assetData === assetData) {\n                    return this.images[i].img;\n                }\n                i += 1;\n            }\n            return null;\n        }\n        function destroy() {\n            this.imagesLoadedCb = null;\n            this.images.length = 0;\n        }\n        function loadedImages() {\n            return this.totalImages === this.loadedAssets;\n        }\n        function loadedFootages() {\n            return this.totalFootages === this.loadedFootagesCount;\n        }\n        function setCacheType(type, elementHelper) {\n            if (type === 'svg') {\n                this._elementHelper = elementHelper;\n                this._createImageData = this.createImageData.bind(this);\n            } else {\n                this._createImageData = this.createImgData.bind(this);\n            }\n        }\n        function ImagePreloaderFactory() {\n            this._imageLoaded = imageLoaded.bind(this);\n            this._footageLoaded = footageLoaded.bind(this);\n            this.testImageLoaded = testImageLoaded.bind(this);\n            this.createFootageData = createFootageData.bind(this);\n            this.assetsPath = '';\n            this.path = '';\n            this.totalImages = 0;\n            this.totalFootages = 0;\n            this.loadedAssets = 0;\n            this.loadedFootagesCount = 0;\n            this.imagesLoadedCb = null;\n            this.images = [];\n        }\n        ImagePreloaderFactory.prototype = {\n            loadAssets: loadAssets,\n            setAssetsPath: setAssetsPath,\n            setPath: setPath,\n            loadedImages: loadedImages,\n            loadedFootages: loadedFootages,\n            destroy: destroy,\n            getAsset: getAsset,\n            createImgData: createImgData,\n            createImageData: createImageData,\n            imageLoaded: imageLoaded,\n            footageLoaded: footageLoaded,\n            setCacheType: setCacheType\n        };\n        return ImagePreloaderFactory;\n    }();\n    function BaseEvent() {}\n    BaseEvent.prototype = {\n        triggerEvent: function triggerEvent(eventName, args) {\n            if (this._cbs[eventName]) {\n                var callbacks = this._cbs[eventName];\n                for(var i = 0; i < callbacks.length; i += 1){\n                    callbacks[i](args);\n                }\n            }\n        },\n        addEventListener: function addEventListener(eventName, callback) {\n            if (!this._cbs[eventName]) {\n                this._cbs[eventName] = [];\n            }\n            this._cbs[eventName].push(callback);\n            return (function() {\n                this.removeEventListener(eventName, callback);\n            }).bind(this);\n        },\n        removeEventListener: function removeEventListener(eventName, callback) {\n            if (!callback) {\n                this._cbs[eventName] = null;\n            } else if (this._cbs[eventName]) {\n                var i = 0;\n                var len = this._cbs[eventName].length;\n                while(i < len){\n                    if (this._cbs[eventName][i] === callback) {\n                        this._cbs[eventName].splice(i, 1);\n                        i -= 1;\n                        len -= 1;\n                    }\n                    i += 1;\n                }\n                if (!this._cbs[eventName].length) {\n                    this._cbs[eventName] = null;\n                }\n            }\n        }\n    };\n    var markerParser = function() {\n        function parsePayloadLines(payload) {\n            var lines = payload.split('\\r\\n');\n            var keys = {};\n            var line;\n            var keysCount = 0;\n            for(var i = 0; i < lines.length; i += 1){\n                line = lines[i].split(':');\n                if (line.length === 2) {\n                    keys[line[0]] = line[1].trim();\n                    keysCount += 1;\n                }\n            }\n            if (keysCount === 0) {\n                throw new Error();\n            }\n            return keys;\n        }\n        return function(_markers) {\n            var markers = [];\n            for(var i = 0; i < _markers.length; i += 1){\n                var _marker = _markers[i];\n                var markerData = {\n                    time: _marker.tm,\n                    duration: _marker.dr\n                };\n                try {\n                    markerData.payload = JSON.parse(_markers[i].cm);\n                } catch (_) {\n                    try {\n                        markerData.payload = parsePayloadLines(_markers[i].cm);\n                    } catch (__) {\n                        markerData.payload = {\n                            name: _markers[i].cm\n                        };\n                    }\n                }\n                markers.push(markerData);\n            }\n            return markers;\n        };\n    }();\n    var ProjectInterface = function() {\n        function registerComposition(comp) {\n            this.compositions.push(comp);\n        }\n        return function() {\n            function _thisProjectFunction(name) {\n                var i = 0;\n                var len = this.compositions.length;\n                while(i < len){\n                    if (this.compositions[i].data && this.compositions[i].data.nm === name) {\n                        if (this.compositions[i].prepareFrame && this.compositions[i].data.xt) {\n                            this.compositions[i].prepareFrame(this.currentFrame);\n                        }\n                        return this.compositions[i].compInterface;\n                    }\n                    i += 1;\n                }\n                return null;\n            }\n            _thisProjectFunction.compositions = [];\n            _thisProjectFunction.currentFrame = 0;\n            _thisProjectFunction.registerComposition = registerComposition;\n            return _thisProjectFunction;\n        };\n    }();\n    var renderers = {};\n    var registerRenderer = function registerRenderer(key, value) {\n        renderers[key] = value;\n    };\n    function getRenderer(key) {\n        return renderers[key];\n    }\n    function getRegisteredRenderer() {\n        // Returns canvas by default for compatibility\n        if (renderers.canvas) {\n            return 'canvas';\n        }\n        // Returns any renderer that is registered\n        for(var key in renderers){\n            if (renderers[key]) {\n                return key;\n            }\n        }\n        return '';\n    }\n    function _typeof$4(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof$4 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof$4(o);\n    }\n    var AnimationItem = function AnimationItem() {\n        this._cbs = [];\n        this.name = '';\n        this.path = '';\n        this.isLoaded = false;\n        this.currentFrame = 0;\n        this.currentRawFrame = 0;\n        this.firstFrame = 0;\n        this.totalFrames = 0;\n        this.frameRate = 0;\n        this.frameMult = 0;\n        this.playSpeed = 1;\n        this.playDirection = 1;\n        this.playCount = 0;\n        this.animationData = {};\n        this.assets = [];\n        this.isPaused = true;\n        this.autoplay = false;\n        this.loop = true;\n        this.renderer = null;\n        this.animationID = createElementID();\n        this.assetsPath = '';\n        this.timeCompleted = 0;\n        this.segmentPos = 0;\n        this.isSubframeEnabled = getSubframeEnabled();\n        this.segments = [];\n        this._idle = true;\n        this._completedLoop = false;\n        this.projectInterface = ProjectInterface();\n        this.imagePreloader = new ImagePreloader();\n        this.audioController = audioControllerFactory();\n        this.markers = [];\n        this.configAnimation = this.configAnimation.bind(this);\n        this.onSetupError = this.onSetupError.bind(this);\n        this.onSegmentComplete = this.onSegmentComplete.bind(this);\n        this.drawnFrameEvent = new BMEnterFrameEvent('drawnFrame', 0, 0, 0);\n        this.expressionsPlugin = getExpressionsPlugin();\n    };\n    extendPrototype([\n        BaseEvent\n    ], AnimationItem);\n    AnimationItem.prototype.setParams = function(params) {\n        if (params.wrapper || params.container) {\n            this.wrapper = params.wrapper || params.container;\n        }\n        var animType = 'svg';\n        if (params.animType) {\n            animType = params.animType;\n        } else if (params.renderer) {\n            animType = params.renderer;\n        }\n        var RendererClass = getRenderer(animType);\n        this.renderer = new RendererClass(this, params.rendererSettings);\n        this.imagePreloader.setCacheType(animType, this.renderer.globalData.defs);\n        this.renderer.setProjectInterface(this.projectInterface);\n        this.animType = animType;\n        if (params.loop === '' || params.loop === null || params.loop === undefined || params.loop === true) {\n            this.loop = true;\n        } else if (params.loop === false) {\n            this.loop = false;\n        } else {\n            this.loop = parseInt(params.loop, 10);\n        }\n        this.autoplay = 'autoplay' in params ? params.autoplay : true;\n        this.name = params.name ? params.name : '';\n        this.autoloadSegments = Object.prototype.hasOwnProperty.call(params, 'autoloadSegments') ? params.autoloadSegments : true;\n        this.assetsPath = params.assetsPath;\n        this.initialSegment = params.initialSegment;\n        if (params.audioFactory) {\n            this.audioController.setAudioFactory(params.audioFactory);\n        }\n        if (params.animationData) {\n            this.setupAnimation(params.animationData);\n        } else if (params.path) {\n            if (params.path.lastIndexOf('\\\\') !== -1) {\n                this.path = params.path.substr(0, params.path.lastIndexOf('\\\\') + 1);\n            } else {\n                this.path = params.path.substr(0, params.path.lastIndexOf('/') + 1);\n            }\n            this.fileName = params.path.substr(params.path.lastIndexOf('/') + 1);\n            this.fileName = this.fileName.substr(0, this.fileName.lastIndexOf('.json'));\n            dataManager.loadAnimation(params.path, this.configAnimation, this.onSetupError);\n        }\n    };\n    AnimationItem.prototype.onSetupError = function() {\n        this.trigger('data_failed');\n    };\n    AnimationItem.prototype.setupAnimation = function(data) {\n        dataManager.completeAnimation(data, this.configAnimation);\n    };\n    AnimationItem.prototype.setData = function(wrapper, animationData) {\n        if (animationData) {\n            if (_typeof$4(animationData) !== 'object') {\n                animationData = JSON.parse(animationData);\n            }\n        }\n        var params = {\n            wrapper: wrapper,\n            animationData: animationData\n        };\n        var wrapperAttributes = wrapper.attributes;\n        params.path = wrapperAttributes.getNamedItem('data-animation-path') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-animation-path').value : wrapperAttributes.getNamedItem('data-bm-path') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-bm-path').value : wrapperAttributes.getNamedItem('bm-path') ? wrapperAttributes.getNamedItem('bm-path').value : '';\n        params.animType = wrapperAttributes.getNamedItem('data-anim-type') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-anim-type').value : wrapperAttributes.getNamedItem('data-bm-type') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-bm-type').value : wrapperAttributes.getNamedItem('bm-type') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('bm-type').value : wrapperAttributes.getNamedItem('data-bm-renderer') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-bm-renderer').value : wrapperAttributes.getNamedItem('bm-renderer') ? wrapperAttributes.getNamedItem('bm-renderer').value : getRegisteredRenderer() || 'canvas';\n        var loop = wrapperAttributes.getNamedItem('data-anim-loop') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-anim-loop').value : wrapperAttributes.getNamedItem('data-bm-loop') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-bm-loop').value : wrapperAttributes.getNamedItem('bm-loop') ? wrapperAttributes.getNamedItem('bm-loop').value : '';\n        if (loop === 'false') {\n            params.loop = false;\n        } else if (loop === 'true') {\n            params.loop = true;\n        } else if (loop !== '') {\n            params.loop = parseInt(loop, 10);\n        }\n        var autoplay = wrapperAttributes.getNamedItem('data-anim-autoplay') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-anim-autoplay').value : wrapperAttributes.getNamedItem('data-bm-autoplay') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-bm-autoplay').value : wrapperAttributes.getNamedItem('bm-autoplay') ? wrapperAttributes.getNamedItem('bm-autoplay').value : true;\n        params.autoplay = autoplay !== 'false';\n        params.name = wrapperAttributes.getNamedItem('data-name') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-name').value : wrapperAttributes.getNamedItem('data-bm-name') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-bm-name').value : wrapperAttributes.getNamedItem('bm-name') ? wrapperAttributes.getNamedItem('bm-name').value : '';\n        var prerender = wrapperAttributes.getNamedItem('data-anim-prerender') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-anim-prerender').value : wrapperAttributes.getNamedItem('data-bm-prerender') // eslint-disable-line no-nested-ternary\n         ? wrapperAttributes.getNamedItem('data-bm-prerender').value : wrapperAttributes.getNamedItem('bm-prerender') ? wrapperAttributes.getNamedItem('bm-prerender').value : '';\n        if (prerender === 'false') {\n            params.prerender = false;\n        }\n        if (!params.path) {\n            this.trigger('destroy');\n        } else {\n            this.setParams(params);\n        }\n    };\n    AnimationItem.prototype.includeLayers = function(data) {\n        if (data.op > this.animationData.op) {\n            this.animationData.op = data.op;\n            this.totalFrames = Math.floor(data.op - this.animationData.ip);\n        }\n        var layers = this.animationData.layers;\n        var i;\n        var len = layers.length;\n        var newLayers = data.layers;\n        var j;\n        var jLen = newLayers.length;\n        for(j = 0; j < jLen; j += 1){\n            i = 0;\n            while(i < len){\n                if (layers[i].id === newLayers[j].id) {\n                    layers[i] = newLayers[j];\n                    break;\n                }\n                i += 1;\n            }\n        }\n        if (data.chars || data.fonts) {\n            this.renderer.globalData.fontManager.addChars(data.chars);\n            this.renderer.globalData.fontManager.addFonts(data.fonts, this.renderer.globalData.defs);\n        }\n        if (data.assets) {\n            len = data.assets.length;\n            for(i = 0; i < len; i += 1){\n                this.animationData.assets.push(data.assets[i]);\n            }\n        }\n        this.animationData.__complete = false;\n        dataManager.completeAnimation(this.animationData, this.onSegmentComplete);\n    };\n    AnimationItem.prototype.onSegmentComplete = function(data) {\n        this.animationData = data;\n        var expressionsPlugin = getExpressionsPlugin();\n        if (expressionsPlugin) {\n            expressionsPlugin.initExpressions(this);\n        }\n        this.loadNextSegment();\n    };\n    AnimationItem.prototype.loadNextSegment = function() {\n        var segments = this.animationData.segments;\n        if (!segments || segments.length === 0 || !this.autoloadSegments) {\n            this.trigger('data_ready');\n            this.timeCompleted = this.totalFrames;\n            return;\n        }\n        var segment = segments.shift();\n        this.timeCompleted = segment.time * this.frameRate;\n        var segmentPath = this.path + this.fileName + '_' + this.segmentPos + '.json';\n        this.segmentPos += 1;\n        dataManager.loadData(segmentPath, this.includeLayers.bind(this), (function() {\n            this.trigger('data_failed');\n        }).bind(this));\n    };\n    AnimationItem.prototype.loadSegments = function() {\n        var segments = this.animationData.segments;\n        if (!segments) {\n            this.timeCompleted = this.totalFrames;\n        }\n        this.loadNextSegment();\n    };\n    AnimationItem.prototype.imagesLoaded = function() {\n        this.trigger('loaded_images');\n        this.checkLoaded();\n    };\n    AnimationItem.prototype.preloadImages = function() {\n        this.imagePreloader.setAssetsPath(this.assetsPath);\n        this.imagePreloader.setPath(this.path);\n        this.imagePreloader.loadAssets(this.animationData.assets, this.imagesLoaded.bind(this));\n    };\n    AnimationItem.prototype.configAnimation = function(animData) {\n        if (!this.renderer) {\n            return;\n        }\n        try {\n            this.animationData = animData;\n            if (this.initialSegment) {\n                this.totalFrames = Math.floor(this.initialSegment[1] - this.initialSegment[0]);\n                this.firstFrame = Math.round(this.initialSegment[0]);\n            } else {\n                this.totalFrames = Math.floor(this.animationData.op - this.animationData.ip);\n                this.firstFrame = Math.round(this.animationData.ip);\n            }\n            this.renderer.configAnimation(animData);\n            if (!animData.assets) {\n                animData.assets = [];\n            }\n            this.assets = this.animationData.assets;\n            this.frameRate = this.animationData.fr;\n            this.frameMult = this.animationData.fr / 1000;\n            this.renderer.searchExtraCompositions(animData.assets);\n            this.markers = markerParser(animData.markers || []);\n            this.trigger('config_ready');\n            this.preloadImages();\n            this.loadSegments();\n            this.updaFrameModifier();\n            this.waitForFontsLoaded();\n            if (this.isPaused) {\n                this.audioController.pause();\n            }\n        } catch (error) {\n            this.triggerConfigError(error);\n        }\n    };\n    AnimationItem.prototype.waitForFontsLoaded = function() {\n        if (!this.renderer) {\n            return;\n        }\n        if (this.renderer.globalData.fontManager.isLoaded) {\n            this.checkLoaded();\n        } else {\n            setTimeout(this.waitForFontsLoaded.bind(this), 20);\n        }\n    };\n    AnimationItem.prototype.checkLoaded = function() {\n        if (!this.isLoaded && this.renderer.globalData.fontManager.isLoaded && (this.imagePreloader.loadedImages() || this.renderer.rendererType !== 'canvas') && this.imagePreloader.loadedFootages()) {\n            this.isLoaded = true;\n            var expressionsPlugin = getExpressionsPlugin();\n            if (expressionsPlugin) {\n                expressionsPlugin.initExpressions(this);\n            }\n            this.renderer.initItems();\n            setTimeout((function() {\n                this.trigger('DOMLoaded');\n            }).bind(this), 0);\n            this.gotoFrame();\n            if (this.autoplay) {\n                this.play();\n            }\n        }\n    };\n    AnimationItem.prototype.resize = function(width, height) {\n        // Adding this validation for backwards compatibility in case an event object was being passed down\n        var _width = typeof width === 'number' ? width : undefined;\n        var _height = typeof height === 'number' ? height : undefined;\n        this.renderer.updateContainerSize(_width, _height);\n    };\n    AnimationItem.prototype.setSubframe = function(flag) {\n        this.isSubframeEnabled = !!flag;\n    };\n    AnimationItem.prototype.gotoFrame = function() {\n        this.currentFrame = this.isSubframeEnabled ? this.currentRawFrame : ~~this.currentRawFrame; // eslint-disable-line no-bitwise\n        if (this.timeCompleted !== this.totalFrames && this.currentFrame > this.timeCompleted) {\n            this.currentFrame = this.timeCompleted;\n        }\n        this.trigger('enterFrame');\n        this.renderFrame();\n        this.trigger('drawnFrame');\n    };\n    AnimationItem.prototype.renderFrame = function() {\n        if (this.isLoaded === false || !this.renderer) {\n            return;\n        }\n        try {\n            if (this.expressionsPlugin) {\n                this.expressionsPlugin.resetFrame();\n            }\n            this.renderer.renderFrame(this.currentFrame + this.firstFrame);\n        } catch (error) {\n            this.triggerRenderFrameError(error);\n        }\n    };\n    AnimationItem.prototype.play = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === true) {\n            this.isPaused = false;\n            this.trigger('_play');\n            this.audioController.resume();\n            if (this._idle) {\n                this._idle = false;\n                this.trigger('_active');\n            }\n        }\n    };\n    AnimationItem.prototype.pause = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === false) {\n            this.isPaused = true;\n            this.trigger('_pause');\n            this._idle = true;\n            this.trigger('_idle');\n            this.audioController.pause();\n        }\n    };\n    AnimationItem.prototype.togglePause = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        if (this.isPaused === true) {\n            this.play();\n        } else {\n            this.pause();\n        }\n    };\n    AnimationItem.prototype.stop = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.pause();\n        this.playCount = 0;\n        this._completedLoop = false;\n        this.setCurrentRawFrameValue(0);\n    };\n    AnimationItem.prototype.getMarkerData = function(markerName) {\n        var marker;\n        for(var i = 0; i < this.markers.length; i += 1){\n            marker = this.markers[i];\n            if (marker.payload && marker.payload.name === markerName) {\n                return marker;\n            }\n        }\n        return null;\n    };\n    AnimationItem.prototype.goToAndStop = function(value, isFrame, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        var numValue = Number(value);\n        if (isNaN(numValue)) {\n            var marker = this.getMarkerData(value);\n            if (marker) {\n                this.goToAndStop(marker.time, true);\n            }\n        } else if (isFrame) {\n            this.setCurrentRawFrameValue(value);\n        } else {\n            this.setCurrentRawFrameValue(value * this.frameModifier);\n        }\n        this.pause();\n    };\n    AnimationItem.prototype.goToAndPlay = function(value, isFrame, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        var numValue = Number(value);\n        if (isNaN(numValue)) {\n            var marker = this.getMarkerData(value);\n            if (marker) {\n                if (!marker.duration) {\n                    this.goToAndStop(marker.time, true);\n                } else {\n                    this.playSegments([\n                        marker.time,\n                        marker.time + marker.duration\n                    ], true);\n                }\n            }\n        } else {\n            this.goToAndStop(numValue, isFrame, name);\n        }\n        this.play();\n    };\n    AnimationItem.prototype.advanceTime = function(value) {\n        if (this.isPaused === true || this.isLoaded === false) {\n            return;\n        }\n        var nextValue = this.currentRawFrame + value * this.frameModifier;\n        var _isComplete = false;\n        // Checking if nextValue > totalFrames - 1 for addressing non looping and looping animations.\n        // If animation won't loop, it should stop at totalFrames - 1. If it will loop it should complete the last frame and then loop.\n        if (nextValue >= this.totalFrames - 1 && this.frameModifier > 0) {\n            if (!this.loop || this.playCount === this.loop) {\n                if (!this.checkSegments(nextValue > this.totalFrames ? nextValue % this.totalFrames : 0)) {\n                    _isComplete = true;\n                    nextValue = this.totalFrames - 1;\n                }\n            } else if (nextValue >= this.totalFrames) {\n                this.playCount += 1;\n                if (!this.checkSegments(nextValue % this.totalFrames)) {\n                    this.setCurrentRawFrameValue(nextValue % this.totalFrames);\n                    this._completedLoop = true;\n                    this.trigger('loopComplete');\n                }\n            } else {\n                this.setCurrentRawFrameValue(nextValue);\n            }\n        } else if (nextValue < 0) {\n            if (!this.checkSegments(nextValue % this.totalFrames)) {\n                if (this.loop && !(this.playCount-- <= 0 && this.loop !== true)) {\n                    // eslint-disable-line no-plusplus\n                    this.setCurrentRawFrameValue(this.totalFrames + nextValue % this.totalFrames);\n                    if (!this._completedLoop) {\n                        this._completedLoop = true;\n                    } else {\n                        this.trigger('loopComplete');\n                    }\n                } else {\n                    _isComplete = true;\n                    nextValue = 0;\n                }\n            }\n        } else {\n            this.setCurrentRawFrameValue(nextValue);\n        }\n        if (_isComplete) {\n            this.setCurrentRawFrameValue(nextValue);\n            this.pause();\n            this.trigger('complete');\n        }\n    };\n    AnimationItem.prototype.adjustSegment = function(arr, offset) {\n        this.playCount = 0;\n        if (arr[1] < arr[0]) {\n            if (this.frameModifier > 0) {\n                if (this.playSpeed < 0) {\n                    this.setSpeed(-this.playSpeed);\n                } else {\n                    this.setDirection(-1);\n                }\n            }\n            this.totalFrames = arr[0] - arr[1];\n            this.timeCompleted = this.totalFrames;\n            this.firstFrame = arr[1];\n            this.setCurrentRawFrameValue(this.totalFrames - 0.001 - offset);\n        } else if (arr[1] > arr[0]) {\n            if (this.frameModifier < 0) {\n                if (this.playSpeed < 0) {\n                    this.setSpeed(-this.playSpeed);\n                } else {\n                    this.setDirection(1);\n                }\n            }\n            this.totalFrames = arr[1] - arr[0];\n            this.timeCompleted = this.totalFrames;\n            this.firstFrame = arr[0];\n            this.setCurrentRawFrameValue(0.001 + offset);\n        }\n        this.trigger('segmentStart');\n    };\n    AnimationItem.prototype.setSegment = function(init, end) {\n        var pendingFrame = -1;\n        if (this.isPaused) {\n            if (this.currentRawFrame + this.firstFrame < init) {\n                pendingFrame = init;\n            } else if (this.currentRawFrame + this.firstFrame > end) {\n                pendingFrame = end - init;\n            }\n        }\n        this.firstFrame = init;\n        this.totalFrames = end - init;\n        this.timeCompleted = this.totalFrames;\n        if (pendingFrame !== -1) {\n            this.goToAndStop(pendingFrame, true);\n        }\n    };\n    AnimationItem.prototype.playSegments = function(arr, forceFlag) {\n        if (forceFlag) {\n            this.segments.length = 0;\n        }\n        if (_typeof$4(arr[0]) === 'object') {\n            var i;\n            var len = arr.length;\n            for(i = 0; i < len; i += 1){\n                this.segments.push(arr[i]);\n            }\n        } else {\n            this.segments.push(arr);\n        }\n        if (this.segments.length && forceFlag) {\n            this.adjustSegment(this.segments.shift(), 0);\n        }\n        if (this.isPaused) {\n            this.play();\n        }\n    };\n    AnimationItem.prototype.resetSegments = function(forceFlag) {\n        this.segments.length = 0;\n        this.segments.push([\n            this.animationData.ip,\n            this.animationData.op\n        ]);\n        if (forceFlag) {\n            this.checkSegments(0);\n        }\n    };\n    AnimationItem.prototype.checkSegments = function(offset) {\n        if (this.segments.length) {\n            this.adjustSegment(this.segments.shift(), offset);\n            return true;\n        }\n        return false;\n    };\n    AnimationItem.prototype.destroy = function(name) {\n        if (name && this.name !== name || !this.renderer) {\n            return;\n        }\n        this.renderer.destroy();\n        this.imagePreloader.destroy();\n        this.trigger('destroy');\n        this._cbs = null;\n        this.onEnterFrame = null;\n        this.onLoopComplete = null;\n        this.onComplete = null;\n        this.onSegmentStart = null;\n        this.onDestroy = null;\n        this.renderer = null;\n        this.expressionsPlugin = null;\n        this.imagePreloader = null;\n        this.projectInterface = null;\n    };\n    AnimationItem.prototype.setCurrentRawFrameValue = function(value) {\n        this.currentRawFrame = value;\n        this.gotoFrame();\n    };\n    AnimationItem.prototype.setSpeed = function(val) {\n        this.playSpeed = val;\n        this.updaFrameModifier();\n    };\n    AnimationItem.prototype.setDirection = function(val) {\n        this.playDirection = val < 0 ? -1 : 1;\n        this.updaFrameModifier();\n    };\n    AnimationItem.prototype.setLoop = function(isLooping) {\n        this.loop = isLooping;\n    };\n    AnimationItem.prototype.setVolume = function(val, name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.setVolume(val);\n    };\n    AnimationItem.prototype.getVolume = function() {\n        return this.audioController.getVolume();\n    };\n    AnimationItem.prototype.mute = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.mute();\n    };\n    AnimationItem.prototype.unmute = function(name) {\n        if (name && this.name !== name) {\n            return;\n        }\n        this.audioController.unmute();\n    };\n    AnimationItem.prototype.updaFrameModifier = function() {\n        this.frameModifier = this.frameMult * this.playSpeed * this.playDirection;\n        this.audioController.setRate(this.playSpeed * this.playDirection);\n    };\n    AnimationItem.prototype.getPath = function() {\n        return this.path;\n    };\n    AnimationItem.prototype.getAssetsPath = function(assetData) {\n        var path = '';\n        if (assetData.e) {\n            path = assetData.p;\n        } else if (this.assetsPath) {\n            var imagePath = assetData.p;\n            if (imagePath.indexOf('images/') !== -1) {\n                imagePath = imagePath.split('/')[1];\n            }\n            path = this.assetsPath + imagePath;\n        } else {\n            path = this.path;\n            path += assetData.u ? assetData.u : '';\n            path += assetData.p;\n        }\n        return path;\n    };\n    AnimationItem.prototype.getAssetData = function(id) {\n        var i = 0;\n        var len = this.assets.length;\n        while(i < len){\n            if (id === this.assets[i].id) {\n                return this.assets[i];\n            }\n            i += 1;\n        }\n        return null;\n    };\n    AnimationItem.prototype.hide = function() {\n        this.renderer.hide();\n    };\n    AnimationItem.prototype.show = function() {\n        this.renderer.show();\n    };\n    AnimationItem.prototype.getDuration = function(isFrame) {\n        return isFrame ? this.totalFrames : this.totalFrames / this.frameRate;\n    };\n    AnimationItem.prototype.updateDocumentData = function(path, documentData, index) {\n        try {\n            var element = this.renderer.getElementByPath(path);\n            element.updateDocumentData(documentData, index);\n        } catch (error) {\n        // TODO: decide how to handle catch case\n        }\n    };\n    AnimationItem.prototype.trigger = function(name) {\n        if (this._cbs && this._cbs[name]) {\n            switch(name){\n                case 'enterFrame':\n                    this.triggerEvent(name, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameModifier));\n                    break;\n                case 'drawnFrame':\n                    this.drawnFrameEvent.currentTime = this.currentFrame;\n                    this.drawnFrameEvent.totalTime = this.totalFrames;\n                    this.drawnFrameEvent.direction = this.frameModifier;\n                    this.triggerEvent(name, this.drawnFrameEvent);\n                    break;\n                case 'loopComplete':\n                    this.triggerEvent(name, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n                    break;\n                case 'complete':\n                    this.triggerEvent(name, new BMCompleteEvent(name, this.frameMult));\n                    break;\n                case 'segmentStart':\n                    this.triggerEvent(name, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n                    break;\n                case 'destroy':\n                    this.triggerEvent(name, new BMDestroyEvent(name, this));\n                    break;\n                default:\n                    this.triggerEvent(name);\n            }\n        }\n        if (name === 'enterFrame' && this.onEnterFrame) {\n            this.onEnterFrame.call(this, new BMEnterFrameEvent(name, this.currentFrame, this.totalFrames, this.frameMult));\n        }\n        if (name === 'loopComplete' && this.onLoopComplete) {\n            this.onLoopComplete.call(this, new BMCompleteLoopEvent(name, this.loop, this.playCount, this.frameMult));\n        }\n        if (name === 'complete' && this.onComplete) {\n            this.onComplete.call(this, new BMCompleteEvent(name, this.frameMult));\n        }\n        if (name === 'segmentStart' && this.onSegmentStart) {\n            this.onSegmentStart.call(this, new BMSegmentStartEvent(name, this.firstFrame, this.totalFrames));\n        }\n        if (name === 'destroy' && this.onDestroy) {\n            this.onDestroy.call(this, new BMDestroyEvent(name, this));\n        }\n    };\n    AnimationItem.prototype.triggerRenderFrameError = function(nativeError) {\n        var error = new BMRenderFrameErrorEvent(nativeError, this.currentFrame);\n        this.triggerEvent('error', error);\n        if (this.onError) {\n            this.onError.call(this, error);\n        }\n    };\n    AnimationItem.prototype.triggerConfigError = function(nativeError) {\n        var error = new BMConfigErrorEvent(nativeError, this.currentFrame);\n        this.triggerEvent('error', error);\n        if (this.onError) {\n            this.onError.call(this, error);\n        }\n    };\n    var animationManager = function() {\n        var moduleOb = {};\n        var registeredAnimations = [];\n        var initTime = 0;\n        var len = 0;\n        var playingAnimationsNum = 0;\n        var _stopped = true;\n        var _isFrozen = false;\n        function removeElement(ev) {\n            var i = 0;\n            var animItem = ev.target;\n            while(i < len){\n                if (registeredAnimations[i].animation === animItem) {\n                    registeredAnimations.splice(i, 1);\n                    i -= 1;\n                    len -= 1;\n                    if (!animItem.isPaused) {\n                        subtractPlayingCount();\n                    }\n                }\n                i += 1;\n            }\n        }\n        function registerAnimation(element, animationData) {\n            if (!element) {\n                return null;\n            }\n            var i = 0;\n            while(i < len){\n                if (registeredAnimations[i].elem === element && registeredAnimations[i].elem !== null) {\n                    return registeredAnimations[i].animation;\n                }\n                i += 1;\n            }\n            var animItem = new AnimationItem();\n            setupAnimation(animItem, element);\n            animItem.setData(element, animationData);\n            return animItem;\n        }\n        function getRegisteredAnimations() {\n            var i;\n            var lenAnims = registeredAnimations.length;\n            var animations = [];\n            for(i = 0; i < lenAnims; i += 1){\n                animations.push(registeredAnimations[i].animation);\n            }\n            return animations;\n        }\n        function addPlayingCount() {\n            playingAnimationsNum += 1;\n            activate();\n        }\n        function subtractPlayingCount() {\n            playingAnimationsNum -= 1;\n        }\n        function setupAnimation(animItem, element) {\n            animItem.addEventListener('destroy', removeElement);\n            animItem.addEventListener('_active', addPlayingCount);\n            animItem.addEventListener('_idle', subtractPlayingCount);\n            registeredAnimations.push({\n                elem: element,\n                animation: animItem\n            });\n            len += 1;\n        }\n        function loadAnimation(params) {\n            var animItem = new AnimationItem();\n            setupAnimation(animItem, null);\n            animItem.setParams(params);\n            return animItem;\n        }\n        function setSpeed(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setSpeed(val, animation);\n            }\n        }\n        function setDirection(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setDirection(val, animation);\n            }\n        }\n        function play(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.play(animation);\n            }\n        }\n        function resume(nowTime) {\n            var elapsedTime = nowTime - initTime;\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.advanceTime(elapsedTime);\n            }\n            initTime = nowTime;\n            if (playingAnimationsNum && !_isFrozen) {\n                window.requestAnimationFrame(resume);\n            } else {\n                _stopped = true;\n            }\n        }\n        function first(nowTime) {\n            initTime = nowTime;\n            window.requestAnimationFrame(resume);\n        }\n        function pause(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.pause(animation);\n            }\n        }\n        function goToAndStop(value, isFrame, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.goToAndStop(value, isFrame, animation);\n            }\n        }\n        function stop(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.stop(animation);\n            }\n        }\n        function togglePause(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.togglePause(animation);\n            }\n        }\n        function destroy(animation) {\n            var i;\n            for(i = len - 1; i >= 0; i -= 1){\n                registeredAnimations[i].animation.destroy(animation);\n            }\n        }\n        function searchAnimations(animationData, standalone, renderer) {\n            var animElements = [].concat([].slice.call(document.getElementsByClassName('lottie')), [].slice.call(document.getElementsByClassName('bodymovin')));\n            var i;\n            var lenAnims = animElements.length;\n            for(i = 0; i < lenAnims; i += 1){\n                if (renderer) {\n                    animElements[i].setAttribute('data-bm-type', renderer);\n                }\n                registerAnimation(animElements[i], animationData);\n            }\n            if (standalone && lenAnims === 0) {\n                if (!renderer) {\n                    renderer = 'svg';\n                }\n                var body = document.getElementsByTagName('body')[0];\n                body.innerText = '';\n                var div = createTag('div');\n                div.style.width = '100%';\n                div.style.height = '100%';\n                div.setAttribute('data-bm-type', renderer);\n                body.appendChild(div);\n                registerAnimation(div, animationData);\n            }\n        }\n        function resize() {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.resize();\n            }\n        }\n        function activate() {\n            if (!_isFrozen && playingAnimationsNum) {\n                if (_stopped) {\n                    window.requestAnimationFrame(first);\n                    _stopped = false;\n                }\n            }\n        }\n        function freeze() {\n            _isFrozen = true;\n        }\n        function unfreeze() {\n            _isFrozen = false;\n            activate();\n        }\n        function setVolume(val, animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.setVolume(val, animation);\n            }\n        }\n        function mute(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.mute(animation);\n            }\n        }\n        function unmute(animation) {\n            var i;\n            for(i = 0; i < len; i += 1){\n                registeredAnimations[i].animation.unmute(animation);\n            }\n        }\n        moduleOb.registerAnimation = registerAnimation;\n        moduleOb.loadAnimation = loadAnimation;\n        moduleOb.setSpeed = setSpeed;\n        moduleOb.setDirection = setDirection;\n        moduleOb.play = play;\n        moduleOb.pause = pause;\n        moduleOb.stop = stop;\n        moduleOb.togglePause = togglePause;\n        moduleOb.searchAnimations = searchAnimations;\n        moduleOb.resize = resize;\n        // moduleOb.start = start;\n        moduleOb.goToAndStop = goToAndStop;\n        moduleOb.destroy = destroy;\n        moduleOb.freeze = freeze;\n        moduleOb.unfreeze = unfreeze;\n        moduleOb.setVolume = setVolume;\n        moduleOb.mute = mute;\n        moduleOb.unmute = unmute;\n        moduleOb.getRegisteredAnimations = getRegisteredAnimations;\n        return moduleOb;\n    }();\n    /* eslint-disable */ var BezierFactory = function() {\n        /**\n       * BezierEasing - use bezier curve for transition easing function\n       * by Gatan Renaudeau 2014 - 2015  MIT License\n       *\n       * Credits: is based on Firefox's nsSMILKeySpline.cpp\n       * Usage:\n       * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])\n       * spline.get(x) => returns the easing value | x must be in [0, 1] range\n       *\n       */ var ob = {};\n        ob.getBezierEasing = getBezierEasing;\n        var beziers = {};\n        function getBezierEasing(a, b, c, d, nm) {\n            var str = nm || ('bez_' + a + '_' + b + '_' + c + '_' + d).replace(/\\./g, 'p');\n            if (beziers[str]) {\n                return beziers[str];\n            }\n            var bezEasing = new BezierEasing([\n                a,\n                b,\n                c,\n                d\n            ]);\n            beziers[str] = bezEasing;\n            return bezEasing;\n        }\n        // These values are established by empiricism with tests (tradeoff: performance VS precision)\n        var NEWTON_ITERATIONS = 4;\n        var NEWTON_MIN_SLOPE = 0.001;\n        var SUBDIVISION_PRECISION = 0.0000001;\n        var SUBDIVISION_MAX_ITERATIONS = 10;\n        var kSplineTableSize = 11;\n        var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);\n        var float32ArraySupported = typeof Float32Array === 'function';\n        function A(aA1, aA2) {\n            return 1.0 - 3.0 * aA2 + 3.0 * aA1;\n        }\n        function B(aA1, aA2) {\n            return 3.0 * aA2 - 6.0 * aA1;\n        }\n        function C(aA1) {\n            return 3.0 * aA1;\n        }\n        // Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.\n        function calcBezier(aT, aA1, aA2) {\n            return ((A(aA1, aA2) * aT + B(aA1, aA2)) * aT + C(aA1)) * aT;\n        }\n        // Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.\n        function getSlope(aT, aA1, aA2) {\n            return 3.0 * A(aA1, aA2) * aT * aT + 2.0 * B(aA1, aA2) * aT + C(aA1);\n        }\n        function binarySubdivide(aX, aA, aB, mX1, mX2) {\n            var currentX, currentT, i = 0;\n            do {\n                currentT = aA + (aB - aA) / 2.0;\n                currentX = calcBezier(currentT, mX1, mX2) - aX;\n                if (currentX > 0.0) {\n                    aB = currentT;\n                } else {\n                    aA = currentT;\n                }\n            }while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);\n            return currentT;\n        }\n        function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {\n            for(var i = 0; i < NEWTON_ITERATIONS; ++i){\n                var currentSlope = getSlope(aGuessT, mX1, mX2);\n                if (currentSlope === 0.0) return aGuessT;\n                var currentX = calcBezier(aGuessT, mX1, mX2) - aX;\n                aGuessT -= currentX / currentSlope;\n            }\n            return aGuessT;\n        }\n        /**\n       * points is an array of [ mX1, mY1, mX2, mY2 ]\n       */ function BezierEasing(points) {\n            this._p = points;\n            this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);\n            this._precomputed = false;\n            this.get = this.get.bind(this);\n        }\n        BezierEasing.prototype = {\n            get: function get(x) {\n                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];\n                if (!this._precomputed) this._precompute();\n                if (mX1 === mY1 && mX2 === mY2) return x; // linear\n                // Because JavaScript number are imprecise, we should guarantee the extremes are right.\n                if (x === 0) return 0;\n                if (x === 1) return 1;\n                return calcBezier(this._getTForX(x), mY1, mY2);\n            },\n            // Private part\n            _precompute: function _precompute() {\n                var mX1 = this._p[0], mY1 = this._p[1], mX2 = this._p[2], mY2 = this._p[3];\n                this._precomputed = true;\n                if (mX1 !== mY1 || mX2 !== mY2) {\n                    this._calcSampleValues();\n                }\n            },\n            _calcSampleValues: function _calcSampleValues() {\n                var mX1 = this._p[0], mX2 = this._p[2];\n                for(var i = 0; i < kSplineTableSize; ++i){\n                    this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);\n                }\n            },\n            /**\n           * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.\n           */ _getTForX: function _getTForX(aX) {\n                var mX1 = this._p[0], mX2 = this._p[2], mSampleValues = this._mSampleValues;\n                var intervalStart = 0.0;\n                var currentSample = 1;\n                var lastSample = kSplineTableSize - 1;\n                for(; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample){\n                    intervalStart += kSampleStepSize;\n                }\n                --currentSample;\n                // Interpolate to provide an initial guess for t\n                var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample + 1] - mSampleValues[currentSample]);\n                var guessForT = intervalStart + dist * kSampleStepSize;\n                var initialSlope = getSlope(guessForT, mX1, mX2);\n                if (initialSlope >= NEWTON_MIN_SLOPE) {\n                    return newtonRaphsonIterate(aX, guessForT, mX1, mX2);\n                }\n                if (initialSlope === 0.0) {\n                    return guessForT;\n                }\n                return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);\n            }\n        };\n        return ob;\n    }();\n    var pooling = function() {\n        function _double(arr) {\n            return arr.concat(createSizedArray(arr.length));\n        }\n        return {\n            \"double\": _double\n        };\n    }();\n    var poolFactory = function() {\n        return function(initialLength, _create, _release) {\n            var _length = 0;\n            var _maxLength = initialLength;\n            var pool = createSizedArray(_maxLength);\n            var ob = {\n                newElement: newElement,\n                release: release\n            };\n            function newElement() {\n                var element;\n                if (_length) {\n                    _length -= 1;\n                    element = pool[_length];\n                } else {\n                    element = _create();\n                }\n                return element;\n            }\n            function release(element) {\n                if (_length === _maxLength) {\n                    pool = pooling[\"double\"](pool);\n                    _maxLength *= 2;\n                }\n                if (_release) {\n                    _release(element);\n                }\n                pool[_length] = element;\n                _length += 1;\n            }\n            return ob;\n        };\n    }();\n    var bezierLengthPool = function() {\n        function create() {\n            return {\n                addedLength: 0,\n                percents: createTypedArray('float32', getDefaultCurveSegments()),\n                lengths: createTypedArray('float32', getDefaultCurveSegments())\n            };\n        }\n        return poolFactory(8, create);\n    }();\n    var segmentsLengthPool = function() {\n        function create() {\n            return {\n                lengths: [],\n                totalLength: 0\n            };\n        }\n        function release(element) {\n            var i;\n            var len = element.lengths.length;\n            for(i = 0; i < len; i += 1){\n                bezierLengthPool.release(element.lengths[i]);\n            }\n            element.lengths.length = 0;\n        }\n        return poolFactory(8, create, release);\n    }();\n    function bezFunction() {\n        var math = Math;\n        function pointOnLine2D(x1, y1, x2, y2, x3, y3) {\n            var det1 = x1 * y2 + y1 * x3 + x2 * y3 - x3 * y2 - y3 * x1 - x2 * y1;\n            return det1 > -0.001 && det1 < 0.001;\n        }\n        function pointOnLine3D(x1, y1, z1, x2, y2, z2, x3, y3, z3) {\n            if (z1 === 0 && z2 === 0 && z3 === 0) {\n                return pointOnLine2D(x1, y1, x2, y2, x3, y3);\n            }\n            var dist1 = math.sqrt(math.pow(x2 - x1, 2) + math.pow(y2 - y1, 2) + math.pow(z2 - z1, 2));\n            var dist2 = math.sqrt(math.pow(x3 - x1, 2) + math.pow(y3 - y1, 2) + math.pow(z3 - z1, 2));\n            var dist3 = math.sqrt(math.pow(x3 - x2, 2) + math.pow(y3 - y2, 2) + math.pow(z3 - z2, 2));\n            var diffDist;\n            if (dist1 > dist2) {\n                if (dist1 > dist3) {\n                    diffDist = dist1 - dist2 - dist3;\n                } else {\n                    diffDist = dist3 - dist2 - dist1;\n                }\n            } else if (dist3 > dist2) {\n                diffDist = dist3 - dist2 - dist1;\n            } else {\n                diffDist = dist2 - dist1 - dist3;\n            }\n            return diffDist > -0.0001 && diffDist < 0.0001;\n        }\n        var getBezierLength = function() {\n            return function(pt1, pt2, pt3, pt4) {\n                var curveSegments = getDefaultCurveSegments();\n                var k;\n                var i;\n                var len;\n                var ptCoord;\n                var perc;\n                var addedLength = 0;\n                var ptDistance;\n                var point = [];\n                var lastPoint = [];\n                var lengthData = bezierLengthPool.newElement();\n                len = pt3.length;\n                for(k = 0; k < curveSegments; k += 1){\n                    perc = k / (curveSegments - 1);\n                    ptDistance = 0;\n                    for(i = 0; i < len; i += 1){\n                        ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * pt3[i] + 3 * (1 - perc) * bmPow(perc, 2) * pt4[i] + bmPow(perc, 3) * pt2[i];\n                        point[i] = ptCoord;\n                        if (lastPoint[i] !== null) {\n                            ptDistance += bmPow(point[i] - lastPoint[i], 2);\n                        }\n                        lastPoint[i] = point[i];\n                    }\n                    if (ptDistance) {\n                        ptDistance = bmSqrt(ptDistance);\n                        addedLength += ptDistance;\n                    }\n                    lengthData.percents[k] = perc;\n                    lengthData.lengths[k] = addedLength;\n                }\n                lengthData.addedLength = addedLength;\n                return lengthData;\n            };\n        }();\n        function getSegmentsLength(shapeData) {\n            var segmentsLength = segmentsLengthPool.newElement();\n            var closed = shapeData.c;\n            var pathV = shapeData.v;\n            var pathO = shapeData.o;\n            var pathI = shapeData.i;\n            var i;\n            var len = shapeData._length;\n            var lengths = segmentsLength.lengths;\n            var totalLength = 0;\n            for(i = 0; i < len - 1; i += 1){\n                lengths[i] = getBezierLength(pathV[i], pathV[i + 1], pathO[i], pathI[i + 1]);\n                totalLength += lengths[i].addedLength;\n            }\n            if (closed && len) {\n                lengths[i] = getBezierLength(pathV[i], pathV[0], pathO[i], pathI[0]);\n                totalLength += lengths[i].addedLength;\n            }\n            segmentsLength.totalLength = totalLength;\n            return segmentsLength;\n        }\n        function BezierData(length) {\n            this.segmentLength = 0;\n            this.points = new Array(length);\n        }\n        function PointData(partial, point) {\n            this.partialLength = partial;\n            this.point = point;\n        }\n        var buildBezierData = function() {\n            var storedData = {};\n            return function(pt1, pt2, pt3, pt4) {\n                var bezierName = (pt1[0] + '_' + pt1[1] + '_' + pt2[0] + '_' + pt2[1] + '_' + pt3[0] + '_' + pt3[1] + '_' + pt4[0] + '_' + pt4[1]).replace(/\\./g, 'p');\n                if (!storedData[bezierName]) {\n                    var curveSegments = getDefaultCurveSegments();\n                    var k;\n                    var i;\n                    var len;\n                    var ptCoord;\n                    var perc;\n                    var addedLength = 0;\n                    var ptDistance;\n                    var point;\n                    var lastPoint = null;\n                    if (pt1.length === 2 && (pt1[0] !== pt2[0] || pt1[1] !== pt2[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt1[0] + pt3[0], pt1[1] + pt3[1]) && pointOnLine2D(pt1[0], pt1[1], pt2[0], pt2[1], pt2[0] + pt4[0], pt2[1] + pt4[1])) {\n                        curveSegments = 2;\n                    }\n                    var bezierData = new BezierData(curveSegments);\n                    len = pt3.length;\n                    for(k = 0; k < curveSegments; k += 1){\n                        point = createSizedArray(len);\n                        perc = k / (curveSegments - 1);\n                        ptDistance = 0;\n                        for(i = 0; i < len; i += 1){\n                            ptCoord = bmPow(1 - perc, 3) * pt1[i] + 3 * bmPow(1 - perc, 2) * perc * (pt1[i] + pt3[i]) + 3 * (1 - perc) * bmPow(perc, 2) * (pt2[i] + pt4[i]) + bmPow(perc, 3) * pt2[i];\n                            point[i] = ptCoord;\n                            if (lastPoint !== null) {\n                                ptDistance += bmPow(point[i] - lastPoint[i], 2);\n                            }\n                        }\n                        ptDistance = bmSqrt(ptDistance);\n                        addedLength += ptDistance;\n                        bezierData.points[k] = new PointData(ptDistance, point);\n                        lastPoint = point;\n                    }\n                    bezierData.segmentLength = addedLength;\n                    storedData[bezierName] = bezierData;\n                }\n                return storedData[bezierName];\n            };\n        }();\n        function getDistancePerc(perc, bezierData) {\n            var percents = bezierData.percents;\n            var lengths = bezierData.lengths;\n            var len = percents.length;\n            var initPos = bmFloor((len - 1) * perc);\n            var lengthPos = perc * bezierData.addedLength;\n            var lPerc = 0;\n            if (initPos === len - 1 || initPos === 0 || lengthPos === lengths[initPos]) {\n                return percents[initPos];\n            }\n            var dir = lengths[initPos] > lengthPos ? -1 : 1;\n            var flag = true;\n            while(flag){\n                if (lengths[initPos] <= lengthPos && lengths[initPos + 1] > lengthPos) {\n                    lPerc = (lengthPos - lengths[initPos]) / (lengths[initPos + 1] - lengths[initPos]);\n                    flag = false;\n                } else {\n                    initPos += dir;\n                }\n                if (initPos < 0 || initPos >= len - 1) {\n                    // FIX for TypedArrays that don't store floating point values with enough accuracy\n                    if (initPos === len - 1) {\n                        return percents[initPos];\n                    }\n                    flag = false;\n                }\n            }\n            return percents[initPos] + (percents[initPos + 1] - percents[initPos]) * lPerc;\n        }\n        function getPointInSegment(pt1, pt2, pt3, pt4, percent, bezierData) {\n            var t1 = getDistancePerc(percent, bezierData);\n            var u1 = 1 - t1;\n            var ptX = math.round((u1 * u1 * u1 * pt1[0] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[0] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[0] + t1 * t1 * t1 * pt2[0]) * 1000) / 1000;\n            var ptY = math.round((u1 * u1 * u1 * pt1[1] + (t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1) * pt3[1] + (t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1) * pt4[1] + t1 * t1 * t1 * pt2[1]) * 1000) / 1000;\n            return [\n                ptX,\n                ptY\n            ];\n        }\n        var bezierSegmentPoints = createTypedArray('float32', 8);\n        function getNewSegment(pt1, pt2, pt3, pt4, startPerc, endPerc, bezierData) {\n            if (startPerc < 0) {\n                startPerc = 0;\n            } else if (startPerc > 1) {\n                startPerc = 1;\n            }\n            var t0 = getDistancePerc(startPerc, bezierData);\n            endPerc = endPerc > 1 ? 1 : endPerc;\n            var t1 = getDistancePerc(endPerc, bezierData);\n            var i;\n            var len = pt1.length;\n            var u0 = 1 - t0;\n            var u1 = 1 - t1;\n            var u0u0u0 = u0 * u0 * u0;\n            var t0u0u0_3 = t0 * u0 * u0 * 3; // eslint-disable-line camelcase\n            var t0t0u0_3 = t0 * t0 * u0 * 3; // eslint-disable-line camelcase\n            var t0t0t0 = t0 * t0 * t0;\n            //\n            var u0u0u1 = u0 * u0 * u1;\n            var t0u0u1_3 = t0 * u0 * u1 + u0 * t0 * u1 + u0 * u0 * t1; // eslint-disable-line camelcase\n            var t0t0u1_3 = t0 * t0 * u1 + u0 * t0 * t1 + t0 * u0 * t1; // eslint-disable-line camelcase\n            var t0t0t1 = t0 * t0 * t1;\n            //\n            var u0u1u1 = u0 * u1 * u1;\n            var t0u1u1_3 = t0 * u1 * u1 + u0 * t1 * u1 + u0 * u1 * t1; // eslint-disable-line camelcase\n            var t0t1u1_3 = t0 * t1 * u1 + u0 * t1 * t1 + t0 * u1 * t1; // eslint-disable-line camelcase\n            var t0t1t1 = t0 * t1 * t1;\n            //\n            var u1u1u1 = u1 * u1 * u1;\n            var t1u1u1_3 = t1 * u1 * u1 + u1 * t1 * u1 + u1 * u1 * t1; // eslint-disable-line camelcase\n            var t1t1u1_3 = t1 * t1 * u1 + u1 * t1 * t1 + t1 * u1 * t1; // eslint-disable-line camelcase\n            var t1t1t1 = t1 * t1 * t1;\n            for(i = 0; i < len; i += 1){\n                bezierSegmentPoints[i * 4] = math.round((u0u0u0 * pt1[i] + t0u0u0_3 * pt3[i] + t0t0u0_3 * pt4[i] + t0t0t0 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 1] = math.round((u0u0u1 * pt1[i] + t0u0u1_3 * pt3[i] + t0t0u1_3 * pt4[i] + t0t0t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 2] = math.round((u0u1u1 * pt1[i] + t0u1u1_3 * pt3[i] + t0t1u1_3 * pt4[i] + t0t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n                bezierSegmentPoints[i * 4 + 3] = math.round((u1u1u1 * pt1[i] + t1u1u1_3 * pt3[i] + t1t1u1_3 * pt4[i] + t1t1t1 * pt2[i]) * 1000) / 1000; // eslint-disable-line camelcase\n            }\n            return bezierSegmentPoints;\n        }\n        return {\n            getSegmentsLength: getSegmentsLength,\n            getNewSegment: getNewSegment,\n            getPointInSegment: getPointInSegment,\n            buildBezierData: buildBezierData,\n            pointOnLine2D: pointOnLine2D,\n            pointOnLine3D: pointOnLine3D\n        };\n    }\n    var bez = bezFunction();\n    var initFrame = initialDefaultFrame;\n    var mathAbs = Math.abs;\n    function interpolateValue(frameNum, caching) {\n        var offsetTime = this.offsetTime;\n        var newValue;\n        if (this.propType === 'multidimensional') {\n            newValue = createTypedArray('float32', this.pv.length);\n        }\n        var iterationIndex = caching.lastIndex;\n        var i = iterationIndex;\n        var len = this.keyframes.length - 1;\n        var flag = true;\n        var keyData;\n        var nextKeyData;\n        var keyframeMetadata;\n        while(flag){\n            keyData = this.keyframes[i];\n            nextKeyData = this.keyframes[i + 1];\n            if (i === len - 1 && frameNum >= nextKeyData.t - offsetTime) {\n                if (keyData.h) {\n                    keyData = nextKeyData;\n                }\n                iterationIndex = 0;\n                break;\n            }\n            if (nextKeyData.t - offsetTime > frameNum) {\n                iterationIndex = i;\n                break;\n            }\n            if (i < len - 1) {\n                i += 1;\n            } else {\n                iterationIndex = 0;\n                flag = false;\n            }\n        }\n        keyframeMetadata = this.keyframesMetadata[i] || {};\n        var k;\n        var kLen;\n        var perc;\n        var jLen;\n        var j;\n        var fnc;\n        var nextKeyTime = nextKeyData.t - offsetTime;\n        var keyTime = keyData.t - offsetTime;\n        var endValue;\n        if (keyData.to) {\n            if (!keyframeMetadata.bezierData) {\n                keyframeMetadata.bezierData = bez.buildBezierData(keyData.s, nextKeyData.s || keyData.e, keyData.to, keyData.ti);\n            }\n            var bezierData = keyframeMetadata.bezierData;\n            if (frameNum >= nextKeyTime || frameNum < keyTime) {\n                var ind = frameNum >= nextKeyTime ? bezierData.points.length - 1 : 0;\n                kLen = bezierData.points[ind].point.length;\n                for(k = 0; k < kLen; k += 1){\n                    newValue[k] = bezierData.points[ind].point[k];\n                }\n            // caching._lastKeyframeIndex = -1;\n            } else {\n                if (keyframeMetadata.__fnct) {\n                    fnc = keyframeMetadata.__fnct;\n                } else {\n                    fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y, keyData.n).get;\n                    keyframeMetadata.__fnct = fnc;\n                }\n                perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n                var distanceInLine = bezierData.segmentLength * perc;\n                var segmentPerc;\n                var addedLength = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastAddedLength : 0;\n                j = caching.lastFrame < frameNum && caching._lastKeyframeIndex === i ? caching._lastPoint : 0;\n                flag = true;\n                jLen = bezierData.points.length;\n                while(flag){\n                    addedLength += bezierData.points[j].partialLength;\n                    if (distanceInLine === 0 || perc === 0 || j === bezierData.points.length - 1) {\n                        kLen = bezierData.points[j].point.length;\n                        for(k = 0; k < kLen; k += 1){\n                            newValue[k] = bezierData.points[j].point[k];\n                        }\n                        break;\n                    } else if (distanceInLine >= addedLength && distanceInLine < addedLength + bezierData.points[j + 1].partialLength) {\n                        segmentPerc = (distanceInLine - addedLength) / bezierData.points[j + 1].partialLength;\n                        kLen = bezierData.points[j].point.length;\n                        for(k = 0; k < kLen; k += 1){\n                            newValue[k] = bezierData.points[j].point[k] + (bezierData.points[j + 1].point[k] - bezierData.points[j].point[k]) * segmentPerc;\n                        }\n                        break;\n                    }\n                    if (j < jLen - 1) {\n                        j += 1;\n                    } else {\n                        flag = false;\n                    }\n                }\n                caching._lastPoint = j;\n                caching._lastAddedLength = addedLength - bezierData.points[j].partialLength;\n                caching._lastKeyframeIndex = i;\n            }\n        } else {\n            var outX;\n            var outY;\n            var inX;\n            var inY;\n            var keyValue;\n            len = keyData.s.length;\n            endValue = nextKeyData.s || keyData.e;\n            if (this.sh && keyData.h !== 1) {\n                if (frameNum >= nextKeyTime) {\n                    newValue[0] = endValue[0];\n                    newValue[1] = endValue[1];\n                    newValue[2] = endValue[2];\n                } else if (frameNum <= keyTime) {\n                    newValue[0] = keyData.s[0];\n                    newValue[1] = keyData.s[1];\n                    newValue[2] = keyData.s[2];\n                } else {\n                    var quatStart = createQuaternion(keyData.s);\n                    var quatEnd = createQuaternion(endValue);\n                    var time = (frameNum - keyTime) / (nextKeyTime - keyTime);\n                    quaternionToEuler(newValue, slerp(quatStart, quatEnd, time));\n                }\n            } else {\n                for(i = 0; i < len; i += 1){\n                    if (keyData.h !== 1) {\n                        if (frameNum >= nextKeyTime) {\n                            perc = 1;\n                        } else if (frameNum < keyTime) {\n                            perc = 0;\n                        } else {\n                            if (keyData.o.x.constructor === Array) {\n                                if (!keyframeMetadata.__fnct) {\n                                    keyframeMetadata.__fnct = [];\n                                }\n                                if (!keyframeMetadata.__fnct[i]) {\n                                    outX = keyData.o.x[i] === undefined ? keyData.o.x[0] : keyData.o.x[i];\n                                    outY = keyData.o.y[i] === undefined ? keyData.o.y[0] : keyData.o.y[i];\n                                    inX = keyData.i.x[i] === undefined ? keyData.i.x[0] : keyData.i.x[i];\n                                    inY = keyData.i.y[i] === undefined ? keyData.i.y[0] : keyData.i.y[i];\n                                    fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                                    keyframeMetadata.__fnct[i] = fnc;\n                                } else {\n                                    fnc = keyframeMetadata.__fnct[i];\n                                }\n                            } else if (!keyframeMetadata.__fnct) {\n                                outX = keyData.o.x;\n                                outY = keyData.o.y;\n                                inX = keyData.i.x;\n                                inY = keyData.i.y;\n                                fnc = BezierFactory.getBezierEasing(outX, outY, inX, inY).get;\n                                keyData.keyframeMetadata = fnc;\n                            } else {\n                                fnc = keyframeMetadata.__fnct;\n                            }\n                            perc = fnc((frameNum - keyTime) / (nextKeyTime - keyTime));\n                        }\n                    }\n                    endValue = nextKeyData.s || keyData.e;\n                    keyValue = keyData.h === 1 ? keyData.s[i] : keyData.s[i] + (endValue[i] - keyData.s[i]) * perc;\n                    if (this.propType === 'multidimensional') {\n                        newValue[i] = keyValue;\n                    } else {\n                        newValue = keyValue;\n                    }\n                }\n            }\n        }\n        caching.lastIndex = iterationIndex;\n        return newValue;\n    }\n    // based on @Toji's https://github.com/toji/gl-matrix/\n    function slerp(a, b, t) {\n        var out = [];\n        var ax = a[0];\n        var ay = a[1];\n        var az = a[2];\n        var aw = a[3];\n        var bx = b[0];\n        var by = b[1];\n        var bz = b[2];\n        var bw = b[3];\n        var omega;\n        var cosom;\n        var sinom;\n        var scale0;\n        var scale1;\n        cosom = ax * bx + ay * by + az * bz + aw * bw;\n        if (cosom < 0.0) {\n            cosom = -cosom;\n            bx = -bx;\n            by = -by;\n            bz = -bz;\n            bw = -bw;\n        }\n        if (1.0 - cosom > 0.000001) {\n            omega = Math.acos(cosom);\n            sinom = Math.sin(omega);\n            scale0 = Math.sin((1.0 - t) * omega) / sinom;\n            scale1 = Math.sin(t * omega) / sinom;\n        } else {\n            scale0 = 1.0 - t;\n            scale1 = t;\n        }\n        out[0] = scale0 * ax + scale1 * bx;\n        out[1] = scale0 * ay + scale1 * by;\n        out[2] = scale0 * az + scale1 * bz;\n        out[3] = scale0 * aw + scale1 * bw;\n        return out;\n    }\n    function quaternionToEuler(out, quat) {\n        var qx = quat[0];\n        var qy = quat[1];\n        var qz = quat[2];\n        var qw = quat[3];\n        var heading = Math.atan2(2 * qy * qw - 2 * qx * qz, 1 - 2 * qy * qy - 2 * qz * qz);\n        var attitude = Math.asin(2 * qx * qy + 2 * qz * qw);\n        var bank = Math.atan2(2 * qx * qw - 2 * qy * qz, 1 - 2 * qx * qx - 2 * qz * qz);\n        out[0] = heading / degToRads;\n        out[1] = attitude / degToRads;\n        out[2] = bank / degToRads;\n    }\n    function createQuaternion(values) {\n        var heading = values[0] * degToRads;\n        var attitude = values[1] * degToRads;\n        var bank = values[2] * degToRads;\n        var c1 = Math.cos(heading / 2);\n        var c2 = Math.cos(attitude / 2);\n        var c3 = Math.cos(bank / 2);\n        var s1 = Math.sin(heading / 2);\n        var s2 = Math.sin(attitude / 2);\n        var s3 = Math.sin(bank / 2);\n        var w = c1 * c2 * c3 - s1 * s2 * s3;\n        var x = s1 * s2 * c3 + c1 * c2 * s3;\n        var y = s1 * c2 * c3 + c1 * s2 * s3;\n        var z = c1 * s2 * c3 - s1 * c2 * s3;\n        return [\n            x,\n            y,\n            z,\n            w\n        ];\n    }\n    function getValueAtCurrentTime() {\n        var frameNum = this.comp.renderedFrame - this.offsetTime;\n        var initTime = this.keyframes[0].t - this.offsetTime;\n        var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n        if (!(frameNum === this._caching.lastFrame || this._caching.lastFrame !== initFrame && (this._caching.lastFrame >= endTime && frameNum >= endTime || this._caching.lastFrame < initTime && frameNum < initTime))) {\n            if (this._caching.lastFrame >= frameNum) {\n                this._caching._lastKeyframeIndex = -1;\n                this._caching.lastIndex = 0;\n            }\n            var renderResult = this.interpolateValue(frameNum, this._caching);\n            this.pv = renderResult;\n        }\n        this._caching.lastFrame = frameNum;\n        return this.pv;\n    }\n    function setVValue(val) {\n        var multipliedValue;\n        if (this.propType === 'unidimensional') {\n            multipliedValue = val * this.mult;\n            if (mathAbs(this.v - multipliedValue) > 0.00001) {\n                this.v = multipliedValue;\n                this._mdf = true;\n            }\n        } else {\n            var i = 0;\n            var len = this.v.length;\n            while(i < len){\n                multipliedValue = val[i] * this.mult;\n                if (mathAbs(this.v[i] - multipliedValue) > 0.00001) {\n                    this.v[i] = multipliedValue;\n                    this._mdf = true;\n                }\n                i += 1;\n            }\n        }\n    }\n    function processEffectsSequence() {\n        if (this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) {\n            return;\n        }\n        if (this.lock) {\n            this.setVValue(this.pv);\n            return;\n        }\n        this.lock = true;\n        this._mdf = this._isFirstFrame;\n        var i;\n        var len = this.effectsSequence.length;\n        var finalValue = this.kf ? this.pv : this.data.k;\n        for(i = 0; i < len; i += 1){\n            finalValue = this.effectsSequence[i](finalValue);\n        }\n        this.setVValue(finalValue);\n        this._isFirstFrame = false;\n        this.lock = false;\n        this.frameId = this.elem.globalData.frameId;\n    }\n    function addEffect(effectFunction) {\n        this.effectsSequence.push(effectFunction);\n        this.container.addDynamicProperty(this);\n    }\n    function ValueProperty(elem, data, mult, container) {\n        this.propType = 'unidimensional';\n        this.mult = mult || 1;\n        this.data = data;\n        this.v = mult ? data.k * mult : data.k;\n        this.pv = data.k;\n        this._mdf = false;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.k = false;\n        this.kf = false;\n        this.vel = 0;\n        this.effectsSequence = [];\n        this._isFirstFrame = true;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.addEffect = addEffect;\n    }\n    function MultiDimensionalProperty(elem, data, mult, container) {\n        this.propType = 'multidimensional';\n        this.mult = mult || 1;\n        this.data = data;\n        this._mdf = false;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.k = false;\n        this.kf = false;\n        this.frameId = -1;\n        var i;\n        var len = data.k.length;\n        this.v = createTypedArray('float32', len);\n        this.pv = createTypedArray('float32', len);\n        this.vel = createTypedArray('float32', len);\n        for(i = 0; i < len; i += 1){\n            this.v[i] = data.k[i] * this.mult;\n            this.pv[i] = data.k[i];\n        }\n        this._isFirstFrame = true;\n        this.effectsSequence = [];\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.addEffect = addEffect;\n    }\n    function KeyframedValueProperty(elem, data, mult, container) {\n        this.propType = 'unidimensional';\n        this.keyframes = data.k;\n        this.keyframesMetadata = [];\n        this.offsetTime = elem.data.st;\n        this.frameId = -1;\n        this._caching = {\n            lastFrame: initFrame,\n            lastIndex: 0,\n            value: 0,\n            _lastKeyframeIndex: -1\n        };\n        this.k = true;\n        this.kf = true;\n        this.data = data;\n        this.mult = mult || 1;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.v = initFrame;\n        this.pv = initFrame;\n        this._isFirstFrame = true;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.interpolateValue = interpolateValue;\n        this.effectsSequence = [\n            getValueAtCurrentTime.bind(this)\n        ];\n        this.addEffect = addEffect;\n    }\n    function KeyframedMultidimensionalProperty(elem, data, mult, container) {\n        this.propType = 'multidimensional';\n        var i;\n        var len = data.k.length;\n        var s;\n        var e;\n        var to;\n        var ti;\n        for(i = 0; i < len - 1; i += 1){\n            if (data.k[i].to && data.k[i].s && data.k[i + 1] && data.k[i + 1].s) {\n                s = data.k[i].s;\n                e = data.k[i + 1].s;\n                to = data.k[i].to;\n                ti = data.k[i].ti;\n                if (s.length === 2 && !(s[0] === e[0] && s[1] === e[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], s[0] + to[0], s[1] + to[1]) && bez.pointOnLine2D(s[0], s[1], e[0], e[1], e[0] + ti[0], e[1] + ti[1]) || s.length === 3 && !(s[0] === e[0] && s[1] === e[1] && s[2] === e[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], s[0] + to[0], s[1] + to[1], s[2] + to[2]) && bez.pointOnLine3D(s[0], s[1], s[2], e[0], e[1], e[2], e[0] + ti[0], e[1] + ti[1], e[2] + ti[2])) {\n                    data.k[i].to = null;\n                    data.k[i].ti = null;\n                }\n                if (s[0] === e[0] && s[1] === e[1] && to[0] === 0 && to[1] === 0 && ti[0] === 0 && ti[1] === 0) {\n                    if (s.length === 2 || s[2] === e[2] && to[2] === 0 && ti[2] === 0) {\n                        data.k[i].to = null;\n                        data.k[i].ti = null;\n                    }\n                }\n            }\n        }\n        this.effectsSequence = [\n            getValueAtCurrentTime.bind(this)\n        ];\n        this.data = data;\n        this.keyframes = data.k;\n        this.keyframesMetadata = [];\n        this.offsetTime = elem.data.st;\n        this.k = true;\n        this.kf = true;\n        this._isFirstFrame = true;\n        this.mult = mult || 1;\n        this.elem = elem;\n        this.container = container;\n        this.comp = elem.comp;\n        this.getValue = processEffectsSequence;\n        this.setVValue = setVValue;\n        this.interpolateValue = interpolateValue;\n        this.frameId = -1;\n        var arrLen = data.k[0].s.length;\n        this.v = createTypedArray('float32', arrLen);\n        this.pv = createTypedArray('float32', arrLen);\n        for(i = 0; i < arrLen; i += 1){\n            this.v[i] = initFrame;\n            this.pv[i] = initFrame;\n        }\n        this._caching = {\n            lastFrame: initFrame,\n            lastIndex: 0,\n            value: createTypedArray('float32', arrLen)\n        };\n        this.addEffect = addEffect;\n    }\n    var PropertyFactory = function() {\n        function getProp(elem, data, type, mult, container) {\n            if (data.sid) {\n                data = elem.globalData.slotManager.getProp(data);\n            }\n            var p;\n            if (!data.k.length) {\n                p = new ValueProperty(elem, data, mult, container);\n            } else if (typeof data.k[0] === 'number') {\n                p = new MultiDimensionalProperty(elem, data, mult, container);\n            } else {\n                switch(type){\n                    case 0:\n                        p = new KeyframedValueProperty(elem, data, mult, container);\n                        break;\n                    case 1:\n                        p = new KeyframedMultidimensionalProperty(elem, data, mult, container);\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (p.effectsSequence.length) {\n                container.addDynamicProperty(p);\n            }\n            return p;\n        }\n        var ob = {\n            getProp: getProp\n        };\n        return ob;\n    }();\n    function DynamicPropertyContainer() {}\n    DynamicPropertyContainer.prototype = {\n        addDynamicProperty: function addDynamicProperty(prop) {\n            if (this.dynamicProperties.indexOf(prop) === -1) {\n                this.dynamicProperties.push(prop);\n                this.container.addDynamicProperty(this);\n                this._isAnimated = true;\n            }\n        },\n        iterateDynamicProperties: function iterateDynamicProperties() {\n            this._mdf = false;\n            var i;\n            var len = this.dynamicProperties.length;\n            for(i = 0; i < len; i += 1){\n                this.dynamicProperties[i].getValue();\n                if (this.dynamicProperties[i]._mdf) {\n                    this._mdf = true;\n                }\n            }\n        },\n        initDynamicPropertyContainer: function initDynamicPropertyContainer(container) {\n            this.container = container;\n            this.dynamicProperties = [];\n            this._mdf = false;\n            this._isAnimated = false;\n        }\n    };\n    var pointPool = function() {\n        function create() {\n            return createTypedArray('float32', 2);\n        }\n        return poolFactory(8, create);\n    }();\n    function ShapePath() {\n        this.c = false;\n        this._length = 0;\n        this._maxLength = 8;\n        this.v = createSizedArray(this._maxLength);\n        this.o = createSizedArray(this._maxLength);\n        this.i = createSizedArray(this._maxLength);\n    }\n    ShapePath.prototype.setPathData = function(closed, len) {\n        this.c = closed;\n        this.setLength(len);\n        var i = 0;\n        while(i < len){\n            this.v[i] = pointPool.newElement();\n            this.o[i] = pointPool.newElement();\n            this.i[i] = pointPool.newElement();\n            i += 1;\n        }\n    };\n    ShapePath.prototype.setLength = function(len) {\n        while(this._maxLength < len){\n            this.doubleArrayLength();\n        }\n        this._length = len;\n    };\n    ShapePath.prototype.doubleArrayLength = function() {\n        this.v = this.v.concat(createSizedArray(this._maxLength));\n        this.i = this.i.concat(createSizedArray(this._maxLength));\n        this.o = this.o.concat(createSizedArray(this._maxLength));\n        this._maxLength *= 2;\n    };\n    ShapePath.prototype.setXYAt = function(x, y, type, pos, replace) {\n        var arr;\n        this._length = Math.max(this._length, pos + 1);\n        if (this._length >= this._maxLength) {\n            this.doubleArrayLength();\n        }\n        switch(type){\n            case 'v':\n                arr = this.v;\n                break;\n            case 'i':\n                arr = this.i;\n                break;\n            case 'o':\n                arr = this.o;\n                break;\n            default:\n                arr = [];\n                break;\n        }\n        if (!arr[pos] || arr[pos] && !replace) {\n            arr[pos] = pointPool.newElement();\n        }\n        arr[pos][0] = x;\n        arr[pos][1] = y;\n    };\n    ShapePath.prototype.setTripleAt = function(vX, vY, oX, oY, iX, iY, pos, replace) {\n        this.setXYAt(vX, vY, 'v', pos, replace);\n        this.setXYAt(oX, oY, 'o', pos, replace);\n        this.setXYAt(iX, iY, 'i', pos, replace);\n    };\n    ShapePath.prototype.reverse = function() {\n        var newPath = new ShapePath();\n        newPath.setPathData(this.c, this._length);\n        var vertices = this.v;\n        var outPoints = this.o;\n        var inPoints = this.i;\n        var init = 0;\n        if (this.c) {\n            newPath.setTripleAt(vertices[0][0], vertices[0][1], inPoints[0][0], inPoints[0][1], outPoints[0][0], outPoints[0][1], 0, false);\n            init = 1;\n        }\n        var cnt = this._length - 1;\n        var len = this._length;\n        var i;\n        for(i = init; i < len; i += 1){\n            newPath.setTripleAt(vertices[cnt][0], vertices[cnt][1], inPoints[cnt][0], inPoints[cnt][1], outPoints[cnt][0], outPoints[cnt][1], i, false);\n            cnt -= 1;\n        }\n        return newPath;\n    };\n    ShapePath.prototype.length = function() {\n        return this._length;\n    };\n    var shapePool = function() {\n        function create() {\n            return new ShapePath();\n        }\n        function release(shapePath) {\n            var len = shapePath._length;\n            var i;\n            for(i = 0; i < len; i += 1){\n                pointPool.release(shapePath.v[i]);\n                pointPool.release(shapePath.i[i]);\n                pointPool.release(shapePath.o[i]);\n                shapePath.v[i] = null;\n                shapePath.i[i] = null;\n                shapePath.o[i] = null;\n            }\n            shapePath._length = 0;\n            shapePath.c = false;\n        }\n        function clone(shape) {\n            var cloned = factory.newElement();\n            var i;\n            var len = shape._length === undefined ? shape.v.length : shape._length;\n            cloned.setLength(len);\n            cloned.c = shape.c;\n            for(i = 0; i < len; i += 1){\n                cloned.setTripleAt(shape.v[i][0], shape.v[i][1], shape.o[i][0], shape.o[i][1], shape.i[i][0], shape.i[i][1], i);\n            }\n            return cloned;\n        }\n        var factory = poolFactory(4, create, release);\n        factory.clone = clone;\n        return factory;\n    }();\n    function ShapeCollection() {\n        this._length = 0;\n        this._maxLength = 4;\n        this.shapes = createSizedArray(this._maxLength);\n    }\n    ShapeCollection.prototype.addShape = function(shapeData) {\n        if (this._length === this._maxLength) {\n            this.shapes = this.shapes.concat(createSizedArray(this._maxLength));\n            this._maxLength *= 2;\n        }\n        this.shapes[this._length] = shapeData;\n        this._length += 1;\n    };\n    ShapeCollection.prototype.releaseShapes = function() {\n        var i;\n        for(i = 0; i < this._length; i += 1){\n            shapePool.release(this.shapes[i]);\n        }\n        this._length = 0;\n    };\n    var shapeCollectionPool = function() {\n        var ob = {\n            newShapeCollection: newShapeCollection,\n            release: release\n        };\n        var _length = 0;\n        var _maxLength = 4;\n        var pool = createSizedArray(_maxLength);\n        function newShapeCollection() {\n            var shapeCollection;\n            if (_length) {\n                _length -= 1;\n                shapeCollection = pool[_length];\n            } else {\n                shapeCollection = new ShapeCollection();\n            }\n            return shapeCollection;\n        }\n        function release(shapeCollection) {\n            var i;\n            var len = shapeCollection._length;\n            for(i = 0; i < len; i += 1){\n                shapePool.release(shapeCollection.shapes[i]);\n            }\n            shapeCollection._length = 0;\n            if (_length === _maxLength) {\n                pool = pooling[\"double\"](pool);\n                _maxLength *= 2;\n            }\n            pool[_length] = shapeCollection;\n            _length += 1;\n        }\n        return ob;\n    }();\n    var ShapePropertyFactory = function() {\n        var initFrame = -999999;\n        function interpolateShape(frameNum, previousValue, caching) {\n            var iterationIndex = caching.lastIndex;\n            var keyPropS;\n            var keyPropE;\n            var isHold;\n            var j;\n            var k;\n            var jLen;\n            var kLen;\n            var perc;\n            var vertexValue;\n            var kf = this.keyframes;\n            if (frameNum < kf[0].t - this.offsetTime) {\n                keyPropS = kf[0].s[0];\n                isHold = true;\n                iterationIndex = 0;\n            } else if (frameNum >= kf[kf.length - 1].t - this.offsetTime) {\n                keyPropS = kf[kf.length - 1].s ? kf[kf.length - 1].s[0] : kf[kf.length - 2].e[0];\n                /* if(kf[kf.length - 1].s){\n                  keyPropS = kf[kf.length - 1].s[0];\n              }else{\n                  keyPropS = kf[kf.length - 2].e[0];\n              } */ isHold = true;\n            } else {\n                var i = iterationIndex;\n                var len = kf.length - 1;\n                var flag = true;\n                var keyData;\n                var nextKeyData;\n                var keyframeMetadata;\n                while(flag){\n                    keyData = kf[i];\n                    nextKeyData = kf[i + 1];\n                    if (nextKeyData.t - this.offsetTime > frameNum) {\n                        break;\n                    }\n                    if (i < len - 1) {\n                        i += 1;\n                    } else {\n                        flag = false;\n                    }\n                }\n                keyframeMetadata = this.keyframesMetadata[i] || {};\n                isHold = keyData.h === 1;\n                iterationIndex = i;\n                if (!isHold) {\n                    if (frameNum >= nextKeyData.t - this.offsetTime) {\n                        perc = 1;\n                    } else if (frameNum < keyData.t - this.offsetTime) {\n                        perc = 0;\n                    } else {\n                        var fnc;\n                        if (keyframeMetadata.__fnct) {\n                            fnc = keyframeMetadata.__fnct;\n                        } else {\n                            fnc = BezierFactory.getBezierEasing(keyData.o.x, keyData.o.y, keyData.i.x, keyData.i.y).get;\n                            keyframeMetadata.__fnct = fnc;\n                        }\n                        perc = fnc((frameNum - (keyData.t - this.offsetTime)) / (nextKeyData.t - this.offsetTime - (keyData.t - this.offsetTime)));\n                    }\n                    keyPropE = nextKeyData.s ? nextKeyData.s[0] : keyData.e[0];\n                }\n                keyPropS = keyData.s[0];\n            }\n            jLen = previousValue._length;\n            kLen = keyPropS.i[0].length;\n            caching.lastIndex = iterationIndex;\n            for(j = 0; j < jLen; j += 1){\n                for(k = 0; k < kLen; k += 1){\n                    vertexValue = isHold ? keyPropS.i[j][k] : keyPropS.i[j][k] + (keyPropE.i[j][k] - keyPropS.i[j][k]) * perc;\n                    previousValue.i[j][k] = vertexValue;\n                    vertexValue = isHold ? keyPropS.o[j][k] : keyPropS.o[j][k] + (keyPropE.o[j][k] - keyPropS.o[j][k]) * perc;\n                    previousValue.o[j][k] = vertexValue;\n                    vertexValue = isHold ? keyPropS.v[j][k] : keyPropS.v[j][k] + (keyPropE.v[j][k] - keyPropS.v[j][k]) * perc;\n                    previousValue.v[j][k] = vertexValue;\n                }\n            }\n        }\n        function interpolateShapeCurrentTime() {\n            var frameNum = this.comp.renderedFrame - this.offsetTime;\n            var initTime = this.keyframes[0].t - this.offsetTime;\n            var endTime = this.keyframes[this.keyframes.length - 1].t - this.offsetTime;\n            var lastFrame = this._caching.lastFrame;\n            if (!(lastFrame !== initFrame && (lastFrame < initTime && frameNum < initTime || lastFrame > endTime && frameNum > endTime))) {\n                /// /\n                this._caching.lastIndex = lastFrame < frameNum ? this._caching.lastIndex : 0;\n                this.interpolateShape(frameNum, this.pv, this._caching);\n            /// /\n            }\n            this._caching.lastFrame = frameNum;\n            return this.pv;\n        }\n        function resetShape() {\n            this.paths = this.localShapeCollection;\n        }\n        function shapesEqual(shape1, shape2) {\n            if (shape1._length !== shape2._length || shape1.c !== shape2.c) {\n                return false;\n            }\n            var i;\n            var len = shape1._length;\n            for(i = 0; i < len; i += 1){\n                if (shape1.v[i][0] !== shape2.v[i][0] || shape1.v[i][1] !== shape2.v[i][1] || shape1.o[i][0] !== shape2.o[i][0] || shape1.o[i][1] !== shape2.o[i][1] || shape1.i[i][0] !== shape2.i[i][0] || shape1.i[i][1] !== shape2.i[i][1]) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        function setVValue(newPath) {\n            if (!shapesEqual(this.v, newPath)) {\n                this.v = shapePool.clone(newPath);\n                this.localShapeCollection.releaseShapes();\n                this.localShapeCollection.addShape(this.v);\n                this._mdf = true;\n                this.paths = this.localShapeCollection;\n            }\n        }\n        function processEffectsSequence() {\n            if (this.elem.globalData.frameId === this.frameId) {\n                return;\n            }\n            if (!this.effectsSequence.length) {\n                this._mdf = false;\n                return;\n            }\n            if (this.lock) {\n                this.setVValue(this.pv);\n                return;\n            }\n            this.lock = true;\n            this._mdf = false;\n            var finalValue;\n            if (this.kf) {\n                finalValue = this.pv;\n            } else if (this.data.ks) {\n                finalValue = this.data.ks.k;\n            } else {\n                finalValue = this.data.pt.k;\n            }\n            var i;\n            var len = this.effectsSequence.length;\n            for(i = 0; i < len; i += 1){\n                finalValue = this.effectsSequence[i](finalValue);\n            }\n            this.setVValue(finalValue);\n            this.lock = false;\n            this.frameId = this.elem.globalData.frameId;\n        }\n        function ShapeProperty(elem, data, type) {\n            this.propType = 'shape';\n            this.comp = elem.comp;\n            this.container = elem;\n            this.elem = elem;\n            this.data = data;\n            this.k = false;\n            this.kf = false;\n            this._mdf = false;\n            var pathData = type === 3 ? data.pt.k : data.ks.k;\n            this.v = shapePool.clone(pathData);\n            this.pv = shapePool.clone(this.v);\n            this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n            this.paths = this.localShapeCollection;\n            this.paths.addShape(this.v);\n            this.reset = resetShape;\n            this.effectsSequence = [];\n        }\n        function addEffect(effectFunction) {\n            this.effectsSequence.push(effectFunction);\n            this.container.addDynamicProperty(this);\n        }\n        ShapeProperty.prototype.interpolateShape = interpolateShape;\n        ShapeProperty.prototype.getValue = processEffectsSequence;\n        ShapeProperty.prototype.setVValue = setVValue;\n        ShapeProperty.prototype.addEffect = addEffect;\n        function KeyframedShapeProperty(elem, data, type) {\n            this.propType = 'shape';\n            this.comp = elem.comp;\n            this.elem = elem;\n            this.container = elem;\n            this.offsetTime = elem.data.st;\n            this.keyframes = type === 3 ? data.pt.k : data.ks.k;\n            this.keyframesMetadata = [];\n            this.k = true;\n            this.kf = true;\n            var len = this.keyframes[0].s[0].i.length;\n            this.v = shapePool.newElement();\n            this.v.setPathData(this.keyframes[0].s[0].c, len);\n            this.pv = shapePool.clone(this.v);\n            this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n            this.paths = this.localShapeCollection;\n            this.paths.addShape(this.v);\n            this.lastFrame = initFrame;\n            this.reset = resetShape;\n            this._caching = {\n                lastFrame: initFrame,\n                lastIndex: 0\n            };\n            this.effectsSequence = [\n                interpolateShapeCurrentTime.bind(this)\n            ];\n        }\n        KeyframedShapeProperty.prototype.getValue = processEffectsSequence;\n        KeyframedShapeProperty.prototype.interpolateShape = interpolateShape;\n        KeyframedShapeProperty.prototype.setVValue = setVValue;\n        KeyframedShapeProperty.prototype.addEffect = addEffect;\n        var EllShapeProperty = function() {\n            var cPoint = roundCorner;\n            function EllShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.setPathData(true, 4);\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.paths = this.localShapeCollection;\n                this.localShapeCollection.addShape(this.v);\n                this.d = data.d;\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.frameId = -1;\n                this.initDynamicPropertyContainer(elem);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertEllToPath();\n                }\n            }\n            EllShapePropertyFactory.prototype = {\n                reset: resetShape,\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertEllToPath();\n                    }\n                },\n                convertEllToPath: function convertEllToPath() {\n                    var p0 = this.p.v[0];\n                    var p1 = this.p.v[1];\n                    var s0 = this.s.v[0] / 2;\n                    var s1 = this.s.v[1] / 2;\n                    var _cw = this.d !== 3;\n                    var _v = this.v;\n                    _v.v[0][0] = p0;\n                    _v.v[0][1] = p1 - s1;\n                    _v.v[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.v[1][1] = p1;\n                    _v.v[2][0] = p0;\n                    _v.v[2][1] = p1 + s1;\n                    _v.v[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.v[3][1] = p1;\n                    _v.i[0][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n                    _v.i[0][1] = p1 - s1;\n                    _v.i[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.i[1][1] = p1 - s1 * cPoint;\n                    _v.i[2][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n                    _v.i[2][1] = p1 + s1;\n                    _v.i[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.i[3][1] = p1 + s1 * cPoint;\n                    _v.o[0][0] = _cw ? p0 + s0 * cPoint : p0 - s0 * cPoint;\n                    _v.o[0][1] = p1 - s1;\n                    _v.o[1][0] = _cw ? p0 + s0 : p0 - s0;\n                    _v.o[1][1] = p1 + s1 * cPoint;\n                    _v.o[2][0] = _cw ? p0 - s0 * cPoint : p0 + s0 * cPoint;\n                    _v.o[2][1] = p1 + s1;\n                    _v.o[3][0] = _cw ? p0 - s0 : p0 + s0;\n                    _v.o[3][1] = p1 - s1 * cPoint;\n                }\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], EllShapePropertyFactory);\n            return EllShapePropertyFactory;\n        }();\n        var StarShapeProperty = function() {\n            function StarShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.setPathData(true, 0);\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.data = data;\n                this.frameId = -1;\n                this.d = data.d;\n                this.initDynamicPropertyContainer(elem);\n                if (data.sy === 1) {\n                    this.ir = PropertyFactory.getProp(elem, data.ir, 0, 0, this);\n                    this.is = PropertyFactory.getProp(elem, data.is, 0, 0.01, this);\n                    this.convertToPath = this.convertStarToPath;\n                } else {\n                    this.convertToPath = this.convertPolygonToPath;\n                }\n                this.pt = PropertyFactory.getProp(elem, data.pt, 0, 0, this);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.r = PropertyFactory.getProp(elem, data.r, 0, degToRads, this);\n                this.or = PropertyFactory.getProp(elem, data.or, 0, 0, this);\n                this.os = PropertyFactory.getProp(elem, data.os, 0, 0.01, this);\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.localShapeCollection.addShape(this.v);\n                this.paths = this.localShapeCollection;\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertToPath();\n                }\n            }\n            StarShapePropertyFactory.prototype = {\n                reset: resetShape,\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertToPath();\n                    }\n                },\n                convertStarToPath: function convertStarToPath() {\n                    var numPts = Math.floor(this.pt.v) * 2;\n                    var angle = Math.PI * 2 / numPts;\n                    /* this.v.v.length = numPts;\n                  this.v.i.length = numPts;\n                  this.v.o.length = numPts; */ var longFlag = true;\n                    var longRad = this.or.v;\n                    var shortRad = this.ir.v;\n                    var longRound = this.os.v;\n                    var shortRound = this.is.v;\n                    var longPerimSegment = 2 * Math.PI * longRad / (numPts * 2);\n                    var shortPerimSegment = 2 * Math.PI * shortRad / (numPts * 2);\n                    var i;\n                    var rad;\n                    var roundness;\n                    var perimSegment;\n                    var currentAng = -Math.PI / 2;\n                    currentAng += this.r.v;\n                    var dir = this.data.d === 3 ? -1 : 1;\n                    this.v._length = 0;\n                    for(i = 0; i < numPts; i += 1){\n                        rad = longFlag ? longRad : shortRad;\n                        roundness = longFlag ? longRound : shortRound;\n                        perimSegment = longFlag ? longPerimSegment : shortPerimSegment;\n                        var x = rad * Math.cos(currentAng);\n                        var y = rad * Math.sin(currentAng);\n                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n                        x += +this.p.v[0];\n                        y += +this.p.v[1];\n                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n                        /* this.v.v[i] = [x,y];\n                      this.v.i[i] = [x+ox*perimSegment*roundness*dir,y+oy*perimSegment*roundness*dir];\n                      this.v.o[i] = [x-ox*perimSegment*roundness*dir,y-oy*perimSegment*roundness*dir];\n                      this.v._length = numPts; */ longFlag = !longFlag;\n                        currentAng += angle * dir;\n                    }\n                },\n                convertPolygonToPath: function convertPolygonToPath() {\n                    var numPts = Math.floor(this.pt.v);\n                    var angle = Math.PI * 2 / numPts;\n                    var rad = this.or.v;\n                    var roundness = this.os.v;\n                    var perimSegment = 2 * Math.PI * rad / (numPts * 4);\n                    var i;\n                    var currentAng = -Math.PI * 0.5;\n                    var dir = this.data.d === 3 ? -1 : 1;\n                    currentAng += this.r.v;\n                    this.v._length = 0;\n                    for(i = 0; i < numPts; i += 1){\n                        var x = rad * Math.cos(currentAng);\n                        var y = rad * Math.sin(currentAng);\n                        var ox = x === 0 && y === 0 ? 0 : y / Math.sqrt(x * x + y * y);\n                        var oy = x === 0 && y === 0 ? 0 : -x / Math.sqrt(x * x + y * y);\n                        x += +this.p.v[0];\n                        y += +this.p.v[1];\n                        this.v.setTripleAt(x, y, x - ox * perimSegment * roundness * dir, y - oy * perimSegment * roundness * dir, x + ox * perimSegment * roundness * dir, y + oy * perimSegment * roundness * dir, i, true);\n                        currentAng += angle * dir;\n                    }\n                    this.paths.length = 0;\n                    this.paths[0] = this.v;\n                }\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], StarShapePropertyFactory);\n            return StarShapePropertyFactory;\n        }();\n        var RectShapeProperty = function() {\n            function RectShapePropertyFactory(elem, data) {\n                this.v = shapePool.newElement();\n                this.v.c = true;\n                this.localShapeCollection = shapeCollectionPool.newShapeCollection();\n                this.localShapeCollection.addShape(this.v);\n                this.paths = this.localShapeCollection;\n                this.elem = elem;\n                this.comp = elem.comp;\n                this.frameId = -1;\n                this.d = data.d;\n                this.initDynamicPropertyContainer(elem);\n                this.p = PropertyFactory.getProp(elem, data.p, 1, 0, this);\n                this.s = PropertyFactory.getProp(elem, data.s, 1, 0, this);\n                this.r = PropertyFactory.getProp(elem, data.r, 0, 0, this);\n                if (this.dynamicProperties.length) {\n                    this.k = true;\n                } else {\n                    this.k = false;\n                    this.convertRectToPath();\n                }\n            }\n            RectShapePropertyFactory.prototype = {\n                convertRectToPath: function convertRectToPath() {\n                    var p0 = this.p.v[0];\n                    var p1 = this.p.v[1];\n                    var v0 = this.s.v[0] / 2;\n                    var v1 = this.s.v[1] / 2;\n                    var round = bmMin(v0, v1, this.r.v);\n                    var cPoint = round * (1 - roundCorner);\n                    this.v._length = 0;\n                    if (this.d === 2 || this.d === 1) {\n                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, 0, true);\n                        this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, p0 + v0, p1 + v1 - round, 1, true);\n                        if (round !== 0) {\n                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, 2, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0 + round, p1 + v1, 3, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, 4, true);\n                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1 + round, 5, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, 6, true);\n                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, p0 + v0 - round, p1 - v1, 7, true);\n                        } else {\n                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0 + cPoint, p1 + v1, p0 - v0, p1 + v1, 2);\n                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0, p1 - v1 + cPoint, p0 - v0, p1 - v1, 3);\n                        }\n                    } else {\n                        this.v.setTripleAt(p0 + v0, p1 - v1 + round, p0 + v0, p1 - v1 + cPoint, p0 + v0, p1 - v1 + round, 0, true);\n                        if (round !== 0) {\n                            this.v.setTripleAt(p0 + v0 - round, p1 - v1, p0 + v0 - round, p1 - v1, p0 + v0 - cPoint, p1 - v1, 1, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0 + round, p1 - v1, 2, true);\n                            this.v.setTripleAt(p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + round, p0 - v0, p1 - v1 + cPoint, 3, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1 - round, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1 - round, 4, true);\n                            this.v.setTripleAt(p0 - v0 + round, p1 + v1, p0 - v0 + round, p1 + v1, p0 - v0 + cPoint, p1 + v1, 5, true);\n                            this.v.setTripleAt(p0 + v0 - round, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0 - round, p1 + v1, 6, true);\n                            this.v.setTripleAt(p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - round, p0 + v0, p1 + v1 - cPoint, 7, true);\n                        } else {\n                            this.v.setTripleAt(p0 - v0, p1 - v1, p0 - v0 + cPoint, p1 - v1, p0 - v0, p1 - v1, 1, true);\n                            this.v.setTripleAt(p0 - v0, p1 + v1, p0 - v0, p1 + v1 - cPoint, p0 - v0, p1 + v1, 2, true);\n                            this.v.setTripleAt(p0 + v0, p1 + v1, p0 + v0 - cPoint, p1 + v1, p0 + v0, p1 + v1, 3, true);\n                        }\n                    }\n                },\n                getValue: function getValue() {\n                    if (this.elem.globalData.frameId === this.frameId) {\n                        return;\n                    }\n                    this.frameId = this.elem.globalData.frameId;\n                    this.iterateDynamicProperties();\n                    if (this._mdf) {\n                        this.convertRectToPath();\n                    }\n                },\n                reset: resetShape\n            };\n            extendPrototype([\n                DynamicPropertyContainer\n            ], RectShapePropertyFactory);\n            return RectShapePropertyFactory;\n        }();\n        function getShapeProp(elem, data, type) {\n            var prop;\n            if (type === 3 || type === 4) {\n                var dataProp = type === 3 ? data.pt : data.ks;\n                var keys = dataProp.k;\n                if (keys.length) {\n                    prop = new KeyframedShapeProperty(elem, data, type);\n                } else {\n                    prop = new ShapeProperty(elem, data, type);\n                }\n            } else if (type === 5) {\n                prop = new RectShapeProperty(elem, data);\n            } else if (type === 6) {\n                prop = new EllShapeProperty(elem, data);\n            } else if (type === 7) {\n                prop = new StarShapeProperty(elem, data);\n            }\n            if (prop.k) {\n                elem.addDynamicProperty(prop);\n            }\n            return prop;\n        }\n        function getConstructorFunction() {\n            return ShapeProperty;\n        }\n        function getKeyframedConstructorFunction() {\n            return KeyframedShapeProperty;\n        }\n        var ob = {};\n        ob.getShapeProp = getShapeProp;\n        ob.getConstructorFunction = getConstructorFunction;\n        ob.getKeyframedConstructorFunction = getKeyframedConstructorFunction;\n        return ob;\n    }();\n    /*!\n   Transformation Matrix v2.0\n   (c) Epistemex 2014-2015\n   www.epistemex.com\n   By Ken Fyrstenberg\n   Contributions by leeoniya.\n   License: MIT, header required.\n   */ /**\n   * 2D transformation matrix object initialized with identity matrix.\n   *\n   * The matrix can synchronize a canvas context by supplying the context\n   * as an argument, or later apply current absolute transform to an\n   * existing context.\n   *\n   * All values are handled as floating point values.\n   *\n   * @param {CanvasRenderingContext2D} [context] - Optional context to sync with Matrix\n   * @prop {number} a - scale x\n   * @prop {number} b - shear y\n   * @prop {number} c - shear x\n   * @prop {number} d - scale y\n   * @prop {number} e - translate x\n   * @prop {number} f - translate y\n   * @prop {CanvasRenderingContext2D|null} [context=null] - set or get current canvas context\n   * @constructor\n   */ var Matrix = function() {\n        var _cos = Math.cos;\n        var _sin = Math.sin;\n        var _tan = Math.tan;\n        var _rnd = Math.round;\n        function reset() {\n            this.props[0] = 1;\n            this.props[1] = 0;\n            this.props[2] = 0;\n            this.props[3] = 0;\n            this.props[4] = 0;\n            this.props[5] = 1;\n            this.props[6] = 0;\n            this.props[7] = 0;\n            this.props[8] = 0;\n            this.props[9] = 0;\n            this.props[10] = 1;\n            this.props[11] = 0;\n            this.props[12] = 0;\n            this.props[13] = 0;\n            this.props[14] = 0;\n            this.props[15] = 1;\n            return this;\n        }\n        function rotate(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n        function rotateX(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(1, 0, 0, 0, 0, mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1);\n        }\n        function rotateY(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, 0, mSin, 0, 0, 1, 0, 0, -mSin, 0, mCos, 0, 0, 0, 0, 1);\n        }\n        function rotateZ(angle) {\n            if (angle === 0) {\n                return this;\n            }\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        }\n        function shear(sx, sy) {\n            return this._t(1, sy, sx, 1, 0, 0);\n        }\n        function skew(ax, ay) {\n            return this.shear(_tan(ax), _tan(ay));\n        }\n        function skewFromAxis(ax, angle) {\n            var mCos = _cos(angle);\n            var mSin = _sin(angle);\n            return this._t(mCos, mSin, 0, 0, -mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(1, 0, 0, 0, _tan(ax), 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)._t(mCos, -mSin, 0, 0, mSin, mCos, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);\n        // return this._t(mCos, mSin, -mSin, mCos, 0, 0)._t(1, 0, _tan(ax), 1, 0, 0)._t(mCos, -mSin, mSin, mCos, 0, 0);\n        }\n        function scale(sx, sy, sz) {\n            if (!sz && sz !== 0) {\n                sz = 1;\n            }\n            if (sx === 1 && sy === 1 && sz === 1) {\n                return this;\n            }\n            return this._t(sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1);\n        }\n        function setTransform(a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p) {\n            this.props[0] = a;\n            this.props[1] = b;\n            this.props[2] = c;\n            this.props[3] = d;\n            this.props[4] = e;\n            this.props[5] = f;\n            this.props[6] = g;\n            this.props[7] = h;\n            this.props[8] = i;\n            this.props[9] = j;\n            this.props[10] = k;\n            this.props[11] = l;\n            this.props[12] = m;\n            this.props[13] = n;\n            this.props[14] = o;\n            this.props[15] = p;\n            return this;\n        }\n        function translate(tx, ty, tz) {\n            tz = tz || 0;\n            if (tx !== 0 || ty !== 0 || tz !== 0) {\n                return this._t(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1);\n            }\n            return this;\n        }\n        function transform(a2, b2, c2, d2, e2, f2, g2, h2, i2, j2, k2, l2, m2, n2, o2, p2) {\n            var _p = this.props;\n            if (a2 === 1 && b2 === 0 && c2 === 0 && d2 === 0 && e2 === 0 && f2 === 1 && g2 === 0 && h2 === 0 && i2 === 0 && j2 === 0 && k2 === 1 && l2 === 0) {\n                // NOTE: commenting this condition because TurboFan deoptimizes code when present\n                // if(m2 !== 0 || n2 !== 0 || o2 !== 0){\n                _p[12] = _p[12] * a2 + _p[15] * m2;\n                _p[13] = _p[13] * f2 + _p[15] * n2;\n                _p[14] = _p[14] * k2 + _p[15] * o2;\n                _p[15] *= p2;\n                // }\n                this._identityCalculated = false;\n                return this;\n            }\n            var a1 = _p[0];\n            var b1 = _p[1];\n            var c1 = _p[2];\n            var d1 = _p[3];\n            var e1 = _p[4];\n            var f1 = _p[5];\n            var g1 = _p[6];\n            var h1 = _p[7];\n            var i1 = _p[8];\n            var j1 = _p[9];\n            var k1 = _p[10];\n            var l1 = _p[11];\n            var m1 = _p[12];\n            var n1 = _p[13];\n            var o1 = _p[14];\n            var p1 = _p[15];\n            /* matrix order (canvas compatible):\n           * ace\n           * bdf\n           * 001\n           */ _p[0] = a1 * a2 + b1 * e2 + c1 * i2 + d1 * m2;\n            _p[1] = a1 * b2 + b1 * f2 + c1 * j2 + d1 * n2;\n            _p[2] = a1 * c2 + b1 * g2 + c1 * k2 + d1 * o2;\n            _p[3] = a1 * d2 + b1 * h2 + c1 * l2 + d1 * p2;\n            _p[4] = e1 * a2 + f1 * e2 + g1 * i2 + h1 * m2;\n            _p[5] = e1 * b2 + f1 * f2 + g1 * j2 + h1 * n2;\n            _p[6] = e1 * c2 + f1 * g2 + g1 * k2 + h1 * o2;\n            _p[7] = e1 * d2 + f1 * h2 + g1 * l2 + h1 * p2;\n            _p[8] = i1 * a2 + j1 * e2 + k1 * i2 + l1 * m2;\n            _p[9] = i1 * b2 + j1 * f2 + k1 * j2 + l1 * n2;\n            _p[10] = i1 * c2 + j1 * g2 + k1 * k2 + l1 * o2;\n            _p[11] = i1 * d2 + j1 * h2 + k1 * l2 + l1 * p2;\n            _p[12] = m1 * a2 + n1 * e2 + o1 * i2 + p1 * m2;\n            _p[13] = m1 * b2 + n1 * f2 + o1 * j2 + p1 * n2;\n            _p[14] = m1 * c2 + n1 * g2 + o1 * k2 + p1 * o2;\n            _p[15] = m1 * d2 + n1 * h2 + o1 * l2 + p1 * p2;\n            this._identityCalculated = false;\n            return this;\n        }\n        function multiply(matrix) {\n            var matrixProps = matrix.props;\n            return this.transform(matrixProps[0], matrixProps[1], matrixProps[2], matrixProps[3], matrixProps[4], matrixProps[5], matrixProps[6], matrixProps[7], matrixProps[8], matrixProps[9], matrixProps[10], matrixProps[11], matrixProps[12], matrixProps[13], matrixProps[14], matrixProps[15]);\n        }\n        function isIdentity() {\n            if (!this._identityCalculated) {\n                this._identity = !(this.props[0] !== 1 || this.props[1] !== 0 || this.props[2] !== 0 || this.props[3] !== 0 || this.props[4] !== 0 || this.props[5] !== 1 || this.props[6] !== 0 || this.props[7] !== 0 || this.props[8] !== 0 || this.props[9] !== 0 || this.props[10] !== 1 || this.props[11] !== 0 || this.props[12] !== 0 || this.props[13] !== 0 || this.props[14] !== 0 || this.props[15] !== 1);\n                this._identityCalculated = true;\n            }\n            return this._identity;\n        }\n        function equals(matr) {\n            var i = 0;\n            while(i < 16){\n                if (matr.props[i] !== this.props[i]) {\n                    return false;\n                }\n                i += 1;\n            }\n            return true;\n        }\n        function clone(matr) {\n            var i;\n            for(i = 0; i < 16; i += 1){\n                matr.props[i] = this.props[i];\n            }\n            return matr;\n        }\n        function cloneFromProps(props) {\n            var i;\n            for(i = 0; i < 16; i += 1){\n                this.props[i] = props[i];\n            }\n        }\n        function applyToPoint(x, y, z) {\n            return {\n                x: x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n                y: x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n                z: x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n            };\n        /* return {\n           x: x * me.a + y * me.c + me.e,\n           y: x * me.b + y * me.d + me.f\n           }; */ }\n        function applyToX(x, y, z) {\n            return x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12];\n        }\n        function applyToY(x, y, z) {\n            return x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13];\n        }\n        function applyToZ(x, y, z) {\n            return x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14];\n        }\n        function getInverseMatrix() {\n            var determinant = this.props[0] * this.props[5] - this.props[1] * this.props[4];\n            var a = this.props[5] / determinant;\n            var b = -this.props[1] / determinant;\n            var c = -this.props[4] / determinant;\n            var d = this.props[0] / determinant;\n            var e = (this.props[4] * this.props[13] - this.props[5] * this.props[12]) / determinant;\n            var f = -(this.props[0] * this.props[13] - this.props[1] * this.props[12]) / determinant;\n            var inverseMatrix = new Matrix();\n            inverseMatrix.props[0] = a;\n            inverseMatrix.props[1] = b;\n            inverseMatrix.props[4] = c;\n            inverseMatrix.props[5] = d;\n            inverseMatrix.props[12] = e;\n            inverseMatrix.props[13] = f;\n            return inverseMatrix;\n        }\n        function inversePoint(pt) {\n            var inverseMatrix = this.getInverseMatrix();\n            return inverseMatrix.applyToPointArray(pt[0], pt[1], pt[2] || 0);\n        }\n        function inversePoints(pts) {\n            var i;\n            var len = pts.length;\n            var retPts = [];\n            for(i = 0; i < len; i += 1){\n                retPts[i] = inversePoint(pts[i]);\n            }\n            return retPts;\n        }\n        function applyToTriplePoints(pt1, pt2, pt3) {\n            var arr = createTypedArray('float32', 6);\n            if (this.isIdentity()) {\n                arr[0] = pt1[0];\n                arr[1] = pt1[1];\n                arr[2] = pt2[0];\n                arr[3] = pt2[1];\n                arr[4] = pt3[0];\n                arr[5] = pt3[1];\n            } else {\n                var p0 = this.props[0];\n                var p1 = this.props[1];\n                var p4 = this.props[4];\n                var p5 = this.props[5];\n                var p12 = this.props[12];\n                var p13 = this.props[13];\n                arr[0] = pt1[0] * p0 + pt1[1] * p4 + p12;\n                arr[1] = pt1[0] * p1 + pt1[1] * p5 + p13;\n                arr[2] = pt2[0] * p0 + pt2[1] * p4 + p12;\n                arr[3] = pt2[0] * p1 + pt2[1] * p5 + p13;\n                arr[4] = pt3[0] * p0 + pt3[1] * p4 + p12;\n                arr[5] = pt3[0] * p1 + pt3[1] * p5 + p13;\n            }\n            return arr;\n        }\n        function applyToPointArray(x, y, z) {\n            var arr;\n            if (this.isIdentity()) {\n                arr = [\n                    x,\n                    y,\n                    z\n                ];\n            } else {\n                arr = [\n                    x * this.props[0] + y * this.props[4] + z * this.props[8] + this.props[12],\n                    x * this.props[1] + y * this.props[5] + z * this.props[9] + this.props[13],\n                    x * this.props[2] + y * this.props[6] + z * this.props[10] + this.props[14]\n                ];\n            }\n            return arr;\n        }\n        function applyToPointStringified(x, y) {\n            if (this.isIdentity()) {\n                return x + ',' + y;\n            }\n            var _p = this.props;\n            return Math.round((x * _p[0] + y * _p[4] + _p[12]) * 100) / 100 + ',' + Math.round((x * _p[1] + y * _p[5] + _p[13]) * 100) / 100;\n        }\n        function toCSS() {\n            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n            /* if(this.isIdentity()) {\n              return '';\n          } */ var i = 0;\n            var props = this.props;\n            var cssValue = 'matrix3d(';\n            var v = 10000;\n            while(i < 16){\n                cssValue += _rnd(props[i] * v) / v;\n                cssValue += i === 15 ? ')' : ',';\n                i += 1;\n            }\n            return cssValue;\n        }\n        function roundMatrixProperty(val) {\n            var v = 10000;\n            if (val < 0.000001 && val > 0 || val > -0.000001 && val < 0) {\n                return _rnd(val * v) / v;\n            }\n            return val;\n        }\n        function to2dCSS() {\n            // Doesn't make much sense to add this optimization. If it is an identity matrix, it's very likely this will get called only once since it won't be keyframed.\n            /* if(this.isIdentity()) {\n              return '';\n          } */ var props = this.props;\n            var _a = roundMatrixProperty(props[0]);\n            var _b = roundMatrixProperty(props[1]);\n            var _c = roundMatrixProperty(props[4]);\n            var _d = roundMatrixProperty(props[5]);\n            var _e = roundMatrixProperty(props[12]);\n            var _f = roundMatrixProperty(props[13]);\n            return 'matrix(' + _a + ',' + _b + ',' + _c + ',' + _d + ',' + _e + ',' + _f + ')';\n        }\n        return function() {\n            this.reset = reset;\n            this.rotate = rotate;\n            this.rotateX = rotateX;\n            this.rotateY = rotateY;\n            this.rotateZ = rotateZ;\n            this.skew = skew;\n            this.skewFromAxis = skewFromAxis;\n            this.shear = shear;\n            this.scale = scale;\n            this.setTransform = setTransform;\n            this.translate = translate;\n            this.transform = transform;\n            this.multiply = multiply;\n            this.applyToPoint = applyToPoint;\n            this.applyToX = applyToX;\n            this.applyToY = applyToY;\n            this.applyToZ = applyToZ;\n            this.applyToPointArray = applyToPointArray;\n            this.applyToTriplePoints = applyToTriplePoints;\n            this.applyToPointStringified = applyToPointStringified;\n            this.toCSS = toCSS;\n            this.to2dCSS = to2dCSS;\n            this.clone = clone;\n            this.cloneFromProps = cloneFromProps;\n            this.equals = equals;\n            this.inversePoints = inversePoints;\n            this.inversePoint = inversePoint;\n            this.getInverseMatrix = getInverseMatrix;\n            this._t = this.transform;\n            this.isIdentity = isIdentity;\n            this._identity = true;\n            this._identityCalculated = false;\n            this.props = createTypedArray('float32', 16);\n            this.reset();\n        };\n    }();\n    function _typeof$3(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof$3 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof$3(o);\n    }\n    var lottie = {};\n    var standalone = '__[STANDALONE]__';\n    var animationData = '__[ANIMATIONDATA]__';\n    var renderer = '';\n    function setLocation(href) {\n        setLocationHref(href);\n    }\n    function searchAnimations() {\n        if (standalone === true) {\n            animationManager.searchAnimations(animationData, standalone, renderer);\n        } else {\n            animationManager.searchAnimations();\n        }\n    }\n    function setSubframeRendering(flag) {\n        setSubframeEnabled(flag);\n    }\n    function setPrefix(prefix) {\n        setIdPrefix(prefix);\n    }\n    function loadAnimation(params) {\n        if (standalone === true) {\n            params.animationData = JSON.parse(animationData);\n        }\n        return animationManager.loadAnimation(params);\n    }\n    function setQuality(value) {\n        if (typeof value === 'string') {\n            switch(value){\n                case 'high':\n                    setDefaultCurveSegments(200);\n                    break;\n                default:\n                case 'medium':\n                    setDefaultCurveSegments(50);\n                    break;\n                case 'low':\n                    setDefaultCurveSegments(10);\n                    break;\n            }\n        } else if (!isNaN(value) && value > 1) {\n            setDefaultCurveSegments(value);\n        }\n        if (getDefaultCurveSegments() >= 50) {\n            roundValues(false);\n        } else {\n            roundValues(true);\n        }\n    }\n    function inBrowser() {\n        return typeof navigator !== 'undefined';\n    }\n    function installPlugin(type, plugin) {\n        if (type === 'expressions') {\n            setExpressionsPlugin(plugin);\n        }\n    }\n    function getFactory(name) {\n        switch(name){\n            case 'propertyFactory':\n                return PropertyFactory;\n            case 'shapePropertyFactory':\n                return ShapePropertyFactory;\n            case 'matrix':\n                return Matrix;\n            default:\n                return null;\n        }\n    }\n    lottie.play = animationManager.play;\n    lottie.pause = animationManager.pause;\n    lottie.setLocationHref = setLocation;\n    lottie.togglePause = animationManager.togglePause;\n    lottie.setSpeed = animationManager.setSpeed;\n    lottie.setDirection = animationManager.setDirection;\n    lottie.stop = animationManager.stop;\n    lottie.searchAnimations = searchAnimations;\n    lottie.registerAnimation = animationManager.registerAnimation;\n    lottie.loadAnimation = loadAnimation;\n    lottie.setSubframeRendering = setSubframeRendering;\n    lottie.resize = animationManager.resize;\n    // lottie.start = start;\n    lottie.goToAndStop = animationManager.goToAndStop;\n    lottie.destroy = animationManager.destroy;\n    lottie.setQuality = setQuality;\n    lottie.inBrowser = inBrowser;\n    lottie.installPlugin = installPlugin;\n    lottie.freeze = animationManager.freeze;\n    lottie.unfreeze = animationManager.unfreeze;\n    lottie.setVolume = animationManager.setVolume;\n    lottie.mute = animationManager.mute;\n    lottie.unmute = animationManager.unmute;\n    lottie.getRegisteredAnimations = animationManager.getRegisteredAnimations;\n    lottie.useWebWorker = setWebWorker;\n    lottie.setIDPrefix = setPrefix;\n    lottie.__getFactory = getFactory;\n    lottie.version = '5.13.0';\n    function checkReady() {\n        if (document.readyState === 'complete') {\n            clearInterval(readyStateCheckInterval);\n            searchAnimations();\n        }\n    }\n    function getQueryVariable(variable) {\n        var vars = queryString.split('&');\n        for(var i = 0; i < vars.length; i += 1){\n            var pair = vars[i].split('=');\n            if (decodeURIComponent(pair[0]) == variable) {\n                // eslint-disable-line eqeqeq\n                return decodeURIComponent(pair[1]);\n            }\n        }\n        return null;\n    }\n    var queryString = '';\n    if (standalone) {\n        var scripts = document.getElementsByTagName('script');\n        var index = scripts.length - 1;\n        var myScript = scripts[index] || {\n            src: ''\n        };\n        queryString = myScript.src ? myScript.src.replace(/^[^\\?]+\\??/, '') : ''; // eslint-disable-line no-useless-escape\n        renderer = getQueryVariable('renderer');\n    }\n    var readyStateCheckInterval = setInterval(checkReady, 100);\n    // this adds bodymovin to the window object for backwards compatibility\n    try {\n        if (!(( false ? 0 : _typeof$3(exports)) === 'object' && \"object\" !== 'undefined') && !( true && __webpack_require__.amdO // eslint-disable-line no-undef\n        )) {}\n    } catch (err) {\n    //\n    }\n    var ShapeModifiers = function() {\n        var ob = {};\n        var modifiers = {};\n        ob.registerModifier = registerModifier;\n        ob.getModifier = getModifier;\n        function registerModifier(nm, factory) {\n            if (!modifiers[nm]) {\n                modifiers[nm] = factory;\n            }\n        }\n        function getModifier(nm, elem, data) {\n            return new modifiers[nm](elem, data);\n        }\n        return ob;\n    }();\n    function ShapeModifier() {}\n    ShapeModifier.prototype.initModifierProperties = function() {};\n    ShapeModifier.prototype.addShapeToModifier = function() {};\n    ShapeModifier.prototype.addShape = function(data) {\n        if (!this.closed) {\n            // Adding shape to dynamic properties. It covers the case where a shape has no effects applied, to reset it's _mdf state on every tick.\n            data.sh.container.addDynamicProperty(data.sh);\n            var shapeData = {\n                shape: data.sh,\n                data: data,\n                localShapeCollection: shapeCollectionPool.newShapeCollection()\n            };\n            this.shapes.push(shapeData);\n            this.addShapeToModifier(shapeData);\n            if (this._isAnimated) {\n                data.setAsAnimated();\n            }\n        }\n    };\n    ShapeModifier.prototype.init = function(elem, data) {\n        this.shapes = [];\n        this.elem = elem;\n        this.initDynamicPropertyContainer(elem);\n        this.initModifierProperties(elem, data);\n        this.frameId = initialDefaultFrame;\n        this.closed = false;\n        this.k = false;\n        if (this.dynamicProperties.length) {\n            this.k = true;\n        } else {\n            this.getValue(true);\n        }\n    };\n    ShapeModifier.prototype.processKeys = function() {\n        if (this.elem.globalData.frameId === this.frameId) {\n            return;\n        }\n        this.frameId = this.elem.globalData.frameId;\n        this.iterateDynamicProperties();\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], ShapeModifier);\n    function TrimModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], TrimModifier);\n    TrimModifier.prototype.initModifierProperties = function(elem, data) {\n        this.s = PropertyFactory.getProp(elem, data.s, 0, 0.01, this);\n        this.e = PropertyFactory.getProp(elem, data.e, 0, 0.01, this);\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0, this);\n        this.sValue = 0;\n        this.eValue = 0;\n        this.getValue = this.processKeys;\n        this.m = data.m;\n        this._isAnimated = !!this.s.effectsSequence.length || !!this.e.effectsSequence.length || !!this.o.effectsSequence.length;\n    };\n    TrimModifier.prototype.addShapeToModifier = function(shapeData) {\n        shapeData.pathsData = [];\n    };\n    TrimModifier.prototype.calculateShapeEdges = function(s, e, shapeLength, addedLength, totalModifierLength) {\n        var segments = [];\n        if (e <= 1) {\n            segments.push({\n                s: s,\n                e: e\n            });\n        } else if (s >= 1) {\n            segments.push({\n                s: s - 1,\n                e: e - 1\n            });\n        } else {\n            segments.push({\n                s: s,\n                e: 1\n            });\n            segments.push({\n                s: 0,\n                e: e - 1\n            });\n        }\n        var shapeSegments = [];\n        var i;\n        var len = segments.length;\n        var segmentOb;\n        for(i = 0; i < len; i += 1){\n            segmentOb = segments[i];\n            if (!(segmentOb.e * totalModifierLength < addedLength || segmentOb.s * totalModifierLength > addedLength + shapeLength)) {\n                var shapeS;\n                var shapeE;\n                if (segmentOb.s * totalModifierLength <= addedLength) {\n                    shapeS = 0;\n                } else {\n                    shapeS = (segmentOb.s * totalModifierLength - addedLength) / shapeLength;\n                }\n                if (segmentOb.e * totalModifierLength >= addedLength + shapeLength) {\n                    shapeE = 1;\n                } else {\n                    shapeE = (segmentOb.e * totalModifierLength - addedLength) / shapeLength;\n                }\n                shapeSegments.push([\n                    shapeS,\n                    shapeE\n                ]);\n            }\n        }\n        if (!shapeSegments.length) {\n            shapeSegments.push([\n                0,\n                0\n            ]);\n        }\n        return shapeSegments;\n    };\n    TrimModifier.prototype.releasePathsData = function(pathsData) {\n        var i;\n        var len = pathsData.length;\n        for(i = 0; i < len; i += 1){\n            segmentsLengthPool.release(pathsData[i]);\n        }\n        pathsData.length = 0;\n        return pathsData;\n    };\n    TrimModifier.prototype.processShapes = function(_isFirstFrame) {\n        var s;\n        var e;\n        if (this._mdf || _isFirstFrame) {\n            var o = this.o.v % 360 / 360;\n            if (o < 0) {\n                o += 1;\n            }\n            if (this.s.v > 1) {\n                s = 1 + o;\n            } else if (this.s.v < 0) {\n                s = 0 + o;\n            } else {\n                s = this.s.v + o;\n            }\n            if (this.e.v > 1) {\n                e = 1 + o;\n            } else if (this.e.v < 0) {\n                e = 0 + o;\n            } else {\n                e = this.e.v + o;\n            }\n            if (s > e) {\n                var _s = s;\n                s = e;\n                e = _s;\n            }\n            s = Math.round(s * 10000) * 0.0001;\n            e = Math.round(e * 10000) * 0.0001;\n            this.sValue = s;\n            this.eValue = e;\n        } else {\n            s = this.sValue;\n            e = this.eValue;\n        }\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var pathsData;\n        var pathData;\n        var totalShapeLength;\n        var totalModifierLength = 0;\n        if (e === s) {\n            for(i = 0; i < len; i += 1){\n                this.shapes[i].localShapeCollection.releaseShapes();\n                this.shapes[i].shape._mdf = true;\n                this.shapes[i].shape.paths = this.shapes[i].localShapeCollection;\n                if (this._mdf) {\n                    this.shapes[i].pathsData.length = 0;\n                }\n            }\n        } else if (!(e === 1 && s === 0 || e === 0 && s === 1)) {\n            var segments = [];\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                // if shape hasn't changed and trim properties haven't changed, cached previous path can be used\n                if (!shapeData.shape._mdf && !this._mdf && !_isFirstFrame && this.m !== 2) {\n                    shapeData.shape.paths = shapeData.localShapeCollection;\n                } else {\n                    shapePaths = shapeData.shape.paths;\n                    jLen = shapePaths._length;\n                    totalShapeLength = 0;\n                    if (!shapeData.shape._mdf && shapeData.pathsData.length) {\n                        totalShapeLength = shapeData.totalShapeLength;\n                    } else {\n                        pathsData = this.releasePathsData(shapeData.pathsData);\n                        for(j = 0; j < jLen; j += 1){\n                            pathData = bez.getSegmentsLength(shapePaths.shapes[j]);\n                            pathsData.push(pathData);\n                            totalShapeLength += pathData.totalLength;\n                        }\n                        shapeData.totalShapeLength = totalShapeLength;\n                        shapeData.pathsData = pathsData;\n                    }\n                    totalModifierLength += totalShapeLength;\n                    shapeData.shape._mdf = true;\n                }\n            }\n            var shapeS = s;\n            var shapeE = e;\n            var addedLength = 0;\n            var edges;\n            for(i = len - 1; i >= 0; i -= 1){\n                shapeData = this.shapes[i];\n                if (shapeData.shape._mdf) {\n                    localShapeCollection = shapeData.localShapeCollection;\n                    localShapeCollection.releaseShapes();\n                    // if m === 2 means paths are trimmed individually so edges need to be found for this specific shape relative to whoel group\n                    if (this.m === 2 && len > 1) {\n                        edges = this.calculateShapeEdges(s, e, shapeData.totalShapeLength, addedLength, totalModifierLength);\n                        addedLength += shapeData.totalShapeLength;\n                    } else {\n                        edges = [\n                            [\n                                shapeS,\n                                shapeE\n                            ]\n                        ];\n                    }\n                    jLen = edges.length;\n                    for(j = 0; j < jLen; j += 1){\n                        shapeS = edges[j][0];\n                        shapeE = edges[j][1];\n                        segments.length = 0;\n                        if (shapeE <= 1) {\n                            segments.push({\n                                s: shapeData.totalShapeLength * shapeS,\n                                e: shapeData.totalShapeLength * shapeE\n                            });\n                        } else if (shapeS >= 1) {\n                            segments.push({\n                                s: shapeData.totalShapeLength * (shapeS - 1),\n                                e: shapeData.totalShapeLength * (shapeE - 1)\n                            });\n                        } else {\n                            segments.push({\n                                s: shapeData.totalShapeLength * shapeS,\n                                e: shapeData.totalShapeLength\n                            });\n                            segments.push({\n                                s: 0,\n                                e: shapeData.totalShapeLength * (shapeE - 1)\n                            });\n                        }\n                        var newShapesData = this.addShapes(shapeData, segments[0]);\n                        if (segments[0].s !== segments[0].e) {\n                            if (segments.length > 1) {\n                                var lastShapeInCollection = shapeData.shape.paths.shapes[shapeData.shape.paths._length - 1];\n                                if (lastShapeInCollection.c) {\n                                    var lastShape = newShapesData.pop();\n                                    this.addPaths(newShapesData, localShapeCollection);\n                                    newShapesData = this.addShapes(shapeData, segments[1], lastShape);\n                                } else {\n                                    this.addPaths(newShapesData, localShapeCollection);\n                                    newShapesData = this.addShapes(shapeData, segments[1]);\n                                }\n                            }\n                            this.addPaths(newShapesData, localShapeCollection);\n                        }\n                    }\n                    shapeData.shape.paths = localShapeCollection;\n                }\n            }\n        } else if (this._mdf) {\n            for(i = 0; i < len; i += 1){\n                // Releasign Trim Cached paths data when no trim applied in case shapes are modified inbetween.\n                // Don't remove this even if it's losing cached info.\n                this.shapes[i].pathsData.length = 0;\n                this.shapes[i].shape._mdf = true;\n            }\n        }\n    };\n    TrimModifier.prototype.addPaths = function(newPaths, localShapeCollection) {\n        var i;\n        var len = newPaths.length;\n        for(i = 0; i < len; i += 1){\n            localShapeCollection.addShape(newPaths[i]);\n        }\n    };\n    TrimModifier.prototype.addSegment = function(pt1, pt2, pt3, pt4, shapePath, pos, newShape) {\n        shapePath.setXYAt(pt2[0], pt2[1], 'o', pos);\n        shapePath.setXYAt(pt3[0], pt3[1], 'i', pos + 1);\n        if (newShape) {\n            shapePath.setXYAt(pt1[0], pt1[1], 'v', pos);\n        }\n        shapePath.setXYAt(pt4[0], pt4[1], 'v', pos + 1);\n    };\n    TrimModifier.prototype.addSegmentFromArray = function(points, shapePath, pos, newShape) {\n        shapePath.setXYAt(points[1], points[5], 'o', pos);\n        shapePath.setXYAt(points[2], points[6], 'i', pos + 1);\n        if (newShape) {\n            shapePath.setXYAt(points[0], points[4], 'v', pos);\n        }\n        shapePath.setXYAt(points[3], points[7], 'v', pos + 1);\n    };\n    TrimModifier.prototype.addShapes = function(shapeData, shapeSegment, shapePath) {\n        var pathsData = shapeData.pathsData;\n        var shapePaths = shapeData.shape.paths.shapes;\n        var i;\n        var len = shapeData.shape.paths._length;\n        var j;\n        var jLen;\n        var addedLength = 0;\n        var currentLengthData;\n        var segmentCount;\n        var lengths;\n        var segment;\n        var shapes = [];\n        var initPos;\n        var newShape = true;\n        if (!shapePath) {\n            shapePath = shapePool.newElement();\n            segmentCount = 0;\n            initPos = 0;\n        } else {\n            segmentCount = shapePath._length;\n            initPos = shapePath._length;\n        }\n        shapes.push(shapePath);\n        for(i = 0; i < len; i += 1){\n            lengths = pathsData[i].lengths;\n            shapePath.c = shapePaths[i].c;\n            jLen = shapePaths[i].c ? lengths.length : lengths.length + 1;\n            for(j = 1; j < jLen; j += 1){\n                currentLengthData = lengths[j - 1];\n                if (addedLength + currentLengthData.addedLength < shapeSegment.s) {\n                    addedLength += currentLengthData.addedLength;\n                    shapePath.c = false;\n                } else if (addedLength > shapeSegment.e) {\n                    shapePath.c = false;\n                    break;\n                } else {\n                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + currentLengthData.addedLength) {\n                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[j], shapePaths[i].v[j], shapePath, segmentCount, newShape);\n                        newShape = false;\n                    } else {\n                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[j], shapePaths[i].o[j - 1], shapePaths[i].i[j], (shapeSegment.s - addedLength) / currentLengthData.addedLength, (shapeSegment.e - addedLength) / currentLengthData.addedLength, lengths[j - 1]);\n                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);\n                        // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n                        newShape = false;\n                        shapePath.c = false;\n                    }\n                    addedLength += currentLengthData.addedLength;\n                    segmentCount += 1;\n                }\n            }\n            if (shapePaths[i].c && lengths.length) {\n                currentLengthData = lengths[j - 1];\n                if (addedLength <= shapeSegment.e) {\n                    var segmentLength = lengths[j - 1].addedLength;\n                    if (shapeSegment.s <= addedLength && shapeSegment.e >= addedLength + segmentLength) {\n                        this.addSegment(shapePaths[i].v[j - 1], shapePaths[i].o[j - 1], shapePaths[i].i[0], shapePaths[i].v[0], shapePath, segmentCount, newShape);\n                        newShape = false;\n                    } else {\n                        segment = bez.getNewSegment(shapePaths[i].v[j - 1], shapePaths[i].v[0], shapePaths[i].o[j - 1], shapePaths[i].i[0], (shapeSegment.s - addedLength) / segmentLength, (shapeSegment.e - addedLength) / segmentLength, lengths[j - 1]);\n                        this.addSegmentFromArray(segment, shapePath, segmentCount, newShape);\n                        // this.addSegment(segment.pt1, segment.pt3, segment.pt4, segment.pt2, shapePath, segmentCount, newShape);\n                        newShape = false;\n                        shapePath.c = false;\n                    }\n                } else {\n                    shapePath.c = false;\n                }\n                addedLength += currentLengthData.addedLength;\n                segmentCount += 1;\n            }\n            if (shapePath._length) {\n                shapePath.setXYAt(shapePath.v[initPos][0], shapePath.v[initPos][1], 'i', initPos);\n                shapePath.setXYAt(shapePath.v[shapePath._length - 1][0], shapePath.v[shapePath._length - 1][1], 'o', shapePath._length - 1);\n            }\n            if (addedLength > shapeSegment.e) {\n                break;\n            }\n            if (i < len - 1) {\n                shapePath = shapePool.newElement();\n                newShape = true;\n                shapes.push(shapePath);\n                segmentCount = 0;\n            }\n        }\n        return shapes;\n    };\n    function PuckerAndBloatModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], PuckerAndBloatModifier);\n    PuckerAndBloatModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n        this._isAnimated = !!this.amount.effectsSequence.length;\n    };\n    PuckerAndBloatModifier.prototype.processPath = function(path, amount) {\n        var percent = amount / 100;\n        var centerPoint = [\n            0,\n            0\n        ];\n        var pathLength = path._length;\n        var i = 0;\n        for(i = 0; i < pathLength; i += 1){\n            centerPoint[0] += path.v[i][0];\n            centerPoint[1] += path.v[i][1];\n        }\n        centerPoint[0] /= pathLength;\n        centerPoint[1] /= pathLength;\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        var vX;\n        var vY;\n        var oX;\n        var oY;\n        var iX;\n        var iY;\n        for(i = 0; i < pathLength; i += 1){\n            vX = path.v[i][0] + (centerPoint[0] - path.v[i][0]) * percent;\n            vY = path.v[i][1] + (centerPoint[1] - path.v[i][1]) * percent;\n            oX = path.o[i][0] + (centerPoint[0] - path.o[i][0]) * -percent;\n            oY = path.o[i][1] + (centerPoint[1] - path.o[i][1]) * -percent;\n            iX = path.i[i][0] + (centerPoint[0] - path.i[i][0]) * -percent;\n            iY = path.i[i][1] + (centerPoint[1] - path.i[i][1]) * -percent;\n            clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, i);\n        }\n        return clonedPath;\n    };\n    PuckerAndBloatModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amount = this.amount.v;\n        if (amount !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amount));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    var TransformPropertyFactory = function() {\n        var defaultVector = [\n            0,\n            0\n        ];\n        function applyToMatrix(mat) {\n            var _mdf = this._mdf;\n            this.iterateDynamicProperties();\n            this._mdf = this._mdf || _mdf;\n            if (this.a) {\n                mat.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n            }\n            if (this.s) {\n                mat.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n            }\n            if (this.sk) {\n                mat.skewFromAxis(-this.sk.v, this.sa.v);\n            }\n            if (this.r) {\n                mat.rotate(-this.r.v);\n            } else {\n                mat.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n            }\n            if (this.data.p.s) {\n                if (this.data.p.z) {\n                    mat.translate(this.px.v, this.py.v, -this.pz.v);\n                } else {\n                    mat.translate(this.px.v, this.py.v, 0);\n                }\n            } else {\n                mat.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n            }\n        }\n        function processKeys(forceRender) {\n            if (this.elem.globalData.frameId === this.frameId) {\n                return;\n            }\n            if (this._isDirty) {\n                this.precalculateMatrix();\n                this._isDirty = false;\n            }\n            this.iterateDynamicProperties();\n            if (this._mdf || forceRender) {\n                var frameRate;\n                this.v.cloneFromProps(this.pre.props);\n                if (this.appliedTransformations < 1) {\n                    this.v.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n                }\n                if (this.appliedTransformations < 2) {\n                    this.v.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n                }\n                if (this.sk && this.appliedTransformations < 3) {\n                    this.v.skewFromAxis(-this.sk.v, this.sa.v);\n                }\n                if (this.r && this.appliedTransformations < 4) {\n                    this.v.rotate(-this.r.v);\n                } else if (!this.r && this.appliedTransformations < 4) {\n                    this.v.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n                }\n                if (this.autoOriented) {\n                    var v1;\n                    var v2;\n                    frameRate = this.elem.globalData.frameRate;\n                    if (this.p && this.p.keyframes && this.p.getValueAtTime) {\n                        if (this.p._caching.lastFrame + this.p.offsetTime <= this.p.keyframes[0].t) {\n                            v1 = this.p.getValueAtTime((this.p.keyframes[0].t + 0.01) / frameRate, 0);\n                            v2 = this.p.getValueAtTime(this.p.keyframes[0].t / frameRate, 0);\n                        } else if (this.p._caching.lastFrame + this.p.offsetTime >= this.p.keyframes[this.p.keyframes.length - 1].t) {\n                            v1 = this.p.getValueAtTime(this.p.keyframes[this.p.keyframes.length - 1].t / frameRate, 0);\n                            v2 = this.p.getValueAtTime((this.p.keyframes[this.p.keyframes.length - 1].t - 0.05) / frameRate, 0);\n                        } else {\n                            v1 = this.p.pv;\n                            v2 = this.p.getValueAtTime((this.p._caching.lastFrame + this.p.offsetTime - 0.01) / frameRate, this.p.offsetTime);\n                        }\n                    } else if (this.px && this.px.keyframes && this.py.keyframes && this.px.getValueAtTime && this.py.getValueAtTime) {\n                        v1 = [];\n                        v2 = [];\n                        var px = this.px;\n                        var py = this.py;\n                        if (px._caching.lastFrame + px.offsetTime <= px.keyframes[0].t) {\n                            v1[0] = px.getValueAtTime((px.keyframes[0].t + 0.01) / frameRate, 0);\n                            v1[1] = py.getValueAtTime((py.keyframes[0].t + 0.01) / frameRate, 0);\n                            v2[0] = px.getValueAtTime(px.keyframes[0].t / frameRate, 0);\n                            v2[1] = py.getValueAtTime(py.keyframes[0].t / frameRate, 0);\n                        } else if (px._caching.lastFrame + px.offsetTime >= px.keyframes[px.keyframes.length - 1].t) {\n                            v1[0] = px.getValueAtTime(px.keyframes[px.keyframes.length - 1].t / frameRate, 0);\n                            v1[1] = py.getValueAtTime(py.keyframes[py.keyframes.length - 1].t / frameRate, 0);\n                            v2[0] = px.getValueAtTime((px.keyframes[px.keyframes.length - 1].t - 0.01) / frameRate, 0);\n                            v2[1] = py.getValueAtTime((py.keyframes[py.keyframes.length - 1].t - 0.01) / frameRate, 0);\n                        } else {\n                            v1 = [\n                                px.pv,\n                                py.pv\n                            ];\n                            v2[0] = px.getValueAtTime((px._caching.lastFrame + px.offsetTime - 0.01) / frameRate, px.offsetTime);\n                            v2[1] = py.getValueAtTime((py._caching.lastFrame + py.offsetTime - 0.01) / frameRate, py.offsetTime);\n                        }\n                    } else {\n                        v2 = defaultVector;\n                        v1 = v2;\n                    }\n                    this.v.rotate(-Math.atan2(v1[1] - v2[1], v1[0] - v2[0]));\n                }\n                if (this.data.p && this.data.p.s) {\n                    if (this.data.p.z) {\n                        this.v.translate(this.px.v, this.py.v, -this.pz.v);\n                    } else {\n                        this.v.translate(this.px.v, this.py.v, 0);\n                    }\n                } else {\n                    this.v.translate(this.p.v[0], this.p.v[1], -this.p.v[2]);\n                }\n            }\n            this.frameId = this.elem.globalData.frameId;\n        }\n        function precalculateMatrix() {\n            this.appliedTransformations = 0;\n            this.pre.reset();\n            if (!this.a.effectsSequence.length) {\n                this.pre.translate(-this.a.v[0], -this.a.v[1], this.a.v[2]);\n                this.appliedTransformations = 1;\n            } else {\n                return;\n            }\n            if (!this.s.effectsSequence.length) {\n                this.pre.scale(this.s.v[0], this.s.v[1], this.s.v[2]);\n                this.appliedTransformations = 2;\n            } else {\n                return;\n            }\n            if (this.sk) {\n                if (!this.sk.effectsSequence.length && !this.sa.effectsSequence.length) {\n                    this.pre.skewFromAxis(-this.sk.v, this.sa.v);\n                    this.appliedTransformations = 3;\n                } else {\n                    return;\n                }\n            }\n            if (this.r) {\n                if (!this.r.effectsSequence.length) {\n                    this.pre.rotate(-this.r.v);\n                    this.appliedTransformations = 4;\n                }\n            } else if (!this.rz.effectsSequence.length && !this.ry.effectsSequence.length && !this.rx.effectsSequence.length && !this.or.effectsSequence.length) {\n                this.pre.rotateZ(-this.rz.v).rotateY(this.ry.v).rotateX(this.rx.v).rotateZ(-this.or.v[2]).rotateY(this.or.v[1]).rotateX(this.or.v[0]);\n                this.appliedTransformations = 4;\n            }\n        }\n        function autoOrient() {\n        //\n        // var prevP = this.getValueAtTime();\n        }\n        function addDynamicProperty(prop) {\n            this._addDynamicProperty(prop);\n            this.elem.addDynamicProperty(prop);\n            this._isDirty = true;\n        }\n        function TransformProperty(elem, data, container) {\n            this.elem = elem;\n            this.frameId = -1;\n            this.propType = 'transform';\n            this.data = data;\n            this.v = new Matrix();\n            // Precalculated matrix with non animated properties\n            this.pre = new Matrix();\n            this.appliedTransformations = 0;\n            this.initDynamicPropertyContainer(container || elem);\n            if (data.p && data.p.s) {\n                this.px = PropertyFactory.getProp(elem, data.p.x, 0, 0, this);\n                this.py = PropertyFactory.getProp(elem, data.p.y, 0, 0, this);\n                if (data.p.z) {\n                    this.pz = PropertyFactory.getProp(elem, data.p.z, 0, 0, this);\n                }\n            } else {\n                this.p = PropertyFactory.getProp(elem, data.p || {\n                    k: [\n                        0,\n                        0,\n                        0\n                    ]\n                }, 1, 0, this);\n            }\n            if (data.rx) {\n                this.rx = PropertyFactory.getProp(elem, data.rx, 0, degToRads, this);\n                this.ry = PropertyFactory.getProp(elem, data.ry, 0, degToRads, this);\n                this.rz = PropertyFactory.getProp(elem, data.rz, 0, degToRads, this);\n                if (data.or.k[0].ti) {\n                    var i;\n                    var len = data.or.k.length;\n                    for(i = 0; i < len; i += 1){\n                        data.or.k[i].to = null;\n                        data.or.k[i].ti = null;\n                    }\n                }\n                this.or = PropertyFactory.getProp(elem, data.or, 1, degToRads, this);\n                // sh Indicates it needs to be capped between -180 and 180\n                this.or.sh = true;\n            } else {\n                this.r = PropertyFactory.getProp(elem, data.r || {\n                    k: 0\n                }, 0, degToRads, this);\n            }\n            if (data.sk) {\n                this.sk = PropertyFactory.getProp(elem, data.sk, 0, degToRads, this);\n                this.sa = PropertyFactory.getProp(elem, data.sa, 0, degToRads, this);\n            }\n            this.a = PropertyFactory.getProp(elem, data.a || {\n                k: [\n                    0,\n                    0,\n                    0\n                ]\n            }, 1, 0, this);\n            this.s = PropertyFactory.getProp(elem, data.s || {\n                k: [\n                    100,\n                    100,\n                    100\n                ]\n            }, 1, 0.01, this);\n            // Opacity is not part of the transform properties, that's why it won't use this.dynamicProperties. That way transforms won't get updated if opacity changes.\n            if (data.o) {\n                this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, elem);\n            } else {\n                this.o = {\n                    _mdf: false,\n                    v: 1\n                };\n            }\n            this._isDirty = true;\n            if (!this.dynamicProperties.length) {\n                this.getValue(true);\n            }\n        }\n        TransformProperty.prototype = {\n            applyToMatrix: applyToMatrix,\n            getValue: processKeys,\n            precalculateMatrix: precalculateMatrix,\n            autoOrient: autoOrient\n        };\n        extendPrototype([\n            DynamicPropertyContainer\n        ], TransformProperty);\n        TransformProperty.prototype.addDynamicProperty = addDynamicProperty;\n        TransformProperty.prototype._addDynamicProperty = DynamicPropertyContainer.prototype.addDynamicProperty;\n        function getTransformProperty(elem, data, container) {\n            return new TransformProperty(elem, data, container);\n        }\n        return {\n            getTransformProperty: getTransformProperty\n        };\n    }();\n    function RepeaterModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], RepeaterModifier);\n    RepeaterModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.c = PropertyFactory.getProp(elem, data.c, 0, null, this);\n        this.o = PropertyFactory.getProp(elem, data.o, 0, null, this);\n        this.tr = TransformPropertyFactory.getTransformProperty(elem, data.tr, this);\n        this.so = PropertyFactory.getProp(elem, data.tr.so, 0, 0.01, this);\n        this.eo = PropertyFactory.getProp(elem, data.tr.eo, 0, 0.01, this);\n        this.data = data;\n        if (!this.dynamicProperties.length) {\n            this.getValue(true);\n        }\n        this._isAnimated = !!this.dynamicProperties.length;\n        this.pMatrix = new Matrix();\n        this.rMatrix = new Matrix();\n        this.sMatrix = new Matrix();\n        this.tMatrix = new Matrix();\n        this.matrix = new Matrix();\n    };\n    RepeaterModifier.prototype.applyTransforms = function(pMatrix, rMatrix, sMatrix, transform, perc, inv) {\n        var dir = inv ? -1 : 1;\n        var scaleX = transform.s.v[0] + (1 - transform.s.v[0]) * (1 - perc);\n        var scaleY = transform.s.v[1] + (1 - transform.s.v[1]) * (1 - perc);\n        pMatrix.translate(transform.p.v[0] * dir * perc, transform.p.v[1] * dir * perc, transform.p.v[2]);\n        rMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n        rMatrix.rotate(-transform.r.v * dir * perc);\n        rMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n        sMatrix.translate(-transform.a.v[0], -transform.a.v[1], transform.a.v[2]);\n        sMatrix.scale(inv ? 1 / scaleX : scaleX, inv ? 1 / scaleY : scaleY);\n        sMatrix.translate(transform.a.v[0], transform.a.v[1], transform.a.v[2]);\n    };\n    RepeaterModifier.prototype.init = function(elem, arr, pos, elemsData) {\n        this.elem = elem;\n        this.arr = arr;\n        this.pos = pos;\n        this.elemsData = elemsData;\n        this._currentCopies = 0;\n        this._elements = [];\n        this._groups = [];\n        this.frameId = -1;\n        this.initDynamicPropertyContainer(elem);\n        this.initModifierProperties(elem, arr[pos]);\n        while(pos > 0){\n            pos -= 1;\n            // this._elements.unshift(arr.splice(pos,1)[0]);\n            this._elements.unshift(arr[pos]);\n        }\n        if (this.dynamicProperties.length) {\n            this.k = true;\n        } else {\n            this.getValue(true);\n        }\n    };\n    RepeaterModifier.prototype.resetElements = function(elements) {\n        var i;\n        var len = elements.length;\n        for(i = 0; i < len; i += 1){\n            elements[i]._processed = false;\n            if (elements[i].ty === 'gr') {\n                this.resetElements(elements[i].it);\n            }\n        }\n    };\n    RepeaterModifier.prototype.cloneElements = function(elements) {\n        var newElements = JSON.parse(JSON.stringify(elements));\n        this.resetElements(newElements);\n        return newElements;\n    };\n    RepeaterModifier.prototype.changeGroupRender = function(elements, renderFlag) {\n        var i;\n        var len = elements.length;\n        for(i = 0; i < len; i += 1){\n            elements[i]._render = renderFlag;\n            if (elements[i].ty === 'gr') {\n                this.changeGroupRender(elements[i].it, renderFlag);\n            }\n        }\n    };\n    RepeaterModifier.prototype.processShapes = function(_isFirstFrame) {\n        var items;\n        var itemsTransform;\n        var i;\n        var dir;\n        var cont;\n        var hasReloaded = false;\n        if (this._mdf || _isFirstFrame) {\n            var copies = Math.ceil(this.c.v);\n            if (this._groups.length < copies) {\n                while(this._groups.length < copies){\n                    var group = {\n                        it: this.cloneElements(this._elements),\n                        ty: 'gr'\n                    };\n                    group.it.push({\n                        a: {\n                            a: 0,\n                            ix: 1,\n                            k: [\n                                0,\n                                0\n                            ]\n                        },\n                        nm: 'Transform',\n                        o: {\n                            a: 0,\n                            ix: 7,\n                            k: 100\n                        },\n                        p: {\n                            a: 0,\n                            ix: 2,\n                            k: [\n                                0,\n                                0\n                            ]\n                        },\n                        r: {\n                            a: 1,\n                            ix: 6,\n                            k: [\n                                {\n                                    s: 0,\n                                    e: 0,\n                                    t: 0\n                                },\n                                {\n                                    s: 0,\n                                    e: 0,\n                                    t: 1\n                                }\n                            ]\n                        },\n                        s: {\n                            a: 0,\n                            ix: 3,\n                            k: [\n                                100,\n                                100\n                            ]\n                        },\n                        sa: {\n                            a: 0,\n                            ix: 5,\n                            k: 0\n                        },\n                        sk: {\n                            a: 0,\n                            ix: 4,\n                            k: 0\n                        },\n                        ty: 'tr'\n                    });\n                    this.arr.splice(0, 0, group);\n                    this._groups.splice(0, 0, group);\n                    this._currentCopies += 1;\n                }\n                this.elem.reloadShapes();\n                hasReloaded = true;\n            }\n            cont = 0;\n            var renderFlag;\n            for(i = 0; i <= this._groups.length - 1; i += 1){\n                renderFlag = cont < copies;\n                this._groups[i]._render = renderFlag;\n                this.changeGroupRender(this._groups[i].it, renderFlag);\n                if (!renderFlag) {\n                    var elems = this.elemsData[i].it;\n                    var transformData = elems[elems.length - 1];\n                    if (transformData.transform.op.v !== 0) {\n                        transformData.transform.op._mdf = true;\n                        transformData.transform.op.v = 0;\n                    } else {\n                        transformData.transform.op._mdf = false;\n                    }\n                }\n                cont += 1;\n            }\n            this._currentCopies = copies;\n            /// /\n            var offset = this.o.v;\n            var offsetModulo = offset % 1;\n            var roundOffset = offset > 0 ? Math.floor(offset) : Math.ceil(offset);\n            var pProps = this.pMatrix.props;\n            var rProps = this.rMatrix.props;\n            var sProps = this.sMatrix.props;\n            this.pMatrix.reset();\n            this.rMatrix.reset();\n            this.sMatrix.reset();\n            this.tMatrix.reset();\n            this.matrix.reset();\n            var iteration = 0;\n            if (offset > 0) {\n                while(iteration < roundOffset){\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n                    iteration += 1;\n                }\n                if (offsetModulo) {\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, offsetModulo, false);\n                    iteration += offsetModulo;\n                }\n            } else if (offset < 0) {\n                while(iteration > roundOffset){\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, true);\n                    iteration -= 1;\n                }\n                if (offsetModulo) {\n                    this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, -offsetModulo, true);\n                    iteration -= offsetModulo;\n                }\n            }\n            i = this.data.m === 1 ? 0 : this._currentCopies - 1;\n            dir = this.data.m === 1 ? 1 : -1;\n            cont = this._currentCopies;\n            var j;\n            var jLen;\n            while(cont){\n                items = this.elemsData[i].it;\n                itemsTransform = items[items.length - 1].transform.mProps.v.props;\n                jLen = itemsTransform.length;\n                items[items.length - 1].transform.mProps._mdf = true;\n                items[items.length - 1].transform.op._mdf = true;\n                items[items.length - 1].transform.op.v = this._currentCopies === 1 ? this.so.v : this.so.v + (this.eo.v - this.so.v) * (i / (this._currentCopies - 1));\n                if (iteration !== 0) {\n                    if (i !== 0 && dir === 1 || i !== this._currentCopies - 1 && dir === -1) {\n                        this.applyTransforms(this.pMatrix, this.rMatrix, this.sMatrix, this.tr, 1, false);\n                    }\n                    this.matrix.transform(rProps[0], rProps[1], rProps[2], rProps[3], rProps[4], rProps[5], rProps[6], rProps[7], rProps[8], rProps[9], rProps[10], rProps[11], rProps[12], rProps[13], rProps[14], rProps[15]);\n                    this.matrix.transform(sProps[0], sProps[1], sProps[2], sProps[3], sProps[4], sProps[5], sProps[6], sProps[7], sProps[8], sProps[9], sProps[10], sProps[11], sProps[12], sProps[13], sProps[14], sProps[15]);\n                    this.matrix.transform(pProps[0], pProps[1], pProps[2], pProps[3], pProps[4], pProps[5], pProps[6], pProps[7], pProps[8], pProps[9], pProps[10], pProps[11], pProps[12], pProps[13], pProps[14], pProps[15]);\n                    for(j = 0; j < jLen; j += 1){\n                        itemsTransform[j] = this.matrix.props[j];\n                    }\n                    this.matrix.reset();\n                } else {\n                    this.matrix.reset();\n                    for(j = 0; j < jLen; j += 1){\n                        itemsTransform[j] = this.matrix.props[j];\n                    }\n                }\n                iteration += 1;\n                cont -= 1;\n                i += dir;\n            }\n        } else {\n            cont = this._currentCopies;\n            i = 0;\n            dir = 1;\n            while(cont){\n                items = this.elemsData[i].it;\n                itemsTransform = items[items.length - 1].transform.mProps.v.props;\n                items[items.length - 1].transform.mProps._mdf = false;\n                items[items.length - 1].transform.op._mdf = false;\n                cont -= 1;\n                i += dir;\n            }\n        }\n        return hasReloaded;\n    };\n    RepeaterModifier.prototype.addShape = function() {};\n    function RoundCornersModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], RoundCornersModifier);\n    RoundCornersModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.rd = PropertyFactory.getProp(elem, data.r, 0, null, this);\n        this._isAnimated = !!this.rd.effectsSequence.length;\n    };\n    RoundCornersModifier.prototype.processPath = function(path, round) {\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        var i;\n        var len = path._length;\n        var currentV;\n        var currentI;\n        var currentO;\n        var closerV;\n        var distance;\n        var newPosPerc;\n        var index = 0;\n        var vX;\n        var vY;\n        var oX;\n        var oY;\n        var iX;\n        var iY;\n        for(i = 0; i < len; i += 1){\n            currentV = path.v[i];\n            currentO = path.o[i];\n            currentI = path.i[i];\n            if (currentV[0] === currentO[0] && currentV[1] === currentO[1] && currentV[0] === currentI[0] && currentV[1] === currentI[1]) {\n                if ((i === 0 || i === len - 1) && !path.c) {\n                    clonedPath.setTripleAt(currentV[0], currentV[1], currentO[0], currentO[1], currentI[0], currentI[1], index);\n                    /* clonedPath.v[index] = currentV;\n                  clonedPath.o[index] = currentO;\n                  clonedPath.i[index] = currentI; */ index += 1;\n                } else {\n                    if (i === 0) {\n                        closerV = path.v[len - 1];\n                    } else {\n                        closerV = path.v[i - 1];\n                    }\n                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n                    iX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n                    vX = iX;\n                    iY = currentV[1] - (currentV[1] - closerV[1]) * newPosPerc;\n                    vY = iY;\n                    oX = vX - (vX - currentV[0]) * roundCorner;\n                    oY = vY - (vY - currentV[1]) * roundCorner;\n                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n                    index += 1;\n                    if (i === len - 1) {\n                        closerV = path.v[0];\n                    } else {\n                        closerV = path.v[i + 1];\n                    }\n                    distance = Math.sqrt(Math.pow(currentV[0] - closerV[0], 2) + Math.pow(currentV[1] - closerV[1], 2));\n                    newPosPerc = distance ? Math.min(distance / 2, round) / distance : 0;\n                    oX = currentV[0] + (closerV[0] - currentV[0]) * newPosPerc;\n                    vX = oX;\n                    oY = currentV[1] + (closerV[1] - currentV[1]) * newPosPerc;\n                    vY = oY;\n                    iX = vX - (vX - currentV[0]) * roundCorner;\n                    iY = vY - (vY - currentV[1]) * roundCorner;\n                    clonedPath.setTripleAt(vX, vY, oX, oY, iX, iY, index);\n                    index += 1;\n                }\n            } else {\n                clonedPath.setTripleAt(path.v[i][0], path.v[i][1], path.o[i][0], path.o[i][1], path.i[i][0], path.i[i][1], index);\n                index += 1;\n            }\n        }\n        return clonedPath;\n    };\n    RoundCornersModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var rd = this.rd.v;\n        if (rd !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], rd));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function floatEqual(a, b) {\n        return Math.abs(a - b) * 100000 <= Math.min(Math.abs(a), Math.abs(b));\n    }\n    function floatZero(f) {\n        return Math.abs(f) <= 0.00001;\n    }\n    function lerp(p0, p1, amount) {\n        return p0 * (1 - amount) + p1 * amount;\n    }\n    function lerpPoint(p0, p1, amount) {\n        return [\n            lerp(p0[0], p1[0], amount),\n            lerp(p0[1], p1[1], amount)\n        ];\n    }\n    function quadRoots(a, b, c) {\n        // no root\n        if (a === 0) return [];\n        var s = b * b - 4 * a * c;\n        // Complex roots\n        if (s < 0) return [];\n        var singleRoot = -b / (2 * a);\n        // 1 root\n        if (s === 0) return [\n            singleRoot\n        ];\n        var delta = Math.sqrt(s) / (2 * a);\n        // 2 roots\n        return [\n            singleRoot - delta,\n            singleRoot + delta\n        ];\n    }\n    function polynomialCoefficients(p0, p1, p2, p3) {\n        return [\n            -p0 + 3 * p1 - 3 * p2 + p3,\n            3 * p0 - 6 * p1 + 3 * p2,\n            -3 * p0 + 3 * p1,\n            p0\n        ];\n    }\n    function singlePoint(p) {\n        return new PolynomialBezier(p, p, p, p, false);\n    }\n    function PolynomialBezier(p0, p1, p2, p3, linearize) {\n        if (linearize && pointEqual(p0, p1)) {\n            p1 = lerpPoint(p0, p3, 1 / 3);\n        }\n        if (linearize && pointEqual(p2, p3)) {\n            p2 = lerpPoint(p0, p3, 2 / 3);\n        }\n        var coeffx = polynomialCoefficients(p0[0], p1[0], p2[0], p3[0]);\n        var coeffy = polynomialCoefficients(p0[1], p1[1], p2[1], p3[1]);\n        this.a = [\n            coeffx[0],\n            coeffy[0]\n        ];\n        this.b = [\n            coeffx[1],\n            coeffy[1]\n        ];\n        this.c = [\n            coeffx[2],\n            coeffy[2]\n        ];\n        this.d = [\n            coeffx[3],\n            coeffy[3]\n        ];\n        this.points = [\n            p0,\n            p1,\n            p2,\n            p3\n        ];\n    }\n    PolynomialBezier.prototype.point = function(t) {\n        return [\n            ((this.a[0] * t + this.b[0]) * t + this.c[0]) * t + this.d[0],\n            ((this.a[1] * t + this.b[1]) * t + this.c[1]) * t + this.d[1]\n        ];\n    };\n    PolynomialBezier.prototype.derivative = function(t) {\n        return [\n            (3 * t * this.a[0] + 2 * this.b[0]) * t + this.c[0],\n            (3 * t * this.a[1] + 2 * this.b[1]) * t + this.c[1]\n        ];\n    };\n    PolynomialBezier.prototype.tangentAngle = function(t) {\n        var p = this.derivative(t);\n        return Math.atan2(p[1], p[0]);\n    };\n    PolynomialBezier.prototype.normalAngle = function(t) {\n        var p = this.derivative(t);\n        return Math.atan2(p[0], p[1]);\n    };\n    PolynomialBezier.prototype.inflectionPoints = function() {\n        var denom = this.a[1] * this.b[0] - this.a[0] * this.b[1];\n        if (floatZero(denom)) return [];\n        var tcusp = -0.5 * (this.a[1] * this.c[0] - this.a[0] * this.c[1]) / denom;\n        var square = tcusp * tcusp - 1 / 3 * (this.b[1] * this.c[0] - this.b[0] * this.c[1]) / denom;\n        if (square < 0) return [];\n        var root = Math.sqrt(square);\n        if (floatZero(root)) {\n            if (root > 0 && root < 1) return [\n                tcusp\n            ];\n            return [];\n        }\n        return [\n            tcusp - root,\n            tcusp + root\n        ].filter(function(r) {\n            return r > 0 && r < 1;\n        });\n    };\n    PolynomialBezier.prototype.split = function(t) {\n        if (t <= 0) return [\n            singlePoint(this.points[0]),\n            this\n        ];\n        if (t >= 1) return [\n            this,\n            singlePoint(this.points[this.points.length - 1])\n        ];\n        var p10 = lerpPoint(this.points[0], this.points[1], t);\n        var p11 = lerpPoint(this.points[1], this.points[2], t);\n        var p12 = lerpPoint(this.points[2], this.points[3], t);\n        var p20 = lerpPoint(p10, p11, t);\n        var p21 = lerpPoint(p11, p12, t);\n        var p3 = lerpPoint(p20, p21, t);\n        return [\n            new PolynomialBezier(this.points[0], p10, p20, p3, true),\n            new PolynomialBezier(p3, p21, p12, this.points[3], true)\n        ];\n    };\n    function extrema(bez, comp) {\n        var min = bez.points[0][comp];\n        var max = bez.points[bez.points.length - 1][comp];\n        if (min > max) {\n            var e = max;\n            max = min;\n            min = e;\n        }\n        // Derivative roots to find min/max\n        var f = quadRoots(3 * bez.a[comp], 2 * bez.b[comp], bez.c[comp]);\n        for(var i = 0; i < f.length; i += 1){\n            if (f[i] > 0 && f[i] < 1) {\n                var val = bez.point(f[i])[comp];\n                if (val < min) min = val;\n                else if (val > max) max = val;\n            }\n        }\n        return {\n            min: min,\n            max: max\n        };\n    }\n    PolynomialBezier.prototype.bounds = function() {\n        return {\n            x: extrema(this, 0),\n            y: extrema(this, 1)\n        };\n    };\n    PolynomialBezier.prototype.boundingBox = function() {\n        var bounds = this.bounds();\n        return {\n            left: bounds.x.min,\n            right: bounds.x.max,\n            top: bounds.y.min,\n            bottom: bounds.y.max,\n            width: bounds.x.max - bounds.x.min,\n            height: bounds.y.max - bounds.y.min,\n            cx: (bounds.x.max + bounds.x.min) / 2,\n            cy: (bounds.y.max + bounds.y.min) / 2\n        };\n    };\n    function intersectData(bez, t1, t2) {\n        var box = bez.boundingBox();\n        return {\n            cx: box.cx,\n            cy: box.cy,\n            width: box.width,\n            height: box.height,\n            bez: bez,\n            t: (t1 + t2) / 2,\n            t1: t1,\n            t2: t2\n        };\n    }\n    function splitData(data) {\n        var split = data.bez.split(0.5);\n        return [\n            intersectData(split[0], data.t1, data.t),\n            intersectData(split[1], data.t, data.t2)\n        ];\n    }\n    function boxIntersect(b1, b2) {\n        return Math.abs(b1.cx - b2.cx) * 2 < b1.width + b2.width && Math.abs(b1.cy - b2.cy) * 2 < b1.height + b2.height;\n    }\n    function intersectsImpl(d1, d2, depth, tolerance, intersections, maxRecursion) {\n        if (!boxIntersect(d1, d2)) return;\n        if (depth >= maxRecursion || d1.width <= tolerance && d1.height <= tolerance && d2.width <= tolerance && d2.height <= tolerance) {\n            intersections.push([\n                d1.t,\n                d2.t\n            ]);\n            return;\n        }\n        var d1s = splitData(d1);\n        var d2s = splitData(d2);\n        intersectsImpl(d1s[0], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[0], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[1], d2s[0], depth + 1, tolerance, intersections, maxRecursion);\n        intersectsImpl(d1s[1], d2s[1], depth + 1, tolerance, intersections, maxRecursion);\n    }\n    PolynomialBezier.prototype.intersections = function(other, tolerance, maxRecursion) {\n        if (tolerance === undefined) tolerance = 2;\n        if (maxRecursion === undefined) maxRecursion = 7;\n        var intersections = [];\n        intersectsImpl(intersectData(this, 0, 1), intersectData(other, 0, 1), 0, tolerance, intersections, maxRecursion);\n        return intersections;\n    };\n    PolynomialBezier.shapeSegment = function(shapePath, index) {\n        var nextIndex = (index + 1) % shapePath.length();\n        return new PolynomialBezier(shapePath.v[index], shapePath.o[index], shapePath.i[nextIndex], shapePath.v[nextIndex], true);\n    };\n    PolynomialBezier.shapeSegmentInverted = function(shapePath, index) {\n        var nextIndex = (index + 1) % shapePath.length();\n        return new PolynomialBezier(shapePath.v[nextIndex], shapePath.i[nextIndex], shapePath.o[index], shapePath.v[index], true);\n    };\n    function crossProduct(a, b) {\n        return [\n            a[1] * b[2] - a[2] * b[1],\n            a[2] * b[0] - a[0] * b[2],\n            a[0] * b[1] - a[1] * b[0]\n        ];\n    }\n    function lineIntersection(start1, end1, start2, end2) {\n        var v1 = [\n            start1[0],\n            start1[1],\n            1\n        ];\n        var v2 = [\n            end1[0],\n            end1[1],\n            1\n        ];\n        var v3 = [\n            start2[0],\n            start2[1],\n            1\n        ];\n        var v4 = [\n            end2[0],\n            end2[1],\n            1\n        ];\n        var r = crossProduct(crossProduct(v1, v2), crossProduct(v3, v4));\n        if (floatZero(r[2])) return null;\n        return [\n            r[0] / r[2],\n            r[1] / r[2]\n        ];\n    }\n    function polarOffset(p, angle, length) {\n        return [\n            p[0] + Math.cos(angle) * length,\n            p[1] - Math.sin(angle) * length\n        ];\n    }\n    function pointDistance(p1, p2) {\n        return Math.hypot(p1[0] - p2[0], p1[1] - p2[1]);\n    }\n    function pointEqual(p1, p2) {\n        return floatEqual(p1[0], p2[0]) && floatEqual(p1[1], p2[1]);\n    }\n    function ZigZagModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], ZigZagModifier);\n    ZigZagModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amplitude = PropertyFactory.getProp(elem, data.s, 0, null, this);\n        this.frequency = PropertyFactory.getProp(elem, data.r, 0, null, this);\n        this.pointsType = PropertyFactory.getProp(elem, data.pt, 0, null, this);\n        this._isAnimated = this.amplitude.effectsSequence.length !== 0 || this.frequency.effectsSequence.length !== 0 || this.pointsType.effectsSequence.length !== 0;\n    };\n    function setPoint(outputBezier, point, angle, direction, amplitude, outAmplitude, inAmplitude) {\n        var angO = angle - Math.PI / 2;\n        var angI = angle + Math.PI / 2;\n        var px = point[0] + Math.cos(angle) * direction * amplitude;\n        var py = point[1] - Math.sin(angle) * direction * amplitude;\n        outputBezier.setTripleAt(px, py, px + Math.cos(angO) * outAmplitude, py - Math.sin(angO) * outAmplitude, px + Math.cos(angI) * inAmplitude, py - Math.sin(angI) * inAmplitude, outputBezier.length());\n    }\n    function getPerpendicularVector(pt1, pt2) {\n        var vector = [\n            pt2[0] - pt1[0],\n            pt2[1] - pt1[1]\n        ];\n        var rot = -Math.PI * 0.5;\n        var rotatedVector = [\n            Math.cos(rot) * vector[0] - Math.sin(rot) * vector[1],\n            Math.sin(rot) * vector[0] + Math.cos(rot) * vector[1]\n        ];\n        return rotatedVector;\n    }\n    function getProjectingAngle(path, cur) {\n        var prevIndex = cur === 0 ? path.length() - 1 : cur - 1;\n        var nextIndex = (cur + 1) % path.length();\n        var prevPoint = path.v[prevIndex];\n        var nextPoint = path.v[nextIndex];\n        var pVector = getPerpendicularVector(prevPoint, nextPoint);\n        return Math.atan2(0, 1) - Math.atan2(pVector[1], pVector[0]);\n    }\n    function zigZagCorner(outputBezier, path, cur, amplitude, frequency, pointType, direction) {\n        var angle = getProjectingAngle(path, cur);\n        var point = path.v[cur % path._length];\n        var prevPoint = path.v[cur === 0 ? path._length - 1 : cur - 1];\n        var nextPoint = path.v[(cur + 1) % path._length];\n        var prevDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - prevPoint[0], 2) + Math.pow(point[1] - prevPoint[1], 2)) : 0;\n        var nextDist = pointType === 2 ? Math.sqrt(Math.pow(point[0] - nextPoint[0], 2) + Math.pow(point[1] - nextPoint[1], 2)) : 0;\n        setPoint(outputBezier, path.v[cur % path._length], angle, direction, amplitude, nextDist / ((frequency + 1) * 2), prevDist / ((frequency + 1) * 2), pointType);\n    }\n    function zigZagSegment(outputBezier, segment, amplitude, frequency, pointType, direction) {\n        for(var i = 0; i < frequency; i += 1){\n            var t = (i + 1) / (frequency + 1);\n            var dist = pointType === 2 ? Math.sqrt(Math.pow(segment.points[3][0] - segment.points[0][0], 2) + Math.pow(segment.points[3][1] - segment.points[0][1], 2)) : 0;\n            var angle = segment.normalAngle(t);\n            var point = segment.point(t);\n            setPoint(outputBezier, point, angle, direction, amplitude, dist / ((frequency + 1) * 2), dist / ((frequency + 1) * 2), pointType);\n            direction = -direction;\n        }\n        return direction;\n    }\n    ZigZagModifier.prototype.processPath = function(path, amplitude, frequency, pointType) {\n        var count = path._length;\n        var clonedPath = shapePool.newElement();\n        clonedPath.c = path.c;\n        if (!path.c) {\n            count -= 1;\n        }\n        if (count === 0) return clonedPath;\n        var direction = -1;\n        var segment = PolynomialBezier.shapeSegment(path, 0);\n        zigZagCorner(clonedPath, path, 0, amplitude, frequency, pointType, direction);\n        for(var i = 0; i < count; i += 1){\n            direction = zigZagSegment(clonedPath, segment, amplitude, frequency, pointType, -direction);\n            if (i === count - 1 && !path.c) {\n                segment = null;\n            } else {\n                segment = PolynomialBezier.shapeSegment(path, (i + 1) % count);\n            }\n            zigZagCorner(clonedPath, path, i + 1, amplitude, frequency, pointType, direction);\n        }\n        return clonedPath;\n    };\n    ZigZagModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amplitude = this.amplitude.v;\n        var frequency = Math.max(0, Math.round(this.frequency.v));\n        var pointType = this.pointsType.v;\n        if (amplitude !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amplitude, frequency, pointType));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function linearOffset(p1, p2, amount) {\n        var angle = Math.atan2(p2[0] - p1[0], p2[1] - p1[1]);\n        return [\n            polarOffset(p1, angle, amount),\n            polarOffset(p2, angle, amount)\n        ];\n    }\n    function offsetSegment(segment, amount) {\n        var p0;\n        var p1a;\n        var p1b;\n        var p2b;\n        var p2a;\n        var p3;\n        var e;\n        e = linearOffset(segment.points[0], segment.points[1], amount);\n        p0 = e[0];\n        p1a = e[1];\n        e = linearOffset(segment.points[1], segment.points[2], amount);\n        p1b = e[0];\n        p2b = e[1];\n        e = linearOffset(segment.points[2], segment.points[3], amount);\n        p2a = e[0];\n        p3 = e[1];\n        var p1 = lineIntersection(p0, p1a, p1b, p2b);\n        if (p1 === null) p1 = p1a;\n        var p2 = lineIntersection(p2a, p3, p1b, p2b);\n        if (p2 === null) p2 = p2a;\n        return new PolynomialBezier(p0, p1, p2, p3);\n    }\n    function joinLines(outputBezier, seg1, seg2, lineJoin, miterLimit) {\n        var p0 = seg1.points[3];\n        var p1 = seg2.points[0];\n        // Bevel\n        if (lineJoin === 3) return p0;\n        // Connected, they don't need a joint\n        if (pointEqual(p0, p1)) return p0;\n        // Round\n        if (lineJoin === 2) {\n            var angleOut = -seg1.tangentAngle(1);\n            var angleIn = -seg2.tangentAngle(0) + Math.PI;\n            var center = lineIntersection(p0, polarOffset(p0, angleOut + Math.PI / 2, 100), p1, polarOffset(p1, angleOut + Math.PI / 2, 100));\n            var radius = center ? pointDistance(center, p0) : pointDistance(p0, p1) / 2;\n            var tan = polarOffset(p0, angleOut, 2 * radius * roundCorner);\n            outputBezier.setXYAt(tan[0], tan[1], 'o', outputBezier.length() - 1);\n            tan = polarOffset(p1, angleIn, 2 * radius * roundCorner);\n            outputBezier.setTripleAt(p1[0], p1[1], p1[0], p1[1], tan[0], tan[1], outputBezier.length());\n            return p1;\n        }\n        // Miter\n        var t0 = pointEqual(p0, seg1.points[2]) ? seg1.points[0] : seg1.points[2];\n        var t1 = pointEqual(p1, seg2.points[1]) ? seg2.points[3] : seg2.points[1];\n        var intersection = lineIntersection(t0, p0, p1, t1);\n        if (intersection && pointDistance(intersection, p0) < miterLimit) {\n            outputBezier.setTripleAt(intersection[0], intersection[1], intersection[0], intersection[1], intersection[0], intersection[1], outputBezier.length());\n            return intersection;\n        }\n        return p0;\n    }\n    function getIntersection(a, b) {\n        var intersect = a.intersections(b);\n        if (intersect.length && floatEqual(intersect[0][0], 1)) intersect.shift();\n        if (intersect.length) return intersect[0];\n        return null;\n    }\n    function pruneSegmentIntersection(a, b) {\n        var outa = a.slice();\n        var outb = b.slice();\n        var intersect = getIntersection(a[a.length - 1], b[0]);\n        if (intersect) {\n            outa[a.length - 1] = a[a.length - 1].split(intersect[0])[0];\n            outb[0] = b[0].split(intersect[1])[1];\n        }\n        if (a.length > 1 && b.length > 1) {\n            intersect = getIntersection(a[0], b[b.length - 1]);\n            if (intersect) {\n                return [\n                    [\n                        a[0].split(intersect[0])[0]\n                    ],\n                    [\n                        b[b.length - 1].split(intersect[1])[1]\n                    ]\n                ];\n            }\n        }\n        return [\n            outa,\n            outb\n        ];\n    }\n    function pruneIntersections(segments) {\n        var e;\n        for(var i = 1; i < segments.length; i += 1){\n            e = pruneSegmentIntersection(segments[i - 1], segments[i]);\n            segments[i - 1] = e[0];\n            segments[i] = e[1];\n        }\n        if (segments.length > 1) {\n            e = pruneSegmentIntersection(segments[segments.length - 1], segments[0]);\n            segments[segments.length - 1] = e[0];\n            segments[0] = e[1];\n        }\n        return segments;\n    }\n    function offsetSegmentSplit(segment, amount) {\n        /*\n      We split each bezier segment into smaller pieces based\n      on inflection points, this ensures the control point\n      polygon is convex.\n       (A cubic bezier can have none, one, or two inflection points)\n    */ var flex = segment.inflectionPoints();\n        var left;\n        var right;\n        var split;\n        var mid;\n        if (flex.length === 0) {\n            return [\n                offsetSegment(segment, amount)\n            ];\n        }\n        if (flex.length === 1 || floatEqual(flex[1], 1)) {\n            split = segment.split(flex[0]);\n            left = split[0];\n            right = split[1];\n            return [\n                offsetSegment(left, amount),\n                offsetSegment(right, amount)\n            ];\n        }\n        split = segment.split(flex[0]);\n        left = split[0];\n        var t = (flex[1] - flex[0]) / (1 - flex[0]);\n        split = split[1].split(t);\n        mid = split[0];\n        right = split[1];\n        return [\n            offsetSegment(left, amount),\n            offsetSegment(mid, amount),\n            offsetSegment(right, amount)\n        ];\n    }\n    function OffsetPathModifier() {}\n    extendPrototype([\n        ShapeModifier\n    ], OffsetPathModifier);\n    OffsetPathModifier.prototype.initModifierProperties = function(elem, data) {\n        this.getValue = this.processKeys;\n        this.amount = PropertyFactory.getProp(elem, data.a, 0, null, this);\n        this.miterLimit = PropertyFactory.getProp(elem, data.ml, 0, null, this);\n        this.lineJoin = data.lj;\n        this._isAnimated = this.amount.effectsSequence.length !== 0;\n    };\n    OffsetPathModifier.prototype.processPath = function(inputBezier, amount, lineJoin, miterLimit) {\n        var outputBezier = shapePool.newElement();\n        outputBezier.c = inputBezier.c;\n        var count = inputBezier.length();\n        if (!inputBezier.c) {\n            count -= 1;\n        }\n        var i;\n        var j;\n        var segment;\n        var multiSegments = [];\n        for(i = 0; i < count; i += 1){\n            segment = PolynomialBezier.shapeSegment(inputBezier, i);\n            multiSegments.push(offsetSegmentSplit(segment, amount));\n        }\n        if (!inputBezier.c) {\n            for(i = count - 1; i >= 0; i -= 1){\n                segment = PolynomialBezier.shapeSegmentInverted(inputBezier, i);\n                multiSegments.push(offsetSegmentSplit(segment, amount));\n            }\n        }\n        multiSegments = pruneIntersections(multiSegments);\n        // Add bezier segments to the output and apply line joints\n        var lastPoint = null;\n        var lastSeg = null;\n        for(i = 0; i < multiSegments.length; i += 1){\n            var multiSegment = multiSegments[i];\n            if (lastSeg) lastPoint = joinLines(outputBezier, lastSeg, multiSegment[0], lineJoin, miterLimit);\n            lastSeg = multiSegment[multiSegment.length - 1];\n            for(j = 0; j < multiSegment.length; j += 1){\n                segment = multiSegment[j];\n                if (lastPoint && pointEqual(segment.points[0], lastPoint)) {\n                    outputBezier.setXYAt(segment.points[1][0], segment.points[1][1], 'o', outputBezier.length() - 1);\n                } else {\n                    outputBezier.setTripleAt(segment.points[0][0], segment.points[0][1], segment.points[1][0], segment.points[1][1], segment.points[0][0], segment.points[0][1], outputBezier.length());\n                }\n                outputBezier.setTripleAt(segment.points[3][0], segment.points[3][1], segment.points[3][0], segment.points[3][1], segment.points[2][0], segment.points[2][1], outputBezier.length());\n                lastPoint = segment.points[3];\n            }\n        }\n        if (multiSegments.length) joinLines(outputBezier, lastSeg, multiSegments[0][0], lineJoin, miterLimit);\n        return outputBezier;\n    };\n    OffsetPathModifier.prototype.processShapes = function(_isFirstFrame) {\n        var shapePaths;\n        var i;\n        var len = this.shapes.length;\n        var j;\n        var jLen;\n        var amount = this.amount.v;\n        var miterLimit = this.miterLimit.v;\n        var lineJoin = this.lineJoin;\n        if (amount !== 0) {\n            var shapeData;\n            var localShapeCollection;\n            for(i = 0; i < len; i += 1){\n                shapeData = this.shapes[i];\n                localShapeCollection = shapeData.localShapeCollection;\n                if (!(!shapeData.shape._mdf && !this._mdf && !_isFirstFrame)) {\n                    localShapeCollection.releaseShapes();\n                    shapeData.shape._mdf = true;\n                    shapePaths = shapeData.shape.paths.shapes;\n                    jLen = shapeData.shape.paths._length;\n                    for(j = 0; j < jLen; j += 1){\n                        localShapeCollection.addShape(this.processPath(shapePaths[j], amount, lineJoin, miterLimit));\n                    }\n                }\n                shapeData.shape.paths = shapeData.localShapeCollection;\n            }\n        }\n        if (!this.dynamicProperties.length) {\n            this._mdf = false;\n        }\n    };\n    function getFontProperties(fontData) {\n        var styles = fontData.fStyle ? fontData.fStyle.split(' ') : [];\n        var fWeight = 'normal';\n        var fStyle = 'normal';\n        var len = styles.length;\n        var styleName;\n        for(var i = 0; i < len; i += 1){\n            styleName = styles[i].toLowerCase();\n            switch(styleName){\n                case 'italic':\n                    fStyle = 'italic';\n                    break;\n                case 'bold':\n                    fWeight = '700';\n                    break;\n                case 'black':\n                    fWeight = '900';\n                    break;\n                case 'medium':\n                    fWeight = '500';\n                    break;\n                case 'regular':\n                case 'normal':\n                    fWeight = '400';\n                    break;\n                case 'light':\n                case 'thin':\n                    fWeight = '200';\n                    break;\n                default:\n                    break;\n            }\n        }\n        return {\n            style: fStyle,\n            weight: fontData.fWeight || fWeight\n        };\n    }\n    var FontManager = function() {\n        var maxWaitingTime = 5000;\n        var emptyChar = {\n            w: 0,\n            size: 0,\n            shapes: [],\n            data: {\n                shapes: []\n            }\n        };\n        var combinedCharacters = [];\n        // Hindi characters\n        combinedCharacters = combinedCharacters.concat([\n            2304,\n            2305,\n            2306,\n            2307,\n            2362,\n            2363,\n            2364,\n            2364,\n            2366,\n            2367,\n            2368,\n            2369,\n            2370,\n            2371,\n            2372,\n            2373,\n            2374,\n            2375,\n            2376,\n            2377,\n            2378,\n            2379,\n            2380,\n            2381,\n            2382,\n            2383,\n            2387,\n            2388,\n            2389,\n            2390,\n            2391,\n            2402,\n            2403\n        ]);\n        var BLACK_FLAG_CODE_POINT = 127988;\n        var CANCEL_TAG_CODE_POINT = 917631;\n        var A_TAG_CODE_POINT = 917601;\n        var Z_TAG_CODE_POINT = 917626;\n        var VARIATION_SELECTOR_16_CODE_POINT = 65039;\n        var ZERO_WIDTH_JOINER_CODE_POINT = 8205;\n        var REGIONAL_CHARACTER_A_CODE_POINT = 127462;\n        var REGIONAL_CHARACTER_Z_CODE_POINT = 127487;\n        var surrogateModifiers = [\n            'd83cdffb',\n            'd83cdffc',\n            'd83cdffd',\n            'd83cdffe',\n            'd83cdfff'\n        ];\n        function trimFontOptions(font) {\n            var familyArray = font.split(',');\n            var i;\n            var len = familyArray.length;\n            var enabledFamilies = [];\n            for(i = 0; i < len; i += 1){\n                if (familyArray[i] !== 'sans-serif' && familyArray[i] !== 'monospace') {\n                    enabledFamilies.push(familyArray[i]);\n                }\n            }\n            return enabledFamilies.join(',');\n        }\n        function setUpNode(font, family) {\n            var parentNode = createTag('span');\n            // Node is invisible to screen readers.\n            parentNode.setAttribute('aria-hidden', true);\n            parentNode.style.fontFamily = family;\n            var node = createTag('span');\n            // Characters that vary significantly among different fonts\n            node.innerText = 'giItT1WQy@!-/#';\n            // Visible - so we can measure it - but not on the screen\n            parentNode.style.position = 'absolute';\n            parentNode.style.left = '-10000px';\n            parentNode.style.top = '-10000px';\n            // Large font size makes even subtle changes obvious\n            parentNode.style.fontSize = '300px';\n            // Reset any font properties\n            parentNode.style.fontVariant = 'normal';\n            parentNode.style.fontStyle = 'normal';\n            parentNode.style.fontWeight = 'normal';\n            parentNode.style.letterSpacing = '0';\n            parentNode.appendChild(node);\n            document.body.appendChild(parentNode);\n            // Remember width with no applied web font\n            var width = node.offsetWidth;\n            node.style.fontFamily = trimFontOptions(font) + ', ' + family;\n            return {\n                node: node,\n                w: width,\n                parent: parentNode\n            };\n        }\n        function checkLoadedFonts() {\n            var i;\n            var len = this.fonts.length;\n            var node;\n            var w;\n            var loadedCount = len;\n            for(i = 0; i < len; i += 1){\n                if (this.fonts[i].loaded) {\n                    loadedCount -= 1;\n                } else if (this.fonts[i].fOrigin === 'n' || this.fonts[i].origin === 0) {\n                    this.fonts[i].loaded = true;\n                } else {\n                    node = this.fonts[i].monoCase.node;\n                    w = this.fonts[i].monoCase.w;\n                    if (node.offsetWidth !== w) {\n                        loadedCount -= 1;\n                        this.fonts[i].loaded = true;\n                    } else {\n                        node = this.fonts[i].sansCase.node;\n                        w = this.fonts[i].sansCase.w;\n                        if (node.offsetWidth !== w) {\n                            loadedCount -= 1;\n                            this.fonts[i].loaded = true;\n                        }\n                    }\n                    if (this.fonts[i].loaded) {\n                        this.fonts[i].sansCase.parent.parentNode.removeChild(this.fonts[i].sansCase.parent);\n                        this.fonts[i].monoCase.parent.parentNode.removeChild(this.fonts[i].monoCase.parent);\n                    }\n                }\n            }\n            if (loadedCount !== 0 && Date.now() - this.initTime < maxWaitingTime) {\n                setTimeout(this.checkLoadedFontsBinded, 20);\n            } else {\n                setTimeout(this.setIsLoadedBinded, 10);\n            }\n        }\n        function createHelper(fontData, def) {\n            var engine = document.body && def ? 'svg' : 'canvas';\n            var helper;\n            var fontProps = getFontProperties(fontData);\n            if (engine === 'svg') {\n                var tHelper = createNS('text');\n                tHelper.style.fontSize = '100px';\n                // tHelper.style.fontFamily = fontData.fFamily;\n                tHelper.setAttribute('font-family', fontData.fFamily);\n                tHelper.setAttribute('font-style', fontProps.style);\n                tHelper.setAttribute('font-weight', fontProps.weight);\n                tHelper.textContent = '1';\n                if (fontData.fClass) {\n                    tHelper.style.fontFamily = 'inherit';\n                    tHelper.setAttribute('class', fontData.fClass);\n                } else {\n                    tHelper.style.fontFamily = fontData.fFamily;\n                }\n                def.appendChild(tHelper);\n                helper = tHelper;\n            } else {\n                var tCanvasHelper = new OffscreenCanvas(500, 500).getContext('2d');\n                tCanvasHelper.font = fontProps.style + ' ' + fontProps.weight + ' 100px ' + fontData.fFamily;\n                helper = tCanvasHelper;\n            }\n            function measure(text) {\n                if (engine === 'svg') {\n                    helper.textContent = text;\n                    return helper.getComputedTextLength();\n                }\n                return helper.measureText(text).width;\n            }\n            return {\n                measureText: measure\n            };\n        }\n        function addFonts(fontData, defs) {\n            if (!fontData) {\n                this.isLoaded = true;\n                return;\n            }\n            if (this.chars) {\n                this.isLoaded = true;\n                this.fonts = fontData.list;\n                return;\n            }\n            if (!document.body) {\n                this.isLoaded = true;\n                fontData.list.forEach(function(data) {\n                    data.helper = createHelper(data);\n                    data.cache = {};\n                });\n                this.fonts = fontData.list;\n                return;\n            }\n            var fontArr = fontData.list;\n            var i;\n            var len = fontArr.length;\n            var _pendingFonts = len;\n            for(i = 0; i < len; i += 1){\n                var shouldLoadFont = true;\n                var loadedSelector;\n                var j;\n                fontArr[i].loaded = false;\n                fontArr[i].monoCase = setUpNode(fontArr[i].fFamily, 'monospace');\n                fontArr[i].sansCase = setUpNode(fontArr[i].fFamily, 'sans-serif');\n                if (!fontArr[i].fPath) {\n                    fontArr[i].loaded = true;\n                    _pendingFonts -= 1;\n                } else if (fontArr[i].fOrigin === 'p' || fontArr[i].origin === 3) {\n                    loadedSelector = document.querySelectorAll('style[f-forigin=\"p\"][f-family=\"' + fontArr[i].fFamily + '\"], style[f-origin=\"3\"][f-family=\"' + fontArr[i].fFamily + '\"]');\n                    if (loadedSelector.length > 0) {\n                        shouldLoadFont = false;\n                    }\n                    if (shouldLoadFont) {\n                        var s = createTag('style');\n                        s.setAttribute('f-forigin', fontArr[i].fOrigin);\n                        s.setAttribute('f-origin', fontArr[i].origin);\n                        s.setAttribute('f-family', fontArr[i].fFamily);\n                        s.type = 'text/css';\n                        s.innerText = '@font-face {font-family: ' + fontArr[i].fFamily + \"; font-style: normal; src: url('\" + fontArr[i].fPath + \"');}\";\n                        defs.appendChild(s);\n                    }\n                } else if (fontArr[i].fOrigin === 'g' || fontArr[i].origin === 1) {\n                    loadedSelector = document.querySelectorAll('link[f-forigin=\"g\"], link[f-origin=\"1\"]');\n                    for(j = 0; j < loadedSelector.length; j += 1){\n                        if (loadedSelector[j].href.indexOf(fontArr[i].fPath) !== -1) {\n                            // Font is already loaded\n                            shouldLoadFont = false;\n                        }\n                    }\n                    if (shouldLoadFont) {\n                        var l = createTag('link');\n                        l.setAttribute('f-forigin', fontArr[i].fOrigin);\n                        l.setAttribute('f-origin', fontArr[i].origin);\n                        l.type = 'text/css';\n                        l.rel = 'stylesheet';\n                        l.href = fontArr[i].fPath;\n                        document.body.appendChild(l);\n                    }\n                } else if (fontArr[i].fOrigin === 't' || fontArr[i].origin === 2) {\n                    loadedSelector = document.querySelectorAll('script[f-forigin=\"t\"], script[f-origin=\"2\"]');\n                    for(j = 0; j < loadedSelector.length; j += 1){\n                        if (fontArr[i].fPath === loadedSelector[j].src) {\n                            // Font is already loaded\n                            shouldLoadFont = false;\n                        }\n                    }\n                    if (shouldLoadFont) {\n                        var sc = createTag('link');\n                        sc.setAttribute('f-forigin', fontArr[i].fOrigin);\n                        sc.setAttribute('f-origin', fontArr[i].origin);\n                        sc.setAttribute('rel', 'stylesheet');\n                        sc.setAttribute('href', fontArr[i].fPath);\n                        defs.appendChild(sc);\n                    }\n                }\n                fontArr[i].helper = createHelper(fontArr[i], defs);\n                fontArr[i].cache = {};\n                this.fonts.push(fontArr[i]);\n            }\n            if (_pendingFonts === 0) {\n                this.isLoaded = true;\n            } else {\n                // On some cases even if the font is loaded, it won't load correctly when measuring text on canvas.\n                // Adding this timeout seems to fix it\n                setTimeout(this.checkLoadedFonts.bind(this), 100);\n            }\n        }\n        function addChars(chars) {\n            if (!chars) {\n                return;\n            }\n            if (!this.chars) {\n                this.chars = [];\n            }\n            var i;\n            var len = chars.length;\n            var j;\n            var jLen = this.chars.length;\n            var found;\n            for(i = 0; i < len; i += 1){\n                j = 0;\n                found = false;\n                while(j < jLen){\n                    if (this.chars[j].style === chars[i].style && this.chars[j].fFamily === chars[i].fFamily && this.chars[j].ch === chars[i].ch) {\n                        found = true;\n                    }\n                    j += 1;\n                }\n                if (!found) {\n                    this.chars.push(chars[i]);\n                    jLen += 1;\n                }\n            }\n        }\n        function getCharData(_char, style, font) {\n            var i = 0;\n            var len = this.chars.length;\n            while(i < len){\n                if (this.chars[i].ch === _char && this.chars[i].style === style && this.chars[i].fFamily === font) {\n                    return this.chars[i];\n                }\n                i += 1;\n            }\n            if ((typeof _char === 'string' && _char.charCodeAt(0) !== 13 || !_char) && console && console.warn // eslint-disable-line no-console\n             && !this._warned) {\n                this._warned = true;\n                console.warn('Missing character from exported characters list: ', _char, style, font); // eslint-disable-line no-console\n            }\n            return emptyChar;\n        }\n        function measureText(_char2, fontName, size) {\n            var fontData = this.getFontByName(fontName);\n            // Using the char instead of char.charCodeAt(0)\n            // to avoid collisions between equal chars\n            var index = _char2;\n            if (!fontData.cache[index]) {\n                var tHelper = fontData.helper;\n                if (_char2 === ' ') {\n                    var doubleSize = tHelper.measureText('|' + _char2 + '|');\n                    var singleSize = tHelper.measureText('||');\n                    fontData.cache[index] = (doubleSize - singleSize) / 100;\n                } else {\n                    fontData.cache[index] = tHelper.measureText(_char2) / 100;\n                }\n            }\n            return fontData.cache[index] * size;\n        }\n        function getFontByName(name) {\n            var i = 0;\n            var len = this.fonts.length;\n            while(i < len){\n                if (this.fonts[i].fName === name) {\n                    return this.fonts[i];\n                }\n                i += 1;\n            }\n            return this.fonts[0];\n        }\n        function getCodePoint(string) {\n            var codePoint = 0;\n            var first = string.charCodeAt(0);\n            if (first >= 0xD800 && first <= 0xDBFF) {\n                var second = string.charCodeAt(1);\n                if (second >= 0xDC00 && second <= 0xDFFF) {\n                    codePoint = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n                }\n            }\n            return codePoint;\n        }\n        // Skin tone modifiers\n        function isModifier(firstCharCode, secondCharCode) {\n            var sum = firstCharCode.toString(16) + secondCharCode.toString(16);\n            return surrogateModifiers.indexOf(sum) !== -1;\n        }\n        function isZeroWidthJoiner(charCode) {\n            return charCode === ZERO_WIDTH_JOINER_CODE_POINT;\n        }\n        // This codepoint may change the appearance of the preceding character.\n        // If that is a symbol, dingbat or emoji, U+FE0F forces it to be rendered\n        // as a colorful image as compared to a monochrome text variant.\n        function isVariationSelector(charCode) {\n            return charCode === VARIATION_SELECTOR_16_CODE_POINT;\n        }\n        // The regional indicator symbols are a set of 26 alphabetic Unicode\n        /// characters (AZ) intended to be used to encode ISO 3166-1 alpha-2\n        // two-letter country codes in a way that allows optional special treatment.\n        function isRegionalCode(string) {\n            var codePoint = getCodePoint(string);\n            if (codePoint >= REGIONAL_CHARACTER_A_CODE_POINT && codePoint <= REGIONAL_CHARACTER_Z_CODE_POINT) {\n                return true;\n            }\n            return false;\n        }\n        // Some Emoji implementations represent combinations of\n        // two regional indicator letters as a single flag symbol.\n        function isFlagEmoji(string) {\n            return isRegionalCode(string.substr(0, 2)) && isRegionalCode(string.substr(2, 2));\n        }\n        function isCombinedCharacter(_char3) {\n            return combinedCharacters.indexOf(_char3) !== -1;\n        }\n        // Regional flags start with a BLACK_FLAG_CODE_POINT\n        // folowed by 5 chars in the TAG range\n        // and end with a CANCEL_TAG_CODE_POINT\n        function isRegionalFlag(text, index) {\n            var codePoint = getCodePoint(text.substr(index, 2));\n            if (codePoint !== BLACK_FLAG_CODE_POINT) {\n                return false;\n            }\n            var count = 0;\n            index += 2;\n            while(count < 5){\n                codePoint = getCodePoint(text.substr(index, 2));\n                if (codePoint < A_TAG_CODE_POINT || codePoint > Z_TAG_CODE_POINT) {\n                    return false;\n                }\n                count += 1;\n                index += 2;\n            }\n            return getCodePoint(text.substr(index, 2)) === CANCEL_TAG_CODE_POINT;\n        }\n        function setIsLoaded() {\n            this.isLoaded = true;\n        }\n        var Font = function Font() {\n            this.fonts = [];\n            this.chars = null;\n            this.typekitLoaded = 0;\n            this.isLoaded = false;\n            this._warned = false;\n            this.initTime = Date.now();\n            this.setIsLoadedBinded = this.setIsLoaded.bind(this);\n            this.checkLoadedFontsBinded = this.checkLoadedFonts.bind(this);\n        };\n        Font.isModifier = isModifier;\n        Font.isZeroWidthJoiner = isZeroWidthJoiner;\n        Font.isFlagEmoji = isFlagEmoji;\n        Font.isRegionalCode = isRegionalCode;\n        Font.isCombinedCharacter = isCombinedCharacter;\n        Font.isRegionalFlag = isRegionalFlag;\n        Font.isVariationSelector = isVariationSelector;\n        Font.BLACK_FLAG_CODE_POINT = BLACK_FLAG_CODE_POINT;\n        var fontPrototype = {\n            addChars: addChars,\n            addFonts: addFonts,\n            getCharData: getCharData,\n            getFontByName: getFontByName,\n            measureText: measureText,\n            checkLoadedFonts: checkLoadedFonts,\n            setIsLoaded: setIsLoaded\n        };\n        Font.prototype = fontPrototype;\n        return Font;\n    }();\n    function SlotManager(animationData) {\n        this.animationData = animationData;\n    }\n    SlotManager.prototype.getProp = function(data) {\n        if (this.animationData.slots && this.animationData.slots[data.sid]) {\n            return Object.assign(data, this.animationData.slots[data.sid].p);\n        }\n        return data;\n    };\n    function slotFactory(animationData) {\n        return new SlotManager(animationData);\n    }\n    function RenderableElement() {}\n    RenderableElement.prototype = {\n        initRenderable: function initRenderable() {\n            // layer's visibility related to inpoint and outpoint. Rename isVisible to isInRange\n            this.isInRange = false;\n            // layer's display state\n            this.hidden = false;\n            // If layer's transparency equals 0, it can be hidden\n            this.isTransparent = false;\n            // list of animated components\n            this.renderableComponents = [];\n        },\n        addRenderableComponent: function addRenderableComponent(component) {\n            if (this.renderableComponents.indexOf(component) === -1) {\n                this.renderableComponents.push(component);\n            }\n        },\n        removeRenderableComponent: function removeRenderableComponent(component) {\n            if (this.renderableComponents.indexOf(component) !== -1) {\n                this.renderableComponents.splice(this.renderableComponents.indexOf(component), 1);\n            }\n        },\n        prepareRenderableFrame: function prepareRenderableFrame(num) {\n            this.checkLayerLimits(num);\n        },\n        checkTransparency: function checkTransparency() {\n            if (this.finalTransform.mProp.o.v <= 0) {\n                if (!this.isTransparent && this.globalData.renderConfig.hideOnTransparent) {\n                    this.isTransparent = true;\n                    this.hide();\n                }\n            } else if (this.isTransparent) {\n                this.isTransparent = false;\n                this.show();\n            }\n        },\n        /**\n       * @function\n       * Initializes frame related properties.\n       *\n       * @param {number} num\n       * current frame number in Layer's time\n       *\n       */ checkLayerLimits: function checkLayerLimits(num) {\n            if (this.data.ip - this.data.st <= num && this.data.op - this.data.st > num) {\n                if (this.isInRange !== true) {\n                    this.globalData._mdf = true;\n                    this._mdf = true;\n                    this.isInRange = true;\n                    this.show();\n                }\n            } else if (this.isInRange !== false) {\n                this.globalData._mdf = true;\n                this.isInRange = false;\n                this.hide();\n            }\n        },\n        renderRenderable: function renderRenderable() {\n            var i;\n            var len = this.renderableComponents.length;\n            for(i = 0; i < len; i += 1){\n                this.renderableComponents[i].renderFrame(this._isFirstFrame);\n            }\n        /* this.maskManager.renderFrame(this.finalTransform.mat);\n          this.renderableEffectsManager.renderFrame(this._isFirstFrame); */ },\n        sourceRectAtTime: function sourceRectAtTime() {\n            return {\n                top: 0,\n                left: 0,\n                width: 100,\n                height: 100\n            };\n        },\n        getLayerSize: function getLayerSize() {\n            if (this.data.ty === 5) {\n                return {\n                    w: this.data.textData.width,\n                    h: this.data.textData.height\n                };\n            }\n            return {\n                w: this.data.width,\n                h: this.data.height\n            };\n        }\n    };\n    var getBlendMode = function() {\n        var blendModeEnums = {\n            0: 'source-over',\n            1: 'multiply',\n            2: 'screen',\n            3: 'overlay',\n            4: 'darken',\n            5: 'lighten',\n            6: 'color-dodge',\n            7: 'color-burn',\n            8: 'hard-light',\n            9: 'soft-light',\n            10: 'difference',\n            11: 'exclusion',\n            12: 'hue',\n            13: 'saturation',\n            14: 'color',\n            15: 'luminosity'\n        };\n        return function(mode) {\n            return blendModeEnums[mode] || '';\n        };\n    }();\n    function SliderEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function AngleEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function ColorEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n    }\n    function PointEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 1, 0, container);\n    }\n    function LayerIndexEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function MaskIndexEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function CheckboxEffect(data, elem, container) {\n        this.p = PropertyFactory.getProp(elem, data.v, 0, 0, container);\n    }\n    function NoValueEffect() {\n        this.p = {};\n    }\n    function EffectsManager(data, element) {\n        var effects = data.ef || [];\n        this.effectElements = [];\n        var i;\n        var len = effects.length;\n        var effectItem;\n        for(i = 0; i < len; i += 1){\n            effectItem = new GroupEffect(effects[i], element);\n            this.effectElements.push(effectItem);\n        }\n    }\n    function GroupEffect(data, element) {\n        this.init(data, element);\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], GroupEffect);\n    GroupEffect.prototype.getValue = GroupEffect.prototype.iterateDynamicProperties;\n    GroupEffect.prototype.init = function(data, element) {\n        this.data = data;\n        this.effectElements = [];\n        this.initDynamicPropertyContainer(element);\n        var i;\n        var len = this.data.ef.length;\n        var eff;\n        var effects = this.data.ef;\n        for(i = 0; i < len; i += 1){\n            eff = null;\n            switch(effects[i].ty){\n                case 0:\n                    eff = new SliderEffect(effects[i], element, this);\n                    break;\n                case 1:\n                    eff = new AngleEffect(effects[i], element, this);\n                    break;\n                case 2:\n                    eff = new ColorEffect(effects[i], element, this);\n                    break;\n                case 3:\n                    eff = new PointEffect(effects[i], element, this);\n                    break;\n                case 4:\n                case 7:\n                    eff = new CheckboxEffect(effects[i], element, this);\n                    break;\n                case 10:\n                    eff = new LayerIndexEffect(effects[i], element, this);\n                    break;\n                case 11:\n                    eff = new MaskIndexEffect(effects[i], element, this);\n                    break;\n                case 5:\n                    eff = new EffectsManager(effects[i], element, this);\n                    break;\n                // case 6:\n                default:\n                    eff = new NoValueEffect(effects[i], element, this);\n                    break;\n            }\n            if (eff) {\n                this.effectElements.push(eff);\n            }\n        }\n    };\n    function BaseElement() {}\n    BaseElement.prototype = {\n        checkMasks: function checkMasks() {\n            if (!this.data.hasMask) {\n                return false;\n            }\n            var i = 0;\n            var len = this.data.masksProperties.length;\n            while(i < len){\n                if (this.data.masksProperties[i].mode !== 'n' && this.data.masksProperties[i].cl !== false) {\n                    return true;\n                }\n                i += 1;\n            }\n            return false;\n        },\n        initExpressions: function initExpressions() {\n            var expressionsInterfaces = getExpressionInterfaces();\n            if (!expressionsInterfaces) {\n                return;\n            }\n            var LayerExpressionInterface = expressionsInterfaces('layer');\n            var EffectsExpressionInterface = expressionsInterfaces('effects');\n            var ShapeExpressionInterface = expressionsInterfaces('shape');\n            var TextExpressionInterface = expressionsInterfaces('text');\n            var CompExpressionInterface = expressionsInterfaces('comp');\n            this.layerInterface = LayerExpressionInterface(this);\n            if (this.data.hasMask && this.maskManager) {\n                this.layerInterface.registerMaskInterface(this.maskManager);\n            }\n            var effectsInterface = EffectsExpressionInterface.createEffectsInterface(this, this.layerInterface);\n            this.layerInterface.registerEffectsInterface(effectsInterface);\n            if (this.data.ty === 0 || this.data.xt) {\n                this.compInterface = CompExpressionInterface(this);\n            } else if (this.data.ty === 4) {\n                this.layerInterface.shapeInterface = ShapeExpressionInterface(this.shapesData, this.itemsData, this.layerInterface);\n                this.layerInterface.content = this.layerInterface.shapeInterface;\n            } else if (this.data.ty === 5) {\n                this.layerInterface.textInterface = TextExpressionInterface(this);\n                this.layerInterface.text = this.layerInterface.textInterface;\n            }\n        },\n        setBlendMode: function setBlendMode() {\n            var blendModeValue = getBlendMode(this.data.bm);\n            var elem = this.baseElement || this.layerElement;\n            elem.style['mix-blend-mode'] = blendModeValue;\n        },\n        initBaseData: function initBaseData(data, globalData, comp) {\n            this.globalData = globalData;\n            this.comp = comp;\n            this.data = data;\n            this.layerId = createElementID();\n            // Stretch factor for old animations missing this property.\n            if (!this.data.sr) {\n                this.data.sr = 1;\n            }\n            // effects manager\n            this.effectsManager = new EffectsManager(this.data, this, this.dynamicProperties);\n        },\n        getType: function getType() {\n            return this.type;\n        },\n        sourceRectAtTime: function sourceRectAtTime() {}\n    };\n    /**\n   * @file\n   * Handles element's layer frame update.\n   * Checks layer in point and out point\n   *\n   */ function FrameElement() {}\n    FrameElement.prototype = {\n        /**\n       * @function\n       * Initializes frame related properties.\n       *\n       */ initFrame: function initFrame() {\n            // set to true when inpoint is rendered\n            this._isFirstFrame = false;\n            // list of animated properties\n            this.dynamicProperties = [];\n            // If layer has been modified in current tick this will be true\n            this._mdf = false;\n        },\n        /**\n       * @function\n       * Calculates all dynamic values\n       *\n       * @param {number} num\n       * current frame number in Layer's time\n       * @param {boolean} isVisible\n       * if layers is currently in range\n       *\n       */ prepareProperties: function prepareProperties(num, isVisible) {\n            var i;\n            var len = this.dynamicProperties.length;\n            for(i = 0; i < len; i += 1){\n                if (isVisible || this._isParent && this.dynamicProperties[i].propType === 'transform') {\n                    this.dynamicProperties[i].getValue();\n                    if (this.dynamicProperties[i]._mdf) {\n                        this.globalData._mdf = true;\n                        this._mdf = true;\n                    }\n                }\n            }\n        },\n        addDynamicProperty: function addDynamicProperty(prop) {\n            if (this.dynamicProperties.indexOf(prop) === -1) {\n                this.dynamicProperties.push(prop);\n            }\n        }\n    };\n    function FootageElement(data, globalData, comp) {\n        this.initFrame();\n        this.initRenderable();\n        this.assetData = globalData.getAssetData(data.refId);\n        this.footageData = globalData.imageLoader.getAsset(this.assetData);\n        this.initBaseData(data, globalData, comp);\n    }\n    FootageElement.prototype.prepareFrame = function() {};\n    extendPrototype([\n        RenderableElement,\n        BaseElement,\n        FrameElement\n    ], FootageElement);\n    FootageElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    FootageElement.prototype.renderFrame = function() {};\n    FootageElement.prototype.destroy = function() {};\n    FootageElement.prototype.initExpressions = function() {\n        var expressionsInterfaces = getExpressionInterfaces();\n        if (!expressionsInterfaces) {\n            return;\n        }\n        var FootageInterface = expressionsInterfaces('footage');\n        this.layerInterface = FootageInterface(this);\n    };\n    FootageElement.prototype.getFootageData = function() {\n        return this.footageData;\n    };\n    function AudioElement(data, globalData, comp) {\n        this.initFrame();\n        this.initRenderable();\n        this.assetData = globalData.getAssetData(data.refId);\n        this.initBaseData(data, globalData, comp);\n        this._isPlaying = false;\n        this._canPlay = false;\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        this.audio = this.globalData.audioController.createAudio(assetPath);\n        this._currentTime = 0;\n        this.globalData.audioController.addAudio(this);\n        this._volumeMultiplier = 1;\n        this._volume = 1;\n        this._previousVolume = null;\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n        this.lv = PropertyFactory.getProp(this, data.au && data.au.lv ? data.au.lv : {\n            k: [\n                100\n            ]\n        }, 1, 0.01, this);\n    }\n    AudioElement.prototype.prepareFrame = function(num) {\n        this.prepareRenderableFrame(num, true);\n        this.prepareProperties(num, true);\n        if (!this.tm._placeholder) {\n            var timeRemapped = this.tm.v;\n            this._currentTime = timeRemapped;\n        } else {\n            this._currentTime = num / this.data.sr;\n        }\n        this._volume = this.lv.v[0];\n        var totalVolume = this._volume * this._volumeMultiplier;\n        if (this._previousVolume !== totalVolume) {\n            this._previousVolume = totalVolume;\n            this.audio.volume(totalVolume);\n        }\n    };\n    extendPrototype([\n        RenderableElement,\n        BaseElement,\n        FrameElement\n    ], AudioElement);\n    AudioElement.prototype.renderFrame = function() {\n        if (this.isInRange && this._canPlay) {\n            if (!this._isPlaying) {\n                this.audio.play();\n                this.audio.seek(this._currentTime / this.globalData.frameRate);\n                this._isPlaying = true;\n            } else if (!this.audio.playing() || Math.abs(this._currentTime / this.globalData.frameRate - this.audio.seek()) > 0.1) {\n                this.audio.seek(this._currentTime / this.globalData.frameRate);\n            }\n        }\n    };\n    AudioElement.prototype.show = function() {\n    // this.audio.play()\n    };\n    AudioElement.prototype.hide = function() {\n        this.audio.pause();\n        this._isPlaying = false;\n    };\n    AudioElement.prototype.pause = function() {\n        this.audio.pause();\n        this._isPlaying = false;\n        this._canPlay = false;\n    };\n    AudioElement.prototype.resume = function() {\n        this._canPlay = true;\n    };\n    AudioElement.prototype.setRate = function(rateValue) {\n        this.audio.rate(rateValue);\n    };\n    AudioElement.prototype.volume = function(volumeValue) {\n        this._volumeMultiplier = volumeValue;\n        this._previousVolume = volumeValue * this._volume;\n        this.audio.volume(this._previousVolume);\n    };\n    AudioElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    AudioElement.prototype.destroy = function() {};\n    AudioElement.prototype.sourceRectAtTime = function() {};\n    AudioElement.prototype.initExpressions = function() {};\n    function BaseRenderer() {}\n    BaseRenderer.prototype.checkLayers = function(num) {\n        var i;\n        var len = this.layers.length;\n        var data;\n        this.completeLayers = true;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (!this.elements[i]) {\n                data = this.layers[i];\n                if (data.ip - data.st <= num - this.layers[i].st && data.op - data.st > num - this.layers[i].st) {\n                    this.buildItem(i);\n                }\n            }\n            this.completeLayers = this.elements[i] ? this.completeLayers : false;\n        }\n        this.checkPendingElements();\n    };\n    BaseRenderer.prototype.createItem = function(layer) {\n        switch(layer.ty){\n            case 2:\n                return this.createImage(layer);\n            case 0:\n                return this.createComp(layer);\n            case 1:\n                return this.createSolid(layer);\n            case 3:\n                return this.createNull(layer);\n            case 4:\n                return this.createShape(layer);\n            case 5:\n                return this.createText(layer);\n            case 6:\n                return this.createAudio(layer);\n            case 13:\n                return this.createCamera(layer);\n            case 15:\n                return this.createFootage(layer);\n            default:\n                return this.createNull(layer);\n        }\n    };\n    BaseRenderer.prototype.createCamera = function() {\n        throw new Error('You\\'re using a 3d camera. Try the html renderer.');\n    };\n    BaseRenderer.prototype.createAudio = function(data) {\n        return new AudioElement(data, this.globalData, this);\n    };\n    BaseRenderer.prototype.createFootage = function(data) {\n        return new FootageElement(data, this.globalData, this);\n    };\n    BaseRenderer.prototype.buildAllItems = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            this.buildItem(i);\n        }\n        this.checkPendingElements();\n    };\n    BaseRenderer.prototype.includeLayers = function(newLayers) {\n        this.completeLayers = false;\n        var i;\n        var len = newLayers.length;\n        var j;\n        var jLen = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            j = 0;\n            while(j < jLen){\n                if (this.layers[j].id === newLayers[i].id) {\n                    this.layers[j] = newLayers[i];\n                    break;\n                }\n                j += 1;\n            }\n        }\n    };\n    BaseRenderer.prototype.setProjectInterface = function(pInterface) {\n        this.globalData.projectInterface = pInterface;\n    };\n    BaseRenderer.prototype.initItems = function() {\n        if (!this.globalData.progressiveLoad) {\n            this.buildAllItems();\n        }\n    };\n    BaseRenderer.prototype.buildElementParenting = function(element, parentName, hierarchy) {\n        var elements = this.elements;\n        var layers = this.layers;\n        var i = 0;\n        var len = layers.length;\n        while(i < len){\n            if (layers[i].ind == parentName) {\n                // eslint-disable-line eqeqeq\n                if (!elements[i] || elements[i] === true) {\n                    this.buildItem(i);\n                    this.addPendingElement(element);\n                } else {\n                    hierarchy.push(elements[i]);\n                    elements[i].setAsParent();\n                    if (layers[i].parent !== undefined) {\n                        this.buildElementParenting(element, layers[i].parent, hierarchy);\n                    } else {\n                        element.setHierarchy(hierarchy);\n                    }\n                }\n            }\n            i += 1;\n        }\n    };\n    BaseRenderer.prototype.addPendingElement = function(element) {\n        this.pendingElements.push(element);\n    };\n    BaseRenderer.prototype.searchExtraCompositions = function(assets) {\n        var i;\n        var len = assets.length;\n        for(i = 0; i < len; i += 1){\n            if (assets[i].xt) {\n                var comp = this.createComp(assets[i]);\n                comp.initExpressions();\n                this.globalData.projectInterface.registerComposition(comp);\n            }\n        }\n    };\n    BaseRenderer.prototype.getElementById = function(ind) {\n        var i;\n        var len = this.elements.length;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i].data.ind === ind) {\n                return this.elements[i];\n            }\n        }\n        return null;\n    };\n    BaseRenderer.prototype.getElementByPath = function(path) {\n        var pathValue = path.shift();\n        var element;\n        if (typeof pathValue === 'number') {\n            element = this.elements[pathValue];\n        } else {\n            var i;\n            var len = this.elements.length;\n            for(i = 0; i < len; i += 1){\n                if (this.elements[i].data.nm === pathValue) {\n                    element = this.elements[i];\n                    break;\n                }\n            }\n        }\n        if (path.length === 0) {\n            return element;\n        }\n        return element.getElementByPath(path);\n    };\n    BaseRenderer.prototype.setupGlobalData = function(animData, fontsContainer) {\n        this.globalData.fontManager = new FontManager();\n        this.globalData.slotManager = slotFactory(animData);\n        this.globalData.fontManager.addChars(animData.chars);\n        this.globalData.fontManager.addFonts(animData.fonts, fontsContainer);\n        this.globalData.getAssetData = this.animationItem.getAssetData.bind(this.animationItem);\n        this.globalData.getAssetsPath = this.animationItem.getAssetsPath.bind(this.animationItem);\n        this.globalData.imageLoader = this.animationItem.imagePreloader;\n        this.globalData.audioController = this.animationItem.audioController;\n        this.globalData.frameId = 0;\n        this.globalData.frameRate = animData.fr;\n        this.globalData.nm = animData.nm;\n        this.globalData.compSize = {\n            w: animData.w,\n            h: animData.h\n        };\n    };\n    var effectTypes = {\n        TRANSFORM_EFFECT: 'transformEFfect'\n    };\n    function TransformElement() {}\n    TransformElement.prototype = {\n        initTransform: function initTransform() {\n            var mat = new Matrix();\n            this.finalTransform = {\n                mProp: this.data.ks ? TransformPropertyFactory.getTransformProperty(this, this.data.ks, this) : {\n                    o: 0\n                },\n                _matMdf: false,\n                _localMatMdf: false,\n                _opMdf: false,\n                mat: mat,\n                localMat: mat,\n                localOpacity: 1\n            };\n            if (this.data.ao) {\n                this.finalTransform.mProp.autoOriented = true;\n            }\n            // TODO: check TYPE 11: Guided elements\n            if (this.data.ty !== 11) {\n            // this.createElements();\n            }\n        },\n        renderTransform: function renderTransform() {\n            this.finalTransform._opMdf = this.finalTransform.mProp.o._mdf || this._isFirstFrame;\n            this.finalTransform._matMdf = this.finalTransform.mProp._mdf || this._isFirstFrame;\n            if (this.hierarchy) {\n                var mat;\n                var finalMat = this.finalTransform.mat;\n                var i = 0;\n                var len = this.hierarchy.length;\n                // Checking if any of the transformation matrices in the hierarchy chain has changed.\n                if (!this.finalTransform._matMdf) {\n                    while(i < len){\n                        if (this.hierarchy[i].finalTransform.mProp._mdf) {\n                            this.finalTransform._matMdf = true;\n                            break;\n                        }\n                        i += 1;\n                    }\n                }\n                if (this.finalTransform._matMdf) {\n                    mat = this.finalTransform.mProp.v.props;\n                    finalMat.cloneFromProps(mat);\n                    for(i = 0; i < len; i += 1){\n                        finalMat.multiply(this.hierarchy[i].finalTransform.mProp.v);\n                    }\n                }\n            }\n            if (!this.localTransforms || this.finalTransform._matMdf) {\n                this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n            }\n            if (this.finalTransform._opMdf) {\n                this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n            }\n        },\n        renderLocalTransform: function renderLocalTransform() {\n            if (this.localTransforms) {\n                var i = 0;\n                var len = this.localTransforms.length;\n                this.finalTransform._localMatMdf = this.finalTransform._matMdf;\n                if (!this.finalTransform._localMatMdf || !this.finalTransform._opMdf) {\n                    while(i < len){\n                        if (this.localTransforms[i]._mdf) {\n                            this.finalTransform._localMatMdf = true;\n                        }\n                        if (this.localTransforms[i]._opMdf && !this.finalTransform._opMdf) {\n                            this.finalTransform.localOpacity = this.finalTransform.mProp.o.v;\n                            this.finalTransform._opMdf = true;\n                        }\n                        i += 1;\n                    }\n                }\n                if (this.finalTransform._localMatMdf) {\n                    var localMat = this.finalTransform.localMat;\n                    this.localTransforms[0].matrix.clone(localMat);\n                    for(i = 1; i < len; i += 1){\n                        var lmat = this.localTransforms[i].matrix;\n                        localMat.multiply(lmat);\n                    }\n                    localMat.multiply(this.finalTransform.mat);\n                }\n                if (this.finalTransform._opMdf) {\n                    var localOp = this.finalTransform.localOpacity;\n                    for(i = 0; i < len; i += 1){\n                        localOp *= this.localTransforms[i].opacity * 0.01;\n                    }\n                    this.finalTransform.localOpacity = localOp;\n                }\n            }\n        },\n        searchEffectTransforms: function searchEffectTransforms() {\n            if (this.renderableEffectsManager) {\n                var transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n                if (transformEffects.length) {\n                    this.localTransforms = [];\n                    this.finalTransform.localMat = new Matrix();\n                    var i = 0;\n                    var len = transformEffects.length;\n                    for(i = 0; i < len; i += 1){\n                        this.localTransforms.push(transformEffects[i]);\n                    }\n                }\n            }\n        },\n        globalToLocal: function globalToLocal(pt) {\n            var transforms = [];\n            transforms.push(this.finalTransform);\n            var flag = true;\n            var comp = this.comp;\n            while(flag){\n                if (comp.finalTransform) {\n                    if (comp.data.hasMask) {\n                        transforms.splice(0, 0, comp.finalTransform);\n                    }\n                    comp = comp.comp;\n                } else {\n                    flag = false;\n                }\n            }\n            var i;\n            var len = transforms.length;\n            var ptNew;\n            for(i = 0; i < len; i += 1){\n                ptNew = transforms[i].mat.applyToPointArray(0, 0, 0);\n                // ptNew = transforms[i].mat.applyToPointArray(pt[0],pt[1],pt[2]);\n                pt = [\n                    pt[0] - ptNew[0],\n                    pt[1] - ptNew[1],\n                    0\n                ];\n            }\n            return pt;\n        },\n        mHelper: new Matrix()\n    };\n    function MaskElement(data, element, globalData) {\n        this.data = data;\n        this.element = element;\n        this.globalData = globalData;\n        this.storedData = [];\n        this.masksProperties = this.data.masksProperties || [];\n        this.maskElement = null;\n        var defs = this.globalData.defs;\n        var i;\n        var len = this.masksProperties ? this.masksProperties.length : 0;\n        this.viewData = createSizedArray(len);\n        this.solidPath = '';\n        var path;\n        var properties = this.masksProperties;\n        var count = 0;\n        var currentMasks = [];\n        var j;\n        var jLen;\n        var layerId = createElementID();\n        var rect;\n        var expansor;\n        var feMorph;\n        var x;\n        var maskType = 'clipPath';\n        var maskRef = 'clip-path';\n        for(i = 0; i < len; i += 1){\n            if (properties[i].mode !== 'a' && properties[i].mode !== 'n' || properties[i].inv || properties[i].o.k !== 100 || properties[i].o.x) {\n                maskType = 'mask';\n                maskRef = 'mask';\n            }\n            if ((properties[i].mode === 's' || properties[i].mode === 'i') && count === 0) {\n                rect = createNS('rect');\n                rect.setAttribute('fill', '#ffffff');\n                rect.setAttribute('width', this.element.comp.data.w || 0);\n                rect.setAttribute('height', this.element.comp.data.h || 0);\n                currentMasks.push(rect);\n            } else {\n                rect = null;\n            }\n            path = createNS('path');\n            if (properties[i].mode === 'n') {\n                // TODO move this to a factory or to a constructor\n                this.viewData[i] = {\n                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n                    elem: path,\n                    lastPath: ''\n                };\n                defs.appendChild(path);\n            } else {\n                count += 1;\n                path.setAttribute('fill', properties[i].mode === 's' ? '#000000' : '#ffffff');\n                path.setAttribute('clip-rule', 'nonzero');\n                var filterID;\n                if (properties[i].x.k !== 0) {\n                    maskType = 'mask';\n                    maskRef = 'mask';\n                    x = PropertyFactory.getProp(this.element, properties[i].x, 0, null, this.element);\n                    filterID = createElementID();\n                    expansor = createNS('filter');\n                    expansor.setAttribute('id', filterID);\n                    feMorph = createNS('feMorphology');\n                    feMorph.setAttribute('operator', 'erode');\n                    feMorph.setAttribute('in', 'SourceGraphic');\n                    feMorph.setAttribute('radius', '0');\n                    expansor.appendChild(feMorph);\n                    defs.appendChild(expansor);\n                    path.setAttribute('stroke', properties[i].mode === 's' ? '#000000' : '#ffffff');\n                } else {\n                    feMorph = null;\n                    x = null;\n                }\n                // TODO move this to a factory or to a constructor\n                this.storedData[i] = {\n                    elem: path,\n                    x: x,\n                    expan: feMorph,\n                    lastPath: '',\n                    lastOperator: '',\n                    filterId: filterID,\n                    lastRadius: 0\n                };\n                if (properties[i].mode === 'i') {\n                    jLen = currentMasks.length;\n                    var g = createNS('g');\n                    for(j = 0; j < jLen; j += 1){\n                        g.appendChild(currentMasks[j]);\n                    }\n                    var mask = createNS('mask');\n                    mask.setAttribute('mask-type', 'alpha');\n                    mask.setAttribute('id', layerId + '_' + count);\n                    mask.appendChild(path);\n                    defs.appendChild(mask);\n                    g.setAttribute('mask', 'url(' + getLocationHref() + '#' + layerId + '_' + count + ')');\n                    currentMasks.length = 0;\n                    currentMasks.push(g);\n                } else {\n                    currentMasks.push(path);\n                }\n                if (properties[i].inv && !this.solidPath) {\n                    this.solidPath = this.createLayerSolidPath();\n                }\n                // TODO move this to a factory or to a constructor\n                this.viewData[i] = {\n                    elem: path,\n                    lastPath: '',\n                    op: PropertyFactory.getProp(this.element, properties[i].o, 0, 0.01, this.element),\n                    prop: ShapePropertyFactory.getShapeProp(this.element, properties[i], 3),\n                    invRect: rect\n                };\n                if (!this.viewData[i].prop.k) {\n                    this.drawPath(properties[i], this.viewData[i].prop.v, this.viewData[i]);\n                }\n            }\n        }\n        this.maskElement = createNS(maskType);\n        len = currentMasks.length;\n        for(i = 0; i < len; i += 1){\n            this.maskElement.appendChild(currentMasks[i]);\n        }\n        if (count > 0) {\n            this.maskElement.setAttribute('id', layerId);\n            this.element.maskedElement.setAttribute(maskRef, 'url(' + getLocationHref() + '#' + layerId + ')');\n            defs.appendChild(this.maskElement);\n        }\n        if (this.viewData.length) {\n            this.element.addRenderableComponent(this);\n        }\n    }\n    MaskElement.prototype.getMaskProperty = function(pos) {\n        return this.viewData[pos].prop;\n    };\n    MaskElement.prototype.renderFrame = function(isFirstFrame) {\n        var finalMat = this.element.finalTransform.mat;\n        var i;\n        var len = this.masksProperties.length;\n        for(i = 0; i < len; i += 1){\n            if (this.viewData[i].prop._mdf || isFirstFrame) {\n                this.drawPath(this.masksProperties[i], this.viewData[i].prop.v, this.viewData[i]);\n            }\n            if (this.viewData[i].op._mdf || isFirstFrame) {\n                this.viewData[i].elem.setAttribute('fill-opacity', this.viewData[i].op.v);\n            }\n            if (this.masksProperties[i].mode !== 'n') {\n                if (this.viewData[i].invRect && (this.element.finalTransform.mProp._mdf || isFirstFrame)) {\n                    this.viewData[i].invRect.setAttribute('transform', finalMat.getInverseMatrix().to2dCSS());\n                }\n                if (this.storedData[i].x && (this.storedData[i].x._mdf || isFirstFrame)) {\n                    var feMorph = this.storedData[i].expan;\n                    if (this.storedData[i].x.v < 0) {\n                        if (this.storedData[i].lastOperator !== 'erode') {\n                            this.storedData[i].lastOperator = 'erode';\n                            this.storedData[i].elem.setAttribute('filter', 'url(' + getLocationHref() + '#' + this.storedData[i].filterId + ')');\n                        }\n                        feMorph.setAttribute('radius', -this.storedData[i].x.v);\n                    } else {\n                        if (this.storedData[i].lastOperator !== 'dilate') {\n                            this.storedData[i].lastOperator = 'dilate';\n                            this.storedData[i].elem.setAttribute('filter', null);\n                        }\n                        this.storedData[i].elem.setAttribute('stroke-width', this.storedData[i].x.v * 2);\n                    }\n                }\n            }\n        }\n    };\n    MaskElement.prototype.getMaskelement = function() {\n        return this.maskElement;\n    };\n    MaskElement.prototype.createLayerSolidPath = function() {\n        var path = 'M0,0 ';\n        path += ' h' + this.globalData.compSize.w;\n        path += ' v' + this.globalData.compSize.h;\n        path += ' h-' + this.globalData.compSize.w;\n        path += ' v-' + this.globalData.compSize.h + ' ';\n        return path;\n    };\n    MaskElement.prototype.drawPath = function(pathData, pathNodes, viewData) {\n        var pathString = ' M' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];\n        var i;\n        var len;\n        len = pathNodes._length;\n        for(i = 1; i < len; i += 1){\n            // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[i][0]+','+pathNodes.i[i][1] + \" \"+pathNodes.v[i][0]+','+pathNodes.v[i][1];\n            pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[i][0] + ',' + pathNodes.i[i][1] + ' ' + pathNodes.v[i][0] + ',' + pathNodes.v[i][1];\n        }\n        // pathString += \" C\"+pathNodes.o[i-1][0]+','+pathNodes.o[i-1][1] + \" \"+pathNodes.i[0][0]+','+pathNodes.i[0][1] + \" \"+pathNodes.v[0][0]+','+pathNodes.v[0][1];\n        if (pathNodes.c && len > 1) {\n            pathString += ' C' + pathNodes.o[i - 1][0] + ',' + pathNodes.o[i - 1][1] + ' ' + pathNodes.i[0][0] + ',' + pathNodes.i[0][1] + ' ' + pathNodes.v[0][0] + ',' + pathNodes.v[0][1];\n        }\n        // pathNodes.__renderedString = pathString;\n        if (viewData.lastPath !== pathString) {\n            var pathShapeValue = '';\n            if (viewData.elem) {\n                if (pathNodes.c) {\n                    pathShapeValue = pathData.inv ? this.solidPath + pathString : pathString;\n                }\n                viewData.elem.setAttribute('d', pathShapeValue);\n            }\n            viewData.lastPath = pathString;\n        }\n    };\n    MaskElement.prototype.destroy = function() {\n        this.element = null;\n        this.globalData = null;\n        this.maskElement = null;\n        this.data = null;\n        this.masksProperties = null;\n    };\n    var filtersFactory = function() {\n        var ob = {};\n        ob.createFilter = createFilter;\n        ob.createAlphaToLuminanceFilter = createAlphaToLuminanceFilter;\n        function createFilter(filId, skipCoordinates) {\n            var fil = createNS('filter');\n            fil.setAttribute('id', filId);\n            if (skipCoordinates !== true) {\n                fil.setAttribute('filterUnits', 'objectBoundingBox');\n                fil.setAttribute('x', '0%');\n                fil.setAttribute('y', '0%');\n                fil.setAttribute('width', '100%');\n                fil.setAttribute('height', '100%');\n            }\n            return fil;\n        }\n        function createAlphaToLuminanceFilter() {\n            var feColorMatrix = createNS('feColorMatrix');\n            feColorMatrix.setAttribute('type', 'matrix');\n            feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n            feColorMatrix.setAttribute('values', '0 0 0 1 0  0 0 0 1 0  0 0 0 1 0  0 0 0 1 1');\n            return feColorMatrix;\n        }\n        return ob;\n    }();\n    var featureSupport = function() {\n        var ob = {\n            maskType: true,\n            svgLumaHidden: true,\n            offscreenCanvas: typeof OffscreenCanvas !== 'undefined'\n        };\n        if (/MSIE 10/i.test(navigator.userAgent) || /MSIE 9/i.test(navigator.userAgent) || /rv:11.0/i.test(navigator.userAgent) || /Edge\\/\\d./i.test(navigator.userAgent)) {\n            ob.maskType = false;\n        }\n        if (/firefox/i.test(navigator.userAgent)) {\n            ob.svgLumaHidden = false;\n        }\n        return ob;\n    }();\n    var registeredEffects$1 = {};\n    var idPrefix = 'filter_result_';\n    function SVGEffects(elem) {\n        var i;\n        var source = 'SourceGraphic';\n        var len = elem.data.ef ? elem.data.ef.length : 0;\n        var filId = createElementID();\n        var fil = filtersFactory.createFilter(filId, true);\n        var count = 0;\n        this.filters = [];\n        var filterManager;\n        for(i = 0; i < len; i += 1){\n            filterManager = null;\n            var type = elem.data.ef[i].ty;\n            if (registeredEffects$1[type]) {\n                var Effect = registeredEffects$1[type].effect;\n                filterManager = new Effect(fil, elem.effectsManager.effectElements[i], elem, idPrefix + count, source);\n                source = idPrefix + count;\n                if (registeredEffects$1[type].countsAsEffect) {\n                    count += 1;\n                }\n            }\n            if (filterManager) {\n                this.filters.push(filterManager);\n            }\n        }\n        if (count) {\n            elem.globalData.defs.appendChild(fil);\n            elem.layerElement.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n        }\n        if (this.filters.length) {\n            elem.addRenderableComponent(this);\n        }\n    }\n    SVGEffects.prototype.renderFrame = function(_isFirstFrame) {\n        var i;\n        var len = this.filters.length;\n        for(i = 0; i < len; i += 1){\n            this.filters[i].renderFrame(_isFirstFrame);\n        }\n    };\n    SVGEffects.prototype.getEffects = function(type) {\n        var i;\n        var len = this.filters.length;\n        var effects = [];\n        for(i = 0; i < len; i += 1){\n            if (this.filters[i].type === type) {\n                effects.push(this.filters[i]);\n            }\n        }\n        return effects;\n    };\n    function registerEffect$1(id, effect, countsAsEffect) {\n        registeredEffects$1[id] = {\n            effect: effect,\n            countsAsEffect: countsAsEffect\n        };\n    }\n    function SVGBaseElement() {}\n    SVGBaseElement.prototype = {\n        initRendererElement: function initRendererElement() {\n            this.layerElement = createNS('g');\n        },\n        createContainerElements: function createContainerElements() {\n            this.matteElement = createNS('g');\n            this.transformedElement = this.layerElement;\n            this.maskedElement = this.layerElement;\n            this._sizeChanged = false;\n            var layerElementParent = null;\n            // If this layer acts as a mask for the following layer\n            if (this.data.td) {\n                this.matteMasks = {};\n                var gg = createNS('g');\n                gg.setAttribute('id', this.layerId);\n                gg.appendChild(this.layerElement);\n                layerElementParent = gg;\n                this.globalData.defs.appendChild(gg);\n            } else if (this.data.tt) {\n                this.matteElement.appendChild(this.layerElement);\n                layerElementParent = this.matteElement;\n                this.baseElement = this.matteElement;\n            } else {\n                this.baseElement = this.layerElement;\n            }\n            if (this.data.ln) {\n                this.layerElement.setAttribute('id', this.data.ln);\n            }\n            if (this.data.cl) {\n                this.layerElement.setAttribute('class', this.data.cl);\n            }\n            // Clipping compositions to hide content that exceeds boundaries. If collapsed transformations is on, component should not be clipped\n            if (this.data.ty === 0 && !this.data.hd) {\n                var cp = createNS('clipPath');\n                var pt = createNS('path');\n                pt.setAttribute('d', 'M0,0 L' + this.data.w + ',0 L' + this.data.w + ',' + this.data.h + ' L0,' + this.data.h + 'z');\n                var clipId = createElementID();\n                cp.setAttribute('id', clipId);\n                cp.appendChild(pt);\n                this.globalData.defs.appendChild(cp);\n                if (this.checkMasks()) {\n                    var cpGroup = createNS('g');\n                    cpGroup.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');\n                    cpGroup.appendChild(this.layerElement);\n                    this.transformedElement = cpGroup;\n                    if (layerElementParent) {\n                        layerElementParent.appendChild(this.transformedElement);\n                    } else {\n                        this.baseElement = this.transformedElement;\n                    }\n                } else {\n                    this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + clipId + ')');\n                }\n            }\n            if (this.data.bm !== 0) {\n                this.setBlendMode();\n            }\n        },\n        renderElement: function renderElement() {\n            if (this.finalTransform._localMatMdf) {\n                this.transformedElement.setAttribute('transform', this.finalTransform.localMat.to2dCSS());\n            }\n            if (this.finalTransform._opMdf) {\n                this.transformedElement.setAttribute('opacity', this.finalTransform.localOpacity);\n            }\n        },\n        destroyBaseElement: function destroyBaseElement() {\n            this.layerElement = null;\n            this.matteElement = null;\n            this.maskManager.destroy();\n        },\n        getBaseElement: function getBaseElement() {\n            if (this.data.hd) {\n                return null;\n            }\n            return this.baseElement;\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new MaskElement(this.data, this, this.globalData);\n            this.renderableEffectsManager = new SVGEffects(this);\n            this.searchEffectTransforms();\n        },\n        getMatte: function getMatte(matteType) {\n            // This should not be a common case. But for backward compatibility, we'll create the matte object.\n            // It solves animations that have two consecutive layers marked as matte masks.\n            // Which is an undefined behavior in AE.\n            if (!this.matteMasks) {\n                this.matteMasks = {};\n            }\n            if (!this.matteMasks[matteType]) {\n                var id = this.layerId + '_' + matteType;\n                var filId;\n                var fil;\n                var useElement;\n                var gg;\n                if (matteType === 1 || matteType === 3) {\n                    var masker = createNS('mask');\n                    masker.setAttribute('id', id);\n                    masker.setAttribute('mask-type', matteType === 3 ? 'luminance' : 'alpha');\n                    useElement = createNS('use');\n                    useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);\n                    masker.appendChild(useElement);\n                    this.globalData.defs.appendChild(masker);\n                    if (!featureSupport.maskType && matteType === 1) {\n                        masker.setAttribute('mask-type', 'luminance');\n                        filId = createElementID();\n                        fil = filtersFactory.createFilter(filId);\n                        this.globalData.defs.appendChild(fil);\n                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n                        gg = createNS('g');\n                        gg.appendChild(useElement);\n                        masker.appendChild(gg);\n                        gg.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n                    }\n                } else if (matteType === 2) {\n                    var maskGroup = createNS('mask');\n                    maskGroup.setAttribute('id', id);\n                    maskGroup.setAttribute('mask-type', 'alpha');\n                    var maskGrouper = createNS('g');\n                    maskGroup.appendChild(maskGrouper);\n                    filId = createElementID();\n                    fil = filtersFactory.createFilter(filId);\n                    /// /\n                    var feCTr = createNS('feComponentTransfer');\n                    feCTr.setAttribute('in', 'SourceGraphic');\n                    fil.appendChild(feCTr);\n                    var feFunc = createNS('feFuncA');\n                    feFunc.setAttribute('type', 'table');\n                    feFunc.setAttribute('tableValues', '1.0 0.0');\n                    feCTr.appendChild(feFunc);\n                    /// /\n                    this.globalData.defs.appendChild(fil);\n                    var alphaRect = createNS('rect');\n                    alphaRect.setAttribute('width', this.comp.data.w);\n                    alphaRect.setAttribute('height', this.comp.data.h);\n                    alphaRect.setAttribute('x', '0');\n                    alphaRect.setAttribute('y', '0');\n                    alphaRect.setAttribute('fill', '#ffffff');\n                    alphaRect.setAttribute('opacity', '0');\n                    maskGrouper.setAttribute('filter', 'url(' + getLocationHref() + '#' + filId + ')');\n                    maskGrouper.appendChild(alphaRect);\n                    useElement = createNS('use');\n                    useElement.setAttributeNS('http://www.w3.org/1999/xlink', 'href', '#' + this.layerId);\n                    maskGrouper.appendChild(useElement);\n                    if (!featureSupport.maskType) {\n                        maskGroup.setAttribute('mask-type', 'luminance');\n                        fil.appendChild(filtersFactory.createAlphaToLuminanceFilter());\n                        gg = createNS('g');\n                        maskGrouper.appendChild(alphaRect);\n                        gg.appendChild(this.layerElement);\n                        maskGrouper.appendChild(gg);\n                    }\n                    this.globalData.defs.appendChild(maskGroup);\n                }\n                this.matteMasks[matteType] = id;\n            }\n            return this.matteMasks[matteType];\n        },\n        setMatte: function setMatte(id) {\n            if (!this.matteElement) {\n                return;\n            }\n            this.matteElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');\n        }\n    };\n    /**\n   * @file\n   * Handles AE's layer parenting property.\n   *\n   */ function HierarchyElement() {}\n    HierarchyElement.prototype = {\n        /**\n       * @function\n       * Initializes hierarchy properties\n       *\n       */ initHierarchy: function initHierarchy() {\n            // element's parent list\n            this.hierarchy = [];\n            // if element is parent of another layer _isParent will be true\n            this._isParent = false;\n            this.checkParenting();\n        },\n        /**\n       * @function\n       * Sets layer's hierarchy.\n       * @param {array} hierarch\n       * layer's parent list\n       *\n       */ setHierarchy: function setHierarchy(hierarchy) {\n            this.hierarchy = hierarchy;\n        },\n        /**\n       * @function\n       * Sets layer as parent.\n       *\n       */ setAsParent: function setAsParent() {\n            this._isParent = true;\n        },\n        /**\n       * @function\n       * Searches layer's parenting chain\n       *\n       */ checkParenting: function checkParenting() {\n            if (this.data.parent !== undefined) {\n                this.comp.buildElementParenting(this, this.data.parent, []);\n            }\n        }\n    };\n    function RenderableDOMElement() {}\n    (function() {\n        var _prototype = {\n            initElement: function initElement(data, globalData, comp) {\n                this.initFrame();\n                this.initBaseData(data, globalData, comp);\n                this.initTransform(data, globalData, comp);\n                this.initHierarchy();\n                this.initRenderable();\n                this.initRendererElement();\n                this.createContainerElements();\n                this.createRenderableComponents();\n                this.createContent();\n                this.hide();\n            },\n            hide: function hide() {\n                // console.log('HIDE', this);\n                if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n                    var elem = this.baseElement || this.layerElement;\n                    elem.style.display = 'none';\n                    this.hidden = true;\n                }\n            },\n            show: function show() {\n                // console.log('SHOW', this);\n                if (this.isInRange && !this.isTransparent) {\n                    if (!this.data.hd) {\n                        var elem = this.baseElement || this.layerElement;\n                        elem.style.display = 'block';\n                    }\n                    this.hidden = false;\n                    this._isFirstFrame = true;\n                }\n            },\n            renderFrame: function renderFrame() {\n                // If it is exported as hidden (data.hd === true) no need to render\n                // If it is not visible no need to render\n                if (this.data.hd || this.hidden) {\n                    return;\n                }\n                this.renderTransform();\n                this.renderRenderable();\n                this.renderLocalTransform();\n                this.renderElement();\n                this.renderInnerContent();\n                if (this._isFirstFrame) {\n                    this._isFirstFrame = false;\n                }\n            },\n            renderInnerContent: function renderInnerContent() {},\n            prepareFrame: function prepareFrame(num) {\n                this._mdf = false;\n                this.prepareRenderableFrame(num);\n                this.prepareProperties(num, this.isInRange);\n                this.checkTransparency();\n            },\n            destroy: function destroy() {\n                this.innerElem = null;\n                this.destroyBaseElement();\n            }\n        };\n        extendPrototype([\n            RenderableElement,\n            createProxyFunction(_prototype)\n        ], RenderableDOMElement);\n    })();\n    function IImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        if (this.assetData && this.assetData.sid) {\n            this.assetData = globalData.slotManager.getProp(this.assetData);\n        }\n        this.initElement(data, globalData, comp);\n        this.sourceRect = {\n            top: 0,\n            left: 0,\n            width: this.assetData.w,\n            height: this.assetData.h\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], IImageElement);\n    IImageElement.prototype.createContent = function() {\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        this.innerElem = createNS('image');\n        this.innerElem.setAttribute('width', this.assetData.w + 'px');\n        this.innerElem.setAttribute('height', this.assetData.h + 'px');\n        this.innerElem.setAttribute('preserveAspectRatio', this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio);\n        this.innerElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);\n        this.layerElement.appendChild(this.innerElem);\n    };\n    IImageElement.prototype.sourceRectAtTime = function() {\n        return this.sourceRect;\n    };\n    function ProcessedElement(element, position) {\n        this.elem = element;\n        this.pos = position;\n    }\n    function IShapeElement() {}\n    IShapeElement.prototype = {\n        addShapeToModifiers: function addShapeToModifiers(data) {\n            var i;\n            var len = this.shapeModifiers.length;\n            for(i = 0; i < len; i += 1){\n                this.shapeModifiers[i].addShape(data);\n            }\n        },\n        isShapeInAnimatedModifiers: function isShapeInAnimatedModifiers(data) {\n            var i = 0;\n            var len = this.shapeModifiers.length;\n            while(i < len){\n                if (this.shapeModifiers[i].isAnimatedWithShape(data)) {\n                    return true;\n                }\n            }\n            return false;\n        },\n        renderModifiers: function renderModifiers() {\n            if (!this.shapeModifiers.length) {\n                return;\n            }\n            var i;\n            var len = this.shapes.length;\n            for(i = 0; i < len; i += 1){\n                this.shapes[i].sh.reset();\n            }\n            len = this.shapeModifiers.length;\n            var shouldBreakProcess;\n            for(i = len - 1; i >= 0; i -= 1){\n                shouldBreakProcess = this.shapeModifiers[i].processShapes(this._isFirstFrame);\n                // workaround to fix cases where a repeater resets the shape so the following processes get called twice\n                // TODO: find a better solution for this\n                if (shouldBreakProcess) {\n                    break;\n                }\n            }\n        },\n        searchProcessedElement: function searchProcessedElement(elem) {\n            var elements = this.processedElements;\n            var i = 0;\n            var len = elements.length;\n            while(i < len){\n                if (elements[i].elem === elem) {\n                    return elements[i].pos;\n                }\n                i += 1;\n            }\n            return 0;\n        },\n        addProcessedElement: function addProcessedElement(elem, pos) {\n            var elements = this.processedElements;\n            var i = elements.length;\n            while(i){\n                i -= 1;\n                if (elements[i].elem === elem) {\n                    elements[i].pos = pos;\n                    return;\n                }\n            }\n            elements.push(new ProcessedElement(elem, pos));\n        },\n        prepareFrame: function prepareFrame(num) {\n            this.prepareRenderableFrame(num);\n            this.prepareProperties(num, this.isInRange);\n        }\n    };\n    var lineCapEnum = {\n        1: 'butt',\n        2: 'round',\n        3: 'square'\n    };\n    var lineJoinEnum = {\n        1: 'miter',\n        2: 'round',\n        3: 'bevel'\n    };\n    function SVGShapeData(transformers, level, shape) {\n        this.caches = [];\n        this.styles = [];\n        this.transformers = transformers;\n        this.lStr = '';\n        this.sh = shape;\n        this.lvl = level;\n        // TODO find if there are some cases where _isAnimated can be false.\n        // For now, since shapes add up with other shapes. They have to be calculated every time.\n        // One way of finding out is checking if all styles associated to this shape depend only of this shape\n        this._isAnimated = !!shape.k;\n        // TODO: commenting this for now since all shapes are animated\n        var i = 0;\n        var len = transformers.length;\n        while(i < len){\n            if (transformers[i].mProps.dynamicProperties.length) {\n                this._isAnimated = true;\n                break;\n            }\n            i += 1;\n        }\n    }\n    SVGShapeData.prototype.setAsAnimated = function() {\n        this._isAnimated = true;\n    };\n    function SVGStyleData(data, level) {\n        this.data = data;\n        this.type = data.ty;\n        this.d = '';\n        this.lvl = level;\n        this._mdf = false;\n        this.closed = data.hd === true;\n        this.pElem = createNS('path');\n        this.msElem = null;\n    }\n    SVGStyleData.prototype.reset = function() {\n        this.d = '';\n        this._mdf = false;\n    };\n    function DashProperty(elem, data, renderer, container) {\n        this.elem = elem;\n        this.frameId = -1;\n        this.dataProps = createSizedArray(data.length);\n        this.renderer = renderer;\n        this.k = false;\n        this.dashStr = '';\n        this.dashArray = createTypedArray('float32', data.length ? data.length - 1 : 0);\n        this.dashoffset = createTypedArray('float32', 1);\n        this.initDynamicPropertyContainer(container);\n        var i;\n        var len = data.length || 0;\n        var prop;\n        for(i = 0; i < len; i += 1){\n            prop = PropertyFactory.getProp(elem, data[i].v, 0, 0, this);\n            this.k = prop.k || this.k;\n            this.dataProps[i] = {\n                n: data[i].n,\n                p: prop\n            };\n        }\n        if (!this.k) {\n            this.getValue(true);\n        }\n        this._isAnimated = this.k;\n    }\n    DashProperty.prototype.getValue = function(forceRender) {\n        if (this.elem.globalData.frameId === this.frameId && !forceRender) {\n            return;\n        }\n        this.frameId = this.elem.globalData.frameId;\n        this.iterateDynamicProperties();\n        this._mdf = this._mdf || forceRender;\n        if (this._mdf) {\n            var i = 0;\n            var len = this.dataProps.length;\n            if (this.renderer === 'svg') {\n                this.dashStr = '';\n            }\n            for(i = 0; i < len; i += 1){\n                if (this.dataProps[i].n !== 'o') {\n                    if (this.renderer === 'svg') {\n                        this.dashStr += ' ' + this.dataProps[i].p.v;\n                    } else {\n                        this.dashArray[i] = this.dataProps[i].p.v;\n                    }\n                } else {\n                    this.dashoffset[0] = this.dataProps[i].p.v;\n                }\n            }\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], DashProperty);\n    function SVGStrokeStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n        this.d = new DashProperty(elem, data.d || {}, 'svg', this);\n        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n        this.style = styleOb;\n        this._isAnimated = !!this._isAnimated;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGStrokeStyleData);\n    function SVGFillStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.c = PropertyFactory.getProp(elem, data.c, 1, 255, this);\n        this.style = styleOb;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGFillStyleData);\n    function SVGNoStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.style = styleOb;\n    }\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGNoStyleData);\n    function GradientProperty(elem, data, container) {\n        this.data = data;\n        this.c = createTypedArray('uint8c', data.p * 4);\n        var cLength = data.k.k[0].s ? data.k.k[0].s.length - data.p * 4 : data.k.k.length - data.p * 4;\n        this.o = createTypedArray('float32', cLength);\n        this._cmdf = false;\n        this._omdf = false;\n        this._collapsable = this.checkCollapsable();\n        this._hasOpacity = cLength;\n        this.initDynamicPropertyContainer(container);\n        this.prop = PropertyFactory.getProp(elem, data.k, 1, null, this);\n        this.k = this.prop.k;\n        this.getValue(true);\n    }\n    GradientProperty.prototype.comparePoints = function(values, points) {\n        var i = 0;\n        var len = this.o.length / 2;\n        var diff;\n        while(i < len){\n            diff = Math.abs(values[i * 4] - values[points * 4 + i * 2]);\n            if (diff > 0.01) {\n                return false;\n            }\n            i += 1;\n        }\n        return true;\n    };\n    GradientProperty.prototype.checkCollapsable = function() {\n        if (this.o.length / 2 !== this.c.length / 4) {\n            return false;\n        }\n        if (this.data.k.k[0].s) {\n            var i = 0;\n            var len = this.data.k.k.length;\n            while(i < len){\n                if (!this.comparePoints(this.data.k.k[i].s, this.data.p)) {\n                    return false;\n                }\n                i += 1;\n            }\n        } else if (!this.comparePoints(this.data.k.k, this.data.p)) {\n            return false;\n        }\n        return true;\n    };\n    GradientProperty.prototype.getValue = function(forceRender) {\n        this.prop.getValue();\n        this._mdf = false;\n        this._cmdf = false;\n        this._omdf = false;\n        if (this.prop._mdf || forceRender) {\n            var i;\n            var len = this.data.p * 4;\n            var mult;\n            var val;\n            for(i = 0; i < len; i += 1){\n                mult = i % 4 === 0 ? 100 : 255;\n                val = Math.round(this.prop.v[i] * mult);\n                if (this.c[i] !== val) {\n                    this.c[i] = val;\n                    this._cmdf = !forceRender;\n                }\n            }\n            if (this.o.length) {\n                len = this.prop.v.length;\n                for(i = this.data.p * 4; i < len; i += 1){\n                    mult = i % 2 === 0 ? 100 : 1;\n                    val = i % 2 === 0 ? Math.round(this.prop.v[i] * 100) : this.prop.v[i];\n                    if (this.o[i - this.data.p * 4] !== val) {\n                        this.o[i - this.data.p * 4] = val;\n                        this._omdf = !forceRender;\n                    }\n                }\n            }\n            this._mdf = !forceRender;\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], GradientProperty);\n    function SVGGradientFillStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.initGradientData(elem, data, styleOb);\n    }\n    SVGGradientFillStyleData.prototype.initGradientData = function(elem, data, styleOb) {\n        this.o = PropertyFactory.getProp(elem, data.o, 0, 0.01, this);\n        this.s = PropertyFactory.getProp(elem, data.s, 1, null, this);\n        this.e = PropertyFactory.getProp(elem, data.e, 1, null, this);\n        this.h = PropertyFactory.getProp(elem, data.h || {\n            k: 0\n        }, 0, 0.01, this);\n        this.a = PropertyFactory.getProp(elem, data.a || {\n            k: 0\n        }, 0, degToRads, this);\n        this.g = new GradientProperty(elem, data.g, this);\n        this.style = styleOb;\n        this.stops = [];\n        this.setGradientData(styleOb.pElem, data);\n        this.setGradientOpacity(data, styleOb);\n        this._isAnimated = !!this._isAnimated;\n    };\n    SVGGradientFillStyleData.prototype.setGradientData = function(pathElement, data) {\n        var gradientId = createElementID();\n        var gfill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\n        gfill.setAttribute('id', gradientId);\n        gfill.setAttribute('spreadMethod', 'pad');\n        gfill.setAttribute('gradientUnits', 'userSpaceOnUse');\n        var stops = [];\n        var stop;\n        var j;\n        var jLen;\n        jLen = data.g.p * 4;\n        for(j = 0; j < jLen; j += 4){\n            stop = createNS('stop');\n            gfill.appendChild(stop);\n            stops.push(stop);\n        }\n        pathElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + gradientId + ')');\n        this.gf = gfill;\n        this.cst = stops;\n    };\n    SVGGradientFillStyleData.prototype.setGradientOpacity = function(data, styleOb) {\n        if (this.g._hasOpacity && !this.g._collapsable) {\n            var stop;\n            var j;\n            var jLen;\n            var mask = createNS('mask');\n            var maskElement = createNS('path');\n            mask.appendChild(maskElement);\n            var opacityId = createElementID();\n            var maskId = createElementID();\n            mask.setAttribute('id', maskId);\n            var opFill = createNS(data.t === 1 ? 'linearGradient' : 'radialGradient');\n            opFill.setAttribute('id', opacityId);\n            opFill.setAttribute('spreadMethod', 'pad');\n            opFill.setAttribute('gradientUnits', 'userSpaceOnUse');\n            jLen = data.g.k.k[0].s ? data.g.k.k[0].s.length : data.g.k.k.length;\n            var stops = this.stops;\n            for(j = data.g.p * 4; j < jLen; j += 2){\n                stop = createNS('stop');\n                stop.setAttribute('stop-color', 'rgb(255,255,255)');\n                opFill.appendChild(stop);\n                stops.push(stop);\n            }\n            maskElement.setAttribute(data.ty === 'gf' ? 'fill' : 'stroke', 'url(' + getLocationHref() + '#' + opacityId + ')');\n            if (data.ty === 'gs') {\n                maskElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);\n                maskElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);\n                if (data.lj === 1) {\n                    maskElement.setAttribute('stroke-miterlimit', data.ml);\n                }\n            }\n            this.of = opFill;\n            this.ms = mask;\n            this.ost = stops;\n            this.maskId = maskId;\n            styleOb.msElem = maskElement;\n        }\n    };\n    extendPrototype([\n        DynamicPropertyContainer\n    ], SVGGradientFillStyleData);\n    function SVGGradientStrokeStyleData(elem, data, styleOb) {\n        this.initDynamicPropertyContainer(elem);\n        this.getValue = this.iterateDynamicProperties;\n        this.w = PropertyFactory.getProp(elem, data.w, 0, null, this);\n        this.d = new DashProperty(elem, data.d || {}, 'svg', this);\n        this.initGradientData(elem, data, styleOb);\n        this._isAnimated = !!this._isAnimated;\n    }\n    extendPrototype([\n        SVGGradientFillStyleData,\n        DynamicPropertyContainer\n    ], SVGGradientStrokeStyleData);\n    function ShapeGroupData() {\n        this.it = [];\n        this.prevViewData = [];\n        this.gr = createNS('g');\n    }\n    function SVGTransformData(mProps, op, container) {\n        this.transform = {\n            mProps: mProps,\n            op: op,\n            container: container\n        };\n        this.elements = [];\n        this._isAnimated = this.transform.mProps.dynamicProperties.length || this.transform.op.effectsSequence.length;\n    }\n    var buildShapeString = function buildShapeString(pathNodes, length, closed, mat) {\n        if (length === 0) {\n            return '';\n        }\n        var _o = pathNodes.o;\n        var _i = pathNodes.i;\n        var _v = pathNodes.v;\n        var i;\n        var shapeString = ' M' + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n        for(i = 1; i < length; i += 1){\n            shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[i][0], _i[i][1]) + ' ' + mat.applyToPointStringified(_v[i][0], _v[i][1]);\n        }\n        if (closed && length) {\n            shapeString += ' C' + mat.applyToPointStringified(_o[i - 1][0], _o[i - 1][1]) + ' ' + mat.applyToPointStringified(_i[0][0], _i[0][1]) + ' ' + mat.applyToPointStringified(_v[0][0], _v[0][1]);\n            shapeString += 'z';\n        }\n        return shapeString;\n    };\n    var SVGElementsRenderer = function() {\n        var _identityMatrix = new Matrix();\n        var _matrixHelper = new Matrix();\n        var ob = {\n            createRenderFunction: createRenderFunction\n        };\n        function createRenderFunction(data) {\n            switch(data.ty){\n                case 'fl':\n                    return renderFill;\n                case 'gf':\n                    return renderGradient;\n                case 'gs':\n                    return renderGradientStroke;\n                case 'st':\n                    return renderStroke;\n                case 'sh':\n                case 'el':\n                case 'rc':\n                case 'sr':\n                    return renderPath;\n                case 'tr':\n                    return renderContentTransform;\n                case 'no':\n                    return renderNoop;\n                default:\n                    return null;\n            }\n        }\n        function renderContentTransform(styleData, itemData, isFirstFrame) {\n            if (isFirstFrame || itemData.transform.op._mdf) {\n                itemData.transform.container.setAttribute('opacity', itemData.transform.op.v);\n            }\n            if (isFirstFrame || itemData.transform.mProps._mdf) {\n                itemData.transform.container.setAttribute('transform', itemData.transform.mProps.v.to2dCSS());\n            }\n        }\n        function renderNoop() {}\n        function renderPath(styleData, itemData, isFirstFrame) {\n            var j;\n            var jLen;\n            var pathStringTransformed;\n            var redraw;\n            var pathNodes;\n            var l;\n            var lLen = itemData.styles.length;\n            var lvl = itemData.lvl;\n            var paths;\n            var mat;\n            var iterations;\n            var k;\n            for(l = 0; l < lLen; l += 1){\n                redraw = itemData.sh._mdf || isFirstFrame;\n                if (itemData.styles[l].lvl < lvl) {\n                    mat = _matrixHelper.reset();\n                    iterations = lvl - itemData.styles[l].lvl;\n                    k = itemData.transformers.length - 1;\n                    while(!redraw && iterations > 0){\n                        redraw = itemData.transformers[k].mProps._mdf || redraw;\n                        iterations -= 1;\n                        k -= 1;\n                    }\n                    if (redraw) {\n                        iterations = lvl - itemData.styles[l].lvl;\n                        k = itemData.transformers.length - 1;\n                        while(iterations > 0){\n                            mat.multiply(itemData.transformers[k].mProps.v);\n                            iterations -= 1;\n                            k -= 1;\n                        }\n                    }\n                } else {\n                    mat = _identityMatrix;\n                }\n                paths = itemData.sh.paths;\n                jLen = paths._length;\n                if (redraw) {\n                    pathStringTransformed = '';\n                    for(j = 0; j < jLen; j += 1){\n                        pathNodes = paths.shapes[j];\n                        if (pathNodes && pathNodes._length) {\n                            pathStringTransformed += buildShapeString(pathNodes, pathNodes._length, pathNodes.c, mat);\n                        }\n                    }\n                    itemData.caches[l] = pathStringTransformed;\n                } else {\n                    pathStringTransformed = itemData.caches[l];\n                }\n                itemData.styles[l].d += styleData.hd === true ? '' : pathStringTransformed;\n                itemData.styles[l]._mdf = redraw || itemData.styles[l]._mdf;\n            }\n        }\n        function renderFill(styleData, itemData, isFirstFrame) {\n            var styleElem = itemData.style;\n            if (itemData.c._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute('fill', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');\n            }\n            if (itemData.o._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute('fill-opacity', itemData.o.v);\n            }\n        }\n        function renderGradientStroke(styleData, itemData, isFirstFrame) {\n            renderGradient(styleData, itemData, isFirstFrame);\n            renderStroke(styleData, itemData, isFirstFrame);\n        }\n        function renderGradient(styleData, itemData, isFirstFrame) {\n            var gfill = itemData.gf;\n            var hasOpacity = itemData.g._hasOpacity;\n            var pt1 = itemData.s.v;\n            var pt2 = itemData.e.v;\n            if (itemData.o._mdf || isFirstFrame) {\n                var attr = styleData.ty === 'gf' ? 'fill-opacity' : 'stroke-opacity';\n                itemData.style.pElem.setAttribute(attr, itemData.o.v);\n            }\n            if (itemData.s._mdf || isFirstFrame) {\n                var attr1 = styleData.t === 1 ? 'x1' : 'cx';\n                var attr2 = attr1 === 'x1' ? 'y1' : 'cy';\n                gfill.setAttribute(attr1, pt1[0]);\n                gfill.setAttribute(attr2, pt1[1]);\n                if (hasOpacity && !itemData.g._collapsable) {\n                    itemData.of.setAttribute(attr1, pt1[0]);\n                    itemData.of.setAttribute(attr2, pt1[1]);\n                }\n            }\n            var stops;\n            var i;\n            var len;\n            var stop;\n            if (itemData.g._cmdf || isFirstFrame) {\n                stops = itemData.cst;\n                var cValues = itemData.g.c;\n                len = stops.length;\n                for(i = 0; i < len; i += 1){\n                    stop = stops[i];\n                    stop.setAttribute('offset', cValues[i * 4] + '%');\n                    stop.setAttribute('stop-color', 'rgb(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ')');\n                }\n            }\n            if (hasOpacity && (itemData.g._omdf || isFirstFrame)) {\n                var oValues = itemData.g.o;\n                if (itemData.g._collapsable) {\n                    stops = itemData.cst;\n                } else {\n                    stops = itemData.ost;\n                }\n                len = stops.length;\n                for(i = 0; i < len; i += 1){\n                    stop = stops[i];\n                    if (!itemData.g._collapsable) {\n                        stop.setAttribute('offset', oValues[i * 2] + '%');\n                    }\n                    stop.setAttribute('stop-opacity', oValues[i * 2 + 1]);\n                }\n            }\n            if (styleData.t === 1) {\n                if (itemData.e._mdf || isFirstFrame) {\n                    gfill.setAttribute('x2', pt2[0]);\n                    gfill.setAttribute('y2', pt2[1]);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute('x2', pt2[0]);\n                        itemData.of.setAttribute('y2', pt2[1]);\n                    }\n                }\n            } else {\n                var rad;\n                if (itemData.s._mdf || itemData.e._mdf || isFirstFrame) {\n                    rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                    gfill.setAttribute('r', rad);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute('r', rad);\n                    }\n                }\n                if (itemData.s._mdf || itemData.e._mdf || itemData.h._mdf || itemData.a._mdf || isFirstFrame) {\n                    if (!rad) {\n                        rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                    }\n                    var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n                    var percent = itemData.h.v;\n                    if (percent >= 1) {\n                        percent = 0.99;\n                    } else if (percent <= -1) {\n                        percent = -0.99;\n                    }\n                    var dist = rad * percent;\n                    var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n                    var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n                    gfill.setAttribute('fx', x);\n                    gfill.setAttribute('fy', y);\n                    if (hasOpacity && !itemData.g._collapsable) {\n                        itemData.of.setAttribute('fx', x);\n                        itemData.of.setAttribute('fy', y);\n                    }\n                }\n            // gfill.setAttribute('fy','200');\n            }\n        }\n        function renderStroke(styleData, itemData, isFirstFrame) {\n            var styleElem = itemData.style;\n            var d = itemData.d;\n            if (d && (d._mdf || isFirstFrame) && d.dashStr) {\n                styleElem.pElem.setAttribute('stroke-dasharray', d.dashStr);\n                styleElem.pElem.setAttribute('stroke-dashoffset', d.dashoffset[0]);\n            }\n            if (itemData.c && (itemData.c._mdf || isFirstFrame)) {\n                styleElem.pElem.setAttribute('stroke', 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')');\n            }\n            if (itemData.o._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute('stroke-opacity', itemData.o.v);\n            }\n            if (itemData.w._mdf || isFirstFrame) {\n                styleElem.pElem.setAttribute('stroke-width', itemData.w.v);\n                if (styleElem.msElem) {\n                    styleElem.msElem.setAttribute('stroke-width', itemData.w.v);\n                }\n            }\n        }\n        return ob;\n    }();\n    function SVGShapeElement(data, globalData, comp) {\n        // List of drawable elements\n        this.shapes = [];\n        // Full shape data\n        this.shapesData = data.shapes;\n        // List of styles that will be applied to shapes\n        this.stylesList = [];\n        // List of modifiers that will be applied to shapes\n        this.shapeModifiers = [];\n        // List of items in shape tree\n        this.itemsData = [];\n        // List of items in previous shape tree\n        this.processedElements = [];\n        // List of animated components\n        this.animatedContents = [];\n        this.initElement(data, globalData, comp);\n        // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n        // List of elements that have been created\n        this.prevViewData = [];\n    // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        IShapeElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], SVGShapeElement);\n    SVGShapeElement.prototype.initSecondaryElement = function() {};\n    SVGShapeElement.prototype.identityMatrix = new Matrix();\n    SVGShapeElement.prototype.buildExpressionInterface = function() {};\n    SVGShapeElement.prototype.createContent = function() {\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n        this.filterUniqueShapes();\n    };\n    /*\n  This method searches for multiple shapes that affect a single element and one of them is animated\n  */ SVGShapeElement.prototype.filterUniqueShapes = function() {\n        var i;\n        var len = this.shapes.length;\n        var shape;\n        var j;\n        var jLen = this.stylesList.length;\n        var style;\n        var tempShapes = [];\n        var areAnimated = false;\n        for(j = 0; j < jLen; j += 1){\n            style = this.stylesList[j];\n            areAnimated = false;\n            tempShapes.length = 0;\n            for(i = 0; i < len; i += 1){\n                shape = this.shapes[i];\n                if (shape.styles.indexOf(style) !== -1) {\n                    tempShapes.push(shape);\n                    areAnimated = shape._isAnimated || areAnimated;\n                }\n            }\n            if (tempShapes.length > 1 && areAnimated) {\n                this.setShapesAsAnimated(tempShapes);\n            }\n        }\n    };\n    SVGShapeElement.prototype.setShapesAsAnimated = function(shapes) {\n        var i;\n        var len = shapes.length;\n        for(i = 0; i < len; i += 1){\n            shapes[i].setAsAnimated();\n        }\n    };\n    SVGShapeElement.prototype.createStyleElement = function(data, level) {\n        // TODO: prevent drawing of hidden styles\n        var elementData;\n        var styleOb = new SVGStyleData(data, level);\n        var pathElement = styleOb.pElem;\n        if (data.ty === 'st') {\n            elementData = new SVGStrokeStyleData(this, data, styleOb);\n        } else if (data.ty === 'fl') {\n            elementData = new SVGFillStyleData(this, data, styleOb);\n        } else if (data.ty === 'gf' || data.ty === 'gs') {\n            var GradientConstructor = data.ty === 'gf' ? SVGGradientFillStyleData : SVGGradientStrokeStyleData;\n            elementData = new GradientConstructor(this, data, styleOb);\n            this.globalData.defs.appendChild(elementData.gf);\n            if (elementData.maskId) {\n                this.globalData.defs.appendChild(elementData.ms);\n                this.globalData.defs.appendChild(elementData.of);\n                pathElement.setAttribute('mask', 'url(' + getLocationHref() + '#' + elementData.maskId + ')');\n            }\n        } else if (data.ty === 'no') {\n            elementData = new SVGNoStyleData(this, data, styleOb);\n        }\n        if (data.ty === 'st' || data.ty === 'gs') {\n            pathElement.setAttribute('stroke-linecap', lineCapEnum[data.lc || 2]);\n            pathElement.setAttribute('stroke-linejoin', lineJoinEnum[data.lj || 2]);\n            pathElement.setAttribute('fill-opacity', '0');\n            if (data.lj === 1) {\n                pathElement.setAttribute('stroke-miterlimit', data.ml);\n            }\n        }\n        if (data.r === 2) {\n            pathElement.setAttribute('fill-rule', 'evenodd');\n        }\n        if (data.ln) {\n            pathElement.setAttribute('id', data.ln);\n        }\n        if (data.cl) {\n            pathElement.setAttribute('class', data.cl);\n        }\n        if (data.bm) {\n            pathElement.style['mix-blend-mode'] = getBlendMode(data.bm);\n        }\n        this.stylesList.push(styleOb);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.createGroupElement = function(data) {\n        var elementData = new ShapeGroupData();\n        if (data.ln) {\n            elementData.gr.setAttribute('id', data.ln);\n        }\n        if (data.cl) {\n            elementData.gr.setAttribute('class', data.cl);\n        }\n        if (data.bm) {\n            elementData.gr.style['mix-blend-mode'] = getBlendMode(data.bm);\n        }\n        return elementData;\n    };\n    SVGShapeElement.prototype.createTransformElement = function(data, container) {\n        var transformProperty = TransformPropertyFactory.getTransformProperty(this, data, this);\n        var elementData = new SVGTransformData(transformProperty, transformProperty.o, container);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.createShapeElement = function(data, ownTransformers, level) {\n        var ty = 4;\n        if (data.ty === 'rc') {\n            ty = 5;\n        } else if (data.ty === 'el') {\n            ty = 6;\n        } else if (data.ty === 'sr') {\n            ty = 7;\n        }\n        var shapeProperty = ShapePropertyFactory.getShapeProp(this, data, ty, this);\n        var elementData = new SVGShapeData(ownTransformers, level, shapeProperty);\n        this.shapes.push(elementData);\n        this.addShapeToModifiers(elementData);\n        this.addToAnimatedContents(data, elementData);\n        return elementData;\n    };\n    SVGShapeElement.prototype.addToAnimatedContents = function(data, element) {\n        var i = 0;\n        var len = this.animatedContents.length;\n        while(i < len){\n            if (this.animatedContents[i].element === element) {\n                return;\n            }\n            i += 1;\n        }\n        this.animatedContents.push({\n            fn: SVGElementsRenderer.createRenderFunction(data),\n            element: element,\n            data: data\n        });\n    };\n    SVGShapeElement.prototype.setElementStyles = function(elementData) {\n        var arr = elementData.styles;\n        var j;\n        var jLen = this.stylesList.length;\n        for(j = 0; j < jLen; j += 1){\n            if (arr.indexOf(this.stylesList[j]) === -1 && !this.stylesList[j].closed) {\n                arr.push(this.stylesList[j]);\n            }\n        }\n    };\n    SVGShapeElement.prototype.reloadShapes = function() {\n        this._isFirstFrame = true;\n        var i;\n        var len = this.itemsData.length;\n        for(i = 0; i < len; i += 1){\n            this.prevViewData[i] = this.itemsData[i];\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.layerElement, 0, [], true);\n        this.filterUniqueShapes();\n        len = this.dynamicProperties.length;\n        for(i = 0; i < len; i += 1){\n            this.dynamicProperties[i].getValue();\n        }\n        this.renderModifiers();\n    };\n    SVGShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, container, level, transformers, render) {\n        var ownTransformers = [].concat(transformers);\n        var i;\n        var len = arr.length - 1;\n        var j;\n        var jLen;\n        var ownStyles = [];\n        var ownModifiers = [];\n        var currentTransform;\n        var modifier;\n        var processedPos;\n        for(i = len; i >= 0; i -= 1){\n            processedPos = this.searchProcessedElement(arr[i]);\n            if (!processedPos) {\n                arr[i]._render = render;\n            } else {\n                itemsData[i] = prevViewData[processedPos - 1];\n            }\n            if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs' || arr[i].ty === 'no') {\n                if (!processedPos) {\n                    itemsData[i] = this.createStyleElement(arr[i], level);\n                } else {\n                    itemsData[i].style.closed = arr[i].hd;\n                }\n                if (arr[i]._render) {\n                    if (itemsData[i].style.pElem.parentNode !== container) {\n                        container.appendChild(itemsData[i].style.pElem);\n                    }\n                }\n                ownStyles.push(itemsData[i].style);\n            } else if (arr[i].ty === 'gr') {\n                if (!processedPos) {\n                    itemsData[i] = this.createGroupElement(arr[i]);\n                } else {\n                    jLen = itemsData[i].it.length;\n                    for(j = 0; j < jLen; j += 1){\n                        itemsData[i].prevViewData[j] = itemsData[i].it[j];\n                    }\n                }\n                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, itemsData[i].gr, level + 1, ownTransformers, render);\n                if (arr[i]._render) {\n                    if (itemsData[i].gr.parentNode !== container) {\n                        container.appendChild(itemsData[i].gr);\n                    }\n                }\n            } else if (arr[i].ty === 'tr') {\n                if (!processedPos) {\n                    itemsData[i] = this.createTransformElement(arr[i], container);\n                }\n                currentTransform = itemsData[i].transform;\n                ownTransformers.push(currentTransform);\n            } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n                if (!processedPos) {\n                    itemsData[i] = this.createShapeElement(arr[i], ownTransformers, level);\n                }\n                this.setElementStyles(itemsData[i]);\n            } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'ms' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    modifier.init(this, arr[i]);\n                    itemsData[i] = modifier;\n                    this.shapeModifiers.push(modifier);\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = false;\n                }\n                ownModifiers.push(modifier);\n            } else if (arr[i].ty === 'rp') {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    itemsData[i] = modifier;\n                    modifier.init(this, arr, i, itemsData);\n                    this.shapeModifiers.push(modifier);\n                    render = false;\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = true;\n                }\n                ownModifiers.push(modifier);\n            }\n            this.addProcessedElement(arr[i], i + 1);\n        }\n        len = ownStyles.length;\n        for(i = 0; i < len; i += 1){\n            ownStyles[i].closed = true;\n        }\n        len = ownModifiers.length;\n        for(i = 0; i < len; i += 1){\n            ownModifiers[i].closed = true;\n        }\n    };\n    SVGShapeElement.prototype.renderInnerContent = function() {\n        this.renderModifiers();\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            this.stylesList[i].reset();\n        }\n        this.renderShape();\n        for(i = 0; i < len; i += 1){\n            if (this.stylesList[i]._mdf || this._isFirstFrame) {\n                if (this.stylesList[i].msElem) {\n                    this.stylesList[i].msElem.setAttribute('d', this.stylesList[i].d);\n                    // Adding M0 0 fixes same mask bug on all browsers\n                    this.stylesList[i].d = 'M0 0' + this.stylesList[i].d;\n                }\n                this.stylesList[i].pElem.setAttribute('d', this.stylesList[i].d || 'M0 0');\n            }\n        }\n    };\n    SVGShapeElement.prototype.renderShape = function() {\n        var i;\n        var len = this.animatedContents.length;\n        var animatedContent;\n        for(i = 0; i < len; i += 1){\n            animatedContent = this.animatedContents[i];\n            if ((this._isFirstFrame || animatedContent.element._isAnimated) && animatedContent.data !== true) {\n                animatedContent.fn(animatedContent.data, animatedContent.element, this._isFirstFrame);\n            }\n        }\n    };\n    SVGShapeElement.prototype.destroy = function() {\n        this.destroyBaseElement();\n        this.shapesData = null;\n        this.itemsData = null;\n    };\n    function LetterProps(o, sw, sc, fc, m, p) {\n        this.o = o;\n        this.sw = sw;\n        this.sc = sc;\n        this.fc = fc;\n        this.m = m;\n        this.p = p;\n        this._mdf = {\n            o: true,\n            sw: !!sw,\n            sc: !!sc,\n            fc: !!fc,\n            m: true,\n            p: true\n        };\n    }\n    LetterProps.prototype.update = function(o, sw, sc, fc, m, p) {\n        this._mdf.o = false;\n        this._mdf.sw = false;\n        this._mdf.sc = false;\n        this._mdf.fc = false;\n        this._mdf.m = false;\n        this._mdf.p = false;\n        var updated = false;\n        if (this.o !== o) {\n            this.o = o;\n            this._mdf.o = true;\n            updated = true;\n        }\n        if (this.sw !== sw) {\n            this.sw = sw;\n            this._mdf.sw = true;\n            updated = true;\n        }\n        if (this.sc !== sc) {\n            this.sc = sc;\n            this._mdf.sc = true;\n            updated = true;\n        }\n        if (this.fc !== fc) {\n            this.fc = fc;\n            this._mdf.fc = true;\n            updated = true;\n        }\n        if (this.m !== m) {\n            this.m = m;\n            this._mdf.m = true;\n            updated = true;\n        }\n        if (p.length && (this.p[0] !== p[0] || this.p[1] !== p[1] || this.p[4] !== p[4] || this.p[5] !== p[5] || this.p[12] !== p[12] || this.p[13] !== p[13])) {\n            this.p = p;\n            this._mdf.p = true;\n            updated = true;\n        }\n        return updated;\n    };\n    function TextProperty(elem, data) {\n        this._frameId = initialDefaultFrame;\n        this.pv = '';\n        this.v = '';\n        this.kf = false;\n        this._isFirstFrame = true;\n        this._mdf = false;\n        if (data.d && data.d.sid) {\n            data.d = elem.globalData.slotManager.getProp(data.d);\n        }\n        this.data = data;\n        this.elem = elem;\n        this.comp = this.elem.comp;\n        this.keysIndex = 0;\n        this.canResize = false;\n        this.minimumFontSize = 1;\n        this.effectsSequence = [];\n        this.currentData = {\n            ascent: 0,\n            boxWidth: this.defaultBoxWidth,\n            f: '',\n            fStyle: '',\n            fWeight: '',\n            fc: '',\n            j: '',\n            justifyOffset: '',\n            l: [],\n            lh: 0,\n            lineWidths: [],\n            ls: '',\n            of: '',\n            s: '',\n            sc: '',\n            sw: 0,\n            t: 0,\n            tr: 0,\n            sz: 0,\n            ps: null,\n            fillColorAnim: false,\n            strokeColorAnim: false,\n            strokeWidthAnim: false,\n            yOffset: 0,\n            finalSize: 0,\n            finalText: [],\n            finalLineHeight: 0,\n            __complete: false\n        };\n        this.copyData(this.currentData, this.data.d.k[0].s);\n        if (!this.searchProperty()) {\n            this.completeTextData(this.currentData);\n        }\n    }\n    TextProperty.prototype.defaultBoxWidth = [\n        0,\n        0\n    ];\n    TextProperty.prototype.copyData = function(obj, data) {\n        for(var s in data){\n            if (Object.prototype.hasOwnProperty.call(data, s)) {\n                obj[s] = data[s];\n            }\n        }\n        return obj;\n    };\n    TextProperty.prototype.setCurrentData = function(data) {\n        if (!data.__complete) {\n            this.completeTextData(data);\n        }\n        this.currentData = data;\n        this.currentData.boxWidth = this.currentData.boxWidth || this.defaultBoxWidth;\n        this._mdf = true;\n    };\n    TextProperty.prototype.searchProperty = function() {\n        return this.searchKeyframes();\n    };\n    TextProperty.prototype.searchKeyframes = function() {\n        this.kf = this.data.d.k.length > 1;\n        if (this.kf) {\n            this.addEffect(this.getKeyframeValue.bind(this));\n        }\n        return this.kf;\n    };\n    TextProperty.prototype.addEffect = function(effectFunction) {\n        this.effectsSequence.push(effectFunction);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.getValue = function(_finalValue) {\n        if ((this.elem.globalData.frameId === this.frameId || !this.effectsSequence.length) && !_finalValue) {\n            return;\n        }\n        this.currentData.t = this.data.d.k[this.keysIndex].s.t;\n        var currentValue = this.currentData;\n        var currentIndex = this.keysIndex;\n        if (this.lock) {\n            this.setCurrentData(this.currentData);\n            return;\n        }\n        this.lock = true;\n        this._mdf = false;\n        var i;\n        var len = this.effectsSequence.length;\n        var finalValue = _finalValue || this.data.d.k[this.keysIndex].s;\n        for(i = 0; i < len; i += 1){\n            // Checking if index changed to prevent creating a new object every time the expression updates.\n            if (currentIndex !== this.keysIndex) {\n                finalValue = this.effectsSequence[i](finalValue, finalValue.t);\n            } else {\n                finalValue = this.effectsSequence[i](this.currentData, finalValue.t);\n            }\n        }\n        if (currentValue !== finalValue) {\n            this.setCurrentData(finalValue);\n        }\n        this.v = this.currentData;\n        this.pv = this.v;\n        this.lock = false;\n        this.frameId = this.elem.globalData.frameId;\n    };\n    TextProperty.prototype.getKeyframeValue = function() {\n        var textKeys = this.data.d.k;\n        var frameNum = this.elem.comp.renderedFrame;\n        var i = 0;\n        var len = textKeys.length;\n        while(i <= len - 1){\n            if (i === len - 1 || textKeys[i + 1].t > frameNum) {\n                break;\n            }\n            i += 1;\n        }\n        if (this.keysIndex !== i) {\n            this.keysIndex = i;\n        }\n        return this.data.d.k[this.keysIndex].s;\n    };\n    TextProperty.prototype.buildFinalText = function(text) {\n        var charactersArray = [];\n        var i = 0;\n        var len = text.length;\n        var charCode;\n        var secondCharCode;\n        var shouldCombine = false;\n        var shouldCombineNext = false;\n        var currentChars = '';\n        while(i < len){\n            shouldCombine = shouldCombineNext;\n            shouldCombineNext = false;\n            charCode = text.charCodeAt(i);\n            currentChars = text.charAt(i);\n            if (FontManager.isCombinedCharacter(charCode)) {\n                shouldCombine = true;\n            // It's a potential surrogate pair (this is the High surrogate)\n            } else if (charCode >= 0xD800 && charCode <= 0xDBFF) {\n                if (FontManager.isRegionalFlag(text, i)) {\n                    currentChars = text.substr(i, 14);\n                } else {\n                    secondCharCode = text.charCodeAt(i + 1);\n                    // It's a surrogate pair (this is the Low surrogate)\n                    if (secondCharCode >= 0xDC00 && secondCharCode <= 0xDFFF) {\n                        if (FontManager.isModifier(charCode, secondCharCode)) {\n                            currentChars = text.substr(i, 2);\n                            shouldCombine = true;\n                        } else if (FontManager.isFlagEmoji(text.substr(i, 4))) {\n                            currentChars = text.substr(i, 4);\n                        } else {\n                            currentChars = text.substr(i, 2);\n                        }\n                    }\n                }\n            } else if (charCode > 0xDBFF) {\n                secondCharCode = text.charCodeAt(i + 1);\n                if (FontManager.isVariationSelector(charCode)) {\n                    shouldCombine = true;\n                }\n            } else if (FontManager.isZeroWidthJoiner(charCode)) {\n                shouldCombine = true;\n                shouldCombineNext = true;\n            }\n            if (shouldCombine) {\n                charactersArray[charactersArray.length - 1] += currentChars;\n                shouldCombine = false;\n            } else {\n                charactersArray.push(currentChars);\n            }\n            i += currentChars.length;\n        }\n        return charactersArray;\n    };\n    TextProperty.prototype.completeTextData = function(documentData) {\n        documentData.__complete = true;\n        var fontManager = this.elem.globalData.fontManager;\n        var data = this.data;\n        var letters = [];\n        var i;\n        var len;\n        var newLineFlag;\n        var index = 0;\n        var val;\n        var anchorGrouping = data.m.g;\n        var currentSize = 0;\n        var currentPos = 0;\n        var currentLine = 0;\n        var lineWidths = [];\n        var lineWidth = 0;\n        var maxLineWidth = 0;\n        var j;\n        var jLen;\n        var fontData = fontManager.getFontByName(documentData.f);\n        var charData;\n        var cLength = 0;\n        var fontProps = getFontProperties(fontData);\n        documentData.fWeight = fontProps.weight;\n        documentData.fStyle = fontProps.style;\n        documentData.finalSize = documentData.s;\n        documentData.finalText = this.buildFinalText(documentData.t);\n        len = documentData.finalText.length;\n        documentData.finalLineHeight = documentData.lh;\n        var trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n        var charCode;\n        if (documentData.sz) {\n            var flag = true;\n            var boxWidth = documentData.sz[0];\n            var boxHeight = documentData.sz[1];\n            var currentHeight;\n            var finalText;\n            while(flag){\n                finalText = this.buildFinalText(documentData.t);\n                currentHeight = 0;\n                lineWidth = 0;\n                len = finalText.length;\n                trackingOffset = documentData.tr / 1000 * documentData.finalSize;\n                var lastSpaceIndex = -1;\n                for(i = 0; i < len; i += 1){\n                    charCode = finalText[i].charCodeAt(0);\n                    newLineFlag = false;\n                    if (finalText[i] === ' ') {\n                        lastSpaceIndex = i;\n                    } else if (charCode === 13 || charCode === 3) {\n                        lineWidth = 0;\n                        newLineFlag = true;\n                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n                    }\n                    if (fontManager.chars) {\n                        charData = fontManager.getCharData(finalText[i], fontData.fStyle, fontData.fFamily);\n                        cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n                    } else {\n                        // tCanvasHelper.font = documentData.s + 'px '+ fontData.fFamily;\n                        cLength = fontManager.measureText(finalText[i], documentData.f, documentData.finalSize);\n                    }\n                    if (lineWidth + cLength > boxWidth && finalText[i] !== ' ') {\n                        if (lastSpaceIndex === -1) {\n                            len += 1;\n                        } else {\n                            i = lastSpaceIndex;\n                        }\n                        currentHeight += documentData.finalLineHeight || documentData.finalSize * 1.2;\n                        finalText.splice(i, lastSpaceIndex === i ? 1 : 0, '\\r');\n                        // finalText = finalText.substr(0,i) + \"\\r\" + finalText.substr(i === lastSpaceIndex ? i + 1 : i);\n                        lastSpaceIndex = -1;\n                        lineWidth = 0;\n                    } else {\n                        lineWidth += cLength;\n                        lineWidth += trackingOffset;\n                    }\n                }\n                currentHeight += fontData.ascent * documentData.finalSize / 100;\n                if (this.canResize && documentData.finalSize > this.minimumFontSize && boxHeight < currentHeight) {\n                    documentData.finalSize -= 1;\n                    documentData.finalLineHeight = documentData.finalSize * documentData.lh / documentData.s;\n                } else {\n                    documentData.finalText = finalText;\n                    len = documentData.finalText.length;\n                    flag = false;\n                }\n            }\n        }\n        lineWidth = -trackingOffset;\n        cLength = 0;\n        var uncollapsedSpaces = 0;\n        var currentChar;\n        for(i = 0; i < len; i += 1){\n            newLineFlag = false;\n            currentChar = documentData.finalText[i];\n            charCode = currentChar.charCodeAt(0);\n            if (charCode === 13 || charCode === 3) {\n                uncollapsedSpaces = 0;\n                lineWidths.push(lineWidth);\n                maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n                lineWidth = -2 * trackingOffset;\n                val = '';\n                newLineFlag = true;\n                currentLine += 1;\n            } else {\n                val = currentChar;\n            }\n            if (fontManager.chars) {\n                charData = fontManager.getCharData(currentChar, fontData.fStyle, fontManager.getFontByName(documentData.f).fFamily);\n                cLength = newLineFlag ? 0 : charData.w * documentData.finalSize / 100;\n            } else {\n                // var charWidth = fontManager.measureText(val, documentData.f, documentData.finalSize);\n                // tCanvasHelper.font = documentData.finalSize + 'px '+ fontManager.getFontByName(documentData.f).fFamily;\n                cLength = fontManager.measureText(val, documentData.f, documentData.finalSize);\n            }\n            //\n            if (currentChar === ' ') {\n                uncollapsedSpaces += cLength + trackingOffset;\n            } else {\n                lineWidth += cLength + trackingOffset + uncollapsedSpaces;\n                uncollapsedSpaces = 0;\n            }\n            letters.push({\n                l: cLength,\n                an: cLength,\n                add: currentSize,\n                n: newLineFlag,\n                anIndexes: [],\n                val: val,\n                line: currentLine,\n                animatorJustifyOffset: 0\n            });\n            if (anchorGrouping == 2) {\n                // eslint-disable-line eqeqeq\n                currentSize += cLength;\n                if (val === '' || val === ' ' || i === len - 1) {\n                    if (val === '' || val === ' ') {\n                        currentSize -= cLength;\n                    }\n                    while(currentPos <= i){\n                        letters[currentPos].an = currentSize;\n                        letters[currentPos].ind = index;\n                        letters[currentPos].extra = cLength;\n                        currentPos += 1;\n                    }\n                    index += 1;\n                    currentSize = 0;\n                }\n            } else if (anchorGrouping == 3) {\n                // eslint-disable-line eqeqeq\n                currentSize += cLength;\n                if (val === '' || i === len - 1) {\n                    if (val === '') {\n                        currentSize -= cLength;\n                    }\n                    while(currentPos <= i){\n                        letters[currentPos].an = currentSize;\n                        letters[currentPos].ind = index;\n                        letters[currentPos].extra = cLength;\n                        currentPos += 1;\n                    }\n                    currentSize = 0;\n                    index += 1;\n                }\n            } else {\n                letters[index].ind = index;\n                letters[index].extra = 0;\n                index += 1;\n            }\n        }\n        documentData.l = letters;\n        maxLineWidth = lineWidth > maxLineWidth ? lineWidth : maxLineWidth;\n        lineWidths.push(lineWidth);\n        if (documentData.sz) {\n            documentData.boxWidth = documentData.sz[0];\n            documentData.justifyOffset = 0;\n        } else {\n            documentData.boxWidth = maxLineWidth;\n            switch(documentData.j){\n                case 1:\n                    documentData.justifyOffset = -documentData.boxWidth;\n                    break;\n                case 2:\n                    documentData.justifyOffset = -documentData.boxWidth / 2;\n                    break;\n                default:\n                    documentData.justifyOffset = 0;\n            }\n        }\n        documentData.lineWidths = lineWidths;\n        var animators = data.a;\n        var animatorData;\n        var letterData;\n        jLen = animators.length;\n        var based;\n        var ind;\n        var indexes = [];\n        for(j = 0; j < jLen; j += 1){\n            animatorData = animators[j];\n            if (animatorData.a.sc) {\n                documentData.strokeColorAnim = true;\n            }\n            if (animatorData.a.sw) {\n                documentData.strokeWidthAnim = true;\n            }\n            if (animatorData.a.fc || animatorData.a.fh || animatorData.a.fs || animatorData.a.fb) {\n                documentData.fillColorAnim = true;\n            }\n            ind = 0;\n            based = animatorData.s.b;\n            for(i = 0; i < len; i += 1){\n                letterData = letters[i];\n                letterData.anIndexes[j] = ind;\n                if (based == 1 && letterData.val !== '' || based == 2 && letterData.val !== '' && letterData.val !== ' ' || based == 3 && (letterData.n || letterData.val == ' ' || i == len - 1) || based == 4 && (letterData.n || i == len - 1)) {\n                    // eslint-disable-line eqeqeq\n                    if (animatorData.s.rn === 1) {\n                        indexes.push(ind);\n                    }\n                    ind += 1;\n                }\n            }\n            data.a[j].s.totalChars = ind;\n            var currentInd = -1;\n            var newInd;\n            if (animatorData.s.rn === 1) {\n                for(i = 0; i < len; i += 1){\n                    letterData = letters[i];\n                    if (currentInd != letterData.anIndexes[j]) {\n                        // eslint-disable-line eqeqeq\n                        currentInd = letterData.anIndexes[j];\n                        newInd = indexes.splice(Math.floor(Math.random() * indexes.length), 1)[0];\n                    }\n                    letterData.anIndexes[j] = newInd;\n                }\n            }\n        }\n        documentData.yOffset = documentData.finalLineHeight || documentData.finalSize * 1.2;\n        documentData.ls = documentData.ls || 0;\n        documentData.ascent = fontData.ascent * documentData.finalSize / 100;\n    };\n    TextProperty.prototype.updateDocumentData = function(newData, index) {\n        index = index === undefined ? this.keysIndex : index;\n        var dData = this.copyData({}, this.data.d.k[index].s);\n        dData = this.copyData(dData, newData);\n        this.data.d.k[index].s = dData;\n        this.recalculate(index);\n        this.setCurrentData(dData);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.recalculate = function(index) {\n        var dData = this.data.d.k[index].s;\n        dData.__complete = false;\n        this.keysIndex = 0;\n        this._isFirstFrame = true;\n        this.getValue(dData);\n    };\n    TextProperty.prototype.canResizeFont = function(_canResize) {\n        this.canResize = _canResize;\n        this.recalculate(this.keysIndex);\n        this.elem.addDynamicProperty(this);\n    };\n    TextProperty.prototype.setMinimumFontSize = function(_fontValue) {\n        this.minimumFontSize = Math.floor(_fontValue) || 1;\n        this.recalculate(this.keysIndex);\n        this.elem.addDynamicProperty(this);\n    };\n    var TextSelectorProp = function() {\n        var max = Math.max;\n        var min = Math.min;\n        var floor = Math.floor;\n        function TextSelectorPropFactory(elem, data) {\n            this._currentTextLength = -1;\n            this.k = false;\n            this.data = data;\n            this.elem = elem;\n            this.comp = elem.comp;\n            this.finalS = 0;\n            this.finalE = 0;\n            this.initDynamicPropertyContainer(elem);\n            this.s = PropertyFactory.getProp(elem, data.s || {\n                k: 0\n            }, 0, 0, this);\n            if ('e' in data) {\n                this.e = PropertyFactory.getProp(elem, data.e, 0, 0, this);\n            } else {\n                this.e = {\n                    v: 100\n                };\n            }\n            this.o = PropertyFactory.getProp(elem, data.o || {\n                k: 0\n            }, 0, 0, this);\n            this.xe = PropertyFactory.getProp(elem, data.xe || {\n                k: 0\n            }, 0, 0, this);\n            this.ne = PropertyFactory.getProp(elem, data.ne || {\n                k: 0\n            }, 0, 0, this);\n            this.sm = PropertyFactory.getProp(elem, data.sm || {\n                k: 100\n            }, 0, 0, this);\n            this.a = PropertyFactory.getProp(elem, data.a, 0, 0.01, this);\n            if (!this.dynamicProperties.length) {\n                this.getValue();\n            }\n        }\n        TextSelectorPropFactory.prototype = {\n            getMult: function getMult(ind) {\n                if (this._currentTextLength !== this.elem.textProperty.currentData.l.length) {\n                    this.getValue();\n                }\n                var x1 = 0;\n                var y1 = 0;\n                var x2 = 1;\n                var y2 = 1;\n                if (this.ne.v > 0) {\n                    x1 = this.ne.v / 100.0;\n                } else {\n                    y1 = -this.ne.v / 100.0;\n                }\n                if (this.xe.v > 0) {\n                    x2 = 1.0 - this.xe.v / 100.0;\n                } else {\n                    y2 = 1.0 + this.xe.v / 100.0;\n                }\n                var easer = BezierFactory.getBezierEasing(x1, y1, x2, y2).get;\n                var mult = 0;\n                var s = this.finalS;\n                var e = this.finalE;\n                var type = this.data.sh;\n                if (type === 2) {\n                    if (e === s) {\n                        mult = ind >= e ? 1 : 0;\n                    } else {\n                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                    }\n                    mult = easer(mult);\n                } else if (type === 3) {\n                    if (e === s) {\n                        mult = ind >= e ? 0 : 1;\n                    } else {\n                        mult = 1 - max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                    }\n                    mult = easer(mult);\n                } else if (type === 4) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        mult = max(0, min(0.5 / (e - s) + (ind - s) / (e - s), 1));\n                        if (mult < 0.5) {\n                            mult *= 2;\n                        } else {\n                            mult = 1 - 2 * (mult - 0.5);\n                        }\n                    }\n                    mult = easer(mult);\n                } else if (type === 5) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        var tot = e - s;\n                        /* ind += 0.5;\n                      mult = -4/(tot*tot)*(ind*ind)+(4/tot)*ind; */ ind = min(max(0, ind + 0.5 - s), e - s);\n                        var x = -tot / 2 + ind;\n                        var a = tot / 2;\n                        mult = Math.sqrt(1 - x * x / (a * a));\n                    }\n                    mult = easer(mult);\n                } else if (type === 6) {\n                    if (e === s) {\n                        mult = 0;\n                    } else {\n                        ind = min(max(0, ind + 0.5 - s), e - s);\n                        mult = (1 + Math.cos(Math.PI + Math.PI * 2 * ind / (e - s))) / 2; // eslint-disable-line\n                    }\n                    mult = easer(mult);\n                } else {\n                    if (ind >= floor(s)) {\n                        if (ind - s < 0) {\n                            mult = max(0, min(min(e, 1) - (s - ind), 1));\n                        } else {\n                            mult = max(0, min(e - ind, 1));\n                        }\n                    }\n                    mult = easer(mult);\n                }\n                // Smoothness implementation.\n                // The smoothness represents a reduced range of the original [0; 1] range.\n                // if smoothness is 25%, the new range will be [0.375; 0.625]\n                // Steps are:\n                // - find the lower value of the new range (threshold)\n                // - if multiplier is smaller than that value, floor it to 0\n                // - if it is larger,\n                //     - subtract the threshold\n                //     - divide it by the smoothness (this will return the range to [0; 1])\n                // Note: If it doesn't work on some scenarios, consider applying it before the easer.\n                if (this.sm.v !== 100) {\n                    var smoothness = this.sm.v * 0.01;\n                    if (smoothness === 0) {\n                        smoothness = 0.00000001;\n                    }\n                    var threshold = 0.5 - smoothness * 0.5;\n                    if (mult < threshold) {\n                        mult = 0;\n                    } else {\n                        mult = (mult - threshold) / smoothness;\n                        if (mult > 1) {\n                            mult = 1;\n                        }\n                    }\n                }\n                return mult * this.a.v;\n            },\n            getValue: function getValue(newCharsFlag) {\n                this.iterateDynamicProperties();\n                this._mdf = newCharsFlag || this._mdf;\n                this._currentTextLength = this.elem.textProperty.currentData.l.length || 0;\n                if (newCharsFlag && this.data.r === 2) {\n                    this.e.v = this._currentTextLength;\n                }\n                var divisor = this.data.r === 2 ? 1 : 100 / this.data.totalChars;\n                var o = this.o.v / divisor;\n                var s = this.s.v / divisor + o;\n                var e = this.e.v / divisor + o;\n                if (s > e) {\n                    var _s = s;\n                    s = e;\n                    e = _s;\n                }\n                this.finalS = s;\n                this.finalE = e;\n            }\n        };\n        extendPrototype([\n            DynamicPropertyContainer\n        ], TextSelectorPropFactory);\n        function getTextSelectorProp(elem, data, arr) {\n            return new TextSelectorPropFactory(elem, data, arr);\n        }\n        return {\n            getTextSelectorProp: getTextSelectorProp\n        };\n    }();\n    function TextAnimatorDataProperty(elem, animatorProps, container) {\n        var defaultData = {\n            propType: false\n        };\n        var getProp = PropertyFactory.getProp;\n        var textAnimatorAnimatables = animatorProps.a;\n        this.a = {\n            r: textAnimatorAnimatables.r ? getProp(elem, textAnimatorAnimatables.r, 0, degToRads, container) : defaultData,\n            rx: textAnimatorAnimatables.rx ? getProp(elem, textAnimatorAnimatables.rx, 0, degToRads, container) : defaultData,\n            ry: textAnimatorAnimatables.ry ? getProp(elem, textAnimatorAnimatables.ry, 0, degToRads, container) : defaultData,\n            sk: textAnimatorAnimatables.sk ? getProp(elem, textAnimatorAnimatables.sk, 0, degToRads, container) : defaultData,\n            sa: textAnimatorAnimatables.sa ? getProp(elem, textAnimatorAnimatables.sa, 0, degToRads, container) : defaultData,\n            s: textAnimatorAnimatables.s ? getProp(elem, textAnimatorAnimatables.s, 1, 0.01, container) : defaultData,\n            a: textAnimatorAnimatables.a ? getProp(elem, textAnimatorAnimatables.a, 1, 0, container) : defaultData,\n            o: textAnimatorAnimatables.o ? getProp(elem, textAnimatorAnimatables.o, 0, 0.01, container) : defaultData,\n            p: textAnimatorAnimatables.p ? getProp(elem, textAnimatorAnimatables.p, 1, 0, container) : defaultData,\n            sw: textAnimatorAnimatables.sw ? getProp(elem, textAnimatorAnimatables.sw, 0, 0, container) : defaultData,\n            sc: textAnimatorAnimatables.sc ? getProp(elem, textAnimatorAnimatables.sc, 1, 0, container) : defaultData,\n            fc: textAnimatorAnimatables.fc ? getProp(elem, textAnimatorAnimatables.fc, 1, 0, container) : defaultData,\n            fh: textAnimatorAnimatables.fh ? getProp(elem, textAnimatorAnimatables.fh, 0, 0, container) : defaultData,\n            fs: textAnimatorAnimatables.fs ? getProp(elem, textAnimatorAnimatables.fs, 0, 0.01, container) : defaultData,\n            fb: textAnimatorAnimatables.fb ? getProp(elem, textAnimatorAnimatables.fb, 0, 0.01, container) : defaultData,\n            t: textAnimatorAnimatables.t ? getProp(elem, textAnimatorAnimatables.t, 0, 0, container) : defaultData\n        };\n        this.s = TextSelectorProp.getTextSelectorProp(elem, animatorProps.s, container);\n        this.s.t = animatorProps.s.t;\n    }\n    function TextAnimatorProperty(textData, renderType, elem) {\n        this._isFirstFrame = true;\n        this._hasMaskedPath = false;\n        this._frameId = -1;\n        this._textData = textData;\n        this._renderType = renderType;\n        this._elem = elem;\n        this._animatorsData = createSizedArray(this._textData.a.length);\n        this._pathData = {};\n        this._moreOptions = {\n            alignment: {}\n        };\n        this.renderedLetters = [];\n        this.lettersChangedFlag = false;\n        this.initDynamicPropertyContainer(elem);\n    }\n    TextAnimatorProperty.prototype.searchProperties = function() {\n        var i;\n        var len = this._textData.a.length;\n        var animatorProps;\n        var getProp = PropertyFactory.getProp;\n        for(i = 0; i < len; i += 1){\n            animatorProps = this._textData.a[i];\n            this._animatorsData[i] = new TextAnimatorDataProperty(this._elem, animatorProps, this);\n        }\n        if (this._textData.p && 'm' in this._textData.p) {\n            this._pathData = {\n                a: getProp(this._elem, this._textData.p.a, 0, 0, this),\n                f: getProp(this._elem, this._textData.p.f, 0, 0, this),\n                l: getProp(this._elem, this._textData.p.l, 0, 0, this),\n                r: getProp(this._elem, this._textData.p.r, 0, 0, this),\n                p: getProp(this._elem, this._textData.p.p, 0, 0, this),\n                m: this._elem.maskManager.getMaskProperty(this._textData.p.m)\n            };\n            this._hasMaskedPath = true;\n        } else {\n            this._hasMaskedPath = false;\n        }\n        this._moreOptions.alignment = getProp(this._elem, this._textData.m.a, 1, 0, this);\n    };\n    TextAnimatorProperty.prototype.getMeasures = function(documentData, lettersChangedFlag) {\n        this.lettersChangedFlag = lettersChangedFlag;\n        if (!this._mdf && !this._isFirstFrame && !lettersChangedFlag && (!this._hasMaskedPath || !this._pathData.m._mdf)) {\n            return;\n        }\n        this._isFirstFrame = false;\n        var alignment = this._moreOptions.alignment.v;\n        var animators = this._animatorsData;\n        var textData = this._textData;\n        var matrixHelper = this.mHelper;\n        var renderType = this._renderType;\n        var renderedLettersCount = this.renderedLetters.length;\n        var xPos;\n        var yPos;\n        var i;\n        var len;\n        var letters = documentData.l;\n        var pathInfo;\n        var currentLength;\n        var currentPoint;\n        var segmentLength;\n        var flag;\n        var pointInd;\n        var segmentInd;\n        var prevPoint;\n        var points;\n        var segments;\n        var partialLength;\n        var totalLength;\n        var perc;\n        var tanAngle;\n        var mask;\n        if (this._hasMaskedPath) {\n            mask = this._pathData.m;\n            if (!this._pathData.n || this._pathData._mdf) {\n                var paths = mask.v;\n                if (this._pathData.r.v) {\n                    paths = paths.reverse();\n                }\n                // TODO: release bezier data cached from previous pathInfo: this._pathData.pi\n                pathInfo = {\n                    tLength: 0,\n                    segments: []\n                };\n                len = paths._length - 1;\n                var bezierData;\n                totalLength = 0;\n                for(i = 0; i < len; i += 1){\n                    bezierData = bez.buildBezierData(paths.v[i], paths.v[i + 1], [\n                        paths.o[i][0] - paths.v[i][0],\n                        paths.o[i][1] - paths.v[i][1]\n                    ], [\n                        paths.i[i + 1][0] - paths.v[i + 1][0],\n                        paths.i[i + 1][1] - paths.v[i + 1][1]\n                    ]);\n                    pathInfo.tLength += bezierData.segmentLength;\n                    pathInfo.segments.push(bezierData);\n                    totalLength += bezierData.segmentLength;\n                }\n                i = len;\n                if (mask.v.c) {\n                    bezierData = bez.buildBezierData(paths.v[i], paths.v[0], [\n                        paths.o[i][0] - paths.v[i][0],\n                        paths.o[i][1] - paths.v[i][1]\n                    ], [\n                        paths.i[0][0] - paths.v[0][0],\n                        paths.i[0][1] - paths.v[0][1]\n                    ]);\n                    pathInfo.tLength += bezierData.segmentLength;\n                    pathInfo.segments.push(bezierData);\n                    totalLength += bezierData.segmentLength;\n                }\n                this._pathData.pi = pathInfo;\n            }\n            pathInfo = this._pathData.pi;\n            currentLength = this._pathData.f.v;\n            segmentInd = 0;\n            pointInd = 1;\n            segmentLength = 0;\n            flag = true;\n            segments = pathInfo.segments;\n            if (currentLength < 0 && mask.v.c) {\n                if (pathInfo.tLength < Math.abs(currentLength)) {\n                    currentLength = -Math.abs(currentLength) % pathInfo.tLength;\n                }\n                segmentInd = segments.length - 1;\n                points = segments[segmentInd].points;\n                pointInd = points.length - 1;\n                while(currentLength < 0){\n                    currentLength += points[pointInd].partialLength;\n                    pointInd -= 1;\n                    if (pointInd < 0) {\n                        segmentInd -= 1;\n                        points = segments[segmentInd].points;\n                        pointInd = points.length - 1;\n                    }\n                }\n            }\n            points = segments[segmentInd].points;\n            prevPoint = points[pointInd - 1];\n            currentPoint = points[pointInd];\n            partialLength = currentPoint.partialLength;\n        }\n        len = letters.length;\n        xPos = 0;\n        yPos = 0;\n        var yOff = documentData.finalSize * 1.2 * 0.714;\n        var firstLine = true;\n        var animatorProps;\n        var animatorSelector;\n        var j;\n        var jLen;\n        var letterValue;\n        jLen = animators.length;\n        var mult;\n        var ind = -1;\n        var offf;\n        var xPathPos;\n        var yPathPos;\n        var initPathPos = currentLength;\n        var initSegmentInd = segmentInd;\n        var initPointInd = pointInd;\n        var currentLine = -1;\n        var elemOpacity;\n        var sc;\n        var sw;\n        var fc;\n        var k;\n        var letterSw;\n        var letterSc;\n        var letterFc;\n        var letterM = '';\n        var letterP = this.defaultPropsArray;\n        var letterO;\n        //\n        if (documentData.j === 2 || documentData.j === 1) {\n            var animatorJustifyOffset = 0;\n            var animatorFirstCharOffset = 0;\n            var justifyOffsetMult = documentData.j === 2 ? -0.5 : -1;\n            var lastIndex = 0;\n            var isNewLine = true;\n            for(i = 0; i < len; i += 1){\n                if (letters[i].n) {\n                    if (animatorJustifyOffset) {\n                        animatorJustifyOffset += animatorFirstCharOffset;\n                    }\n                    while(lastIndex < i){\n                        letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n                        lastIndex += 1;\n                    }\n                    animatorJustifyOffset = 0;\n                    isNewLine = true;\n                } else {\n                    for(j = 0; j < jLen; j += 1){\n                        animatorProps = animators[j].a;\n                        if (animatorProps.t.propType) {\n                            if (isNewLine && documentData.j === 2) {\n                                animatorFirstCharOffset += animatorProps.t.v * justifyOffsetMult;\n                            }\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorJustifyOffset += animatorProps.t.v * mult[0] * justifyOffsetMult;\n                            } else {\n                                animatorJustifyOffset += animatorProps.t.v * mult * justifyOffsetMult;\n                            }\n                        }\n                    }\n                    isNewLine = false;\n                }\n            }\n            if (animatorJustifyOffset) {\n                animatorJustifyOffset += animatorFirstCharOffset;\n            }\n            while(lastIndex < i){\n                letters[lastIndex].animatorJustifyOffset = animatorJustifyOffset;\n                lastIndex += 1;\n            }\n        }\n        //\n        for(i = 0; i < len; i += 1){\n            matrixHelper.reset();\n            elemOpacity = 1;\n            if (letters[i].n) {\n                xPos = 0;\n                yPos += documentData.yOffset;\n                yPos += firstLine ? 1 : 0;\n                currentLength = initPathPos;\n                firstLine = false;\n                if (this._hasMaskedPath) {\n                    segmentInd = initSegmentInd;\n                    pointInd = initPointInd;\n                    points = segments[segmentInd].points;\n                    prevPoint = points[pointInd - 1];\n                    currentPoint = points[pointInd];\n                    partialLength = currentPoint.partialLength;\n                    segmentLength = 0;\n                }\n                letterM = '';\n                letterFc = '';\n                letterSw = '';\n                letterO = '';\n                letterP = this.defaultPropsArray;\n            } else {\n                if (this._hasMaskedPath) {\n                    if (currentLine !== letters[i].line) {\n                        switch(documentData.j){\n                            case 1:\n                                currentLength += totalLength - documentData.lineWidths[letters[i].line];\n                                break;\n                            case 2:\n                                currentLength += (totalLength - documentData.lineWidths[letters[i].line]) / 2;\n                                break;\n                            default:\n                                break;\n                        }\n                        currentLine = letters[i].line;\n                    }\n                    if (ind !== letters[i].ind) {\n                        if (letters[ind]) {\n                            currentLength += letters[ind].extra;\n                        }\n                        currentLength += letters[i].an / 2;\n                        ind = letters[i].ind;\n                    }\n                    currentLength += alignment[0] * letters[i].an * 0.005;\n                    var animatorOffset = 0;\n                    for(j = 0; j < jLen; j += 1){\n                        animatorProps = animators[j].a;\n                        if (animatorProps.p.propType) {\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorOffset += animatorProps.p.v[0] * mult[0];\n                            } else {\n                                animatorOffset += animatorProps.p.v[0] * mult;\n                            }\n                        }\n                        if (animatorProps.a.propType) {\n                            animatorSelector = animators[j].s;\n                            mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                            if (mult.length) {\n                                animatorOffset += animatorProps.a.v[0] * mult[0];\n                            } else {\n                                animatorOffset += animatorProps.a.v[0] * mult;\n                            }\n                        }\n                    }\n                    flag = true;\n                    // Force alignment only works with a single line for now\n                    if (this._pathData.a.v) {\n                        currentLength = letters[0].an * 0.5 + (totalLength - this._pathData.f.v - letters[0].an * 0.5 - letters[letters.length - 1].an * 0.5) * ind / (len - 1);\n                        currentLength += this._pathData.f.v;\n                    }\n                    while(flag){\n                        if (segmentLength + partialLength >= currentLength + animatorOffset || !points) {\n                            perc = (currentLength + animatorOffset - segmentLength) / currentPoint.partialLength;\n                            xPathPos = prevPoint.point[0] + (currentPoint.point[0] - prevPoint.point[0]) * perc;\n                            yPathPos = prevPoint.point[1] + (currentPoint.point[1] - prevPoint.point[1]) * perc;\n                            matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -(alignment[1] * yOff) * 0.01);\n                            flag = false;\n                        } else if (points) {\n                            segmentLength += currentPoint.partialLength;\n                            pointInd += 1;\n                            if (pointInd >= points.length) {\n                                pointInd = 0;\n                                segmentInd += 1;\n                                if (!segments[segmentInd]) {\n                                    if (mask.v.c) {\n                                        pointInd = 0;\n                                        segmentInd = 0;\n                                        points = segments[segmentInd].points;\n                                    } else {\n                                        segmentLength -= currentPoint.partialLength;\n                                        points = null;\n                                    }\n                                } else {\n                                    points = segments[segmentInd].points;\n                                }\n                            }\n                            if (points) {\n                                prevPoint = currentPoint;\n                                currentPoint = points[pointInd];\n                                partialLength = currentPoint.partialLength;\n                            }\n                        }\n                    }\n                    offf = letters[i].an / 2 - letters[i].add;\n                    matrixHelper.translate(-offf, 0, 0);\n                } else {\n                    offf = letters[i].an / 2 - letters[i].add;\n                    matrixHelper.translate(-offf, 0, 0);\n                    // Grouping alignment\n                    matrixHelper.translate(-alignment[0] * letters[i].an * 0.005, -alignment[1] * yOff * 0.01, 0);\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.t.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        // This condition is to prevent applying tracking to first character in each line. Might be better to use a boolean \"isNewLine\"\n                        if (xPos !== 0 || documentData.j !== 0) {\n                            if (this._hasMaskedPath) {\n                                if (mult.length) {\n                                    currentLength += animatorProps.t.v * mult[0];\n                                } else {\n                                    currentLength += animatorProps.t.v * mult;\n                                }\n                            } else if (mult.length) {\n                                xPos += animatorProps.t.v * mult[0];\n                            } else {\n                                xPos += animatorProps.t.v * mult;\n                            }\n                        }\n                    }\n                }\n                if (documentData.strokeWidthAnim) {\n                    sw = documentData.sw || 0;\n                }\n                if (documentData.strokeColorAnim) {\n                    if (documentData.sc) {\n                        sc = [\n                            documentData.sc[0],\n                            documentData.sc[1],\n                            documentData.sc[2]\n                        ];\n                    } else {\n                        sc = [\n                            0,\n                            0,\n                            0\n                        ];\n                    }\n                }\n                if (documentData.fillColorAnim && documentData.fc) {\n                    fc = [\n                        documentData.fc[0],\n                        documentData.fc[1],\n                        documentData.fc[2]\n                    ];\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.a.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (mult.length) {\n                            matrixHelper.translate(-animatorProps.a.v[0] * mult[0], -animatorProps.a.v[1] * mult[1], animatorProps.a.v[2] * mult[2]);\n                        } else {\n                            matrixHelper.translate(-animatorProps.a.v[0] * mult, -animatorProps.a.v[1] * mult, animatorProps.a.v[2] * mult);\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.s.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (mult.length) {\n                            matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult[0], 1 + (animatorProps.s.v[1] - 1) * mult[1], 1);\n                        } else {\n                            matrixHelper.scale(1 + (animatorProps.s.v[0] - 1) * mult, 1 + (animatorProps.s.v[1] - 1) * mult, 1);\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    animatorSelector = animators[j].s;\n                    mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                    if (animatorProps.sk.propType) {\n                        if (mult.length) {\n                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult[0], animatorProps.sa.v * mult[1]);\n                        } else {\n                            matrixHelper.skewFromAxis(-animatorProps.sk.v * mult, animatorProps.sa.v * mult);\n                        }\n                    }\n                    if (animatorProps.r.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateZ(-animatorProps.r.v * mult[2]);\n                        } else {\n                            matrixHelper.rotateZ(-animatorProps.r.v * mult);\n                        }\n                    }\n                    if (animatorProps.ry.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateY(animatorProps.ry.v * mult[1]);\n                        } else {\n                            matrixHelper.rotateY(animatorProps.ry.v * mult);\n                        }\n                    }\n                    if (animatorProps.rx.propType) {\n                        if (mult.length) {\n                            matrixHelper.rotateX(animatorProps.rx.v * mult[0]);\n                        } else {\n                            matrixHelper.rotateX(animatorProps.rx.v * mult);\n                        }\n                    }\n                    if (animatorProps.o.propType) {\n                        if (mult.length) {\n                            elemOpacity += (animatorProps.o.v * mult[0] - elemOpacity) * mult[0];\n                        } else {\n                            elemOpacity += (animatorProps.o.v * mult - elemOpacity) * mult;\n                        }\n                    }\n                    if (documentData.strokeWidthAnim && animatorProps.sw.propType) {\n                        if (mult.length) {\n                            sw += animatorProps.sw.v * mult[0];\n                        } else {\n                            sw += animatorProps.sw.v * mult;\n                        }\n                    }\n                    if (documentData.strokeColorAnim && animatorProps.sc.propType) {\n                        for(k = 0; k < 3; k += 1){\n                            if (mult.length) {\n                                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult[0];\n                            } else {\n                                sc[k] += (animatorProps.sc.v[k] - sc[k]) * mult;\n                            }\n                        }\n                    }\n                    if (documentData.fillColorAnim && documentData.fc) {\n                        if (animatorProps.fc.propType) {\n                            for(k = 0; k < 3; k += 1){\n                                if (mult.length) {\n                                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult[0];\n                                } else {\n                                    fc[k] += (animatorProps.fc.v[k] - fc[k]) * mult;\n                                }\n                            }\n                        }\n                        if (animatorProps.fh.propType) {\n                            if (mult.length) {\n                                fc = addHueToRGB(fc, animatorProps.fh.v * mult[0]);\n                            } else {\n                                fc = addHueToRGB(fc, animatorProps.fh.v * mult);\n                            }\n                        }\n                        if (animatorProps.fs.propType) {\n                            if (mult.length) {\n                                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult[0]);\n                            } else {\n                                fc = addSaturationToRGB(fc, animatorProps.fs.v * mult);\n                            }\n                        }\n                        if (animatorProps.fb.propType) {\n                            if (mult.length) {\n                                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult[0]);\n                            } else {\n                                fc = addBrightnessToRGB(fc, animatorProps.fb.v * mult);\n                            }\n                        }\n                    }\n                }\n                for(j = 0; j < jLen; j += 1){\n                    animatorProps = animators[j].a;\n                    if (animatorProps.p.propType) {\n                        animatorSelector = animators[j].s;\n                        mult = animatorSelector.getMult(letters[i].anIndexes[j], textData.a[j].s.totalChars);\n                        if (this._hasMaskedPath) {\n                            if (mult.length) {\n                                matrixHelper.translate(0, animatorProps.p.v[1] * mult[0], -animatorProps.p.v[2] * mult[1]);\n                            } else {\n                                matrixHelper.translate(0, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n                            }\n                        } else if (mult.length) {\n                            matrixHelper.translate(animatorProps.p.v[0] * mult[0], animatorProps.p.v[1] * mult[1], -animatorProps.p.v[2] * mult[2]);\n                        } else {\n                            matrixHelper.translate(animatorProps.p.v[0] * mult, animatorProps.p.v[1] * mult, -animatorProps.p.v[2] * mult);\n                        }\n                    }\n                }\n                if (documentData.strokeWidthAnim) {\n                    letterSw = sw < 0 ? 0 : sw;\n                }\n                if (documentData.strokeColorAnim) {\n                    letterSc = 'rgb(' + Math.round(sc[0] * 255) + ',' + Math.round(sc[1] * 255) + ',' + Math.round(sc[2] * 255) + ')';\n                }\n                if (documentData.fillColorAnim && documentData.fc) {\n                    letterFc = 'rgb(' + Math.round(fc[0] * 255) + ',' + Math.round(fc[1] * 255) + ',' + Math.round(fc[2] * 255) + ')';\n                }\n                if (this._hasMaskedPath) {\n                    matrixHelper.translate(0, -documentData.ls);\n                    matrixHelper.translate(0, alignment[1] * yOff * 0.01 + yPos, 0);\n                    if (this._pathData.p.v) {\n                        tanAngle = (currentPoint.point[1] - prevPoint.point[1]) / (currentPoint.point[0] - prevPoint.point[0]);\n                        var rot = Math.atan(tanAngle) * 180 / Math.PI;\n                        if (currentPoint.point[0] < prevPoint.point[0]) {\n                            rot += 180;\n                        }\n                        matrixHelper.rotate(-rot * Math.PI / 180);\n                    }\n                    matrixHelper.translate(xPathPos, yPathPos, 0);\n                    currentLength -= alignment[0] * letters[i].an * 0.005;\n                    if (letters[i + 1] && ind !== letters[i + 1].ind) {\n                        currentLength += letters[i].an / 2;\n                        currentLength += documentData.tr * 0.001 * documentData.finalSize;\n                    }\n                } else {\n                    matrixHelper.translate(xPos, yPos, 0);\n                    if (documentData.ps) {\n                        // matrixHelper.translate(documentData.ps[0],documentData.ps[1],0);\n                        matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n                    }\n                    switch(documentData.j){\n                        case 1:\n                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]), 0, 0);\n                            break;\n                        case 2:\n                            matrixHelper.translate(letters[i].animatorJustifyOffset + documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[letters[i].line]) / 2, 0, 0);\n                            break;\n                        default:\n                            break;\n                    }\n                    matrixHelper.translate(0, -documentData.ls);\n                    matrixHelper.translate(offf, 0, 0);\n                    matrixHelper.translate(alignment[0] * letters[i].an * 0.005, alignment[1] * yOff * 0.01, 0);\n                    xPos += letters[i].l + documentData.tr * 0.001 * documentData.finalSize;\n                }\n                if (renderType === 'html') {\n                    letterM = matrixHelper.toCSS();\n                } else if (renderType === 'svg') {\n                    letterM = matrixHelper.to2dCSS();\n                } else {\n                    letterP = [\n                        matrixHelper.props[0],\n                        matrixHelper.props[1],\n                        matrixHelper.props[2],\n                        matrixHelper.props[3],\n                        matrixHelper.props[4],\n                        matrixHelper.props[5],\n                        matrixHelper.props[6],\n                        matrixHelper.props[7],\n                        matrixHelper.props[8],\n                        matrixHelper.props[9],\n                        matrixHelper.props[10],\n                        matrixHelper.props[11],\n                        matrixHelper.props[12],\n                        matrixHelper.props[13],\n                        matrixHelper.props[14],\n                        matrixHelper.props[15]\n                    ];\n                }\n                letterO = elemOpacity;\n            }\n            if (renderedLettersCount <= i) {\n                letterValue = new LetterProps(letterO, letterSw, letterSc, letterFc, letterM, letterP);\n                this.renderedLetters.push(letterValue);\n                renderedLettersCount += 1;\n                this.lettersChangedFlag = true;\n            } else {\n                letterValue = this.renderedLetters[i];\n                this.lettersChangedFlag = letterValue.update(letterO, letterSw, letterSc, letterFc, letterM, letterP) || this.lettersChangedFlag;\n            }\n        }\n    };\n    TextAnimatorProperty.prototype.getValue = function() {\n        if (this._elem.globalData.frameId === this._frameId) {\n            return;\n        }\n        this._frameId = this._elem.globalData.frameId;\n        this.iterateDynamicProperties();\n    };\n    TextAnimatorProperty.prototype.mHelper = new Matrix();\n    TextAnimatorProperty.prototype.defaultPropsArray = [];\n    extendPrototype([\n        DynamicPropertyContainer\n    ], TextAnimatorProperty);\n    function ITextElement() {}\n    ITextElement.prototype.initElement = function(data, globalData, comp) {\n        this.lettersChangedFlag = true;\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.textProperty = new TextProperty(this, data.t, this.dynamicProperties);\n        this.textAnimator = new TextAnimatorProperty(data.t, this.renderType, this);\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n        this.initRenderable();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        this.createContent();\n        this.hide();\n        this.textAnimator.searchProperties(this.dynamicProperties);\n    };\n    ITextElement.prototype.prepareFrame = function(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n    };\n    ITextElement.prototype.createPathShape = function(matrixHelper, shapes) {\n        var j;\n        var jLen = shapes.length;\n        var pathNodes;\n        var shapeStr = '';\n        for(j = 0; j < jLen; j += 1){\n            if (shapes[j].ty === 'sh') {\n                pathNodes = shapes[j].ks.k;\n                shapeStr += buildShapeString(pathNodes, pathNodes.i.length, true, matrixHelper);\n            }\n        }\n        return shapeStr;\n    };\n    ITextElement.prototype.updateDocumentData = function(newData, index) {\n        this.textProperty.updateDocumentData(newData, index);\n    };\n    ITextElement.prototype.canResizeFont = function(_canResize) {\n        this.textProperty.canResizeFont(_canResize);\n    };\n    ITextElement.prototype.setMinimumFontSize = function(_fontSize) {\n        this.textProperty.setMinimumFontSize(_fontSize);\n    };\n    ITextElement.prototype.applyTextPropertiesToMatrix = function(documentData, matrixHelper, lineNumber, xPos, yPos) {\n        if (documentData.ps) {\n            matrixHelper.translate(documentData.ps[0], documentData.ps[1] + documentData.ascent, 0);\n        }\n        matrixHelper.translate(0, -documentData.ls, 0);\n        switch(documentData.j){\n            case 1:\n                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]), 0, 0);\n                break;\n            case 2:\n                matrixHelper.translate(documentData.justifyOffset + (documentData.boxWidth - documentData.lineWidths[lineNumber]) / 2, 0, 0);\n                break;\n            default:\n                break;\n        }\n        matrixHelper.translate(xPos, yPos, 0);\n    };\n    ITextElement.prototype.buildColor = function(colorData) {\n        return 'rgb(' + Math.round(colorData[0] * 255) + ',' + Math.round(colorData[1] * 255) + ',' + Math.round(colorData[2] * 255) + ')';\n    };\n    ITextElement.prototype.emptyProp = new LetterProps();\n    ITextElement.prototype.destroy = function() {};\n    ITextElement.prototype.validateText = function() {\n        if (this.textProperty._mdf || this.textProperty._isFirstFrame) {\n            this.buildNewText();\n            this.textProperty._isFirstFrame = false;\n            this.textProperty._mdf = false;\n        }\n    };\n    var emptyShapeData = {\n        shapes: []\n    };\n    function SVGTextLottieElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.renderType = 'svg';\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        SVGBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement,\n        ITextElement\n    ], SVGTextLottieElement);\n    SVGTextLottieElement.prototype.createContent = function() {\n        if (this.data.singleShape && !this.globalData.fontManager.chars) {\n            this.textContainer = createNS('text');\n        }\n    };\n    SVGTextLottieElement.prototype.buildTextContents = function(textArray) {\n        var i = 0;\n        var len = textArray.length;\n        var textContents = [];\n        var currentTextContent = '';\n        while(i < len){\n            if (textArray[i] === String.fromCharCode(13) || textArray[i] === String.fromCharCode(3)) {\n                textContents.push(currentTextContent);\n                currentTextContent = '';\n            } else {\n                currentTextContent += textArray[i];\n            }\n            i += 1;\n        }\n        textContents.push(currentTextContent);\n        return textContents;\n    };\n    SVGTextLottieElement.prototype.buildShapeData = function(data, scale) {\n        // data should probably be cloned to apply scale separately to each instance of a text on different layers\n        // but since text internal content gets only rendered once and then it's never rerendered,\n        // it's probably safe not to clone data and reuse always the same instance even if the object is mutated.\n        // Avoiding cloning is preferred since cloning each character shape data is expensive\n        if (data.shapes && data.shapes.length) {\n            var shape = data.shapes[0];\n            if (shape.it) {\n                var shapeItem = shape.it[shape.it.length - 1];\n                if (shapeItem.s) {\n                    shapeItem.s.k[0] = scale;\n                    shapeItem.s.k[1] = scale;\n                }\n            }\n        }\n        return data;\n    };\n    SVGTextLottieElement.prototype.buildNewText = function() {\n        this.addDynamicProperty(this);\n        var i;\n        var len;\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData ? documentData.l.length : 0);\n        if (documentData.fc) {\n            this.layerElement.setAttribute('fill', this.buildColor(documentData.fc));\n        } else {\n            this.layerElement.setAttribute('fill', 'rgba(0,0,0,0)');\n        }\n        if (documentData.sc) {\n            this.layerElement.setAttribute('stroke', this.buildColor(documentData.sc));\n            this.layerElement.setAttribute('stroke-width', documentData.sw);\n        }\n        this.layerElement.setAttribute('font-size', documentData.finalSize);\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        if (fontData.fClass) {\n            this.layerElement.setAttribute('class', fontData.fClass);\n        } else {\n            this.layerElement.setAttribute('font-family', fontData.fFamily);\n            var fWeight = documentData.fWeight;\n            var fStyle = documentData.fStyle;\n            this.layerElement.setAttribute('font-style', fStyle);\n            this.layerElement.setAttribute('font-weight', fWeight);\n        }\n        this.layerElement.setAttribute('aria-label', documentData.t);\n        var letters = documentData.l || [];\n        var usesGlyphs = !!this.globalData.fontManager.chars;\n        len = letters.length;\n        var tSpan;\n        var matrixHelper = this.mHelper;\n        var shapeStr = '';\n        var singleShape = this.data.singleShape;\n        var xPos = 0;\n        var yPos = 0;\n        var firstLine = true;\n        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n        if (singleShape && !usesGlyphs && !documentData.sz) {\n            var tElement = this.textContainer;\n            var justify = 'start';\n            switch(documentData.j){\n                case 1:\n                    justify = 'end';\n                    break;\n                case 2:\n                    justify = 'middle';\n                    break;\n                default:\n                    justify = 'start';\n                    break;\n            }\n            tElement.setAttribute('text-anchor', justify);\n            tElement.setAttribute('letter-spacing', trackingOffset);\n            var textContent = this.buildTextContents(documentData.finalText);\n            len = textContent.length;\n            yPos = documentData.ps ? documentData.ps[1] + documentData.ascent : 0;\n            for(i = 0; i < len; i += 1){\n                tSpan = this.textSpans[i].span || createNS('tspan');\n                tSpan.textContent = textContent[i];\n                tSpan.setAttribute('x', 0);\n                tSpan.setAttribute('y', yPos);\n                tSpan.style.display = 'inherit';\n                tElement.appendChild(tSpan);\n                if (!this.textSpans[i]) {\n                    this.textSpans[i] = {\n                        span: null,\n                        glyph: null\n                    };\n                }\n                this.textSpans[i].span = tSpan;\n                yPos += documentData.finalLineHeight;\n            }\n            this.layerElement.appendChild(tElement);\n        } else {\n            var cachedSpansLength = this.textSpans.length;\n            var charData;\n            for(i = 0; i < len; i += 1){\n                if (!this.textSpans[i]) {\n                    this.textSpans[i] = {\n                        span: null,\n                        childSpan: null,\n                        glyph: null\n                    };\n                }\n                if (!usesGlyphs || !singleShape || i === 0) {\n                    tSpan = cachedSpansLength > i ? this.textSpans[i].span : createNS(usesGlyphs ? 'g' : 'text');\n                    if (cachedSpansLength <= i) {\n                        tSpan.setAttribute('stroke-linecap', 'butt');\n                        tSpan.setAttribute('stroke-linejoin', 'round');\n                        tSpan.setAttribute('stroke-miterlimit', '4');\n                        this.textSpans[i].span = tSpan;\n                        if (usesGlyphs) {\n                            var childSpan = createNS('g');\n                            tSpan.appendChild(childSpan);\n                            this.textSpans[i].childSpan = childSpan;\n                        }\n                        this.textSpans[i].span = tSpan;\n                        this.layerElement.appendChild(tSpan);\n                    }\n                    tSpan.style.display = 'inherit';\n                }\n                matrixHelper.reset();\n                if (singleShape) {\n                    if (letters[i].n) {\n                        xPos = -trackingOffset;\n                        yPos += documentData.yOffset;\n                        yPos += firstLine ? 1 : 0;\n                        firstLine = false;\n                    }\n                    this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n                    xPos += letters[i].l || 0;\n                    // xPos += letters[i].val === ' ' ? 0 : trackingOffset;\n                    xPos += trackingOffset;\n                }\n                if (usesGlyphs) {\n                    charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n                    var glyphElement;\n                    // t === 1 means the character has been replaced with an animated shaped\n                    if (charData.t === 1) {\n                        glyphElement = new SVGCompElement(charData.data, this.globalData, this);\n                    } else {\n                        var data = emptyShapeData;\n                        if (charData.data && charData.data.shapes) {\n                            data = this.buildShapeData(charData.data, documentData.finalSize);\n                        }\n                        glyphElement = new SVGShapeElement(data, this.globalData, this);\n                    }\n                    if (this.textSpans[i].glyph) {\n                        var glyph = this.textSpans[i].glyph;\n                        this.textSpans[i].childSpan.removeChild(glyph.layerElement);\n                        glyph.destroy();\n                    }\n                    this.textSpans[i].glyph = glyphElement;\n                    glyphElement._debug = true;\n                    glyphElement.prepareFrame(0);\n                    glyphElement.renderFrame();\n                    this.textSpans[i].childSpan.appendChild(glyphElement.layerElement);\n                    // when using animated shapes, the layer will be scaled instead of replacing the internal scale\n                    // this might have issues with strokes and might need a different solution\n                    if (charData.t === 1) {\n                        this.textSpans[i].childSpan.setAttribute('transform', 'scale(' + documentData.finalSize / 100 + ',' + documentData.finalSize / 100 + ')');\n                    }\n                } else {\n                    if (singleShape) {\n                        tSpan.setAttribute('transform', 'translate(' + matrixHelper.props[12] + ',' + matrixHelper.props[13] + ')');\n                    }\n                    tSpan.textContent = letters[i].val;\n                    tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n                }\n            //\n            }\n            if (singleShape && tSpan) {\n                tSpan.setAttribute('d', shapeStr);\n            }\n        }\n        while(i < this.textSpans.length){\n            this.textSpans[i].span.style.display = 'none';\n            i += 1;\n        }\n        this._sizeChanged = true;\n    };\n    SVGTextLottieElement.prototype.sourceRectAtTime = function() {\n        this.prepareFrame(this.comp.renderedFrame - this.data.st);\n        this.renderInnerContent();\n        if (this._sizeChanged) {\n            this._sizeChanged = false;\n            var textBox = this.layerElement.getBBox();\n            this.bbox = {\n                top: textBox.y,\n                left: textBox.x,\n                width: textBox.width,\n                height: textBox.height\n            };\n        }\n        return this.bbox;\n    };\n    SVGTextLottieElement.prototype.getValue = function() {\n        var i;\n        var len = this.textSpans.length;\n        var glyphElement;\n        this.renderedFrame = this.comp.renderedFrame;\n        for(i = 0; i < len; i += 1){\n            glyphElement = this.textSpans[i].glyph;\n            if (glyphElement) {\n                glyphElement.prepareFrame(this.comp.renderedFrame - this.data.st);\n                if (glyphElement._mdf) {\n                    this._mdf = true;\n                }\n            }\n        }\n    };\n    SVGTextLottieElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        if (!this.data.singleShape || this._mdf) {\n            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n            if (this.lettersChangedFlag || this.textAnimator.lettersChangedFlag) {\n                this._sizeChanged = true;\n                var i;\n                var len;\n                var renderedLetters = this.textAnimator.renderedLetters;\n                var letters = this.textProperty.currentData.l;\n                len = letters.length;\n                var renderedLetter;\n                var textSpan;\n                var glyphElement;\n                for(i = 0; i < len; i += 1){\n                    if (!letters[i].n) {\n                        renderedLetter = renderedLetters[i];\n                        textSpan = this.textSpans[i].span;\n                        glyphElement = this.textSpans[i].glyph;\n                        if (glyphElement) {\n                            glyphElement.renderFrame();\n                        }\n                        if (renderedLetter._mdf.m) {\n                            textSpan.setAttribute('transform', renderedLetter.m);\n                        }\n                        if (renderedLetter._mdf.o) {\n                            textSpan.setAttribute('opacity', renderedLetter.o);\n                        }\n                        if (renderedLetter._mdf.sw) {\n                            textSpan.setAttribute('stroke-width', renderedLetter.sw);\n                        }\n                        if (renderedLetter._mdf.sc) {\n                            textSpan.setAttribute('stroke', renderedLetter.sc);\n                        }\n                        if (renderedLetter._mdf.fc) {\n                            textSpan.setAttribute('fill', renderedLetter.fc);\n                        }\n                    }\n                }\n            }\n        }\n    };\n    function ISolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        IImageElement\n    ], ISolidElement);\n    ISolidElement.prototype.createContent = function() {\n        var rect = createNS('rect');\n        /// /rect.style.width = this.data.sw;\n        /// /rect.style.height = this.data.sh;\n        /// /rect.style.fill = this.data.sc;\n        rect.setAttribute('width', this.data.sw);\n        rect.setAttribute('height', this.data.sh);\n        rect.setAttribute('fill', this.data.sc);\n        this.layerElement.appendChild(rect);\n    };\n    function NullElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initFrame();\n        this.initTransform(data, globalData, comp);\n        this.initHierarchy();\n    }\n    NullElement.prototype.prepareFrame = function(num) {\n        this.prepareProperties(num, true);\n    };\n    NullElement.prototype.renderFrame = function() {};\n    NullElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    NullElement.prototype.destroy = function() {};\n    NullElement.prototype.sourceRectAtTime = function() {};\n    NullElement.prototype.hide = function() {};\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HierarchyElement,\n        FrameElement\n    ], NullElement);\n    function SVGRendererBase() {}\n    extendPrototype([\n        BaseRenderer\n    ], SVGRendererBase);\n    SVGRendererBase.prototype.createNull = function(data) {\n        return new NullElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createShape = function(data) {\n        return new SVGShapeElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createText = function(data) {\n        return new SVGTextLottieElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createImage = function(data) {\n        return new IImageElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.createSolid = function(data) {\n        return new ISolidElement(data, this.globalData, this);\n    };\n    SVGRendererBase.prototype.configAnimation = function(animData) {\n        this.svgElement.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n        this.svgElement.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');\n        if (this.renderConfig.viewBoxSize) {\n            this.svgElement.setAttribute('viewBox', this.renderConfig.viewBoxSize);\n        } else {\n            this.svgElement.setAttribute('viewBox', '0 0 ' + animData.w + ' ' + animData.h);\n        }\n        if (!this.renderConfig.viewBoxOnly) {\n            this.svgElement.setAttribute('width', animData.w);\n            this.svgElement.setAttribute('height', animData.h);\n            this.svgElement.style.width = '100%';\n            this.svgElement.style.height = '100%';\n            this.svgElement.style.transform = 'translate3d(0,0,0)';\n            this.svgElement.style.contentVisibility = this.renderConfig.contentVisibility;\n        }\n        if (this.renderConfig.width) {\n            this.svgElement.setAttribute('width', this.renderConfig.width);\n        }\n        if (this.renderConfig.height) {\n            this.svgElement.setAttribute('height', this.renderConfig.height);\n        }\n        if (this.renderConfig.className) {\n            this.svgElement.setAttribute('class', this.renderConfig.className);\n        }\n        if (this.renderConfig.id) {\n            this.svgElement.setAttribute('id', this.renderConfig.id);\n        }\n        if (this.renderConfig.focusable !== undefined) {\n            this.svgElement.setAttribute('focusable', this.renderConfig.focusable);\n        }\n        this.svgElement.setAttribute('preserveAspectRatio', this.renderConfig.preserveAspectRatio);\n        // this.layerElement.style.transform = 'translate3d(0,0,0)';\n        // this.layerElement.style.transformOrigin = this.layerElement.style.mozTransformOrigin = this.layerElement.style.webkitTransformOrigin = this.layerElement.style['-webkit-transform'] = \"0px 0px 0px\";\n        this.animationItem.wrapper.appendChild(this.svgElement);\n        // Mask animation\n        var defs = this.globalData.defs;\n        this.setupGlobalData(animData, defs);\n        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n        this.data = animData;\n        var maskElement = createNS('clipPath');\n        var rect = createNS('rect');\n        rect.setAttribute('width', animData.w);\n        rect.setAttribute('height', animData.h);\n        rect.setAttribute('x', 0);\n        rect.setAttribute('y', 0);\n        var maskId = createElementID();\n        maskElement.setAttribute('id', maskId);\n        maskElement.appendChild(rect);\n        this.layerElement.setAttribute('clip-path', 'url(' + getLocationHref() + '#' + maskId + ')');\n        defs.appendChild(maskElement);\n        this.layers = animData.layers;\n        this.elements = createSizedArray(animData.layers.length);\n    };\n    SVGRendererBase.prototype.destroy = function() {\n        if (this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = '';\n        }\n        this.layerElement = null;\n        this.globalData.defs = null;\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.destroyed = true;\n        this.animationItem = null;\n    };\n    SVGRendererBase.prototype.updateContainerSize = function() {};\n    SVGRendererBase.prototype.findIndexByInd = function(ind) {\n        var i = 0;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.layers[i].ind === ind) {\n                return i;\n            }\n        }\n        return -1;\n    };\n    SVGRendererBase.prototype.buildItem = function(pos) {\n        var elements = this.elements;\n        if (elements[pos] || this.layers[pos].ty === 99) {\n            return;\n        }\n        elements[pos] = true;\n        var element = this.createItem(this.layers[pos]);\n        elements[pos] = element;\n        if (getExpressionsPlugin()) {\n            if (this.layers[pos].ty === 0) {\n                this.globalData.projectInterface.registerComposition(element);\n            }\n            element.initExpressions();\n        }\n        this.appendElementInPos(element, pos);\n        if (this.layers[pos].tt) {\n            var elementIndex = 'tp' in this.layers[pos] ? this.findIndexByInd(this.layers[pos].tp) : pos - 1;\n            if (elementIndex === -1) {\n                return;\n            }\n            if (!this.elements[elementIndex] || this.elements[elementIndex] === true) {\n                this.buildItem(elementIndex);\n                this.addPendingElement(element);\n            } else {\n                var matteElement = elements[elementIndex];\n                var matteMask = matteElement.getMatte(this.layers[pos].tt);\n                element.setMatte(matteMask);\n            }\n        }\n    };\n    SVGRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n            if (element.data.tt) {\n                var i = 0;\n                var len = this.elements.length;\n                while(i < len){\n                    if (this.elements[i] === element) {\n                        var elementIndex = 'tp' in element.data ? this.findIndexByInd(element.data.tp) : i - 1;\n                        var matteElement = this.elements[elementIndex];\n                        var matteMask = matteElement.getMatte(this.layers[i].tt);\n                        element.setMatte(matteMask);\n                        break;\n                    }\n                    i += 1;\n                }\n            }\n        }\n    };\n    SVGRendererBase.prototype.renderFrame = function(num) {\n        if (this.renderedFrame === num || this.destroyed) {\n            return;\n        }\n        if (num === null) {\n            num = this.renderedFrame;\n        } else {\n            this.renderedFrame = num;\n        }\n        // console.log('-------');\n        // console.log('FRAME ',num);\n        this.globalData.frameNum = num;\n        this.globalData.frameId += 1;\n        this.globalData.projectInterface.currentFrame = num;\n        this.globalData._mdf = false;\n        var i;\n        var len = this.layers.length;\n        if (!this.completeLayers) {\n            this.checkLayers(num);\n        }\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(num - this.layers[i].st);\n            }\n        }\n        if (this.globalData._mdf) {\n            for(i = 0; i < len; i += 1){\n                if (this.completeLayers || this.elements[i]) {\n                    this.elements[i].renderFrame();\n                }\n            }\n        }\n    };\n    SVGRendererBase.prototype.appendElementInPos = function(element, pos) {\n        var newElement = element.getBaseElement();\n        if (!newElement) {\n            return;\n        }\n        var i = 0;\n        var nextElement;\n        while(i < pos){\n            if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement()) {\n                nextElement = this.elements[i].getBaseElement();\n            }\n            i += 1;\n        }\n        if (nextElement) {\n            this.layerElement.insertBefore(newElement, nextElement);\n        } else {\n            this.layerElement.appendChild(newElement);\n        }\n    };\n    SVGRendererBase.prototype.hide = function() {\n        this.layerElement.style.display = 'none';\n    };\n    SVGRendererBase.prototype.show = function() {\n        this.layerElement.style.display = 'block';\n    };\n    function ICompElement() {}\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], ICompElement);\n    ICompElement.prototype.initElement = function(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initTransform(data, globalData, comp);\n        this.initRenderable();\n        this.initHierarchy();\n        this.initRendererElement();\n        this.createContainerElements();\n        this.createRenderableComponents();\n        if (this.data.xt || !globalData.progressiveLoad) {\n            this.buildAllItems();\n        }\n        this.hide();\n    };\n    /* ICompElement.prototype.hide = function(){\n      if(!this.hidden){\n          this.hideElement();\n          var i,len = this.elements.length;\n          for( i = 0; i < len; i+=1 ){\n              if(this.elements[i]){\n                  this.elements[i].hide();\n              }\n          }\n      }\n  }; */ ICompElement.prototype.prepareFrame = function(num) {\n        this._mdf = false;\n        this.prepareRenderableFrame(num);\n        this.prepareProperties(num, this.isInRange);\n        if (!this.isInRange && !this.data.xt) {\n            return;\n        }\n        if (!this.tm._placeholder) {\n            var timeRemapped = this.tm.v;\n            if (timeRemapped === this.data.op) {\n                timeRemapped = this.data.op - 1;\n            }\n            this.renderedFrame = timeRemapped;\n        } else {\n            this.renderedFrame = num / this.data.sr;\n        }\n        var i;\n        var len = this.elements.length;\n        if (!this.completeLayers) {\n            this.checkLayers(this.renderedFrame);\n        }\n        // This iteration needs to be backwards because of how expressions connect between each other\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(this.renderedFrame - this.layers[i].st);\n                if (this.elements[i]._mdf) {\n                    this._mdf = true;\n                }\n            }\n        }\n    };\n    ICompElement.prototype.renderInnerContent = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].renderFrame();\n            }\n        }\n    };\n    ICompElement.prototype.setElements = function(elems) {\n        this.elements = elems;\n    };\n    ICompElement.prototype.getElements = function() {\n        return this.elements;\n    };\n    ICompElement.prototype.destroyElements = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i]) {\n                this.elements[i].destroy();\n            }\n        }\n    };\n    ICompElement.prototype.destroy = function() {\n        this.destroyElements();\n        this.destroyBaseElement();\n    };\n    function SVGCompElement(data, globalData, comp) {\n        this.layers = data.layers;\n        this.supports3d = true;\n        this.completeLayers = false;\n        this.pendingElements = [];\n        this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        SVGRendererBase,\n        ICompElement,\n        SVGBaseElement\n    ], SVGCompElement);\n    SVGCompElement.prototype.createComp = function(data) {\n        return new SVGCompElement(data, this.globalData, this);\n    };\n    function SVGRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.svgElement = createNS('svg');\n        var ariaLabel = '';\n        if (config && config.title) {\n            var titleElement = createNS('title');\n            var titleId = createElementID();\n            titleElement.setAttribute('id', titleId);\n            titleElement.textContent = config.title;\n            this.svgElement.appendChild(titleElement);\n            ariaLabel += titleId;\n        }\n        if (config && config.description) {\n            var descElement = createNS('desc');\n            var descId = createElementID();\n            descElement.setAttribute('id', descId);\n            descElement.textContent = config.description;\n            this.svgElement.appendChild(descElement);\n            ariaLabel += ' ' + descId;\n        }\n        if (ariaLabel) {\n            this.svgElement.setAttribute('aria-labelledby', ariaLabel);\n        }\n        var defs = createNS('defs');\n        this.svgElement.appendChild(defs);\n        var maskElement = createNS('g');\n        this.svgElement.appendChild(maskElement);\n        this.layerElement = maskElement;\n        this.renderConfig = {\n            preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n            contentVisibility: config && config.contentVisibility || 'visible',\n            progressiveLoad: config && config.progressiveLoad || false,\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            viewBoxOnly: config && config.viewBoxOnly || false,\n            viewBoxSize: config && config.viewBoxSize || false,\n            className: config && config.className || '',\n            id: config && config.id || '',\n            focusable: config && config.focusable,\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || '100%',\n                height: config && config.filterSize && config.filterSize.height || '100%',\n                x: config && config.filterSize && config.filterSize.x || '0%',\n                y: config && config.filterSize && config.filterSize.y || '0%'\n            },\n            width: config && config.width,\n            height: config && config.height,\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            defs: defs,\n            renderConfig: this.renderConfig\n        };\n        this.elements = [];\n        this.pendingElements = [];\n        this.destroyed = false;\n        this.rendererType = 'svg';\n    }\n    extendPrototype([\n        SVGRendererBase\n    ], SVGRenderer);\n    SVGRenderer.prototype.createComp = function(data) {\n        return new SVGCompElement(data, this.globalData, this);\n    };\n    function ShapeTransformManager() {\n        this.sequences = {};\n        this.sequenceList = [];\n        this.transform_key_count = 0;\n    }\n    ShapeTransformManager.prototype = {\n        addTransformSequence: function addTransformSequence(transforms) {\n            var i;\n            var len = transforms.length;\n            var key = '_';\n            for(i = 0; i < len; i += 1){\n                key += transforms[i].transform.key + '_';\n            }\n            var sequence = this.sequences[key];\n            if (!sequence) {\n                sequence = {\n                    transforms: [].concat(transforms),\n                    finalTransform: new Matrix(),\n                    _mdf: false\n                };\n                this.sequences[key] = sequence;\n                this.sequenceList.push(sequence);\n            }\n            return sequence;\n        },\n        processSequence: function processSequence(sequence, isFirstFrame) {\n            var i = 0;\n            var len = sequence.transforms.length;\n            var _mdf = isFirstFrame;\n            while(i < len && !isFirstFrame){\n                if (sequence.transforms[i].transform.mProps._mdf) {\n                    _mdf = true;\n                    break;\n                }\n                i += 1;\n            }\n            if (_mdf) {\n                sequence.finalTransform.reset();\n                for(i = len - 1; i >= 0; i -= 1){\n                    sequence.finalTransform.multiply(sequence.transforms[i].transform.mProps.v);\n                }\n            }\n            sequence._mdf = _mdf;\n        },\n        processSequences: function processSequences(isFirstFrame) {\n            var i;\n            var len = this.sequenceList.length;\n            for(i = 0; i < len; i += 1){\n                this.processSequence(this.sequenceList[i], isFirstFrame);\n            }\n        },\n        getNewKey: function getNewKey() {\n            this.transform_key_count += 1;\n            return '_' + this.transform_key_count;\n        }\n    };\n    var lumaLoader = function lumaLoader() {\n        var id = '__lottie_element_luma_buffer';\n        var lumaBuffer = null;\n        var lumaBufferCtx = null;\n        var svg = null;\n        // This alternate solution has a slight delay before the filter is applied, resulting in a flicker on the first frame.\n        // Keeping this here for reference, and in the future, if offscreen canvas supports url filters, this can be used.\n        // For now, neither of them work for offscreen canvas, so canvas workers can't support the luma track matte mask.\n        // Naming it solution 2 to mark the extra comment lines.\n        /*\n    var svgString = [\n      '<svg xmlns=\"http://www.w3.org/2000/svg\">',\n      '<filter id=\"' + id + '\">',\n      '<feColorMatrix type=\"matrix\" color-interpolation-filters=\"sRGB\" values=\"',\n      '0.3, 0.3, 0.3, 0, 0, ',\n      '0.3, 0.3, 0.3, 0, 0, ',\n      '0.3, 0.3, 0.3, 0, 0, ',\n      '0.3, 0.3, 0.3, 0, 0',\n      '\"/>',\n      '</filter>',\n      '</svg>',\n    ].join('');\n    var blob = new Blob([svgString], { type: 'image/svg+xml' });\n    var url = URL.createObjectURL(blob);\n    */ function createLumaSvgFilter() {\n            var _svg = createNS('svg');\n            var fil = createNS('filter');\n            var matrix = createNS('feColorMatrix');\n            fil.setAttribute('id', id);\n            matrix.setAttribute('type', 'matrix');\n            matrix.setAttribute('color-interpolation-filters', 'sRGB');\n            matrix.setAttribute('values', '0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0, 0.3, 0.3, 0.3, 0, 0');\n            fil.appendChild(matrix);\n            _svg.appendChild(fil);\n            _svg.setAttribute('id', id + '_svg');\n            if (featureSupport.svgLumaHidden) {\n                _svg.style.display = 'none';\n            }\n            return _svg;\n        }\n        function loadLuma() {\n            if (!lumaBuffer) {\n                svg = createLumaSvgFilter();\n                document.body.appendChild(svg);\n                lumaBuffer = createTag('canvas');\n                lumaBufferCtx = lumaBuffer.getContext('2d');\n                // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n                lumaBufferCtx.filter = 'url(#' + id + ')';\n                lumaBufferCtx.fillStyle = 'rgba(0,0,0,0)';\n                lumaBufferCtx.fillRect(0, 0, 1, 1);\n            }\n        }\n        function getLuma(canvas) {\n            if (!lumaBuffer) {\n                loadLuma();\n            }\n            lumaBuffer.width = canvas.width;\n            lumaBuffer.height = canvas.height;\n            // lumaBufferCtx.filter = `url('${url}#__lottie_element_luma_buffer')`; // part of solution 2\n            lumaBufferCtx.filter = 'url(#' + id + ')';\n            return lumaBuffer;\n        }\n        return {\n            load: loadLuma,\n            get: getLuma\n        };\n    };\n    function createCanvas(width, height) {\n        if (featureSupport.offscreenCanvas) {\n            return new OffscreenCanvas(width, height);\n        }\n        var canvas = createTag('canvas');\n        canvas.width = width;\n        canvas.height = height;\n        return canvas;\n    }\n    var assetLoader = function() {\n        return {\n            loadLumaCanvas: lumaLoader.load,\n            getLumaCanvas: lumaLoader.get,\n            createCanvas: createCanvas\n        };\n    }();\n    var registeredEffects = {};\n    function CVEffects(elem) {\n        var i;\n        var len = elem.data.ef ? elem.data.ef.length : 0;\n        this.filters = [];\n        var filterManager;\n        for(i = 0; i < len; i += 1){\n            filterManager = null;\n            var type = elem.data.ef[i].ty;\n            if (registeredEffects[type]) {\n                var Effect = registeredEffects[type].effect;\n                filterManager = new Effect(elem.effectsManager.effectElements[i], elem);\n            }\n            if (filterManager) {\n                this.filters.push(filterManager);\n            }\n        }\n        if (this.filters.length) {\n            elem.addRenderableComponent(this);\n        }\n    }\n    CVEffects.prototype.renderFrame = function(_isFirstFrame) {\n        var i;\n        var len = this.filters.length;\n        for(i = 0; i < len; i += 1){\n            this.filters[i].renderFrame(_isFirstFrame);\n        }\n    };\n    CVEffects.prototype.getEffects = function(type) {\n        var i;\n        var len = this.filters.length;\n        var effects = [];\n        for(i = 0; i < len; i += 1){\n            if (this.filters[i].type === type) {\n                effects.push(this.filters[i]);\n            }\n        }\n        return effects;\n    };\n    function registerEffect(id, effect) {\n        registeredEffects[id] = {\n            effect: effect\n        };\n    }\n    function CVMaskElement(data, element) {\n        this.data = data;\n        this.element = element;\n        this.masksProperties = this.data.masksProperties || [];\n        this.viewData = createSizedArray(this.masksProperties.length);\n        var i;\n        var len = this.masksProperties.length;\n        var hasMasks = false;\n        for(i = 0; i < len; i += 1){\n            if (this.masksProperties[i].mode !== 'n') {\n                hasMasks = true;\n            }\n            this.viewData[i] = ShapePropertyFactory.getShapeProp(this.element, this.masksProperties[i], 3);\n        }\n        this.hasMasks = hasMasks;\n        if (hasMasks) {\n            this.element.addRenderableComponent(this);\n        }\n    }\n    CVMaskElement.prototype.renderFrame = function() {\n        if (!this.hasMasks) {\n            return;\n        }\n        var transform = this.element.finalTransform.mat;\n        var ctx = this.element.canvasContext;\n        var i;\n        var len = this.masksProperties.length;\n        var pt;\n        var pts;\n        var data;\n        ctx.beginPath();\n        for(i = 0; i < len; i += 1){\n            if (this.masksProperties[i].mode !== 'n') {\n                if (this.masksProperties[i].inv) {\n                    ctx.moveTo(0, 0);\n                    ctx.lineTo(this.element.globalData.compSize.w, 0);\n                    ctx.lineTo(this.element.globalData.compSize.w, this.element.globalData.compSize.h);\n                    ctx.lineTo(0, this.element.globalData.compSize.h);\n                    ctx.lineTo(0, 0);\n                }\n                data = this.viewData[i].v;\n                pt = transform.applyToPointArray(data.v[0][0], data.v[0][1], 0);\n                ctx.moveTo(pt[0], pt[1]);\n                var j;\n                var jLen = data._length;\n                for(j = 1; j < jLen; j += 1){\n                    pts = transform.applyToTriplePoints(data.o[j - 1], data.i[j], data.v[j]);\n                    ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n                }\n                pts = transform.applyToTriplePoints(data.o[j - 1], data.i[0], data.v[0]);\n                ctx.bezierCurveTo(pts[0], pts[1], pts[2], pts[3], pts[4], pts[5]);\n            }\n        }\n        this.element.globalData.renderer.save(true);\n        ctx.clip();\n    };\n    CVMaskElement.prototype.getMaskProperty = MaskElement.prototype.getMaskProperty;\n    CVMaskElement.prototype.destroy = function() {\n        this.element = null;\n    };\n    function CVBaseElement() {}\n    var operationsMap = {\n        1: 'source-in',\n        2: 'source-out',\n        3: 'source-in',\n        4: 'source-out'\n    };\n    CVBaseElement.prototype = {\n        createElements: function createElements() {},\n        initRendererElement: function initRendererElement() {},\n        createContainerElements: function createContainerElements() {\n            // If the layer is masked we will use two buffers to store each different states of the drawing\n            // This solution is not ideal for several reason. But unfortunately, because of the recursive\n            // nature of the render tree, it's the only simple way to make sure one inner mask doesn't override an outer mask.\n            // TODO: try to reduce the size of these buffers to the size of the composition contaning the layer\n            // It might be challenging because the layer most likely is transformed in some way\n            if (this.data.tt >= 1) {\n                this.buffers = [];\n                var canvasContext = this.globalData.canvasContext;\n                var bufferCanvas = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n                this.buffers.push(bufferCanvas);\n                var bufferCanvas2 = assetLoader.createCanvas(canvasContext.canvas.width, canvasContext.canvas.height);\n                this.buffers.push(bufferCanvas2);\n                if (this.data.tt >= 3 && !document._isProxy) {\n                    assetLoader.loadLumaCanvas();\n                }\n            }\n            this.canvasContext = this.globalData.canvasContext;\n            this.transformCanvas = this.globalData.transformCanvas;\n            this.renderableEffectsManager = new CVEffects(this);\n            this.searchEffectTransforms();\n        },\n        createContent: function createContent() {},\n        setBlendMode: function setBlendMode() {\n            var globalData = this.globalData;\n            if (globalData.blendMode !== this.data.bm) {\n                globalData.blendMode = this.data.bm;\n                var blendModeValue = getBlendMode(this.data.bm);\n                globalData.canvasContext.globalCompositeOperation = blendModeValue;\n            }\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new CVMaskElement(this.data, this);\n            this.transformEffects = this.renderableEffectsManager.getEffects(effectTypes.TRANSFORM_EFFECT);\n        },\n        hideElement: function hideElement() {\n            if (!this.hidden && (!this.isInRange || this.isTransparent)) {\n                this.hidden = true;\n            }\n        },\n        showElement: function showElement() {\n            if (this.isInRange && !this.isTransparent) {\n                this.hidden = false;\n                this._isFirstFrame = true;\n                this.maskManager._isFirstFrame = true;\n            }\n        },\n        clearCanvas: function clearCanvas(canvasContext) {\n            canvasContext.clearRect(this.transformCanvas.tx, this.transformCanvas.ty, this.transformCanvas.w * this.transformCanvas.sx, this.transformCanvas.h * this.transformCanvas.sy);\n        },\n        prepareLayer: function prepareLayer() {\n            if (this.data.tt >= 1) {\n                var buffer = this.buffers[0];\n                var bufferCtx = buffer.getContext('2d');\n                this.clearCanvas(bufferCtx);\n                // on the first buffer we store the current state of the global drawing\n                bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);\n                // The next four lines are to clear the canvas\n                // TODO: Check if there is a way to clear the canvas without resetting the transform\n                this.currentTransform = this.canvasContext.getTransform();\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n                this.clearCanvas(this.canvasContext);\n                this.canvasContext.setTransform(this.currentTransform);\n            }\n        },\n        exitLayer: function exitLayer() {\n            if (this.data.tt >= 1) {\n                var buffer = this.buffers[1];\n                // On the second buffer we store the current state of the global drawing\n                // that only contains the content of this layer\n                // (if it is a composition, it also includes the nested layers)\n                var bufferCtx = buffer.getContext('2d');\n                this.clearCanvas(bufferCtx);\n                bufferCtx.drawImage(this.canvasContext.canvas, 0, 0);\n                // We clear the canvas again\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n                this.clearCanvas(this.canvasContext);\n                this.canvasContext.setTransform(this.currentTransform);\n                // We draw the mask\n                var mask = this.comp.getElementById('tp' in this.data ? this.data.tp : this.data.ind - 1);\n                mask.renderFrame(true);\n                // We draw the second buffer (that contains the content of this layer)\n                this.canvasContext.setTransform(1, 0, 0, 1, 0, 0);\n                // If the mask is a Luma matte, we need to do two extra painting operations\n                // the _isProxy check is to avoid drawing a fake canvas in workers that will throw an error\n                if (this.data.tt >= 3 && !document._isProxy) {\n                    // We copy the painted mask to a buffer that has a color matrix filter applied to it\n                    // that applies the rgb values to the alpha channel\n                    var lumaBuffer = assetLoader.getLumaCanvas(this.canvasContext.canvas);\n                    var lumaBufferCtx = lumaBuffer.getContext('2d');\n                    lumaBufferCtx.drawImage(this.canvasContext.canvas, 0, 0);\n                    this.clearCanvas(this.canvasContext);\n                    // we repaint the context with the mask applied to it\n                    this.canvasContext.drawImage(lumaBuffer, 0, 0);\n                }\n                this.canvasContext.globalCompositeOperation = operationsMap[this.data.tt];\n                this.canvasContext.drawImage(buffer, 0, 0);\n                // We finally draw the first buffer (that contains the content of the global drawing)\n                // We use destination-over to draw the global drawing below the current layer\n                this.canvasContext.globalCompositeOperation = 'destination-over';\n                this.canvasContext.drawImage(this.buffers[0], 0, 0);\n                this.canvasContext.setTransform(this.currentTransform);\n                // We reset the globalCompositeOperation to source-over, the standard type of operation\n                this.canvasContext.globalCompositeOperation = 'source-over';\n            }\n        },\n        renderFrame: function renderFrame(forceRender) {\n            if (this.hidden || this.data.hd) {\n                return;\n            }\n            if (this.data.td === 1 && !forceRender) {\n                return;\n            }\n            this.renderTransform();\n            this.renderRenderable();\n            this.renderLocalTransform();\n            this.setBlendMode();\n            var forceRealStack = this.data.ty === 0;\n            this.prepareLayer();\n            this.globalData.renderer.save(forceRealStack);\n            this.globalData.renderer.ctxTransform(this.finalTransform.localMat.props);\n            this.globalData.renderer.ctxOpacity(this.finalTransform.localOpacity);\n            this.renderInnerContent();\n            this.globalData.renderer.restore(forceRealStack);\n            this.exitLayer();\n            if (this.maskManager.hasMasks) {\n                this.globalData.renderer.restore(true);\n            }\n            if (this._isFirstFrame) {\n                this._isFirstFrame = false;\n            }\n        },\n        destroy: function destroy() {\n            this.canvasContext = null;\n            this.data = null;\n            this.globalData = null;\n            this.maskManager.destroy();\n        },\n        mHelper: new Matrix()\n    };\n    CVBaseElement.prototype.hide = CVBaseElement.prototype.hideElement;\n    CVBaseElement.prototype.show = CVBaseElement.prototype.showElement;\n    function CVShapeData(element, data, styles, transformsManager) {\n        this.styledShapes = [];\n        this.tr = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        var ty = 4;\n        if (data.ty === 'rc') {\n            ty = 5;\n        } else if (data.ty === 'el') {\n            ty = 6;\n        } else if (data.ty === 'sr') {\n            ty = 7;\n        }\n        this.sh = ShapePropertyFactory.getShapeProp(element, data, ty, element);\n        var i;\n        var len = styles.length;\n        var styledShape;\n        for(i = 0; i < len; i += 1){\n            if (!styles[i].closed) {\n                styledShape = {\n                    transforms: transformsManager.addTransformSequence(styles[i].transforms),\n                    trNodes: []\n                };\n                this.styledShapes.push(styledShape);\n                styles[i].elements.push(styledShape);\n            }\n        }\n    }\n    CVShapeData.prototype.setAsAnimated = SVGShapeData.prototype.setAsAnimated;\n    function CVShapeElement(data, globalData, comp) {\n        this.shapes = [];\n        this.shapesData = data.shapes;\n        this.stylesList = [];\n        this.itemsData = [];\n        this.prevViewData = [];\n        this.shapeModifiers = [];\n        this.processedElements = [];\n        this.transformsManager = new ShapeTransformManager();\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        IShapeElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVShapeElement);\n    CVShapeElement.prototype.initElement = RenderableDOMElement.prototype.initElement;\n    CVShapeElement.prototype.transformHelper = {\n        opacity: 1,\n        _opMdf: false\n    };\n    CVShapeElement.prototype.dashResetter = [];\n    CVShapeElement.prototype.createContent = function() {\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n    };\n    CVShapeElement.prototype.createStyleElement = function(data, transforms) {\n        var styleElem = {\n            data: data,\n            type: data.ty,\n            preTransforms: this.transformsManager.addTransformSequence(transforms),\n            transforms: [],\n            elements: [],\n            closed: data.hd === true\n        };\n        var elementData = {};\n        if (data.ty === 'fl' || data.ty === 'st') {\n            elementData.c = PropertyFactory.getProp(this, data.c, 1, 255, this);\n            if (!elementData.c.k) {\n                styleElem.co = 'rgb(' + bmFloor(elementData.c.v[0]) + ',' + bmFloor(elementData.c.v[1]) + ',' + bmFloor(elementData.c.v[2]) + ')';\n            }\n        } else if (data.ty === 'gf' || data.ty === 'gs') {\n            elementData.s = PropertyFactory.getProp(this, data.s, 1, null, this);\n            elementData.e = PropertyFactory.getProp(this, data.e, 1, null, this);\n            elementData.h = PropertyFactory.getProp(this, data.h || {\n                k: 0\n            }, 0, 0.01, this);\n            elementData.a = PropertyFactory.getProp(this, data.a || {\n                k: 0\n            }, 0, degToRads, this);\n            elementData.g = new GradientProperty(this, data.g, this);\n        }\n        elementData.o = PropertyFactory.getProp(this, data.o, 0, 0.01, this);\n        if (data.ty === 'st' || data.ty === 'gs') {\n            styleElem.lc = lineCapEnum[data.lc || 2];\n            styleElem.lj = lineJoinEnum[data.lj || 2];\n            if (data.lj == 1) {\n                // eslint-disable-line eqeqeq\n                styleElem.ml = data.ml;\n            }\n            elementData.w = PropertyFactory.getProp(this, data.w, 0, null, this);\n            if (!elementData.w.k) {\n                styleElem.wi = elementData.w.v;\n            }\n            if (data.d) {\n                var d = new DashProperty(this, data.d, 'canvas', this);\n                elementData.d = d;\n                if (!elementData.d.k) {\n                    styleElem.da = elementData.d.dashArray;\n                    styleElem[\"do\"] = elementData.d.dashoffset[0];\n                }\n            }\n        } else {\n            styleElem.r = data.r === 2 ? 'evenodd' : 'nonzero';\n        }\n        this.stylesList.push(styleElem);\n        elementData.style = styleElem;\n        return elementData;\n    };\n    CVShapeElement.prototype.createGroupElement = function() {\n        var elementData = {\n            it: [],\n            prevViewData: []\n        };\n        return elementData;\n    };\n    CVShapeElement.prototype.createTransformElement = function(data) {\n        var elementData = {\n            transform: {\n                opacity: 1,\n                _opMdf: false,\n                key: this.transformsManager.getNewKey(),\n                op: PropertyFactory.getProp(this, data.o, 0, 0.01, this),\n                mProps: TransformPropertyFactory.getTransformProperty(this, data, this)\n            }\n        };\n        return elementData;\n    };\n    CVShapeElement.prototype.createShapeElement = function(data) {\n        var elementData = new CVShapeData(this, data, this.stylesList, this.transformsManager);\n        this.shapes.push(elementData);\n        this.addShapeToModifiers(elementData);\n        return elementData;\n    };\n    CVShapeElement.prototype.reloadShapes = function() {\n        this._isFirstFrame = true;\n        var i;\n        var len = this.itemsData.length;\n        for(i = 0; i < len; i += 1){\n            this.prevViewData[i] = this.itemsData[i];\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, true, []);\n        len = this.dynamicProperties.length;\n        for(i = 0; i < len; i += 1){\n            this.dynamicProperties[i].getValue();\n        }\n        this.renderModifiers();\n        this.transformsManager.processSequences(this._isFirstFrame);\n    };\n    CVShapeElement.prototype.addTransformToStyleList = function(transform) {\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            if (!this.stylesList[i].closed) {\n                this.stylesList[i].transforms.push(transform);\n            }\n        }\n    };\n    CVShapeElement.prototype.removeTransformFromStyleList = function() {\n        var i;\n        var len = this.stylesList.length;\n        for(i = 0; i < len; i += 1){\n            if (!this.stylesList[i].closed) {\n                this.stylesList[i].transforms.pop();\n            }\n        }\n    };\n    CVShapeElement.prototype.closeStyles = function(styles) {\n        var i;\n        var len = styles.length;\n        for(i = 0; i < len; i += 1){\n            styles[i].closed = true;\n        }\n    };\n    CVShapeElement.prototype.searchShapes = function(arr, itemsData, prevViewData, shouldRender, transforms) {\n        var i;\n        var len = arr.length - 1;\n        var j;\n        var jLen;\n        var ownStyles = [];\n        var ownModifiers = [];\n        var processedPos;\n        var modifier;\n        var currentTransform;\n        var ownTransforms = [].concat(transforms);\n        for(i = len; i >= 0; i -= 1){\n            processedPos = this.searchProcessedElement(arr[i]);\n            if (!processedPos) {\n                arr[i]._shouldRender = shouldRender;\n            } else {\n                itemsData[i] = prevViewData[processedPos - 1];\n            }\n            if (arr[i].ty === 'fl' || arr[i].ty === 'st' || arr[i].ty === 'gf' || arr[i].ty === 'gs') {\n                if (!processedPos) {\n                    itemsData[i] = this.createStyleElement(arr[i], ownTransforms);\n                } else {\n                    itemsData[i].style.closed = false;\n                }\n                ownStyles.push(itemsData[i].style);\n            } else if (arr[i].ty === 'gr') {\n                if (!processedPos) {\n                    itemsData[i] = this.createGroupElement(arr[i]);\n                } else {\n                    jLen = itemsData[i].it.length;\n                    for(j = 0; j < jLen; j += 1){\n                        itemsData[i].prevViewData[j] = itemsData[i].it[j];\n                    }\n                }\n                this.searchShapes(arr[i].it, itemsData[i].it, itemsData[i].prevViewData, shouldRender, ownTransforms);\n            } else if (arr[i].ty === 'tr') {\n                if (!processedPos) {\n                    currentTransform = this.createTransformElement(arr[i]);\n                    itemsData[i] = currentTransform;\n                }\n                ownTransforms.push(itemsData[i]);\n                this.addTransformToStyleList(itemsData[i]);\n            } else if (arr[i].ty === 'sh' || arr[i].ty === 'rc' || arr[i].ty === 'el' || arr[i].ty === 'sr') {\n                if (!processedPos) {\n                    itemsData[i] = this.createShapeElement(arr[i]);\n                }\n            } else if (arr[i].ty === 'tm' || arr[i].ty === 'rd' || arr[i].ty === 'pb' || arr[i].ty === 'zz' || arr[i].ty === 'op') {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    modifier.init(this, arr[i]);\n                    itemsData[i] = modifier;\n                    this.shapeModifiers.push(modifier);\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = false;\n                }\n                ownModifiers.push(modifier);\n            } else if (arr[i].ty === 'rp') {\n                if (!processedPos) {\n                    modifier = ShapeModifiers.getModifier(arr[i].ty);\n                    itemsData[i] = modifier;\n                    modifier.init(this, arr, i, itemsData);\n                    this.shapeModifiers.push(modifier);\n                    shouldRender = false;\n                } else {\n                    modifier = itemsData[i];\n                    modifier.closed = true;\n                }\n                ownModifiers.push(modifier);\n            }\n            this.addProcessedElement(arr[i], i + 1);\n        }\n        this.removeTransformFromStyleList();\n        this.closeStyles(ownStyles);\n        len = ownModifiers.length;\n        for(i = 0; i < len; i += 1){\n            ownModifiers[i].closed = true;\n        }\n    };\n    CVShapeElement.prototype.renderInnerContent = function() {\n        this.transformHelper.opacity = 1;\n        this.transformHelper._opMdf = false;\n        this.renderModifiers();\n        this.transformsManager.processSequences(this._isFirstFrame);\n        this.renderShape(this.transformHelper, this.shapesData, this.itemsData, true);\n    };\n    CVShapeElement.prototype.renderShapeTransform = function(parentTransform, groupTransform) {\n        if (parentTransform._opMdf || groupTransform.op._mdf || this._isFirstFrame) {\n            groupTransform.opacity = parentTransform.opacity;\n            groupTransform.opacity *= groupTransform.op.v;\n            groupTransform._opMdf = true;\n        }\n    };\n    CVShapeElement.prototype.drawLayer = function() {\n        var i;\n        var len = this.stylesList.length;\n        var j;\n        var jLen;\n        var k;\n        var kLen;\n        var elems;\n        var nodes;\n        var renderer = this.globalData.renderer;\n        var ctx = this.globalData.canvasContext;\n        var type;\n        var currentStyle;\n        for(i = 0; i < len; i += 1){\n            currentStyle = this.stylesList[i];\n            type = currentStyle.type;\n            // Skipping style when\n            // Stroke width equals 0\n            // style should not be rendered (extra unused repeaters)\n            // current opacity equals 0\n            // global opacity equals 0\n            if (!((type === 'st' || type === 'gs') && currentStyle.wi === 0 || !currentStyle.data._shouldRender || currentStyle.coOp === 0 || this.globalData.currentGlobalAlpha === 0)) {\n                renderer.save();\n                elems = currentStyle.elements;\n                if (type === 'st' || type === 'gs') {\n                    renderer.ctxStrokeStyle(type === 'st' ? currentStyle.co : currentStyle.grd);\n                    // ctx.strokeStyle = type === 'st' ? currentStyle.co : currentStyle.grd;\n                    renderer.ctxLineWidth(currentStyle.wi);\n                    // ctx.lineWidth = currentStyle.wi;\n                    renderer.ctxLineCap(currentStyle.lc);\n                    // ctx.lineCap = currentStyle.lc;\n                    renderer.ctxLineJoin(currentStyle.lj);\n                    // ctx.lineJoin = currentStyle.lj;\n                    renderer.ctxMiterLimit(currentStyle.ml || 0);\n                // ctx.miterLimit = currentStyle.ml || 0;\n                } else {\n                    renderer.ctxFillStyle(type === 'fl' ? currentStyle.co : currentStyle.grd);\n                // ctx.fillStyle = type === 'fl' ? currentStyle.co : currentStyle.grd;\n                }\n                renderer.ctxOpacity(currentStyle.coOp);\n                if (type !== 'st' && type !== 'gs') {\n                    ctx.beginPath();\n                }\n                renderer.ctxTransform(currentStyle.preTransforms.finalTransform.props);\n                jLen = elems.length;\n                for(j = 0; j < jLen; j += 1){\n                    if (type === 'st' || type === 'gs') {\n                        ctx.beginPath();\n                        if (currentStyle.da) {\n                            ctx.setLineDash(currentStyle.da);\n                            ctx.lineDashOffset = currentStyle[\"do\"];\n                        }\n                    }\n                    nodes = elems[j].trNodes;\n                    kLen = nodes.length;\n                    for(k = 0; k < kLen; k += 1){\n                        if (nodes[k].t === 'm') {\n                            ctx.moveTo(nodes[k].p[0], nodes[k].p[1]);\n                        } else if (nodes[k].t === 'c') {\n                            ctx.bezierCurveTo(nodes[k].pts[0], nodes[k].pts[1], nodes[k].pts[2], nodes[k].pts[3], nodes[k].pts[4], nodes[k].pts[5]);\n                        } else {\n                            ctx.closePath();\n                        }\n                    }\n                    if (type === 'st' || type === 'gs') {\n                        // ctx.stroke();\n                        renderer.ctxStroke();\n                        if (currentStyle.da) {\n                            ctx.setLineDash(this.dashResetter);\n                        }\n                    }\n                }\n                if (type !== 'st' && type !== 'gs') {\n                    // ctx.fill(currentStyle.r);\n                    this.globalData.renderer.ctxFill(currentStyle.r);\n                }\n                renderer.restore();\n            }\n        }\n    };\n    CVShapeElement.prototype.renderShape = function(parentTransform, items, data, isMain) {\n        var i;\n        var len = items.length - 1;\n        var groupTransform;\n        groupTransform = parentTransform;\n        for(i = len; i >= 0; i -= 1){\n            if (items[i].ty === 'tr') {\n                groupTransform = data[i].transform;\n                this.renderShapeTransform(parentTransform, groupTransform);\n            } else if (items[i].ty === 'sh' || items[i].ty === 'el' || items[i].ty === 'rc' || items[i].ty === 'sr') {\n                this.renderPath(items[i], data[i]);\n            } else if (items[i].ty === 'fl') {\n                this.renderFill(items[i], data[i], groupTransform);\n            } else if (items[i].ty === 'st') {\n                this.renderStroke(items[i], data[i], groupTransform);\n            } else if (items[i].ty === 'gf' || items[i].ty === 'gs') {\n                this.renderGradientFill(items[i], data[i], groupTransform);\n            } else if (items[i].ty === 'gr') {\n                this.renderShape(groupTransform, items[i].it, data[i].it);\n            } else if (items[i].ty === 'tm') {\n            //\n            }\n        }\n        if (isMain) {\n            this.drawLayer();\n        }\n    };\n    CVShapeElement.prototype.renderStyledShape = function(styledShape, shape) {\n        if (this._isFirstFrame || shape._mdf || styledShape.transforms._mdf) {\n            var shapeNodes = styledShape.trNodes;\n            var paths = shape.paths;\n            var i;\n            var len;\n            var j;\n            var jLen = paths._length;\n            shapeNodes.length = 0;\n            var groupTransformMat = styledShape.transforms.finalTransform;\n            for(j = 0; j < jLen; j += 1){\n                var pathNodes = paths.shapes[j];\n                if (pathNodes && pathNodes.v) {\n                    len = pathNodes._length;\n                    for(i = 1; i < len; i += 1){\n                        if (i === 1) {\n                            shapeNodes.push({\n                                t: 'm',\n                                p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n                            });\n                        }\n                        shapeNodes.push({\n                            t: 'c',\n                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[i], pathNodes.v[i])\n                        });\n                    }\n                    if (len === 1) {\n                        shapeNodes.push({\n                            t: 'm',\n                            p: groupTransformMat.applyToPointArray(pathNodes.v[0][0], pathNodes.v[0][1], 0)\n                        });\n                    }\n                    if (pathNodes.c && len) {\n                        shapeNodes.push({\n                            t: 'c',\n                            pts: groupTransformMat.applyToTriplePoints(pathNodes.o[i - 1], pathNodes.i[0], pathNodes.v[0])\n                        });\n                        shapeNodes.push({\n                            t: 'z'\n                        });\n                    }\n                }\n            }\n            styledShape.trNodes = shapeNodes;\n        }\n    };\n    CVShapeElement.prototype.renderPath = function(pathData, itemData) {\n        if (pathData.hd !== true && pathData._shouldRender) {\n            var i;\n            var len = itemData.styledShapes.length;\n            for(i = 0; i < len; i += 1){\n                this.renderStyledShape(itemData.styledShapes[i], itemData.sh);\n            }\n        }\n    };\n    CVShapeElement.prototype.renderFill = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        if (itemData.c._mdf || this._isFirstFrame) {\n            styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';\n        }\n        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n            styleElem.coOp = itemData.o.v * groupTransform.opacity;\n        }\n    };\n    CVShapeElement.prototype.renderGradientFill = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        var grd;\n        if (!styleElem.grd || itemData.g._mdf || itemData.s._mdf || itemData.e._mdf || styleData.t !== 1 && (itemData.h._mdf || itemData.a._mdf)) {\n            var ctx = this.globalData.canvasContext;\n            var pt1 = itemData.s.v;\n            var pt2 = itemData.e.v;\n            if (styleData.t === 1) {\n                grd = ctx.createLinearGradient(pt1[0], pt1[1], pt2[0], pt2[1]);\n            } else {\n                var rad = Math.sqrt(Math.pow(pt1[0] - pt2[0], 2) + Math.pow(pt1[1] - pt2[1], 2));\n                var ang = Math.atan2(pt2[1] - pt1[1], pt2[0] - pt1[0]);\n                var percent = itemData.h.v;\n                if (percent >= 1) {\n                    percent = 0.99;\n                } else if (percent <= -1) {\n                    percent = -0.99;\n                }\n                var dist = rad * percent;\n                var x = Math.cos(ang + itemData.a.v) * dist + pt1[0];\n                var y = Math.sin(ang + itemData.a.v) * dist + pt1[1];\n                grd = ctx.createRadialGradient(x, y, 0, pt1[0], pt1[1], rad);\n            }\n            var i;\n            var len = styleData.g.p;\n            var cValues = itemData.g.c;\n            var opacity = 1;\n            for(i = 0; i < len; i += 1){\n                if (itemData.g._hasOpacity && itemData.g._collapsable) {\n                    opacity = itemData.g.o[i * 2 + 1];\n                }\n                grd.addColorStop(cValues[i * 4] / 100, 'rgba(' + cValues[i * 4 + 1] + ',' + cValues[i * 4 + 2] + ',' + cValues[i * 4 + 3] + ',' + opacity + ')');\n            }\n            styleElem.grd = grd;\n        }\n        styleElem.coOp = itemData.o.v * groupTransform.opacity;\n    };\n    CVShapeElement.prototype.renderStroke = function(styleData, itemData, groupTransform) {\n        var styleElem = itemData.style;\n        var d = itemData.d;\n        if (d && (d._mdf || this._isFirstFrame)) {\n            styleElem.da = d.dashArray;\n            styleElem[\"do\"] = d.dashoffset[0];\n        }\n        if (itemData.c._mdf || this._isFirstFrame) {\n            styleElem.co = 'rgb(' + bmFloor(itemData.c.v[0]) + ',' + bmFloor(itemData.c.v[1]) + ',' + bmFloor(itemData.c.v[2]) + ')';\n        }\n        if (itemData.o._mdf || groupTransform._opMdf || this._isFirstFrame) {\n            styleElem.coOp = itemData.o.v * groupTransform.opacity;\n        }\n        if (itemData.w._mdf || this._isFirstFrame) {\n            styleElem.wi = itemData.w.v;\n        }\n    };\n    CVShapeElement.prototype.destroy = function() {\n        this.shapesData = null;\n        this.globalData = null;\n        this.canvasContext = null;\n        this.stylesList.length = 0;\n        this.itemsData.length = 0;\n    };\n    function CVTextElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.yOffset = 0;\n        this.fillColorAnim = false;\n        this.strokeColorAnim = false;\n        this.strokeWidthAnim = false;\n        this.stroke = false;\n        this.fill = false;\n        this.justifyOffset = 0;\n        this.currentRender = null;\n        this.renderType = 'canvas';\n        this.values = {\n            fill: 'rgba(0,0,0,0)',\n            stroke: 'rgba(0,0,0,0)',\n            sWidth: 0,\n            fValue: ''\n        };\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement,\n        ITextElement\n    ], CVTextElement);\n    CVTextElement.prototype.tHelper = createTag('canvas').getContext('2d');\n    CVTextElement.prototype.buildNewText = function() {\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n        var hasFill = false;\n        if (documentData.fc) {\n            hasFill = true;\n            this.values.fill = this.buildColor(documentData.fc);\n        } else {\n            this.values.fill = 'rgba(0,0,0,0)';\n        }\n        this.fill = hasFill;\n        var hasStroke = false;\n        if (documentData.sc) {\n            hasStroke = true;\n            this.values.stroke = this.buildColor(documentData.sc);\n            this.values.sWidth = documentData.sw;\n        }\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        var i;\n        var len;\n        var letters = documentData.l;\n        var matrixHelper = this.mHelper;\n        this.stroke = hasStroke;\n        this.values.fValue = documentData.finalSize + 'px ' + this.globalData.fontManager.getFontByName(documentData.f).fFamily;\n        len = documentData.finalText.length;\n        // this.tHelper.font = this.values.fValue;\n        var charData;\n        var shapeData;\n        var k;\n        var kLen;\n        var shapes;\n        var j;\n        var jLen;\n        var pathNodes;\n        var commands;\n        var pathArr;\n        var singleShape = this.data.singleShape;\n        var trackingOffset = documentData.tr * 0.001 * documentData.finalSize;\n        var xPos = 0;\n        var yPos = 0;\n        var firstLine = true;\n        var cnt = 0;\n        for(i = 0; i < len; i += 1){\n            charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n            shapeData = charData && charData.data || {};\n            matrixHelper.reset();\n            if (singleShape && letters[i].n) {\n                xPos = -trackingOffset;\n                yPos += documentData.yOffset;\n                yPos += firstLine ? 1 : 0;\n                firstLine = false;\n            }\n            shapes = shapeData.shapes ? shapeData.shapes[0].it : [];\n            jLen = shapes.length;\n            matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n            if (singleShape) {\n                this.applyTextPropertiesToMatrix(documentData, matrixHelper, letters[i].line, xPos, yPos);\n            }\n            commands = createSizedArray(jLen - 1);\n            var commandsCounter = 0;\n            for(j = 0; j < jLen; j += 1){\n                if (shapes[j].ty === 'sh') {\n                    kLen = shapes[j].ks.k.i.length;\n                    pathNodes = shapes[j].ks.k;\n                    pathArr = [];\n                    for(k = 1; k < kLen; k += 1){\n                        if (k === 1) {\n                            pathArr.push(matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n                        }\n                        pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToY(pathNodes.i[k][0], pathNodes.i[k][1], 0), matrixHelper.applyToX(pathNodes.v[k][0], pathNodes.v[k][1], 0), matrixHelper.applyToY(pathNodes.v[k][0], pathNodes.v[k][1], 0));\n                    }\n                    pathArr.push(matrixHelper.applyToX(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToY(pathNodes.o[k - 1][0], pathNodes.o[k - 1][1], 0), matrixHelper.applyToX(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToY(pathNodes.i[0][0], pathNodes.i[0][1], 0), matrixHelper.applyToX(pathNodes.v[0][0], pathNodes.v[0][1], 0), matrixHelper.applyToY(pathNodes.v[0][0], pathNodes.v[0][1], 0));\n                    commands[commandsCounter] = pathArr;\n                    commandsCounter += 1;\n                }\n            }\n            if (singleShape) {\n                xPos += letters[i].l;\n                xPos += trackingOffset;\n            }\n            if (this.textSpans[cnt]) {\n                this.textSpans[cnt].elem = commands;\n            } else {\n                this.textSpans[cnt] = {\n                    elem: commands\n                };\n            }\n            cnt += 1;\n        }\n    };\n    CVTextElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        var ctx = this.canvasContext;\n        ctx.font = this.values.fValue;\n        this.globalData.renderer.ctxLineCap('butt');\n        // ctx.lineCap = 'butt';\n        this.globalData.renderer.ctxLineJoin('miter');\n        // ctx.lineJoin = 'miter';\n        this.globalData.renderer.ctxMiterLimit(4);\n        // ctx.miterLimit = 4;\n        if (!this.data.singleShape) {\n            this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n        }\n        var i;\n        var len;\n        var j;\n        var jLen;\n        var k;\n        var kLen;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var lastFill = null;\n        var lastStroke = null;\n        var lastStrokeW = null;\n        var commands;\n        var pathArr;\n        var renderer = this.globalData.renderer;\n        for(i = 0; i < len; i += 1){\n            if (!letters[i].n) {\n                renderedLetter = renderedLetters[i];\n                if (renderedLetter) {\n                    renderer.save();\n                    renderer.ctxTransform(renderedLetter.p);\n                    renderer.ctxOpacity(renderedLetter.o);\n                }\n                if (this.fill) {\n                    if (renderedLetter && renderedLetter.fc) {\n                        if (lastFill !== renderedLetter.fc) {\n                            renderer.ctxFillStyle(renderedLetter.fc);\n                            lastFill = renderedLetter.fc;\n                        // ctx.fillStyle = renderedLetter.fc;\n                        }\n                    } else if (lastFill !== this.values.fill) {\n                        lastFill = this.values.fill;\n                        renderer.ctxFillStyle(this.values.fill);\n                    // ctx.fillStyle = this.values.fill;\n                    }\n                    commands = this.textSpans[i].elem;\n                    jLen = commands.length;\n                    this.globalData.canvasContext.beginPath();\n                    for(j = 0; j < jLen; j += 1){\n                        pathArr = commands[j];\n                        kLen = pathArr.length;\n                        this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n                        for(k = 2; k < kLen; k += 6){\n                            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n                        }\n                    }\n                    this.globalData.canvasContext.closePath();\n                    renderer.ctxFill();\n                // this.globalData.canvasContext.fill();\n                /// ctx.fillText(this.textSpans[i].val,0,0);\n                }\n                if (this.stroke) {\n                    if (renderedLetter && renderedLetter.sw) {\n                        if (lastStrokeW !== renderedLetter.sw) {\n                            lastStrokeW = renderedLetter.sw;\n                            renderer.ctxLineWidth(renderedLetter.sw);\n                        // ctx.lineWidth = renderedLetter.sw;\n                        }\n                    } else if (lastStrokeW !== this.values.sWidth) {\n                        lastStrokeW = this.values.sWidth;\n                        renderer.ctxLineWidth(this.values.sWidth);\n                    // ctx.lineWidth = this.values.sWidth;\n                    }\n                    if (renderedLetter && renderedLetter.sc) {\n                        if (lastStroke !== renderedLetter.sc) {\n                            lastStroke = renderedLetter.sc;\n                            renderer.ctxStrokeStyle(renderedLetter.sc);\n                        // ctx.strokeStyle = renderedLetter.sc;\n                        }\n                    } else if (lastStroke !== this.values.stroke) {\n                        lastStroke = this.values.stroke;\n                        renderer.ctxStrokeStyle(this.values.stroke);\n                    // ctx.strokeStyle = this.values.stroke;\n                    }\n                    commands = this.textSpans[i].elem;\n                    jLen = commands.length;\n                    this.globalData.canvasContext.beginPath();\n                    for(j = 0; j < jLen; j += 1){\n                        pathArr = commands[j];\n                        kLen = pathArr.length;\n                        this.globalData.canvasContext.moveTo(pathArr[0], pathArr[1]);\n                        for(k = 2; k < kLen; k += 6){\n                            this.globalData.canvasContext.bezierCurveTo(pathArr[k], pathArr[k + 1], pathArr[k + 2], pathArr[k + 3], pathArr[k + 4], pathArr[k + 5]);\n                        }\n                    }\n                    this.globalData.canvasContext.closePath();\n                    renderer.ctxStroke();\n                // this.globalData.canvasContext.stroke();\n                /// ctx.strokeText(letters[i].val,0,0);\n                }\n                if (renderedLetter) {\n                    this.globalData.renderer.restore();\n                }\n            }\n        }\n    };\n    function CVImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        this.img = globalData.imageLoader.getAsset(this.assetData);\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVImageElement);\n    CVImageElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n    CVImageElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n    CVImageElement.prototype.createContent = function() {\n        if (this.img.width && (this.assetData.w !== this.img.width || this.assetData.h !== this.img.height)) {\n            var canvas = createTag('canvas');\n            canvas.width = this.assetData.w;\n            canvas.height = this.assetData.h;\n            var ctx = canvas.getContext('2d');\n            var imgW = this.img.width;\n            var imgH = this.img.height;\n            var imgRel = imgW / imgH;\n            var canvasRel = this.assetData.w / this.assetData.h;\n            var widthCrop;\n            var heightCrop;\n            var par = this.assetData.pr || this.globalData.renderConfig.imagePreserveAspectRatio;\n            if (imgRel > canvasRel && par === 'xMidYMid slice' || imgRel < canvasRel && par !== 'xMidYMid slice') {\n                heightCrop = imgH;\n                widthCrop = heightCrop * canvasRel;\n            } else {\n                widthCrop = imgW;\n                heightCrop = widthCrop / canvasRel;\n            }\n            ctx.drawImage(this.img, (imgW - widthCrop) / 2, (imgH - heightCrop) / 2, widthCrop, heightCrop, 0, 0, this.assetData.w, this.assetData.h);\n            this.img = canvas;\n        }\n    };\n    CVImageElement.prototype.renderInnerContent = function() {\n        this.canvasContext.drawImage(this.img, 0, 0);\n    };\n    CVImageElement.prototype.destroy = function() {\n        this.img = null;\n    };\n    function CVSolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        CVBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], CVSolidElement);\n    CVSolidElement.prototype.initElement = SVGShapeElement.prototype.initElement;\n    CVSolidElement.prototype.prepareFrame = IImageElement.prototype.prepareFrame;\n    CVSolidElement.prototype.renderInnerContent = function() {\n        // var ctx = this.canvasContext;\n        this.globalData.renderer.ctxFillStyle(this.data.sc);\n        // ctx.fillStyle = this.data.sc;\n        this.globalData.renderer.ctxFillRect(0, 0, this.data.sw, this.data.sh);\n    // ctx.fillRect(0, 0, this.data.sw, this.data.sh);\n    //\n    };\n    function CanvasRendererBase() {}\n    extendPrototype([\n        BaseRenderer\n    ], CanvasRendererBase);\n    CanvasRendererBase.prototype.createShape = function(data) {\n        return new CVShapeElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createText = function(data) {\n        return new CVTextElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createImage = function(data) {\n        return new CVImageElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createSolid = function(data) {\n        return new CVSolidElement(data, this.globalData, this);\n    };\n    CanvasRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n    CanvasRendererBase.prototype.ctxTransform = function(props) {\n        if (props[0] === 1 && props[1] === 0 && props[4] === 0 && props[5] === 1 && props[12] === 0 && props[13] === 0) {\n            return;\n        }\n        this.canvasContext.transform(props[0], props[1], props[4], props[5], props[12], props[13]);\n    };\n    CanvasRendererBase.prototype.ctxOpacity = function(op) {\n        this.canvasContext.globalAlpha *= op < 0 ? 0 : op;\n    };\n    CanvasRendererBase.prototype.ctxFillStyle = function(value) {\n        this.canvasContext.fillStyle = value;\n    };\n    CanvasRendererBase.prototype.ctxStrokeStyle = function(value) {\n        this.canvasContext.strokeStyle = value;\n    };\n    CanvasRendererBase.prototype.ctxLineWidth = function(value) {\n        this.canvasContext.lineWidth = value;\n    };\n    CanvasRendererBase.prototype.ctxLineCap = function(value) {\n        this.canvasContext.lineCap = value;\n    };\n    CanvasRendererBase.prototype.ctxLineJoin = function(value) {\n        this.canvasContext.lineJoin = value;\n    };\n    CanvasRendererBase.prototype.ctxMiterLimit = function(value) {\n        this.canvasContext.miterLimit = value;\n    };\n    CanvasRendererBase.prototype.ctxFill = function(rule) {\n        this.canvasContext.fill(rule);\n    };\n    CanvasRendererBase.prototype.ctxFillRect = function(x, y, w, h) {\n        this.canvasContext.fillRect(x, y, w, h);\n    };\n    CanvasRendererBase.prototype.ctxStroke = function() {\n        this.canvasContext.stroke();\n    };\n    CanvasRendererBase.prototype.reset = function() {\n        if (!this.renderConfig.clearCanvas) {\n            this.canvasContext.restore();\n            return;\n        }\n        this.contextData.reset();\n    };\n    CanvasRendererBase.prototype.save = function() {\n        this.canvasContext.save();\n    };\n    CanvasRendererBase.prototype.restore = function(actionFlag) {\n        if (!this.renderConfig.clearCanvas) {\n            this.canvasContext.restore();\n            return;\n        }\n        if (actionFlag) {\n            this.globalData.blendMode = 'source-over';\n        }\n        this.contextData.restore(actionFlag);\n    };\n    CanvasRendererBase.prototype.configAnimation = function(animData) {\n        if (this.animationItem.wrapper) {\n            this.animationItem.container = createTag('canvas');\n            var containerStyle = this.animationItem.container.style;\n            containerStyle.width = '100%';\n            containerStyle.height = '100%';\n            var origin = '0px 0px 0px';\n            containerStyle.transformOrigin = origin;\n            containerStyle.mozTransformOrigin = origin;\n            containerStyle.webkitTransformOrigin = origin;\n            containerStyle['-webkit-transform'] = origin;\n            containerStyle.contentVisibility = this.renderConfig.contentVisibility;\n            this.animationItem.wrapper.appendChild(this.animationItem.container);\n            this.canvasContext = this.animationItem.container.getContext('2d');\n            if (this.renderConfig.className) {\n                this.animationItem.container.setAttribute('class', this.renderConfig.className);\n            }\n            if (this.renderConfig.id) {\n                this.animationItem.container.setAttribute('id', this.renderConfig.id);\n            }\n        } else {\n            this.canvasContext = this.renderConfig.context;\n        }\n        this.contextData.setContext(this.canvasContext);\n        this.data = animData;\n        this.layers = animData.layers;\n        this.transformCanvas = {\n            w: animData.w,\n            h: animData.h,\n            sx: 0,\n            sy: 0,\n            tx: 0,\n            ty: 0\n        };\n        this.setupGlobalData(animData, document.body);\n        this.globalData.canvasContext = this.canvasContext;\n        this.globalData.renderer = this;\n        this.globalData.isDashed = false;\n        this.globalData.progressiveLoad = this.renderConfig.progressiveLoad;\n        this.globalData.transformCanvas = this.transformCanvas;\n        this.elements = createSizedArray(animData.layers.length);\n        this.updateContainerSize();\n    };\n    CanvasRendererBase.prototype.updateContainerSize = function(width, height) {\n        this.reset();\n        var elementWidth;\n        var elementHeight;\n        if (width) {\n            elementWidth = width;\n            elementHeight = height;\n            this.canvasContext.canvas.width = elementWidth;\n            this.canvasContext.canvas.height = elementHeight;\n        } else {\n            if (this.animationItem.wrapper && this.animationItem.container) {\n                elementWidth = this.animationItem.wrapper.offsetWidth;\n                elementHeight = this.animationItem.wrapper.offsetHeight;\n            } else {\n                elementWidth = this.canvasContext.canvas.width;\n                elementHeight = this.canvasContext.canvas.height;\n            }\n            this.canvasContext.canvas.width = elementWidth * this.renderConfig.dpr;\n            this.canvasContext.canvas.height = elementHeight * this.renderConfig.dpr;\n        }\n        var elementRel;\n        var animationRel;\n        if (this.renderConfig.preserveAspectRatio.indexOf('meet') !== -1 || this.renderConfig.preserveAspectRatio.indexOf('slice') !== -1) {\n            var par = this.renderConfig.preserveAspectRatio.split(' ');\n            var fillType = par[1] || 'meet';\n            var pos = par[0] || 'xMidYMid';\n            var xPos = pos.substr(0, 4);\n            var yPos = pos.substr(4);\n            elementRel = elementWidth / elementHeight;\n            animationRel = this.transformCanvas.w / this.transformCanvas.h;\n            if (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice') {\n                this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n                this.transformCanvas.sy = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n            } else {\n                this.transformCanvas.sx = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n                this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n            }\n            if (xPos === 'xMid' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {\n                this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) / 2 * this.renderConfig.dpr;\n            } else if (xPos === 'xMax' && (animationRel < elementRel && fillType === 'meet' || animationRel > elementRel && fillType === 'slice')) {\n                this.transformCanvas.tx = (elementWidth - this.transformCanvas.w * (elementHeight / this.transformCanvas.h)) * this.renderConfig.dpr;\n            } else {\n                this.transformCanvas.tx = 0;\n            }\n            if (yPos === 'YMid' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {\n                this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) / 2 * this.renderConfig.dpr;\n            } else if (yPos === 'YMax' && (animationRel > elementRel && fillType === 'meet' || animationRel < elementRel && fillType === 'slice')) {\n                this.transformCanvas.ty = (elementHeight - this.transformCanvas.h * (elementWidth / this.transformCanvas.w)) * this.renderConfig.dpr;\n            } else {\n                this.transformCanvas.ty = 0;\n            }\n        } else if (this.renderConfig.preserveAspectRatio === 'none') {\n            this.transformCanvas.sx = elementWidth / (this.transformCanvas.w / this.renderConfig.dpr);\n            this.transformCanvas.sy = elementHeight / (this.transformCanvas.h / this.renderConfig.dpr);\n            this.transformCanvas.tx = 0;\n            this.transformCanvas.ty = 0;\n        } else {\n            this.transformCanvas.sx = this.renderConfig.dpr;\n            this.transformCanvas.sy = this.renderConfig.dpr;\n            this.transformCanvas.tx = 0;\n            this.transformCanvas.ty = 0;\n        }\n        this.transformCanvas.props = [\n            this.transformCanvas.sx,\n            0,\n            0,\n            0,\n            0,\n            this.transformCanvas.sy,\n            0,\n            0,\n            0,\n            0,\n            1,\n            0,\n            this.transformCanvas.tx,\n            this.transformCanvas.ty,\n            0,\n            1\n        ];\n        /* var i, len = this.elements.length;\n      for(i=0;i<len;i+=1){\n          if(this.elements[i] && this.elements[i].data.ty === 0){\n              this.elements[i].resize(this.globalData.transformCanvas);\n          }\n      } */ this.ctxTransform(this.transformCanvas.props);\n        this.canvasContext.beginPath();\n        this.canvasContext.rect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n        this.canvasContext.closePath();\n        this.canvasContext.clip();\n        this.renderFrame(this.renderedFrame, true);\n    };\n    CanvasRendererBase.prototype.destroy = function() {\n        if (this.renderConfig.clearCanvas && this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = '';\n        }\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.globalData.canvasContext = null;\n        this.animationItem.container = null;\n        this.destroyed = true;\n    };\n    CanvasRendererBase.prototype.renderFrame = function(num, forceRender) {\n        if (this.renderedFrame === num && this.renderConfig.clearCanvas === true && !forceRender || this.destroyed || num === -1) {\n            return;\n        }\n        this.renderedFrame = num;\n        this.globalData.frameNum = num - this.animationItem._isFirstFrame;\n        this.globalData.frameId += 1;\n        this.globalData._mdf = !this.renderConfig.clearCanvas || forceRender;\n        this.globalData.projectInterface.currentFrame = num;\n        // console.log('--------');\n        // console.log('NEW: ',num);\n        var i;\n        var len = this.layers.length;\n        if (!this.completeLayers) {\n            this.checkLayers(num);\n        }\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].prepareFrame(num - this.layers[i].st);\n            }\n        }\n        if (this.globalData._mdf) {\n            if (this.renderConfig.clearCanvas === true) {\n                this.canvasContext.clearRect(0, 0, this.transformCanvas.w, this.transformCanvas.h);\n            } else {\n                this.save();\n            }\n            for(i = len - 1; i >= 0; i -= 1){\n                if (this.completeLayers || this.elements[i]) {\n                    this.elements[i].renderFrame();\n                }\n            }\n            if (this.renderConfig.clearCanvas !== true) {\n                this.restore();\n            }\n        }\n    };\n    CanvasRendererBase.prototype.buildItem = function(pos) {\n        var elements = this.elements;\n        if (elements[pos] || this.layers[pos].ty === 99) {\n            return;\n        }\n        var element = this.createItem(this.layers[pos], this, this.globalData);\n        elements[pos] = element;\n        element.initExpressions();\n    /* if(this.layers[pos].ty === 0){\n          element.resize(this.globalData.transformCanvas);\n      } */ };\n    CanvasRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n        }\n    };\n    CanvasRendererBase.prototype.hide = function() {\n        this.animationItem.container.style.display = 'none';\n    };\n    CanvasRendererBase.prototype.show = function() {\n        this.animationItem.container.style.display = 'block';\n    };\n    function CanvasContext() {\n        this.opacity = -1;\n        this.transform = createTypedArray('float32', 16);\n        this.fillStyle = '';\n        this.strokeStyle = '';\n        this.lineWidth = '';\n        this.lineCap = '';\n        this.lineJoin = '';\n        this.miterLimit = '';\n        this.id = Math.random();\n    }\n    function CVContextData() {\n        this.stack = [];\n        this.cArrPos = 0;\n        this.cTr = new Matrix();\n        var i;\n        var len = 15;\n        for(i = 0; i < len; i += 1){\n            var canvasContext = new CanvasContext();\n            this.stack[i] = canvasContext;\n        }\n        this._length = len;\n        this.nativeContext = null;\n        this.transformMat = new Matrix();\n        this.currentOpacity = 1;\n        //\n        this.currentFillStyle = '';\n        this.appliedFillStyle = '';\n        //\n        this.currentStrokeStyle = '';\n        this.appliedStrokeStyle = '';\n        //\n        this.currentLineWidth = '';\n        this.appliedLineWidth = '';\n        //\n        this.currentLineCap = '';\n        this.appliedLineCap = '';\n        //\n        this.currentLineJoin = '';\n        this.appliedLineJoin = '';\n        //\n        this.appliedMiterLimit = '';\n        this.currentMiterLimit = '';\n    }\n    CVContextData.prototype.duplicate = function() {\n        var newLength = this._length * 2;\n        var i = 0;\n        for(i = this._length; i < newLength; i += 1){\n            this.stack[i] = new CanvasContext();\n        }\n        this._length = newLength;\n    };\n    CVContextData.prototype.reset = function() {\n        this.cArrPos = 0;\n        this.cTr.reset();\n        this.stack[this.cArrPos].opacity = 1;\n    };\n    CVContextData.prototype.restore = function(forceRestore) {\n        this.cArrPos -= 1;\n        var currentContext = this.stack[this.cArrPos];\n        var transform = currentContext.transform;\n        var i;\n        var arr = this.cTr.props;\n        for(i = 0; i < 16; i += 1){\n            arr[i] = transform[i];\n        }\n        if (forceRestore) {\n            this.nativeContext.restore();\n            var prevStack = this.stack[this.cArrPos + 1];\n            this.appliedFillStyle = prevStack.fillStyle;\n            this.appliedStrokeStyle = prevStack.strokeStyle;\n            this.appliedLineWidth = prevStack.lineWidth;\n            this.appliedLineCap = prevStack.lineCap;\n            this.appliedLineJoin = prevStack.lineJoin;\n            this.appliedMiterLimit = prevStack.miterLimit;\n        }\n        this.nativeContext.setTransform(transform[0], transform[1], transform[4], transform[5], transform[12], transform[13]);\n        if (forceRestore || currentContext.opacity !== -1 && this.currentOpacity !== currentContext.opacity) {\n            this.nativeContext.globalAlpha = currentContext.opacity;\n            this.currentOpacity = currentContext.opacity;\n        }\n        this.currentFillStyle = currentContext.fillStyle;\n        this.currentStrokeStyle = currentContext.strokeStyle;\n        this.currentLineWidth = currentContext.lineWidth;\n        this.currentLineCap = currentContext.lineCap;\n        this.currentLineJoin = currentContext.lineJoin;\n        this.currentMiterLimit = currentContext.miterLimit;\n    };\n    CVContextData.prototype.save = function(saveOnNativeFlag) {\n        if (saveOnNativeFlag) {\n            this.nativeContext.save();\n        }\n        var props = this.cTr.props;\n        if (this._length <= this.cArrPos) {\n            this.duplicate();\n        }\n        var currentStack = this.stack[this.cArrPos];\n        var i;\n        for(i = 0; i < 16; i += 1){\n            currentStack.transform[i] = props[i];\n        }\n        this.cArrPos += 1;\n        var newStack = this.stack[this.cArrPos];\n        newStack.opacity = currentStack.opacity;\n        newStack.fillStyle = currentStack.fillStyle;\n        newStack.strokeStyle = currentStack.strokeStyle;\n        newStack.lineWidth = currentStack.lineWidth;\n        newStack.lineCap = currentStack.lineCap;\n        newStack.lineJoin = currentStack.lineJoin;\n        newStack.miterLimit = currentStack.miterLimit;\n    };\n    CVContextData.prototype.setOpacity = function(value) {\n        this.stack[this.cArrPos].opacity = value;\n    };\n    CVContextData.prototype.setContext = function(value) {\n        this.nativeContext = value;\n    };\n    CVContextData.prototype.fillStyle = function(value) {\n        if (this.stack[this.cArrPos].fillStyle !== value) {\n            this.currentFillStyle = value;\n            this.stack[this.cArrPos].fillStyle = value;\n        }\n    };\n    CVContextData.prototype.strokeStyle = function(value) {\n        if (this.stack[this.cArrPos].strokeStyle !== value) {\n            this.currentStrokeStyle = value;\n            this.stack[this.cArrPos].strokeStyle = value;\n        }\n    };\n    CVContextData.prototype.lineWidth = function(value) {\n        if (this.stack[this.cArrPos].lineWidth !== value) {\n            this.currentLineWidth = value;\n            this.stack[this.cArrPos].lineWidth = value;\n        }\n    };\n    CVContextData.prototype.lineCap = function(value) {\n        if (this.stack[this.cArrPos].lineCap !== value) {\n            this.currentLineCap = value;\n            this.stack[this.cArrPos].lineCap = value;\n        }\n    };\n    CVContextData.prototype.lineJoin = function(value) {\n        if (this.stack[this.cArrPos].lineJoin !== value) {\n            this.currentLineJoin = value;\n            this.stack[this.cArrPos].lineJoin = value;\n        }\n    };\n    CVContextData.prototype.miterLimit = function(value) {\n        if (this.stack[this.cArrPos].miterLimit !== value) {\n            this.currentMiterLimit = value;\n            this.stack[this.cArrPos].miterLimit = value;\n        }\n    };\n    CVContextData.prototype.transform = function(props) {\n        this.transformMat.cloneFromProps(props);\n        // Taking the last transform value from the stored stack of transforms\n        var currentTransform = this.cTr;\n        // Applying the last transform value after the new transform to respect the order of transformations\n        this.transformMat.multiply(currentTransform);\n        // Storing the new transformed value in the stored transform\n        currentTransform.cloneFromProps(this.transformMat.props);\n        var trProps = currentTransform.props;\n        // Applying the new transform to the canvas\n        this.nativeContext.setTransform(trProps[0], trProps[1], trProps[4], trProps[5], trProps[12], trProps[13]);\n    };\n    CVContextData.prototype.opacity = function(op) {\n        var currentOpacity = this.stack[this.cArrPos].opacity;\n        currentOpacity *= op < 0 ? 0 : op;\n        if (this.stack[this.cArrPos].opacity !== currentOpacity) {\n            if (this.currentOpacity !== op) {\n                this.nativeContext.globalAlpha = op;\n                this.currentOpacity = op;\n            }\n            this.stack[this.cArrPos].opacity = currentOpacity;\n        }\n    };\n    CVContextData.prototype.fill = function(rule) {\n        if (this.appliedFillStyle !== this.currentFillStyle) {\n            this.appliedFillStyle = this.currentFillStyle;\n            this.nativeContext.fillStyle = this.appliedFillStyle;\n        }\n        this.nativeContext.fill(rule);\n    };\n    CVContextData.prototype.fillRect = function(x, y, w, h) {\n        if (this.appliedFillStyle !== this.currentFillStyle) {\n            this.appliedFillStyle = this.currentFillStyle;\n            this.nativeContext.fillStyle = this.appliedFillStyle;\n        }\n        this.nativeContext.fillRect(x, y, w, h);\n    };\n    CVContextData.prototype.stroke = function() {\n        if (this.appliedStrokeStyle !== this.currentStrokeStyle) {\n            this.appliedStrokeStyle = this.currentStrokeStyle;\n            this.nativeContext.strokeStyle = this.appliedStrokeStyle;\n        }\n        if (this.appliedLineWidth !== this.currentLineWidth) {\n            this.appliedLineWidth = this.currentLineWidth;\n            this.nativeContext.lineWidth = this.appliedLineWidth;\n        }\n        if (this.appliedLineCap !== this.currentLineCap) {\n            this.appliedLineCap = this.currentLineCap;\n            this.nativeContext.lineCap = this.appliedLineCap;\n        }\n        if (this.appliedLineJoin !== this.currentLineJoin) {\n            this.appliedLineJoin = this.currentLineJoin;\n            this.nativeContext.lineJoin = this.appliedLineJoin;\n        }\n        if (this.appliedMiterLimit !== this.currentMiterLimit) {\n            this.appliedMiterLimit = this.currentMiterLimit;\n            this.nativeContext.miterLimit = this.appliedMiterLimit;\n        }\n        this.nativeContext.stroke();\n    };\n    function CVCompElement(data, globalData, comp) {\n        this.completeLayers = false;\n        this.layers = data.layers;\n        this.pendingElements = [];\n        this.elements = createSizedArray(this.layers.length);\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        CanvasRendererBase,\n        ICompElement,\n        CVBaseElement\n    ], CVCompElement);\n    CVCompElement.prototype.renderInnerContent = function() {\n        var ctx = this.canvasContext;\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(this.data.w, 0);\n        ctx.lineTo(this.data.w, this.data.h);\n        ctx.lineTo(0, this.data.h);\n        ctx.lineTo(0, 0);\n        ctx.clip();\n        var i;\n        var len = this.layers.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.completeLayers || this.elements[i]) {\n                this.elements[i].renderFrame();\n            }\n        }\n    };\n    CVCompElement.prototype.destroy = function() {\n        var i;\n        var len = this.layers.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            if (this.elements[i]) {\n                this.elements[i].destroy();\n            }\n        }\n        this.layers = null;\n        this.elements = null;\n    };\n    CVCompElement.prototype.createComp = function(data) {\n        return new CVCompElement(data, this.globalData, this);\n    };\n    function CanvasRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.renderConfig = {\n            clearCanvas: config && config.clearCanvas !== undefined ? config.clearCanvas : true,\n            context: config && config.context || null,\n            progressiveLoad: config && config.progressiveLoad || false,\n            preserveAspectRatio: config && config.preserveAspectRatio || 'xMidYMid meet',\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n            contentVisibility: config && config.contentVisibility || 'visible',\n            className: config && config.className || '',\n            id: config && config.id || '',\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.renderConfig.dpr = config && config.dpr || 1;\n        if (this.animationItem.wrapper) {\n            this.renderConfig.dpr = config && config.dpr || window.devicePixelRatio || 1;\n        }\n        this.renderedFrame = -1;\n        this.globalData = {\n            frameNum: -1,\n            _mdf: false,\n            renderConfig: this.renderConfig,\n            currentGlobalAlpha: -1\n        };\n        this.contextData = new CVContextData();\n        this.elements = [];\n        this.pendingElements = [];\n        this.transformMat = new Matrix();\n        this.completeLayers = false;\n        this.rendererType = 'canvas';\n        if (this.renderConfig.clearCanvas) {\n            this.ctxTransform = this.contextData.transform.bind(this.contextData);\n            this.ctxOpacity = this.contextData.opacity.bind(this.contextData);\n            this.ctxFillStyle = this.contextData.fillStyle.bind(this.contextData);\n            this.ctxStrokeStyle = this.contextData.strokeStyle.bind(this.contextData);\n            this.ctxLineWidth = this.contextData.lineWidth.bind(this.contextData);\n            this.ctxLineCap = this.contextData.lineCap.bind(this.contextData);\n            this.ctxLineJoin = this.contextData.lineJoin.bind(this.contextData);\n            this.ctxMiterLimit = this.contextData.miterLimit.bind(this.contextData);\n            this.ctxFill = this.contextData.fill.bind(this.contextData);\n            this.ctxFillRect = this.contextData.fillRect.bind(this.contextData);\n            this.ctxStroke = this.contextData.stroke.bind(this.contextData);\n            this.save = this.contextData.save.bind(this.contextData);\n        }\n    }\n    extendPrototype([\n        CanvasRendererBase\n    ], CanvasRenderer);\n    CanvasRenderer.prototype.createComp = function(data) {\n        return new CVCompElement(data, this.globalData, this);\n    };\n    function HBaseElement() {}\n    HBaseElement.prototype = {\n        checkBlendMode: function checkBlendMode() {},\n        initRendererElement: function initRendererElement() {\n            this.baseElement = createTag(this.data.tg || 'div');\n            if (this.data.hasMask) {\n                this.svgElement = createNS('svg');\n                this.layerElement = createNS('g');\n                this.maskedElement = this.layerElement;\n                this.svgElement.appendChild(this.layerElement);\n                this.baseElement.appendChild(this.svgElement);\n            } else {\n                this.layerElement = this.baseElement;\n            }\n            styleDiv(this.baseElement);\n        },\n        createContainerElements: function createContainerElements() {\n            this.renderableEffectsManager = new CVEffects(this);\n            this.transformedElement = this.baseElement;\n            this.maskedElement = this.layerElement;\n            if (this.data.ln) {\n                this.layerElement.setAttribute('id', this.data.ln);\n            }\n            if (this.data.cl) {\n                this.layerElement.setAttribute('class', this.data.cl);\n            }\n            if (this.data.bm !== 0) {\n                this.setBlendMode();\n            }\n        },\n        renderElement: function renderElement() {\n            var transformedElementStyle = this.transformedElement ? this.transformedElement.style : {};\n            if (this.finalTransform._matMdf) {\n                var matrixValue = this.finalTransform.mat.toCSS();\n                transformedElementStyle.transform = matrixValue;\n                transformedElementStyle.webkitTransform = matrixValue;\n            }\n            if (this.finalTransform._opMdf) {\n                transformedElementStyle.opacity = this.finalTransform.mProp.o.v;\n            }\n        },\n        renderFrame: function renderFrame() {\n            // If it is exported as hidden (data.hd === true) no need to render\n            // If it is not visible no need to render\n            if (this.data.hd || this.hidden) {\n                return;\n            }\n            this.renderTransform();\n            this.renderRenderable();\n            this.renderElement();\n            this.renderInnerContent();\n            if (this._isFirstFrame) {\n                this._isFirstFrame = false;\n            }\n        },\n        destroy: function destroy() {\n            this.layerElement = null;\n            this.transformedElement = null;\n            if (this.matteElement) {\n                this.matteElement = null;\n            }\n            if (this.maskManager) {\n                this.maskManager.destroy();\n                this.maskManager = null;\n            }\n        },\n        createRenderableComponents: function createRenderableComponents() {\n            this.maskManager = new MaskElement(this.data, this, this.globalData);\n        },\n        addEffects: function addEffects() {},\n        setMatte: function setMatte() {}\n    };\n    HBaseElement.prototype.getBaseElement = SVGBaseElement.prototype.getBaseElement;\n    HBaseElement.prototype.destroyBaseElement = HBaseElement.prototype.destroy;\n    HBaseElement.prototype.buildElementParenting = BaseRenderer.prototype.buildElementParenting;\n    function HSolidElement(data, globalData, comp) {\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement\n    ], HSolidElement);\n    HSolidElement.prototype.createContent = function() {\n        var rect;\n        if (this.data.hasMask) {\n            rect = createNS('rect');\n            rect.setAttribute('width', this.data.sw);\n            rect.setAttribute('height', this.data.sh);\n            rect.setAttribute('fill', this.data.sc);\n            this.svgElement.setAttribute('width', this.data.sw);\n            this.svgElement.setAttribute('height', this.data.sh);\n        } else {\n            rect = createTag('div');\n            rect.style.width = this.data.sw + 'px';\n            rect.style.height = this.data.sh + 'px';\n            rect.style.backgroundColor = this.data.sc;\n        }\n        this.layerElement.appendChild(rect);\n    };\n    function HShapeElement(data, globalData, comp) {\n        // List of drawable elements\n        this.shapes = [];\n        // Full shape data\n        this.shapesData = data.shapes;\n        // List of styles that will be applied to shapes\n        this.stylesList = [];\n        // List of modifiers that will be applied to shapes\n        this.shapeModifiers = [];\n        // List of items in shape tree\n        this.itemsData = [];\n        // List of items in previous shape tree\n        this.processedElements = [];\n        // List of animated components\n        this.animatedContents = [];\n        this.shapesContainer = createNS('g');\n        this.initElement(data, globalData, comp);\n        // Moving any property that doesn't get too much access after initialization because of v8 way of handling more than 10 properties.\n        // List of elements that have been created\n        this.prevViewData = [];\n        this.currentBBox = {\n            x: 999999,\n            y: -999999,\n            h: 0,\n            w: 0\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HSolidElement,\n        SVGShapeElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], HShapeElement);\n    HShapeElement.prototype._renderShapeFrame = HShapeElement.prototype.renderInnerContent;\n    HShapeElement.prototype.createContent = function() {\n        var cont;\n        this.baseElement.style.fontSize = 0;\n        if (this.data.hasMask) {\n            this.layerElement.appendChild(this.shapesContainer);\n            cont = this.svgElement;\n        } else {\n            cont = createNS('svg');\n            var size = this.comp.data ? this.comp.data : this.globalData.compSize;\n            cont.setAttribute('width', size.w);\n            cont.setAttribute('height', size.h);\n            cont.appendChild(this.shapesContainer);\n            this.layerElement.appendChild(cont);\n        }\n        this.searchShapes(this.shapesData, this.itemsData, this.prevViewData, this.shapesContainer, 0, [], true);\n        this.filterUniqueShapes();\n        this.shapeCont = cont;\n    };\n    HShapeElement.prototype.getTransformedPoint = function(transformers, point) {\n        var i;\n        var len = transformers.length;\n        for(i = 0; i < len; i += 1){\n            point = transformers[i].mProps.v.applyToPointArray(point[0], point[1], 0);\n        }\n        return point;\n    };\n    HShapeElement.prototype.calculateShapeBoundingBox = function(item, boundingBox) {\n        var shape = item.sh.v;\n        var transformers = item.transformers;\n        var i;\n        var len = shape._length;\n        var vPoint;\n        var oPoint;\n        var nextIPoint;\n        var nextVPoint;\n        if (len <= 1) {\n            return;\n        }\n        for(i = 0; i < len - 1; i += 1){\n            vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n            oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n            nextIPoint = this.getTransformedPoint(transformers, shape.i[i + 1]);\n            nextVPoint = this.getTransformedPoint(transformers, shape.v[i + 1]);\n            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n        }\n        if (shape.c) {\n            vPoint = this.getTransformedPoint(transformers, shape.v[i]);\n            oPoint = this.getTransformedPoint(transformers, shape.o[i]);\n            nextIPoint = this.getTransformedPoint(transformers, shape.i[0]);\n            nextVPoint = this.getTransformedPoint(transformers, shape.v[0]);\n            this.checkBounds(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox);\n        }\n    };\n    HShapeElement.prototype.checkBounds = function(vPoint, oPoint, nextIPoint, nextVPoint, boundingBox) {\n        this.getBoundsOfCurve(vPoint, oPoint, nextIPoint, nextVPoint);\n        var bounds = this.shapeBoundingBox;\n        boundingBox.x = bmMin(bounds.left, boundingBox.x);\n        boundingBox.xMax = bmMax(bounds.right, boundingBox.xMax);\n        boundingBox.y = bmMin(bounds.top, boundingBox.y);\n        boundingBox.yMax = bmMax(bounds.bottom, boundingBox.yMax);\n    };\n    HShapeElement.prototype.shapeBoundingBox = {\n        left: 0,\n        right: 0,\n        top: 0,\n        bottom: 0\n    };\n    HShapeElement.prototype.tempBoundingBox = {\n        x: 0,\n        xMax: 0,\n        y: 0,\n        yMax: 0,\n        width: 0,\n        height: 0\n    };\n    HShapeElement.prototype.getBoundsOfCurve = function(p0, p1, p2, p3) {\n        var bounds = [\n            [\n                p0[0],\n                p3[0]\n            ],\n            [\n                p0[1],\n                p3[1]\n            ]\n        ];\n        for(var a, b, c, t, b2ac, t1, t2, i = 0; i < 2; ++i){\n            // eslint-disable-line no-plusplus\n            b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n            a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n            c = 3 * p1[i] - 3 * p0[i];\n            b |= 0; // eslint-disable-line no-bitwise\n            a |= 0; // eslint-disable-line no-bitwise\n            c |= 0; // eslint-disable-line no-bitwise\n            if (a === 0 && b === 0) {\n            //\n            } else if (a === 0) {\n                t = -c / b;\n                if (t > 0 && t < 1) {\n                    bounds[i].push(this.calculateF(t, p0, p1, p2, p3, i));\n                }\n            } else {\n                b2ac = b * b - 4 * c * a;\n                if (b2ac >= 0) {\n                    t1 = (-b + bmSqrt(b2ac)) / (2 * a);\n                    if (t1 > 0 && t1 < 1) bounds[i].push(this.calculateF(t1, p0, p1, p2, p3, i));\n                    t2 = (-b - bmSqrt(b2ac)) / (2 * a);\n                    if (t2 > 0 && t2 < 1) bounds[i].push(this.calculateF(t2, p0, p1, p2, p3, i));\n                }\n            }\n        }\n        this.shapeBoundingBox.left = bmMin.apply(null, bounds[0]);\n        this.shapeBoundingBox.top = bmMin.apply(null, bounds[1]);\n        this.shapeBoundingBox.right = bmMax.apply(null, bounds[0]);\n        this.shapeBoundingBox.bottom = bmMax.apply(null, bounds[1]);\n    };\n    HShapeElement.prototype.calculateF = function(t, p0, p1, p2, p3, i) {\n        return bmPow(1 - t, 3) * p0[i] + 3 * bmPow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * bmPow(t, 2) * p2[i] + bmPow(t, 3) * p3[i];\n    };\n    HShapeElement.prototype.calculateBoundingBox = function(itemsData, boundingBox) {\n        var i;\n        var len = itemsData.length;\n        for(i = 0; i < len; i += 1){\n            if (itemsData[i] && itemsData[i].sh) {\n                this.calculateShapeBoundingBox(itemsData[i], boundingBox);\n            } else if (itemsData[i] && itemsData[i].it) {\n                this.calculateBoundingBox(itemsData[i].it, boundingBox);\n            } else if (itemsData[i] && itemsData[i].style && itemsData[i].w) {\n                this.expandStrokeBoundingBox(itemsData[i].w, boundingBox);\n            }\n        }\n    };\n    HShapeElement.prototype.expandStrokeBoundingBox = function(widthProperty, boundingBox) {\n        var width = 0;\n        if (widthProperty.keyframes) {\n            for(var i = 0; i < widthProperty.keyframes.length; i += 1){\n                var kfw = widthProperty.keyframes[i].s;\n                if (kfw > width) {\n                    width = kfw;\n                }\n            }\n            width *= widthProperty.mult;\n        } else {\n            width = widthProperty.v * widthProperty.mult;\n        }\n        boundingBox.x -= width;\n        boundingBox.xMax += width;\n        boundingBox.y -= width;\n        boundingBox.yMax += width;\n    };\n    HShapeElement.prototype.currentBoxContains = function(box) {\n        return this.currentBBox.x <= box.x && this.currentBBox.y <= box.y && this.currentBBox.width + this.currentBBox.x >= box.x + box.width && this.currentBBox.height + this.currentBBox.y >= box.y + box.height;\n    };\n    HShapeElement.prototype.renderInnerContent = function() {\n        this._renderShapeFrame();\n        if (!this.hidden && (this._isFirstFrame || this._mdf)) {\n            var tempBoundingBox = this.tempBoundingBox;\n            var max = 999999;\n            tempBoundingBox.x = max;\n            tempBoundingBox.xMax = -max;\n            tempBoundingBox.y = max;\n            tempBoundingBox.yMax = -max;\n            this.calculateBoundingBox(this.itemsData, tempBoundingBox);\n            tempBoundingBox.width = tempBoundingBox.xMax < tempBoundingBox.x ? 0 : tempBoundingBox.xMax - tempBoundingBox.x;\n            tempBoundingBox.height = tempBoundingBox.yMax < tempBoundingBox.y ? 0 : tempBoundingBox.yMax - tempBoundingBox.y;\n            // var tempBoundingBox = this.shapeCont.getBBox();\n            if (this.currentBoxContains(tempBoundingBox)) {\n                return;\n            }\n            var changed = false;\n            if (this.currentBBox.w !== tempBoundingBox.width) {\n                this.currentBBox.w = tempBoundingBox.width;\n                this.shapeCont.setAttribute('width', tempBoundingBox.width);\n                changed = true;\n            }\n            if (this.currentBBox.h !== tempBoundingBox.height) {\n                this.currentBBox.h = tempBoundingBox.height;\n                this.shapeCont.setAttribute('height', tempBoundingBox.height);\n                changed = true;\n            }\n            if (changed || this.currentBBox.x !== tempBoundingBox.x || this.currentBBox.y !== tempBoundingBox.y) {\n                this.currentBBox.w = tempBoundingBox.width;\n                this.currentBBox.h = tempBoundingBox.height;\n                this.currentBBox.x = tempBoundingBox.x;\n                this.currentBBox.y = tempBoundingBox.y;\n                this.shapeCont.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);\n                var shapeStyle = this.shapeCont.style;\n                var shapeTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\n                shapeStyle.transform = shapeTransform;\n                shapeStyle.webkitTransform = shapeTransform;\n            }\n        }\n    };\n    function HTextElement(data, globalData, comp) {\n        this.textSpans = [];\n        this.textPaths = [];\n        this.currentBBox = {\n            x: 999999,\n            y: -999999,\n            h: 0,\n            w: 0\n        };\n        this.renderType = 'svg';\n        this.isMasked = false;\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableDOMElement,\n        ITextElement\n    ], HTextElement);\n    HTextElement.prototype.createContent = function() {\n        this.isMasked = this.checkMasks();\n        if (this.isMasked) {\n            this.renderType = 'svg';\n            this.compW = this.comp.data.w;\n            this.compH = this.comp.data.h;\n            this.svgElement.setAttribute('width', this.compW);\n            this.svgElement.setAttribute('height', this.compH);\n            var g = createNS('g');\n            this.maskedElement.appendChild(g);\n            this.innerElem = g;\n        } else {\n            this.renderType = 'html';\n            this.innerElem = this.layerElement;\n        }\n        this.checkParenting();\n    };\n    HTextElement.prototype.buildNewText = function() {\n        var documentData = this.textProperty.currentData;\n        this.renderedLetters = createSizedArray(documentData.l ? documentData.l.length : 0);\n        var innerElemStyle = this.innerElem.style;\n        var textColor = documentData.fc ? this.buildColor(documentData.fc) : 'rgba(0,0,0,0)';\n        innerElemStyle.fill = textColor;\n        innerElemStyle.color = textColor;\n        if (documentData.sc) {\n            innerElemStyle.stroke = this.buildColor(documentData.sc);\n            innerElemStyle.strokeWidth = documentData.sw + 'px';\n        }\n        var fontData = this.globalData.fontManager.getFontByName(documentData.f);\n        if (!this.globalData.fontManager.chars) {\n            innerElemStyle.fontSize = documentData.finalSize + 'px';\n            innerElemStyle.lineHeight = documentData.finalSize + 'px';\n            if (fontData.fClass) {\n                this.innerElem.className = fontData.fClass;\n            } else {\n                innerElemStyle.fontFamily = fontData.fFamily;\n                var fWeight = documentData.fWeight;\n                var fStyle = documentData.fStyle;\n                innerElemStyle.fontStyle = fStyle;\n                innerElemStyle.fontWeight = fWeight;\n            }\n        }\n        var i;\n        var len;\n        var letters = documentData.l;\n        len = letters.length;\n        var tSpan;\n        var tParent;\n        var tCont;\n        var matrixHelper = this.mHelper;\n        var shapes;\n        var shapeStr = '';\n        var cnt = 0;\n        for(i = 0; i < len; i += 1){\n            if (this.globalData.fontManager.chars) {\n                if (!this.textPaths[cnt]) {\n                    tSpan = createNS('path');\n                    tSpan.setAttribute('stroke-linecap', lineCapEnum[1]);\n                    tSpan.setAttribute('stroke-linejoin', lineJoinEnum[2]);\n                    tSpan.setAttribute('stroke-miterlimit', '4');\n                } else {\n                    tSpan = this.textPaths[cnt];\n                }\n                if (!this.isMasked) {\n                    if (this.textSpans[cnt]) {\n                        tParent = this.textSpans[cnt];\n                        tCont = tParent.children[0];\n                    } else {\n                        tParent = createTag('div');\n                        tParent.style.lineHeight = 0;\n                        tCont = createNS('svg');\n                        tCont.appendChild(tSpan);\n                        styleDiv(tParent);\n                    }\n                }\n            } else if (!this.isMasked) {\n                if (this.textSpans[cnt]) {\n                    tParent = this.textSpans[cnt];\n                    tSpan = this.textPaths[cnt];\n                } else {\n                    tParent = createTag('span');\n                    styleDiv(tParent);\n                    tSpan = createTag('span');\n                    styleDiv(tSpan);\n                    tParent.appendChild(tSpan);\n                }\n            } else {\n                tSpan = this.textPaths[cnt] ? this.textPaths[cnt] : createNS('text');\n            }\n            // tSpan.setAttribute('visibility', 'hidden');\n            if (this.globalData.fontManager.chars) {\n                var charData = this.globalData.fontManager.getCharData(documentData.finalText[i], fontData.fStyle, this.globalData.fontManager.getFontByName(documentData.f).fFamily);\n                var shapeData;\n                if (charData) {\n                    shapeData = charData.data;\n                } else {\n                    shapeData = null;\n                }\n                matrixHelper.reset();\n                if (shapeData && shapeData.shapes && shapeData.shapes.length) {\n                    shapes = shapeData.shapes[0].it;\n                    matrixHelper.scale(documentData.finalSize / 100, documentData.finalSize / 100);\n                    shapeStr = this.createPathShape(matrixHelper, shapes);\n                    tSpan.setAttribute('d', shapeStr);\n                }\n                if (!this.isMasked) {\n                    this.innerElem.appendChild(tParent);\n                    if (shapeData && shapeData.shapes) {\n                        // document.body.appendChild is needed to get exact measure of shape\n                        document.body.appendChild(tCont);\n                        var boundingBox = tCont.getBBox();\n                        tCont.setAttribute('width', boundingBox.width + 2);\n                        tCont.setAttribute('height', boundingBox.height + 2);\n                        tCont.setAttribute('viewBox', boundingBox.x - 1 + ' ' + (boundingBox.y - 1) + ' ' + (boundingBox.width + 2) + ' ' + (boundingBox.height + 2));\n                        var tContStyle = tCont.style;\n                        var tContTranslation = 'translate(' + (boundingBox.x - 1) + 'px,' + (boundingBox.y - 1) + 'px)';\n                        tContStyle.transform = tContTranslation;\n                        tContStyle.webkitTransform = tContTranslation;\n                        letters[i].yOffset = boundingBox.y - 1;\n                    } else {\n                        tCont.setAttribute('width', 1);\n                        tCont.setAttribute('height', 1);\n                    }\n                    tParent.appendChild(tCont);\n                } else {\n                    this.innerElem.appendChild(tSpan);\n                }\n            } else {\n                tSpan.textContent = letters[i].val;\n                tSpan.setAttributeNS('http://www.w3.org/XML/1998/namespace', 'xml:space', 'preserve');\n                if (!this.isMasked) {\n                    this.innerElem.appendChild(tParent);\n                    //\n                    var tStyle = tSpan.style;\n                    var tSpanTranslation = 'translate3d(0,' + -documentData.finalSize / 1.2 + 'px,0)';\n                    tStyle.transform = tSpanTranslation;\n                    tStyle.webkitTransform = tSpanTranslation;\n                } else {\n                    this.innerElem.appendChild(tSpan);\n                }\n            }\n            //\n            if (!this.isMasked) {\n                this.textSpans[cnt] = tParent;\n            } else {\n                this.textSpans[cnt] = tSpan;\n            }\n            this.textSpans[cnt].style.display = 'block';\n            this.textPaths[cnt] = tSpan;\n            cnt += 1;\n        }\n        while(cnt < this.textSpans.length){\n            this.textSpans[cnt].style.display = 'none';\n            cnt += 1;\n        }\n    };\n    HTextElement.prototype.renderInnerContent = function() {\n        this.validateText();\n        var svgStyle;\n        if (this.data.singleShape) {\n            if (!this._isFirstFrame && !this.lettersChangedFlag) {\n                return;\n            }\n            if (this.isMasked && this.finalTransform._matMdf) {\n                // Todo Benchmark if using this is better than getBBox\n                this.svgElement.setAttribute('viewBox', -this.finalTransform.mProp.p.v[0] + ' ' + -this.finalTransform.mProp.p.v[1] + ' ' + this.compW + ' ' + this.compH);\n                svgStyle = this.svgElement.style;\n                var translation = 'translate(' + -this.finalTransform.mProp.p.v[0] + 'px,' + -this.finalTransform.mProp.p.v[1] + 'px)';\n                svgStyle.transform = translation;\n                svgStyle.webkitTransform = translation;\n            }\n        }\n        this.textAnimator.getMeasures(this.textProperty.currentData, this.lettersChangedFlag);\n        if (!this.lettersChangedFlag && !this.textAnimator.lettersChangedFlag) {\n            return;\n        }\n        var i;\n        var len;\n        var count = 0;\n        var renderedLetters = this.textAnimator.renderedLetters;\n        var letters = this.textProperty.currentData.l;\n        len = letters.length;\n        var renderedLetter;\n        var textSpan;\n        var textPath;\n        for(i = 0; i < len; i += 1){\n            if (letters[i].n) {\n                count += 1;\n            } else {\n                textSpan = this.textSpans[i];\n                textPath = this.textPaths[i];\n                renderedLetter = renderedLetters[count];\n                count += 1;\n                if (renderedLetter._mdf.m) {\n                    if (!this.isMasked) {\n                        textSpan.style.webkitTransform = renderedLetter.m;\n                        textSpan.style.transform = renderedLetter.m;\n                    } else {\n                        textSpan.setAttribute('transform', renderedLetter.m);\n                    }\n                }\n                /// /textSpan.setAttribute('opacity',renderedLetter.o);\n                textSpan.style.opacity = renderedLetter.o;\n                if (renderedLetter.sw && renderedLetter._mdf.sw) {\n                    textPath.setAttribute('stroke-width', renderedLetter.sw);\n                }\n                if (renderedLetter.sc && renderedLetter._mdf.sc) {\n                    textPath.setAttribute('stroke', renderedLetter.sc);\n                }\n                if (renderedLetter.fc && renderedLetter._mdf.fc) {\n                    textPath.setAttribute('fill', renderedLetter.fc);\n                    textPath.style.color = renderedLetter.fc;\n                }\n            }\n        }\n        if (this.innerElem.getBBox && !this.hidden && (this._isFirstFrame || this._mdf)) {\n            var boundingBox = this.innerElem.getBBox();\n            if (this.currentBBox.w !== boundingBox.width) {\n                this.currentBBox.w = boundingBox.width;\n                this.svgElement.setAttribute('width', boundingBox.width);\n            }\n            if (this.currentBBox.h !== boundingBox.height) {\n                this.currentBBox.h = boundingBox.height;\n                this.svgElement.setAttribute('height', boundingBox.height);\n            }\n            var margin = 1;\n            if (this.currentBBox.w !== boundingBox.width + margin * 2 || this.currentBBox.h !== boundingBox.height + margin * 2 || this.currentBBox.x !== boundingBox.x - margin || this.currentBBox.y !== boundingBox.y - margin) {\n                this.currentBBox.w = boundingBox.width + margin * 2;\n                this.currentBBox.h = boundingBox.height + margin * 2;\n                this.currentBBox.x = boundingBox.x - margin;\n                this.currentBBox.y = boundingBox.y - margin;\n                this.svgElement.setAttribute('viewBox', this.currentBBox.x + ' ' + this.currentBBox.y + ' ' + this.currentBBox.w + ' ' + this.currentBBox.h);\n                svgStyle = this.svgElement.style;\n                var svgTransform = 'translate(' + this.currentBBox.x + 'px,' + this.currentBBox.y + 'px)';\n                svgStyle.transform = svgTransform;\n                svgStyle.webkitTransform = svgTransform;\n            }\n        }\n    };\n    function HCameraElement(data, globalData, comp) {\n        this.initFrame();\n        this.initBaseData(data, globalData, comp);\n        this.initHierarchy();\n        var getProp = PropertyFactory.getProp;\n        this.pe = getProp(this, data.pe, 0, 0, this);\n        if (data.ks.p.s) {\n            this.px = getProp(this, data.ks.p.x, 1, 0, this);\n            this.py = getProp(this, data.ks.p.y, 1, 0, this);\n            this.pz = getProp(this, data.ks.p.z, 1, 0, this);\n        } else {\n            this.p = getProp(this, data.ks.p, 1, 0, this);\n        }\n        if (data.ks.a) {\n            this.a = getProp(this, data.ks.a, 1, 0, this);\n        }\n        if (data.ks.or.k.length && data.ks.or.k[0].to) {\n            var i;\n            var len = data.ks.or.k.length;\n            for(i = 0; i < len; i += 1){\n                data.ks.or.k[i].to = null;\n                data.ks.or.k[i].ti = null;\n            }\n        }\n        this.or = getProp(this, data.ks.or, 1, degToRads, this);\n        this.or.sh = true;\n        this.rx = getProp(this, data.ks.rx, 0, degToRads, this);\n        this.ry = getProp(this, data.ks.ry, 0, degToRads, this);\n        this.rz = getProp(this, data.ks.rz, 0, degToRads, this);\n        this.mat = new Matrix();\n        this._prevMat = new Matrix();\n        this._isFirstFrame = true;\n        // TODO: find a better way to make the HCamera element to be compatible with the LayerInterface and TransformInterface.\n        this.finalTransform = {\n            mProp: this\n        };\n    }\n    extendPrototype([\n        BaseElement,\n        FrameElement,\n        HierarchyElement\n    ], HCameraElement);\n    HCameraElement.prototype.setup = function() {\n        var i;\n        var len = this.comp.threeDElements.length;\n        var comp;\n        var perspectiveStyle;\n        var containerStyle;\n        for(i = 0; i < len; i += 1){\n            // [perspectiveElem,container]\n            comp = this.comp.threeDElements[i];\n            if (comp.type === '3d') {\n                perspectiveStyle = comp.perspectiveElem.style;\n                containerStyle = comp.container.style;\n                var perspective = this.pe.v + 'px';\n                var origin = '0px 0px 0px';\n                var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\n                perspectiveStyle.perspective = perspective;\n                perspectiveStyle.webkitPerspective = perspective;\n                containerStyle.transformOrigin = origin;\n                containerStyle.mozTransformOrigin = origin;\n                containerStyle.webkitTransformOrigin = origin;\n                perspectiveStyle.transform = matrix;\n                perspectiveStyle.webkitTransform = matrix;\n            }\n        }\n    };\n    HCameraElement.prototype.createElements = function() {};\n    HCameraElement.prototype.hide = function() {};\n    HCameraElement.prototype.renderFrame = function() {\n        var _mdf = this._isFirstFrame;\n        var i;\n        var len;\n        if (this.hierarchy) {\n            len = this.hierarchy.length;\n            for(i = 0; i < len; i += 1){\n                _mdf = this.hierarchy[i].finalTransform.mProp._mdf || _mdf;\n            }\n        }\n        if (_mdf || this.pe._mdf || this.p && this.p._mdf || this.px && (this.px._mdf || this.py._mdf || this.pz._mdf) || this.rx._mdf || this.ry._mdf || this.rz._mdf || this.or._mdf || this.a && this.a._mdf) {\n            this.mat.reset();\n            if (this.hierarchy) {\n                len = this.hierarchy.length - 1;\n                for(i = len; i >= 0; i -= 1){\n                    var mTransf = this.hierarchy[i].finalTransform.mProp;\n                    this.mat.translate(-mTransf.p.v[0], -mTransf.p.v[1], mTransf.p.v[2]);\n                    this.mat.rotateX(-mTransf.or.v[0]).rotateY(-mTransf.or.v[1]).rotateZ(mTransf.or.v[2]);\n                    this.mat.rotateX(-mTransf.rx.v).rotateY(-mTransf.ry.v).rotateZ(mTransf.rz.v);\n                    this.mat.scale(1 / mTransf.s.v[0], 1 / mTransf.s.v[1], 1 / mTransf.s.v[2]);\n                    this.mat.translate(mTransf.a.v[0], mTransf.a.v[1], mTransf.a.v[2]);\n                }\n            }\n            if (this.p) {\n                this.mat.translate(-this.p.v[0], -this.p.v[1], this.p.v[2]);\n            } else {\n                this.mat.translate(-this.px.v, -this.py.v, this.pz.v);\n            }\n            if (this.a) {\n                var diffVector;\n                if (this.p) {\n                    diffVector = [\n                        this.p.v[0] - this.a.v[0],\n                        this.p.v[1] - this.a.v[1],\n                        this.p.v[2] - this.a.v[2]\n                    ];\n                } else {\n                    diffVector = [\n                        this.px.v - this.a.v[0],\n                        this.py.v - this.a.v[1],\n                        this.pz.v - this.a.v[2]\n                    ];\n                }\n                var mag = Math.sqrt(Math.pow(diffVector[0], 2) + Math.pow(diffVector[1], 2) + Math.pow(diffVector[2], 2));\n                // var lookDir = getNormalizedPoint(getDiffVector(this.a.v,this.p.v));\n                var lookDir = [\n                    diffVector[0] / mag,\n                    diffVector[1] / mag,\n                    diffVector[2] / mag\n                ];\n                var lookLengthOnXZ = Math.sqrt(lookDir[2] * lookDir[2] + lookDir[0] * lookDir[0]);\n                var mRotationX = Math.atan2(lookDir[1], lookLengthOnXZ);\n                var mRotationY = Math.atan2(lookDir[0], -lookDir[2]);\n                this.mat.rotateY(mRotationY).rotateX(-mRotationX);\n            }\n            this.mat.rotateX(-this.rx.v).rotateY(-this.ry.v).rotateZ(this.rz.v);\n            this.mat.rotateX(-this.or.v[0]).rotateY(-this.or.v[1]).rotateZ(this.or.v[2]);\n            this.mat.translate(this.globalData.compSize.w / 2, this.globalData.compSize.h / 2, 0);\n            this.mat.translate(0, 0, this.pe.v);\n            var hasMatrixChanged = !this._prevMat.equals(this.mat);\n            if ((hasMatrixChanged || this.pe._mdf) && this.comp.threeDElements) {\n                len = this.comp.threeDElements.length;\n                var comp;\n                var perspectiveStyle;\n                var containerStyle;\n                for(i = 0; i < len; i += 1){\n                    comp = this.comp.threeDElements[i];\n                    if (comp.type === '3d') {\n                        if (hasMatrixChanged) {\n                            var matValue = this.mat.toCSS();\n                            containerStyle = comp.container.style;\n                            containerStyle.transform = matValue;\n                            containerStyle.webkitTransform = matValue;\n                        }\n                        if (this.pe._mdf) {\n                            perspectiveStyle = comp.perspectiveElem.style;\n                            perspectiveStyle.perspective = this.pe.v + 'px';\n                            perspectiveStyle.webkitPerspective = this.pe.v + 'px';\n                        }\n                    }\n                }\n                this.mat.clone(this._prevMat);\n            }\n        }\n        this._isFirstFrame = false;\n    };\n    HCameraElement.prototype.prepareFrame = function(num) {\n        this.prepareProperties(num, true);\n    };\n    HCameraElement.prototype.destroy = function() {};\n    HCameraElement.prototype.getBaseElement = function() {\n        return null;\n    };\n    function HImageElement(data, globalData, comp) {\n        this.assetData = globalData.getAssetData(data.refId);\n        this.initElement(data, globalData, comp);\n    }\n    extendPrototype([\n        BaseElement,\n        TransformElement,\n        HBaseElement,\n        HSolidElement,\n        HierarchyElement,\n        FrameElement,\n        RenderableElement\n    ], HImageElement);\n    HImageElement.prototype.createContent = function() {\n        var assetPath = this.globalData.getAssetsPath(this.assetData);\n        var img = new Image();\n        if (this.data.hasMask) {\n            this.imageElem = createNS('image');\n            this.imageElem.setAttribute('width', this.assetData.w + 'px');\n            this.imageElem.setAttribute('height', this.assetData.h + 'px');\n            this.imageElem.setAttributeNS('http://www.w3.org/1999/xlink', 'href', assetPath);\n            this.layerElement.appendChild(this.imageElem);\n            this.baseElement.setAttribute('width', this.assetData.w);\n            this.baseElement.setAttribute('height', this.assetData.h);\n        } else {\n            this.layerElement.appendChild(img);\n        }\n        img.crossOrigin = 'anonymous';\n        img.src = assetPath;\n        if (this.data.ln) {\n            this.baseElement.setAttribute('id', this.data.ln);\n        }\n    };\n    function HybridRendererBase(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.renderConfig = {\n            className: config && config.className || '',\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || '400%',\n                height: config && config.filterSize && config.filterSize.height || '400%',\n                x: config && config.filterSize && config.filterSize.x || '-100%',\n                y: config && config.filterSize && config.filterSize.y || '-100%'\n            }\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            renderConfig: this.renderConfig\n        };\n        this.pendingElements = [];\n        this.elements = [];\n        this.threeDElements = [];\n        this.destroyed = false;\n        this.camera = null;\n        this.supports3d = true;\n        this.rendererType = 'html';\n    }\n    extendPrototype([\n        BaseRenderer\n    ], HybridRendererBase);\n    HybridRendererBase.prototype.buildItem = SVGRenderer.prototype.buildItem;\n    HybridRendererBase.prototype.checkPendingElements = function() {\n        while(this.pendingElements.length){\n            var element = this.pendingElements.pop();\n            element.checkParenting();\n        }\n    };\n    HybridRendererBase.prototype.appendElementInPos = function(element, pos) {\n        var newDOMElement = element.getBaseElement();\n        if (!newDOMElement) {\n            return;\n        }\n        var layer = this.layers[pos];\n        if (!layer.ddd || !this.supports3d) {\n            if (this.threeDElements) {\n                this.addTo3dContainer(newDOMElement, pos);\n            } else {\n                var i = 0;\n                var nextDOMElement;\n                var nextLayer;\n                var tmpDOMElement;\n                while(i < pos){\n                    if (this.elements[i] && this.elements[i] !== true && this.elements[i].getBaseElement) {\n                        nextLayer = this.elements[i];\n                        tmpDOMElement = this.layers[i].ddd ? this.getThreeDContainerByPos(i) : nextLayer.getBaseElement();\n                        nextDOMElement = tmpDOMElement || nextDOMElement;\n                    }\n                    i += 1;\n                }\n                if (nextDOMElement) {\n                    if (!layer.ddd || !this.supports3d) {\n                        this.layerElement.insertBefore(newDOMElement, nextDOMElement);\n                    }\n                } else if (!layer.ddd || !this.supports3d) {\n                    this.layerElement.appendChild(newDOMElement);\n                }\n            }\n        } else {\n            this.addTo3dContainer(newDOMElement, pos);\n        }\n    };\n    HybridRendererBase.prototype.createShape = function(data) {\n        if (!this.supports3d) {\n            return new SVGShapeElement(data, this.globalData, this);\n        }\n        return new HShapeElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createText = function(data) {\n        if (!this.supports3d) {\n            return new SVGTextLottieElement(data, this.globalData, this);\n        }\n        return new HTextElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createCamera = function(data) {\n        this.camera = new HCameraElement(data, this.globalData, this);\n        return this.camera;\n    };\n    HybridRendererBase.prototype.createImage = function(data) {\n        if (!this.supports3d) {\n            return new IImageElement(data, this.globalData, this);\n        }\n        return new HImageElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createSolid = function(data) {\n        if (!this.supports3d) {\n            return new ISolidElement(data, this.globalData, this);\n        }\n        return new HSolidElement(data, this.globalData, this);\n    };\n    HybridRendererBase.prototype.createNull = SVGRenderer.prototype.createNull;\n    HybridRendererBase.prototype.getThreeDContainerByPos = function(pos) {\n        var i = 0;\n        var len = this.threeDElements.length;\n        while(i < len){\n            if (this.threeDElements[i].startPos <= pos && this.threeDElements[i].endPos >= pos) {\n                return this.threeDElements[i].perspectiveElem;\n            }\n            i += 1;\n        }\n        return null;\n    };\n    HybridRendererBase.prototype.createThreeDContainer = function(pos, type) {\n        var perspectiveElem = createTag('div');\n        var style;\n        var containerStyle;\n        styleDiv(perspectiveElem);\n        var container = createTag('div');\n        styleDiv(container);\n        if (type === '3d') {\n            style = perspectiveElem.style;\n            style.width = this.globalData.compSize.w + 'px';\n            style.height = this.globalData.compSize.h + 'px';\n            var center = '50% 50%';\n            style.webkitTransformOrigin = center;\n            style.mozTransformOrigin = center;\n            style.transformOrigin = center;\n            containerStyle = container.style;\n            var matrix = 'matrix3d(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1)';\n            containerStyle.transform = matrix;\n            containerStyle.webkitTransform = matrix;\n        }\n        perspectiveElem.appendChild(container);\n        // this.resizerElem.appendChild(perspectiveElem);\n        var threeDContainerData = {\n            container: container,\n            perspectiveElem: perspectiveElem,\n            startPos: pos,\n            endPos: pos,\n            type: type\n        };\n        this.threeDElements.push(threeDContainerData);\n        return threeDContainerData;\n    };\n    HybridRendererBase.prototype.build3dContainers = function() {\n        var i;\n        var len = this.layers.length;\n        var lastThreeDContainerData;\n        var currentContainer = '';\n        for(i = 0; i < len; i += 1){\n            if (this.layers[i].ddd && this.layers[i].ty !== 3) {\n                if (currentContainer !== '3d') {\n                    currentContainer = '3d';\n                    lastThreeDContainerData = this.createThreeDContainer(i, '3d');\n                }\n                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n            } else {\n                if (currentContainer !== '2d') {\n                    currentContainer = '2d';\n                    lastThreeDContainerData = this.createThreeDContainer(i, '2d');\n                }\n                lastThreeDContainerData.endPos = Math.max(lastThreeDContainerData.endPos, i);\n            }\n        }\n        len = this.threeDElements.length;\n        for(i = len - 1; i >= 0; i -= 1){\n            this.resizerElem.appendChild(this.threeDElements[i].perspectiveElem);\n        }\n    };\n    HybridRendererBase.prototype.addTo3dContainer = function(elem, pos) {\n        var i = 0;\n        var len = this.threeDElements.length;\n        while(i < len){\n            if (pos <= this.threeDElements[i].endPos) {\n                var j = this.threeDElements[i].startPos;\n                var nextElement;\n                while(j < pos){\n                    if (this.elements[j] && this.elements[j].getBaseElement) {\n                        nextElement = this.elements[j].getBaseElement();\n                    }\n                    j += 1;\n                }\n                if (nextElement) {\n                    this.threeDElements[i].container.insertBefore(elem, nextElement);\n                } else {\n                    this.threeDElements[i].container.appendChild(elem);\n                }\n                break;\n            }\n            i += 1;\n        }\n    };\n    HybridRendererBase.prototype.configAnimation = function(animData) {\n        var resizerElem = createTag('div');\n        var wrapper = this.animationItem.wrapper;\n        var style = resizerElem.style;\n        style.width = animData.w + 'px';\n        style.height = animData.h + 'px';\n        this.resizerElem = resizerElem;\n        styleDiv(resizerElem);\n        style.transformStyle = 'flat';\n        style.mozTransformStyle = 'flat';\n        style.webkitTransformStyle = 'flat';\n        if (this.renderConfig.className) {\n            resizerElem.setAttribute('class', this.renderConfig.className);\n        }\n        wrapper.appendChild(resizerElem);\n        style.overflow = 'hidden';\n        var svg = createNS('svg');\n        svg.setAttribute('width', '1');\n        svg.setAttribute('height', '1');\n        styleDiv(svg);\n        this.resizerElem.appendChild(svg);\n        var defs = createNS('defs');\n        svg.appendChild(defs);\n        this.data = animData;\n        // Mask animation\n        this.setupGlobalData(animData, svg);\n        this.globalData.defs = defs;\n        this.layers = animData.layers;\n        this.layerElement = this.resizerElem;\n        this.build3dContainers();\n        this.updateContainerSize();\n    };\n    HybridRendererBase.prototype.destroy = function() {\n        if (this.animationItem.wrapper) {\n            this.animationItem.wrapper.innerText = '';\n        }\n        this.animationItem.container = null;\n        this.globalData.defs = null;\n        var i;\n        var len = this.layers ? this.layers.length : 0;\n        for(i = 0; i < len; i += 1){\n            if (this.elements[i] && this.elements[i].destroy) {\n                this.elements[i].destroy();\n            }\n        }\n        this.elements.length = 0;\n        this.destroyed = true;\n        this.animationItem = null;\n    };\n    HybridRendererBase.prototype.updateContainerSize = function() {\n        var elementWidth = this.animationItem.wrapper.offsetWidth;\n        var elementHeight = this.animationItem.wrapper.offsetHeight;\n        var elementRel = elementWidth / elementHeight;\n        var animationRel = this.globalData.compSize.w / this.globalData.compSize.h;\n        var sx;\n        var sy;\n        var tx;\n        var ty;\n        if (animationRel > elementRel) {\n            sx = elementWidth / this.globalData.compSize.w;\n            sy = elementWidth / this.globalData.compSize.w;\n            tx = 0;\n            ty = (elementHeight - this.globalData.compSize.h * (elementWidth / this.globalData.compSize.w)) / 2;\n        } else {\n            sx = elementHeight / this.globalData.compSize.h;\n            sy = elementHeight / this.globalData.compSize.h;\n            tx = (elementWidth - this.globalData.compSize.w * (elementHeight / this.globalData.compSize.h)) / 2;\n            ty = 0;\n        }\n        var style = this.resizerElem.style;\n        style.webkitTransform = 'matrix3d(' + sx + ',0,0,0,0,' + sy + ',0,0,0,0,1,0,' + tx + ',' + ty + ',0,1)';\n        style.transform = style.webkitTransform;\n    };\n    HybridRendererBase.prototype.renderFrame = SVGRenderer.prototype.renderFrame;\n    HybridRendererBase.prototype.hide = function() {\n        this.resizerElem.style.display = 'none';\n    };\n    HybridRendererBase.prototype.show = function() {\n        this.resizerElem.style.display = 'block';\n    };\n    HybridRendererBase.prototype.initItems = function() {\n        this.buildAllItems();\n        if (this.camera) {\n            this.camera.setup();\n        } else {\n            var cWidth = this.globalData.compSize.w;\n            var cHeight = this.globalData.compSize.h;\n            var i;\n            var len = this.threeDElements.length;\n            for(i = 0; i < len; i += 1){\n                var style = this.threeDElements[i].perspectiveElem.style;\n                style.webkitPerspective = Math.sqrt(Math.pow(cWidth, 2) + Math.pow(cHeight, 2)) + 'px';\n                style.perspective = style.webkitPerspective;\n            }\n        }\n    };\n    HybridRendererBase.prototype.searchExtraCompositions = function(assets) {\n        var i;\n        var len = assets.length;\n        var floatingContainer = createTag('div');\n        for(i = 0; i < len; i += 1){\n            if (assets[i].xt) {\n                var comp = this.createComp(assets[i], floatingContainer, this.globalData.comp, null);\n                comp.initExpressions();\n                this.globalData.projectInterface.registerComposition(comp);\n            }\n        }\n    };\n    function HCompElement(data, globalData, comp) {\n        this.layers = data.layers;\n        this.supports3d = !data.hasMask;\n        this.completeLayers = false;\n        this.pendingElements = [];\n        this.elements = this.layers ? createSizedArray(this.layers.length) : [];\n        this.initElement(data, globalData, comp);\n        this.tm = data.tm ? PropertyFactory.getProp(this, data.tm, 0, globalData.frameRate, this) : {\n            _placeholder: true\n        };\n    }\n    extendPrototype([\n        HybridRendererBase,\n        ICompElement,\n        HBaseElement\n    ], HCompElement);\n    HCompElement.prototype._createBaseContainerElements = HCompElement.prototype.createContainerElements;\n    HCompElement.prototype.createContainerElements = function() {\n        this._createBaseContainerElements();\n        // divElement.style.clip = 'rect(0px, '+this.data.w+'px, '+this.data.h+'px, 0px)';\n        if (this.data.hasMask) {\n            this.svgElement.setAttribute('width', this.data.w);\n            this.svgElement.setAttribute('height', this.data.h);\n            this.transformedElement = this.baseElement;\n        } else {\n            this.transformedElement = this.layerElement;\n        }\n    };\n    HCompElement.prototype.addTo3dContainer = function(elem, pos) {\n        var j = 0;\n        var nextElement;\n        while(j < pos){\n            if (this.elements[j] && this.elements[j].getBaseElement) {\n                nextElement = this.elements[j].getBaseElement();\n            }\n            j += 1;\n        }\n        if (nextElement) {\n            this.layerElement.insertBefore(elem, nextElement);\n        } else {\n            this.layerElement.appendChild(elem);\n        }\n    };\n    HCompElement.prototype.createComp = function(data) {\n        if (!this.supports3d) {\n            return new SVGCompElement(data, this.globalData, this);\n        }\n        return new HCompElement(data, this.globalData, this);\n    };\n    function HybridRenderer(animationItem, config) {\n        this.animationItem = animationItem;\n        this.layers = null;\n        this.renderedFrame = -1;\n        this.renderConfig = {\n            className: config && config.className || '',\n            imagePreserveAspectRatio: config && config.imagePreserveAspectRatio || 'xMidYMid slice',\n            hideOnTransparent: !(config && config.hideOnTransparent === false),\n            filterSize: {\n                width: config && config.filterSize && config.filterSize.width || '400%',\n                height: config && config.filterSize && config.filterSize.height || '400%',\n                x: config && config.filterSize && config.filterSize.x || '-100%',\n                y: config && config.filterSize && config.filterSize.y || '-100%'\n            },\n            runExpressions: !config || config.runExpressions === undefined || config.runExpressions\n        };\n        this.globalData = {\n            _mdf: false,\n            frameNum: -1,\n            renderConfig: this.renderConfig\n        };\n        this.pendingElements = [];\n        this.elements = [];\n        this.threeDElements = [];\n        this.destroyed = false;\n        this.camera = null;\n        this.supports3d = true;\n        this.rendererType = 'html';\n    }\n    extendPrototype([\n        HybridRendererBase\n    ], HybridRenderer);\n    HybridRenderer.prototype.createComp = function(data) {\n        if (!this.supports3d) {\n            return new SVGCompElement(data, this.globalData, this);\n        }\n        return new HCompElement(data, this.globalData, this);\n    };\n    var CompExpressionInterface = function() {\n        return function(comp) {\n            function _thisLayerFunction(name) {\n                var i = 0;\n                var len = comp.layers.length;\n                while(i < len){\n                    if (comp.layers[i].nm === name || comp.layers[i].ind === name) {\n                        return comp.elements[i].layerInterface;\n                    }\n                    i += 1;\n                }\n                return null;\n            // return {active:false};\n            }\n            Object.defineProperty(_thisLayerFunction, '_name', {\n                value: comp.data.nm\n            });\n            _thisLayerFunction.layer = _thisLayerFunction;\n            _thisLayerFunction.pixelAspect = 1;\n            _thisLayerFunction.height = comp.data.h || comp.globalData.compSize.h;\n            _thisLayerFunction.width = comp.data.w || comp.globalData.compSize.w;\n            _thisLayerFunction.pixelAspect = 1;\n            _thisLayerFunction.frameDuration = 1 / comp.globalData.frameRate;\n            _thisLayerFunction.displayStartTime = 0;\n            _thisLayerFunction.numLayers = comp.layers.length;\n            return _thisLayerFunction;\n        };\n    }();\n    function _typeof$2(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof$2 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof$2(o);\n    }\n    /* eslint-disable */ /*\n   Copyright 2014 David Bau.\n\n   Permission is hereby granted, free of charge, to any person obtaining\n   a copy of this software and associated documentation files (the\n   \"Software\"), to deal in the Software without restriction, including\n   without limitation the rights to use, copy, modify, merge, publish,\n   distribute, sublicense, and/or sell copies of the Software, and to\n   permit persons to whom the Software is furnished to do so, subject to\n   the following conditions:\n\n   The above copyright notice and this permission notice shall be\n   included in all copies or substantial portions of the Software.\n\n   THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n   IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n   CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n   TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n   SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n   */ function seedRandom(pool, math) {\n        //\n        // The following constants are related to IEEE 754 limits.\n        //\n        var global = this, width = 256, // each RC4 output is 0 <= x < 256\n        chunks = 6, // at least six RC4 outputs for each double\n        digits = 52, // there are 52 significant digits in a double\n        rngname = 'random', // rngname: name for Math.random and Math.seedrandom\n        startdenom = math.pow(width, chunks), significance = math.pow(2, digits), overflow = significance * 2, mask = width - 1, nodecrypto; // node.js crypto module, initialized at the bottom.\n        //\n        // seedrandom()\n        // This is the seedrandom function described above.\n        //\n        function seedrandom(seed, options, callback) {\n            var key = [];\n            options = options === true ? {\n                entropy: true\n            } : options || {};\n            // Flatten the seed string or build one from local entropy if needed.\n            var shortseed = mixkey(flatten(options.entropy ? [\n                seed,\n                tostring(pool)\n            ] : seed === null ? autoseed() : seed, 3), key);\n            // Use the seed to initialize an ARC4 generator.\n            var arc4 = new ARC4(key);\n            // This function returns a random double in [0, 1) that contains\n            // randomness in every bit of the mantissa of the IEEE 754 value.\n            var prng = function prng() {\n                var n = arc4.g(chunks), // Start with a numerator n < 2 ^ 48\n                d = startdenom, //   and denominator d = 2 ^ 48.\n                x = 0; //   and no 'extra last byte'.\n                while(n < significance){\n                    // Fill up all significant digits by\n                    n = (n + x) * width; //   shifting numerator and\n                    d *= width; //   denominator and generating a\n                    x = arc4.g(1); //   new least-significant-byte.\n                }\n                while(n >= overflow){\n                    // To avoid rounding up, before adding\n                    n /= 2; //   last byte, shift everything\n                    d /= 2; //   right using integer math until\n                    x >>>= 1; //   we have exactly the desired bits.\n                }\n                return (n + x) / d; // Form the number within [0, 1).\n            };\n            prng.int32 = function() {\n                return arc4.g(4) | 0;\n            };\n            prng.quick = function() {\n                return arc4.g(4) / 0x100000000;\n            };\n            prng[\"double\"] = prng;\n            // Mix the randomness into accumulated entropy.\n            mixkey(tostring(arc4.S), pool);\n            // Calling convention: what to return as a function of prng, seed, is_math.\n            return (options.pass || callback || function(prng, seed, is_math_call, state) {\n                if (state) {\n                    // Load the arc4 state from the given state if it has an S array.\n                    if (state.S) {\n                        copy(state, arc4);\n                    }\n                    // Only provide the .state method if requested via options.state.\n                    prng.state = function() {\n                        return copy(arc4, {});\n                    };\n                }\n                // If called as a method of Math (Math.seedrandom()), mutate\n                // Math.random because that is how seedrandom.js has worked since v1.0.\n                if (is_math_call) {\n                    math[rngname] = prng;\n                    return seed;\n                } else return prng;\n            })(prng, shortseed, 'global' in options ? options.global : this == math, options.state);\n        }\n        math['seed' + rngname] = seedrandom;\n        //\n        // ARC4\n        //\n        // An ARC4 implementation.  The constructor takes a key in the form of\n        // an array of at most (width) integers that should be 0 <= x < (width).\n        //\n        // The g(count) method returns a pseudorandom integer that concatenates\n        // the next (count) outputs from ARC4.  Its return value is a number x\n        // that is in the range 0 <= x < (width ^ count).\n        //\n        function ARC4(key) {\n            var t, keylen = key.length, me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];\n            // The empty key [] is treated as [0].\n            if (!keylen) {\n                key = [\n                    keylen++\n                ];\n            }\n            // Set up S using the standard key scheduling algorithm.\n            while(i < width){\n                s[i] = i++;\n            }\n            for(i = 0; i < width; i++){\n                s[i] = s[j = mask & j + key[i % keylen] + (t = s[i])];\n                s[j] = t;\n            }\n            // The \"g\" method returns the next (count) outputs as one number.\n            me.g = function(count) {\n                // Using instance members instead of closure state nearly doubles speed.\n                var t, r = 0, i = me.i, j = me.j, s = me.S;\n                while(count--){\n                    t = s[i = mask & i + 1];\n                    r = r * width + s[mask & (s[i] = s[j = mask & j + t]) + (s[j] = t)];\n                }\n                me.i = i;\n                me.j = j;\n                return r;\n            // For robust unpredictability, the function call below automatically\n            // discards an initial batch of values.  This is called RC4-drop[256].\n            // See http://google.com/search?q=rsa+fluhrer+response&btnI\n            };\n        }\n        //\n        // copy()\n        // Copies internal state of ARC4 to or from a plain object.\n        //\n        function copy(f, t) {\n            t.i = f.i;\n            t.j = f.j;\n            t.S = f.S.slice();\n            return t;\n        }\n        //\n        // flatten()\n        // Converts an object tree to nested arrays of strings.\n        //\n        function flatten(obj, depth) {\n            var result = [], typ = _typeof$2(obj), prop;\n            if (depth && typ == 'object') {\n                for(prop in obj){\n                    try {\n                        result.push(flatten(obj[prop], depth - 1));\n                    } catch (e) {}\n                }\n            }\n            return result.length ? result : typ == 'string' ? obj : obj + '\\0';\n        }\n        //\n        // mixkey()\n        // Mixes a string seed into a key that is an array of integers, and\n        // returns a shortened string seed that is equivalent to the result key.\n        //\n        function mixkey(seed, key) {\n            var stringseed = seed + '', smear, j = 0;\n            while(j < stringseed.length){\n                key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);\n            }\n            return tostring(key);\n        }\n        //\n        // autoseed()\n        // Returns an object for autoseeding, using window.crypto and Node crypto\n        // module if available.\n        //\n        function autoseed() {\n            try {\n                if (nodecrypto) {\n                    return tostring(nodecrypto.randomBytes(width));\n                }\n                var out = new Uint8Array(width);\n                (global.crypto || global.msCrypto).getRandomValues(out);\n                return tostring(out);\n            } catch (e) {\n                var browser = global.navigator, plugins = browser && browser.plugins;\n                return [\n                    +new Date(),\n                    global,\n                    plugins,\n                    global.screen,\n                    tostring(pool)\n                ];\n            }\n        }\n        //\n        // tostring()\n        // Converts an array of charcodes to a string\n        //\n        function tostring(a) {\n            return String.fromCharCode.apply(0, a);\n        }\n        //\n        // When seedrandom.js is loaded, we immediately mix a few bits\n        // from the built-in RNG into the entropy pool.  Because we do\n        // not want to interfere with deterministic PRNG state later,\n        // seedrandom will not call math.random on its own again after\n        // initialization.\n        //\n        mixkey(math.random(), pool);\n    //\n    // Nodejs and AMD support: export the implementation as a module using\n    // either convention.\n    //\n    // End anonymous scope, and pass initial values.\n    }\n    ;\n    function initialize$2(BMMath) {\n        seedRandom([], BMMath);\n    }\n    var propTypes = {\n        SHAPE: 'shape'\n    };\n    function _typeof$1(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof$1 = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof$1(o);\n    }\n    var ExpressionManager = function() {\n        'use strict';\n        var ob = {};\n        var Math = BMMath;\n        var window = null;\n        var document = null;\n        var XMLHttpRequest = null;\n        var fetch = null;\n        var frames = null;\n        var _lottieGlobal = {};\n        initialize$2(BMMath);\n        function resetFrame() {\n            _lottieGlobal = {};\n        }\n        function $bm_isInstanceOfArray(arr) {\n            return arr.constructor === Array || arr.constructor === Float32Array;\n        }\n        function isNumerable(tOfV, v) {\n            return tOfV === 'number' || v instanceof Number || tOfV === 'boolean' || tOfV === 'string';\n        }\n        function $bm_neg(a) {\n            var tOfA = _typeof$1(a);\n            if (tOfA === 'number' || a instanceof Number || tOfA === 'boolean') {\n                return -a;\n            }\n            if ($bm_isInstanceOfArray(a)) {\n                var i;\n                var lenA = a.length;\n                var retArr = [];\n                for(i = 0; i < lenA; i += 1){\n                    retArr[i] = -a[i];\n                }\n                return retArr;\n            }\n            if (a.propType) {\n                return a.v;\n            }\n            return -a;\n        }\n        var easeInBez = BezierFactory.getBezierEasing(0.333, 0, 0.833, 0.833, 'easeIn').get;\n        var easeOutBez = BezierFactory.getBezierEasing(0.167, 0.167, 0.667, 1, 'easeOut').get;\n        var easeInOutBez = BezierFactory.getBezierEasing(0.33, 0, 0.667, 1, 'easeInOut').get;\n        function sum(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b) || tOfA === 'string' || tOfB === 'string') {\n                return a + b;\n            }\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                a = a.slice(0);\n                a[0] += b;\n                return a;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                b = b.slice(0);\n                b[0] = a + b[0];\n                return b;\n            }\n            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n                var i = 0;\n                var lenA = a.length;\n                var lenB = b.length;\n                var retArr = [];\n                while(i < lenA || i < lenB){\n                    if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {\n                        retArr[i] = a[i] + b[i];\n                    } else {\n                        retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n                    }\n                    i += 1;\n                }\n                return retArr;\n            }\n            return 0;\n        }\n        var add = sum;\n        function sub(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                if (tOfA === 'string') {\n                    a = parseInt(a, 10);\n                }\n                if (tOfB === 'string') {\n                    b = parseInt(b, 10);\n                }\n                return a - b;\n            }\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                a = a.slice(0);\n                a[0] -= b;\n                return a;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                b = b.slice(0);\n                b[0] = a - b[0];\n                return b;\n            }\n            if ($bm_isInstanceOfArray(a) && $bm_isInstanceOfArray(b)) {\n                var i = 0;\n                var lenA = a.length;\n                var lenB = b.length;\n                var retArr = [];\n                while(i < lenA || i < lenB){\n                    if ((typeof a[i] === 'number' || a[i] instanceof Number) && (typeof b[i] === 'number' || b[i] instanceof Number)) {\n                        retArr[i] = a[i] - b[i];\n                    } else {\n                        retArr[i] = b[i] === undefined ? a[i] : a[i] || b[i];\n                    }\n                    i += 1;\n                }\n                return retArr;\n            }\n            return 0;\n        }\n        function mul(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            var arr;\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                return a * b;\n            }\n            var i;\n            var len;\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                len = a.length;\n                arr = createTypedArray('float32', len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a[i] * b;\n                }\n                return arr;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                len = b.length;\n                arr = createTypedArray('float32', len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a * b[i];\n                }\n                return arr;\n            }\n            return 0;\n        }\n        function div(a, b) {\n            var tOfA = _typeof$1(a);\n            var tOfB = _typeof$1(b);\n            var arr;\n            if (isNumerable(tOfA, a) && isNumerable(tOfB, b)) {\n                return a / b;\n            }\n            var i;\n            var len;\n            if ($bm_isInstanceOfArray(a) && isNumerable(tOfB, b)) {\n                len = a.length;\n                arr = createTypedArray('float32', len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a[i] / b;\n                }\n                return arr;\n            }\n            if (isNumerable(tOfA, a) && $bm_isInstanceOfArray(b)) {\n                len = b.length;\n                arr = createTypedArray('float32', len);\n                for(i = 0; i < len; i += 1){\n                    arr[i] = a / b[i];\n                }\n                return arr;\n            }\n            return 0;\n        }\n        function mod(a, b) {\n            if (typeof a === 'string') {\n                a = parseInt(a, 10);\n            }\n            if (typeof b === 'string') {\n                b = parseInt(b, 10);\n            }\n            return a % b;\n        }\n        var $bm_sum = sum;\n        var $bm_sub = sub;\n        var $bm_mul = mul;\n        var $bm_div = div;\n        var $bm_mod = mod;\n        function clamp(num, min, max) {\n            if (min > max) {\n                var mm = max;\n                max = min;\n                min = mm;\n            }\n            return Math.min(Math.max(num, min), max);\n        }\n        function radiansToDegrees(val) {\n            return val / degToRads;\n        }\n        var radians_to_degrees = radiansToDegrees;\n        function degreesToRadians(val) {\n            return val * degToRads;\n        }\n        var degrees_to_radians = radiansToDegrees;\n        var helperLengthArray = [\n            0,\n            0,\n            0,\n            0,\n            0,\n            0\n        ];\n        function length(arr1, arr2) {\n            if (typeof arr1 === 'number' || arr1 instanceof Number) {\n                arr2 = arr2 || 0;\n                return Math.abs(arr1 - arr2);\n            }\n            if (!arr2) {\n                arr2 = helperLengthArray;\n            }\n            var i;\n            var len = Math.min(arr1.length, arr2.length);\n            var addedLength = 0;\n            for(i = 0; i < len; i += 1){\n                addedLength += Math.pow(arr2[i] - arr1[i], 2);\n            }\n            return Math.sqrt(addedLength);\n        }\n        function normalize(vec) {\n            return div(vec, length(vec));\n        }\n        function rgbToHsl(val) {\n            var r = val[0];\n            var g = val[1];\n            var b = val[2];\n            var max = Math.max(r, g, b);\n            var min = Math.min(r, g, b);\n            var h;\n            var s;\n            var l = (max + min) / 2;\n            if (max === min) {\n                h = 0; // achromatic\n                s = 0; // achromatic\n            } else {\n                var d = max - min;\n                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n                switch(max){\n                    case r:\n                        h = (g - b) / d + (g < b ? 6 : 0);\n                        break;\n                    case g:\n                        h = (b - r) / d + 2;\n                        break;\n                    case b:\n                        h = (r - g) / d + 4;\n                        break;\n                    default:\n                        break;\n                }\n                h /= 6;\n            }\n            return [\n                h,\n                s,\n                l,\n                val[3]\n            ];\n        }\n        function hue2rgb(p, q, t) {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        }\n        function hslToRgb(val) {\n            var h = val[0];\n            var s = val[1];\n            var l = val[2];\n            var r;\n            var g;\n            var b;\n            if (s === 0) {\n                r = l; // achromatic\n                b = l; // achromatic\n                g = l; // achromatic\n            } else {\n                var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n                var p = 2 * l - q;\n                r = hue2rgb(p, q, h + 1 / 3);\n                g = hue2rgb(p, q, h);\n                b = hue2rgb(p, q, h - 1 / 3);\n            }\n            return [\n                r,\n                g,\n                b,\n                val[3]\n            ];\n        }\n        function linear(t, tMin, tMax, value1, value2) {\n            if (value1 === undefined || value2 === undefined) {\n                value1 = tMin;\n                value2 = tMax;\n                tMin = 0;\n                tMax = 1;\n            }\n            if (tMax < tMin) {\n                var _tMin = tMax;\n                tMax = tMin;\n                tMin = _tMin;\n            }\n            if (t <= tMin) {\n                return value1;\n            }\n            if (t >= tMax) {\n                return value2;\n            }\n            var perc = tMax === tMin ? 0 : (t - tMin) / (tMax - tMin);\n            if (!value1.length) {\n                return value1 + (value2 - value1) * perc;\n            }\n            var i;\n            var len = value1.length;\n            var arr = createTypedArray('float32', len);\n            for(i = 0; i < len; i += 1){\n                arr[i] = value1[i] + (value2[i] - value1[i]) * perc;\n            }\n            return arr;\n        }\n        function random(min, max) {\n            if (max === undefined) {\n                if (min === undefined) {\n                    min = 0;\n                    max = 1;\n                } else {\n                    max = min;\n                    min = undefined;\n                }\n            }\n            if (max.length) {\n                var i;\n                var len = max.length;\n                if (!min) {\n                    min = createTypedArray('float32', len);\n                }\n                var arr = createTypedArray('float32', len);\n                var rnd = BMMath.random();\n                for(i = 0; i < len; i += 1){\n                    arr[i] = min[i] + rnd * (max[i] - min[i]);\n                }\n                return arr;\n            }\n            if (min === undefined) {\n                min = 0;\n            }\n            var rndm = BMMath.random();\n            return min + rndm * (max - min);\n        }\n        function createPath(points, inTangents, outTangents, closed) {\n            var i;\n            var len = points.length;\n            var path = shapePool.newElement();\n            path.setPathData(!!closed, len);\n            var arrPlaceholder = [\n                0,\n                0\n            ];\n            var inVertexPoint;\n            var outVertexPoint;\n            for(i = 0; i < len; i += 1){\n                inVertexPoint = inTangents && inTangents[i] ? inTangents[i] : arrPlaceholder;\n                outVertexPoint = outTangents && outTangents[i] ? outTangents[i] : arrPlaceholder;\n                path.setTripleAt(points[i][0], points[i][1], outVertexPoint[0] + points[i][0], outVertexPoint[1] + points[i][1], inVertexPoint[0] + points[i][0], inVertexPoint[1] + points[i][1], i, true);\n            }\n            return path;\n        }\n        function initiateExpression(elem, data, property) {\n            // Bail out if we don't want expressions\n            function noOp(_value) {\n                return _value;\n            }\n            if (!elem.globalData.renderConfig.runExpressions) {\n                return noOp;\n            }\n            var val = data.x;\n            var needsVelocity = /velocity(?![\\w\\d])/.test(val);\n            var _needsRandom = val.indexOf('random') !== -1;\n            var elemType = elem.data.ty;\n            var transform;\n            var $bm_transform;\n            var content;\n            var effect;\n            var thisProperty = property;\n            thisProperty._name = elem.data.nm;\n            thisProperty.valueAtTime = thisProperty.getValueAtTime;\n            Object.defineProperty(thisProperty, 'value', {\n                get: function get() {\n                    return thisProperty.v;\n                }\n            });\n            elem.comp.frameDuration = 1 / elem.comp.globalData.frameRate;\n            elem.comp.displayStartTime = 0;\n            var inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n            var outPoint = elem.data.op / elem.comp.globalData.frameRate;\n            var width = elem.data.sw ? elem.data.sw : 0;\n            var height = elem.data.sh ? elem.data.sh : 0;\n            var name = elem.data.nm;\n            var loopIn;\n            var loop_in;\n            var loopOut;\n            var loop_out;\n            var smooth;\n            var toWorld;\n            var fromWorld;\n            var fromComp;\n            var toComp;\n            var fromCompToSurface;\n            var position;\n            var rotation;\n            var anchorPoint;\n            var scale;\n            var thisLayer;\n            var thisComp;\n            var mask;\n            var valueAtTime;\n            var velocityAtTime;\n            var scoped_bm_rt;\n            // val = val.replace(/(\\\\?\"|')((http)(s)?(:\\/))?\\/.*?(\\\\?\"|')/g, \"\\\"\\\"\"); // deter potential network calls\n            var expression_function = eval('[function _expression_function(){' + val + ';scoped_bm_rt=$bm_rt}]')[0]; // eslint-disable-line no-eval\n            var numKeys = property.kf ? data.k.length : 0;\n            var active = !this.data || this.data.hd !== true;\n            var wiggle = (function wiggle(freq, amp) {\n                var iWiggle;\n                var j;\n                var lenWiggle = this.pv.length ? this.pv.length : 1;\n                var addedAmps = createTypedArray('float32', lenWiggle);\n                freq = 5;\n                var iterations = Math.floor(time * freq);\n                iWiggle = 0;\n                j = 0;\n                while(iWiggle < iterations){\n                    // var rnd = BMMath.random();\n                    for(j = 0; j < lenWiggle; j += 1){\n                        addedAmps[j] += -amp + amp * 2 * BMMath.random();\n                    // addedAmps[j] += -amp + amp*2*rnd;\n                    }\n                    iWiggle += 1;\n                }\n                // var rnd2 = BMMath.random();\n                var periods = time * freq;\n                var perc = periods - Math.floor(periods);\n                var arr = createTypedArray('float32', lenWiggle);\n                if (lenWiggle > 1) {\n                    for(j = 0; j < lenWiggle; j += 1){\n                        arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp * 2 * BMMath.random()) * perc;\n                    // arr[j] = this.pv[j] + addedAmps[j] + (-amp + amp*2*rnd)*perc;\n                    // arr[i] = this.pv[i] + addedAmp + amp1*perc + amp2*(1-perc);\n                    }\n                    return arr;\n                }\n                return this.pv + addedAmps[0] + (-amp + amp * 2 * BMMath.random()) * perc;\n            }).bind(this);\n            if (thisProperty.loopIn) {\n                loopIn = thisProperty.loopIn.bind(thisProperty);\n                loop_in = loopIn;\n            }\n            if (thisProperty.loopOut) {\n                loopOut = thisProperty.loopOut.bind(thisProperty);\n                loop_out = loopOut;\n            }\n            if (thisProperty.smooth) {\n                smooth = thisProperty.smooth.bind(thisProperty);\n            }\n            function loopInDuration(type, duration) {\n                return loopIn(type, duration, true);\n            }\n            function loopOutDuration(type, duration) {\n                return loopOut(type, duration, true);\n            }\n            if (this.getValueAtTime) {\n                valueAtTime = this.getValueAtTime.bind(this);\n            }\n            if (this.getVelocityAtTime) {\n                velocityAtTime = this.getVelocityAtTime.bind(this);\n            }\n            var comp = elem.comp.globalData.projectInterface.bind(elem.comp.globalData.projectInterface);\n            function lookAt(elem1, elem2) {\n                var fVec = [\n                    elem2[0] - elem1[0],\n                    elem2[1] - elem1[1],\n                    elem2[2] - elem1[2]\n                ];\n                var pitch = Math.atan2(fVec[0], Math.sqrt(fVec[1] * fVec[1] + fVec[2] * fVec[2])) / degToRads;\n                var yaw = -Math.atan2(fVec[1], fVec[2]) / degToRads;\n                return [\n                    yaw,\n                    pitch,\n                    0\n                ];\n            }\n            function easeOut(t, tMin, tMax, val1, val2) {\n                return applyEase(easeOutBez, t, tMin, tMax, val1, val2);\n            }\n            function easeIn(t, tMin, tMax, val1, val2) {\n                return applyEase(easeInBez, t, tMin, tMax, val1, val2);\n            }\n            function ease(t, tMin, tMax, val1, val2) {\n                return applyEase(easeInOutBez, t, tMin, tMax, val1, val2);\n            }\n            function applyEase(fn, t, tMin, tMax, val1, val2) {\n                if (val1 === undefined) {\n                    val1 = tMin;\n                    val2 = tMax;\n                } else {\n                    t = (t - tMin) / (tMax - tMin);\n                }\n                if (t > 1) {\n                    t = 1;\n                } else if (t < 0) {\n                    t = 0;\n                }\n                var mult = fn(t);\n                if ($bm_isInstanceOfArray(val1)) {\n                    var iKey;\n                    var lenKey = val1.length;\n                    var arr = createTypedArray('float32', lenKey);\n                    for(iKey = 0; iKey < lenKey; iKey += 1){\n                        arr[iKey] = (val2[iKey] - val1[iKey]) * mult + val1[iKey];\n                    }\n                    return arr;\n                }\n                return (val2 - val1) * mult + val1;\n            }\n            function nearestKey(time) {\n                var iKey;\n                var lenKey = data.k.length;\n                var index;\n                var keyTime;\n                if (!data.k.length || typeof data.k[0] === 'number') {\n                    index = 0;\n                    keyTime = 0;\n                } else {\n                    index = -1;\n                    time *= elem.comp.globalData.frameRate;\n                    if (time < data.k[0].t) {\n                        index = 1;\n                        keyTime = data.k[0].t;\n                    } else {\n                        for(iKey = 0; iKey < lenKey - 1; iKey += 1){\n                            if (time === data.k[iKey].t) {\n                                index = iKey + 1;\n                                keyTime = data.k[iKey].t;\n                                break;\n                            } else if (time > data.k[iKey].t && time < data.k[iKey + 1].t) {\n                                if (time - data.k[iKey].t > data.k[iKey + 1].t - time) {\n                                    index = iKey + 2;\n                                    keyTime = data.k[iKey + 1].t;\n                                } else {\n                                    index = iKey + 1;\n                                    keyTime = data.k[iKey].t;\n                                }\n                                break;\n                            }\n                        }\n                        if (index === -1) {\n                            index = iKey + 1;\n                            keyTime = data.k[iKey].t;\n                        }\n                    }\n                }\n                var obKey = {};\n                obKey.index = index;\n                obKey.time = keyTime / elem.comp.globalData.frameRate;\n                return obKey;\n            }\n            function key(ind) {\n                var obKey;\n                var iKey;\n                var lenKey;\n                if (!data.k.length || typeof data.k[0] === 'number') {\n                    throw new Error('The property has no keyframe at index ' + ind);\n                }\n                ind -= 1;\n                obKey = {\n                    time: data.k[ind].t / elem.comp.globalData.frameRate,\n                    value: []\n                };\n                var arr = Object.prototype.hasOwnProperty.call(data.k[ind], 's') ? data.k[ind].s : data.k[ind - 1].e;\n                lenKey = arr.length;\n                for(iKey = 0; iKey < lenKey; iKey += 1){\n                    obKey[iKey] = arr[iKey];\n                    obKey.value[iKey] = arr[iKey];\n                }\n                return obKey;\n            }\n            function framesToTime(fr, fps) {\n                if (!fps) {\n                    fps = elem.comp.globalData.frameRate;\n                }\n                return fr / fps;\n            }\n            function timeToFrames(t, fps) {\n                if (!t && t !== 0) {\n                    t = time;\n                }\n                if (!fps) {\n                    fps = elem.comp.globalData.frameRate;\n                }\n                return t * fps;\n            }\n            function seedRandom(seed) {\n                BMMath.seedrandom(randSeed + seed);\n            }\n            function sourceRectAtTime() {\n                return elem.sourceRectAtTime();\n            }\n            function substring(init, end) {\n                if (typeof value === 'string') {\n                    if (end === undefined) {\n                        return value.substring(init);\n                    }\n                    return value.substring(init, end);\n                }\n                return '';\n            }\n            function substr(init, end) {\n                if (typeof value === 'string') {\n                    if (end === undefined) {\n                        return value.substr(init);\n                    }\n                    return value.substr(init, end);\n                }\n                return '';\n            }\n            function posterizeTime(framesPerSecond) {\n                time = framesPerSecond === 0 ? 0 : Math.floor(time * framesPerSecond) / framesPerSecond;\n                value = valueAtTime(time);\n            }\n            var time;\n            var velocity;\n            var value;\n            var text;\n            var textIndex;\n            var textTotal;\n            var selectorValue;\n            var index = elem.data.ind;\n            var hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n            var parent;\n            var randSeed = Math.floor(Math.random() * 1000000);\n            var globalData = elem.globalData;\n            function executeExpression(_value) {\n                // globalData.pushExpression();\n                value = _value;\n                if (this.frameExpressionId === elem.globalData.frameId && this.propType !== 'textSelector') {\n                    return value;\n                }\n                if (this.propType === 'textSelector') {\n                    textIndex = this.textIndex;\n                    textTotal = this.textTotal;\n                    selectorValue = this.selectorValue;\n                }\n                if (!thisLayer) {\n                    text = elem.layerInterface.text;\n                    thisLayer = elem.layerInterface;\n                    thisComp = elem.comp.compInterface;\n                    toWorld = thisLayer.toWorld.bind(thisLayer);\n                    fromWorld = thisLayer.fromWorld.bind(thisLayer);\n                    fromComp = thisLayer.fromComp.bind(thisLayer);\n                    toComp = thisLayer.toComp.bind(thisLayer);\n                    mask = thisLayer.mask ? thisLayer.mask.bind(thisLayer) : null;\n                    fromCompToSurface = fromComp;\n                }\n                if (!transform) {\n                    transform = elem.layerInterface('ADBE Transform Group');\n                    $bm_transform = transform;\n                    if (transform) {\n                        anchorPoint = transform.anchorPoint;\n                    /* position = transform.position;\n                      rotation = transform.rotation;\n                      scale = transform.scale; */ }\n                }\n                if (elemType === 4 && !content) {\n                    content = thisLayer('ADBE Root Vectors Group');\n                }\n                if (!effect) {\n                    effect = thisLayer(4);\n                }\n                hasParent = !!(elem.hierarchy && elem.hierarchy.length);\n                if (hasParent && !parent) {\n                    parent = elem.hierarchy[0].layerInterface;\n                }\n                time = this.comp.renderedFrame / this.comp.globalData.frameRate;\n                if (_needsRandom) {\n                    seedRandom(randSeed + time);\n                }\n                if (needsVelocity) {\n                    velocity = velocityAtTime(time);\n                }\n                expression_function();\n                this.frameExpressionId = elem.globalData.frameId;\n                // TODO: Check if it's possible to return on ShapeInterface the .v value\n                // Changed this to a ternary operation because Rollup failed compiling it correctly\n                scoped_bm_rt = scoped_bm_rt.propType === propTypes.SHAPE ? scoped_bm_rt.v : scoped_bm_rt;\n                return scoped_bm_rt;\n            }\n            // Bundlers will see these as dead code and unless we reference them\n            executeExpression.__preventDeadCodeRemoval = [\n                $bm_transform,\n                anchorPoint,\n                time,\n                velocity,\n                inPoint,\n                outPoint,\n                width,\n                height,\n                name,\n                loop_in,\n                loop_out,\n                smooth,\n                toComp,\n                fromCompToSurface,\n                toWorld,\n                fromWorld,\n                mask,\n                position,\n                rotation,\n                scale,\n                thisComp,\n                numKeys,\n                active,\n                wiggle,\n                loopInDuration,\n                loopOutDuration,\n                comp,\n                lookAt,\n                easeOut,\n                easeIn,\n                ease,\n                nearestKey,\n                key,\n                text,\n                textIndex,\n                textTotal,\n                selectorValue,\n                framesToTime,\n                timeToFrames,\n                sourceRectAtTime,\n                substring,\n                substr,\n                posterizeTime,\n                index,\n                globalData\n            ];\n            return executeExpression;\n        }\n        ob.initiateExpression = initiateExpression;\n        ob.__preventDeadCodeRemoval = [\n            window,\n            document,\n            XMLHttpRequest,\n            fetch,\n            frames,\n            $bm_neg,\n            add,\n            $bm_sum,\n            $bm_sub,\n            $bm_mul,\n            $bm_div,\n            $bm_mod,\n            clamp,\n            radians_to_degrees,\n            degreesToRadians,\n            degrees_to_radians,\n            normalize,\n            rgbToHsl,\n            hslToRgb,\n            linear,\n            random,\n            createPath,\n            _lottieGlobal\n        ];\n        ob.resetFrame = resetFrame;\n        return ob;\n    }();\n    var Expressions = function() {\n        var ob = {};\n        ob.initExpressions = initExpressions;\n        ob.resetFrame = ExpressionManager.resetFrame;\n        function initExpressions(animation) {\n            var stackCount = 0;\n            var registers = [];\n            function pushExpression() {\n                stackCount += 1;\n            }\n            function popExpression() {\n                stackCount -= 1;\n                if (stackCount === 0) {\n                    releaseInstances();\n                }\n            }\n            function registerExpressionProperty(expression) {\n                if (registers.indexOf(expression) === -1) {\n                    registers.push(expression);\n                }\n            }\n            function releaseInstances() {\n                var i;\n                var len = registers.length;\n                for(i = 0; i < len; i += 1){\n                    registers[i].release();\n                }\n                registers.length = 0;\n            }\n            animation.renderer.compInterface = CompExpressionInterface(animation.renderer);\n            animation.renderer.globalData.projectInterface.registerComposition(animation.renderer);\n            animation.renderer.globalData.pushExpression = pushExpression;\n            animation.renderer.globalData.popExpression = popExpression;\n            animation.renderer.globalData.registerExpressionProperty = registerExpressionProperty;\n        }\n        return ob;\n    }();\n    var MaskManagerInterface = function() {\n        function MaskInterface(mask, data) {\n            this._mask = mask;\n            this._data = data;\n        }\n        Object.defineProperty(MaskInterface.prototype, 'maskPath', {\n            get: function get() {\n                if (this._mask.prop.k) {\n                    this._mask.prop.getValue();\n                }\n                return this._mask.prop;\n            }\n        });\n        Object.defineProperty(MaskInterface.prototype, 'maskOpacity', {\n            get: function get() {\n                if (this._mask.op.k) {\n                    this._mask.op.getValue();\n                }\n                return this._mask.op.v * 100;\n            }\n        });\n        var MaskManager = function MaskManager(maskManager) {\n            var _masksInterfaces = createSizedArray(maskManager.viewData.length);\n            var i;\n            var len = maskManager.viewData.length;\n            for(i = 0; i < len; i += 1){\n                _masksInterfaces[i] = new MaskInterface(maskManager.viewData[i], maskManager.masksProperties[i]);\n            }\n            var maskFunction = function maskFunction(name) {\n                i = 0;\n                while(i < len){\n                    if (maskManager.masksProperties[i].nm === name) {\n                        return _masksInterfaces[i];\n                    }\n                    i += 1;\n                }\n                return null;\n            };\n            return maskFunction;\n        };\n        return MaskManager;\n    }();\n    var ExpressionPropertyInterface = function() {\n        var defaultUnidimensionalValue = {\n            pv: 0,\n            v: 0,\n            mult: 1\n        };\n        var defaultMultidimensionalValue = {\n            pv: [\n                0,\n                0,\n                0\n            ],\n            v: [\n                0,\n                0,\n                0\n            ],\n            mult: 1\n        };\n        function completeProperty(expressionValue, property, type) {\n            Object.defineProperty(expressionValue, 'velocity', {\n                get: function get() {\n                    return property.getVelocityAtTime(property.comp.currentFrame);\n                }\n            });\n            expressionValue.numKeys = property.keyframes ? property.keyframes.length : 0;\n            expressionValue.key = function(pos) {\n                if (!expressionValue.numKeys) {\n                    return 0;\n                }\n                var value = '';\n                if ('s' in property.keyframes[pos - 1]) {\n                    value = property.keyframes[pos - 1].s;\n                } else if ('e' in property.keyframes[pos - 2]) {\n                    value = property.keyframes[pos - 2].e;\n                } else {\n                    value = property.keyframes[pos - 2].s;\n                }\n                var valueProp = type === 'unidimensional' ? new Number(value) : Object.assign({}, value); // eslint-disable-line no-new-wrappers\n                valueProp.time = property.keyframes[pos - 1].t / property.elem.comp.globalData.frameRate;\n                valueProp.value = type === 'unidimensional' ? value[0] : value;\n                return valueProp;\n            };\n            expressionValue.valueAtTime = property.getValueAtTime;\n            expressionValue.speedAtTime = property.getSpeedAtTime;\n            expressionValue.velocityAtTime = property.getVelocityAtTime;\n            expressionValue.propertyGroup = property.propertyGroup;\n        }\n        function UnidimensionalPropertyInterface(property) {\n            if (!property || !('pv' in property)) {\n                property = defaultUnidimensionalValue;\n            }\n            var mult = 1 / property.mult;\n            var val = property.pv * mult;\n            var expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n            expressionValue.value = val;\n            completeProperty(expressionValue, property, 'unidimensional');\n            return function() {\n                if (property.k) {\n                    property.getValue();\n                }\n                val = property.v * mult;\n                if (expressionValue.value !== val) {\n                    expressionValue = new Number(val); // eslint-disable-line no-new-wrappers\n                    expressionValue.value = val;\n                    expressionValue[0] = val;\n                    completeProperty(expressionValue, property, 'unidimensional');\n                }\n                return expressionValue;\n            };\n        }\n        function MultidimensionalPropertyInterface(property) {\n            if (!property || !('pv' in property)) {\n                property = defaultMultidimensionalValue;\n            }\n            var mult = 1 / property.mult;\n            var len = property.data && property.data.l || property.pv.length;\n            var expressionValue = createTypedArray('float32', len);\n            var arrValue = createTypedArray('float32', len);\n            expressionValue.value = arrValue;\n            completeProperty(expressionValue, property, 'multidimensional');\n            return function() {\n                if (property.k) {\n                    property.getValue();\n                }\n                for(var i = 0; i < len; i += 1){\n                    arrValue[i] = property.v[i] * mult;\n                    expressionValue[i] = arrValue[i];\n                }\n                return expressionValue;\n            };\n        }\n        // TODO: try to avoid using this getter\n        function defaultGetter() {\n            return defaultUnidimensionalValue;\n        }\n        return function(property) {\n            if (!property) {\n                return defaultGetter;\n            }\n            if (property.propType === 'unidimensional') {\n                return UnidimensionalPropertyInterface(property);\n            }\n            return MultidimensionalPropertyInterface(property);\n        };\n    }();\n    var TransformExpressionInterface = function() {\n        return function(transform) {\n            function _thisFunction(name) {\n                switch(name){\n                    case 'scale':\n                    case 'Scale':\n                    case 'ADBE Scale':\n                    case 6:\n                        return _thisFunction.scale;\n                    case 'rotation':\n                    case 'Rotation':\n                    case 'ADBE Rotation':\n                    case 'ADBE Rotate Z':\n                    case 10:\n                        return _thisFunction.rotation;\n                    case 'ADBE Rotate X':\n                        return _thisFunction.xRotation;\n                    case 'ADBE Rotate Y':\n                        return _thisFunction.yRotation;\n                    case 'position':\n                    case 'Position':\n                    case 'ADBE Position':\n                    case 2:\n                        return _thisFunction.position;\n                    case 'ADBE Position_0':\n                        return _thisFunction.xPosition;\n                    case 'ADBE Position_1':\n                        return _thisFunction.yPosition;\n                    case 'ADBE Position_2':\n                        return _thisFunction.zPosition;\n                    case 'anchorPoint':\n                    case 'AnchorPoint':\n                    case 'Anchor Point':\n                    case 'ADBE AnchorPoint':\n                    case 1:\n                        return _thisFunction.anchorPoint;\n                    case 'opacity':\n                    case 'Opacity':\n                    case 11:\n                        return _thisFunction.opacity;\n                    default:\n                        return null;\n                }\n            }\n            Object.defineProperty(_thisFunction, 'rotation', {\n                get: ExpressionPropertyInterface(transform.r || transform.rz)\n            });\n            Object.defineProperty(_thisFunction, 'zRotation', {\n                get: ExpressionPropertyInterface(transform.rz || transform.r)\n            });\n            Object.defineProperty(_thisFunction, 'xRotation', {\n                get: ExpressionPropertyInterface(transform.rx)\n            });\n            Object.defineProperty(_thisFunction, 'yRotation', {\n                get: ExpressionPropertyInterface(transform.ry)\n            });\n            Object.defineProperty(_thisFunction, 'scale', {\n                get: ExpressionPropertyInterface(transform.s)\n            });\n            var _px;\n            var _py;\n            var _pz;\n            var _transformFactory;\n            if (transform.p) {\n                _transformFactory = ExpressionPropertyInterface(transform.p);\n            } else {\n                _px = ExpressionPropertyInterface(transform.px);\n                _py = ExpressionPropertyInterface(transform.py);\n                if (transform.pz) {\n                    _pz = ExpressionPropertyInterface(transform.pz);\n                }\n            }\n            Object.defineProperty(_thisFunction, 'position', {\n                get: function get() {\n                    if (transform.p) {\n                        return _transformFactory();\n                    }\n                    return [\n                        _px(),\n                        _py(),\n                        _pz ? _pz() : 0\n                    ];\n                }\n            });\n            Object.defineProperty(_thisFunction, 'xPosition', {\n                get: ExpressionPropertyInterface(transform.px)\n            });\n            Object.defineProperty(_thisFunction, 'yPosition', {\n                get: ExpressionPropertyInterface(transform.py)\n            });\n            Object.defineProperty(_thisFunction, 'zPosition', {\n                get: ExpressionPropertyInterface(transform.pz)\n            });\n            Object.defineProperty(_thisFunction, 'anchorPoint', {\n                get: ExpressionPropertyInterface(transform.a)\n            });\n            Object.defineProperty(_thisFunction, 'opacity', {\n                get: ExpressionPropertyInterface(transform.o)\n            });\n            Object.defineProperty(_thisFunction, 'skew', {\n                get: ExpressionPropertyInterface(transform.sk)\n            });\n            Object.defineProperty(_thisFunction, 'skewAxis', {\n                get: ExpressionPropertyInterface(transform.sa)\n            });\n            Object.defineProperty(_thisFunction, 'orientation', {\n                get: ExpressionPropertyInterface(transform.or)\n            });\n            return _thisFunction;\n        };\n    }();\n    var LayerExpressionInterface = function() {\n        function getMatrix(time) {\n            var toWorldMat = new Matrix();\n            if (time !== undefined) {\n                var propMatrix = this._elem.finalTransform.mProp.getValueAtTime(time);\n                propMatrix.clone(toWorldMat);\n            } else {\n                var transformMat = this._elem.finalTransform.mProp;\n                transformMat.applyToMatrix(toWorldMat);\n            }\n            return toWorldMat;\n        }\n        function toWorldVec(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            toWorldMat.props[12] = 0;\n            toWorldMat.props[13] = 0;\n            toWorldMat.props[14] = 0;\n            return this.applyPoint(toWorldMat, arr);\n        }\n        function toWorld(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            return this.applyPoint(toWorldMat, arr);\n        }\n        function fromWorldVec(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            toWorldMat.props[12] = 0;\n            toWorldMat.props[13] = 0;\n            toWorldMat.props[14] = 0;\n            return this.invertPoint(toWorldMat, arr);\n        }\n        function fromWorld(arr, time) {\n            var toWorldMat = this.getMatrix(time);\n            return this.invertPoint(toWorldMat, arr);\n        }\n        function applyPoint(matrix, arr) {\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n                }\n            }\n            return matrix.applyToPointArray(arr[0], arr[1], arr[2] || 0);\n        }\n        function invertPoint(matrix, arr) {\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(matrix);\n                }\n            }\n            return matrix.inversePoint(arr);\n        }\n        function fromComp(arr) {\n            var toWorldMat = new Matrix();\n            toWorldMat.reset();\n            this._elem.finalTransform.mProp.applyToMatrix(toWorldMat);\n            if (this._elem.hierarchy && this._elem.hierarchy.length) {\n                var i;\n                var len = this._elem.hierarchy.length;\n                for(i = 0; i < len; i += 1){\n                    this._elem.hierarchy[i].finalTransform.mProp.applyToMatrix(toWorldMat);\n                }\n                return toWorldMat.inversePoint(arr);\n            }\n            return toWorldMat.inversePoint(arr);\n        }\n        function sampleImage() {\n            return [\n                1,\n                1,\n                1,\n                1\n            ];\n        }\n        return function(elem) {\n            var transformInterface;\n            function _registerMaskInterface(maskManager) {\n                _thisLayerFunction.mask = new MaskManagerInterface(maskManager, elem);\n            }\n            function _registerEffectsInterface(effects) {\n                _thisLayerFunction.effect = effects;\n            }\n            function _thisLayerFunction(name) {\n                switch(name){\n                    case 'ADBE Root Vectors Group':\n                    case 'Contents':\n                    case 2:\n                        return _thisLayerFunction.shapeInterface;\n                    case 1:\n                    case 6:\n                    case 'Transform':\n                    case 'transform':\n                    case 'ADBE Transform Group':\n                        return transformInterface;\n                    case 4:\n                    case 'ADBE Effect Parade':\n                    case 'effects':\n                    case 'Effects':\n                        return _thisLayerFunction.effect;\n                    case 'ADBE Text Properties':\n                        return _thisLayerFunction.textInterface;\n                    default:\n                        return null;\n                }\n            }\n            _thisLayerFunction.getMatrix = getMatrix;\n            _thisLayerFunction.invertPoint = invertPoint;\n            _thisLayerFunction.applyPoint = applyPoint;\n            _thisLayerFunction.toWorld = toWorld;\n            _thisLayerFunction.toWorldVec = toWorldVec;\n            _thisLayerFunction.fromWorld = fromWorld;\n            _thisLayerFunction.fromWorldVec = fromWorldVec;\n            _thisLayerFunction.toComp = toWorld;\n            _thisLayerFunction.fromComp = fromComp;\n            _thisLayerFunction.sampleImage = sampleImage;\n            _thisLayerFunction.sourceRectAtTime = elem.sourceRectAtTime.bind(elem);\n            _thisLayerFunction._elem = elem;\n            transformInterface = TransformExpressionInterface(elem.finalTransform.mProp);\n            var anchorPointDescriptor = getDescriptor(transformInterface, 'anchorPoint');\n            Object.defineProperties(_thisLayerFunction, {\n                hasParent: {\n                    get: function get() {\n                        return elem.hierarchy.length;\n                    }\n                },\n                parent: {\n                    get: function get() {\n                        return elem.hierarchy[0].layerInterface;\n                    }\n                },\n                rotation: getDescriptor(transformInterface, 'rotation'),\n                scale: getDescriptor(transformInterface, 'scale'),\n                position: getDescriptor(transformInterface, 'position'),\n                opacity: getDescriptor(transformInterface, 'opacity'),\n                anchorPoint: anchorPointDescriptor,\n                anchor_point: anchorPointDescriptor,\n                transform: {\n                    get: function get() {\n                        return transformInterface;\n                    }\n                },\n                active: {\n                    get: function get() {\n                        return elem.isInRange;\n                    }\n                }\n            });\n            _thisLayerFunction.startTime = elem.data.st;\n            _thisLayerFunction.index = elem.data.ind;\n            _thisLayerFunction.source = elem.data.refId;\n            _thisLayerFunction.height = elem.data.ty === 0 ? elem.data.h : 100;\n            _thisLayerFunction.width = elem.data.ty === 0 ? elem.data.w : 100;\n            _thisLayerFunction.inPoint = elem.data.ip / elem.comp.globalData.frameRate;\n            _thisLayerFunction.outPoint = elem.data.op / elem.comp.globalData.frameRate;\n            _thisLayerFunction._name = elem.data.nm;\n            _thisLayerFunction.registerMaskInterface = _registerMaskInterface;\n            _thisLayerFunction.registerEffectsInterface = _registerEffectsInterface;\n            return _thisLayerFunction;\n        };\n    }();\n    var propertyGroupFactory = function() {\n        return function(interfaceFunction, parentPropertyGroup) {\n            return function(val) {\n                val = val === undefined ? 1 : val;\n                if (val <= 0) {\n                    return interfaceFunction;\n                }\n                return parentPropertyGroup(val - 1);\n            };\n        };\n    }();\n    var PropertyInterface = function() {\n        return function(propertyName, propertyGroup) {\n            var interfaceFunction = {\n                _name: propertyName\n            };\n            function _propertyGroup(val) {\n                val = val === undefined ? 1 : val;\n                if (val <= 0) {\n                    return interfaceFunction;\n                }\n                return propertyGroup(val - 1);\n            }\n            return _propertyGroup;\n        };\n    }();\n    var EffectsExpressionInterface = function() {\n        var ob = {\n            createEffectsInterface: createEffectsInterface\n        };\n        function createEffectsInterface(elem, propertyGroup) {\n            if (elem.effectsManager) {\n                var effectElements = [];\n                var effectsData = elem.data.ef;\n                var i;\n                var len = elem.effectsManager.effectElements.length;\n                for(i = 0; i < len; i += 1){\n                    effectElements.push(createGroupInterface(effectsData[i], elem.effectsManager.effectElements[i], propertyGroup, elem));\n                }\n                var effects = elem.data.ef || [];\n                var groupInterface = function groupInterface(name) {\n                    i = 0;\n                    len = effects.length;\n                    while(i < len){\n                        if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n                            return effectElements[i];\n                        }\n                        i += 1;\n                    }\n                    return null;\n                };\n                Object.defineProperty(groupInterface, 'numProperties', {\n                    get: function get() {\n                        return effects.length;\n                    }\n                });\n                return groupInterface;\n            }\n            return null;\n        }\n        function createGroupInterface(data, elements, propertyGroup, elem) {\n            function groupInterface(name) {\n                var effects = data.ef;\n                var i = 0;\n                var len = effects.length;\n                while(i < len){\n                    if (name === effects[i].nm || name === effects[i].mn || name === effects[i].ix) {\n                        if (effects[i].ty === 5) {\n                            return effectElements[i];\n                        }\n                        return effectElements[i]();\n                    }\n                    i += 1;\n                }\n                throw new Error();\n            }\n            var _propertyGroup = propertyGroupFactory(groupInterface, propertyGroup);\n            var effectElements = [];\n            var i;\n            var len = data.ef.length;\n            for(i = 0; i < len; i += 1){\n                if (data.ef[i].ty === 5) {\n                    effectElements.push(createGroupInterface(data.ef[i], elements.effectElements[i], elements.effectElements[i].propertyGroup, elem));\n                } else {\n                    effectElements.push(createValueInterface(elements.effectElements[i], data.ef[i].ty, elem, _propertyGroup));\n                }\n            }\n            if (data.mn === 'ADBE Color Control') {\n                Object.defineProperty(groupInterface, 'color', {\n                    get: function get() {\n                        return effectElements[0]();\n                    }\n                });\n            }\n            Object.defineProperties(groupInterface, {\n                numProperties: {\n                    get: function get() {\n                        return data.np;\n                    }\n                },\n                _name: {\n                    value: data.nm\n                },\n                propertyGroup: {\n                    value: _propertyGroup\n                }\n            });\n            groupInterface.enabled = data.en !== 0;\n            groupInterface.active = groupInterface.enabled;\n            return groupInterface;\n        }\n        function createValueInterface(element, type, elem, propertyGroup) {\n            var expressionProperty = ExpressionPropertyInterface(element.p);\n            function interfaceFunction() {\n                if (type === 10) {\n                    return elem.comp.compInterface(element.p.v);\n                }\n                return expressionProperty();\n            }\n            if (element.p.setGroupProperty) {\n                element.p.setGroupProperty(PropertyInterface('', propertyGroup));\n            }\n            return interfaceFunction;\n        }\n        return ob;\n    }();\n    var ShapePathInterface = function() {\n        return function pathInterfaceFactory(shape, view, propertyGroup) {\n            var prop = view.sh;\n            function interfaceFunction(val) {\n                if (val === 'Shape' || val === 'shape' || val === 'Path' || val === 'path' || val === 'ADBE Vector Shape' || val === 2) {\n                    return interfaceFunction.path;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            prop.setGroupProperty(PropertyInterface('Path', _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                path: {\n                    get: function get() {\n                        if (prop.k) {\n                            prop.getValue();\n                        }\n                        return prop;\n                    }\n                },\n                shape: {\n                    get: function get() {\n                        if (prop.k) {\n                            prop.getValue();\n                        }\n                        return prop;\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                ix: {\n                    value: shape.ix\n                },\n                propertyIndex: {\n                    value: shape.ix\n                },\n                mn: {\n                    value: shape.mn\n                },\n                propertyGroup: {\n                    value: propertyGroup\n                }\n            });\n            return interfaceFunction;\n        };\n    }();\n    var ShapeExpressionInterface = function() {\n        function iterateElements(shapes, view, propertyGroup) {\n            var arr = [];\n            var i;\n            var len = shapes ? shapes.length : 0;\n            for(i = 0; i < len; i += 1){\n                if (shapes[i].ty === 'gr') {\n                    arr.push(groupInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'fl') {\n                    arr.push(fillInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'st') {\n                    arr.push(strokeInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'tm') {\n                    arr.push(trimInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'tr') {\n                // arr.push(transformInterfaceFactory(shapes[i],view[i],propertyGroup));\n                } else if (shapes[i].ty === 'el') {\n                    arr.push(ellipseInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'sr') {\n                    arr.push(starInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'sh') {\n                    arr.push(ShapePathInterface(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'rc') {\n                    arr.push(rectInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'rd') {\n                    arr.push(roundedInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'rp') {\n                    arr.push(repeaterInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else if (shapes[i].ty === 'gf') {\n                    arr.push(gradientFillInterfaceFactory(shapes[i], view[i], propertyGroup));\n                } else {\n                    arr.push(defaultInterfaceFactory(shapes[i], view[i], propertyGroup));\n                }\n            }\n            return arr;\n        }\n        function contentsInterfaceFactory(shape, view, propertyGroup) {\n            var interfaces;\n            var interfaceFunction = function _interfaceFunction(value) {\n                var i = 0;\n                var len = interfaces.length;\n                while(i < len){\n                    if (interfaces[i]._name === value || interfaces[i].mn === value || interfaces[i].propertyIndex === value || interfaces[i].ix === value || interfaces[i].ind === value) {\n                        return interfaces[i];\n                    }\n                    i += 1;\n                }\n                if (typeof value === 'number') {\n                    return interfaces[value - 1];\n                }\n                return null;\n            };\n            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaces = iterateElements(shape.it, view.it, interfaceFunction.propertyGroup);\n            interfaceFunction.numProperties = interfaces.length;\n            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n            interfaceFunction.transform = transformInterface;\n            interfaceFunction.propertyIndex = shape.cix;\n            interfaceFunction._name = shape.nm;\n            return interfaceFunction;\n        }\n        function groupInterfaceFactory(shape, view, propertyGroup) {\n            var interfaceFunction = function _interfaceFunction(value) {\n                switch(value){\n                    case 'ADBE Vectors Group':\n                    case 'Contents':\n                    case 2:\n                        return interfaceFunction.content;\n                    // Not necessary for now. Keeping them here in case a new case appears\n                    // case 'ADBE Vector Transform Group':\n                    // case 3:\n                    default:\n                        return interfaceFunction.transform;\n                }\n            };\n            interfaceFunction.propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var content = contentsInterfaceFactory(shape, view, interfaceFunction.propertyGroup);\n            var transformInterface = transformInterfaceFactory(shape.it[shape.it.length - 1], view.it[view.it.length - 1], interfaceFunction.propertyGroup);\n            interfaceFunction.content = content;\n            interfaceFunction.transform = transformInterface;\n            Object.defineProperty(interfaceFunction, '_name', {\n                get: function get() {\n                    return shape.nm;\n                }\n            });\n            // interfaceFunction.content = interfaceFunction;\n            interfaceFunction.numProperties = shape.np;\n            interfaceFunction.propertyIndex = shape.ix;\n            interfaceFunction.nm = shape.nm;\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function fillInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === 'Color' || val === 'color') {\n                    return interfaceFunction.color;\n                }\n                if (val === 'Opacity' || val === 'opacity') {\n                    return interfaceFunction.opacity;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                color: {\n                    get: ExpressionPropertyInterface(view.c)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.c.setGroupProperty(PropertyInterface('Color', propertyGroup));\n            view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));\n            return interfaceFunction;\n        }\n        function gradientFillInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === 'Start Point' || val === 'start point') {\n                    return interfaceFunction.startPoint;\n                }\n                if (val === 'End Point' || val === 'end point') {\n                    return interfaceFunction.endPoint;\n                }\n                if (val === 'Opacity' || val === 'opacity') {\n                    return interfaceFunction.opacity;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                startPoint: {\n                    get: ExpressionPropertyInterface(view.s)\n                },\n                endPoint: {\n                    get: ExpressionPropertyInterface(view.e)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                type: {\n                    get: function get() {\n                        return 'a';\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.s.setGroupProperty(PropertyInterface('Start Point', propertyGroup));\n            view.e.setGroupProperty(PropertyInterface('End Point', propertyGroup));\n            view.o.setGroupProperty(PropertyInterface('Opacity', propertyGroup));\n            return interfaceFunction;\n        }\n        function defaultInterfaceFactory() {\n            function interfaceFunction() {\n                return null;\n            }\n            return interfaceFunction;\n        }\n        function strokeInterfaceFactory(shape, view, propertyGroup) {\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var _dashPropertyGroup = propertyGroupFactory(dashOb, _propertyGroup);\n            function addPropertyToDashOb(i) {\n                Object.defineProperty(dashOb, shape.d[i].nm, {\n                    get: ExpressionPropertyInterface(view.d.dataProps[i].p)\n                });\n            }\n            var i;\n            var len = shape.d ? shape.d.length : 0;\n            var dashOb = {};\n            for(i = 0; i < len; i += 1){\n                addPropertyToDashOb(i);\n                view.d.dataProps[i].p.setGroupProperty(_dashPropertyGroup);\n            }\n            function interfaceFunction(val) {\n                if (val === 'Color' || val === 'color') {\n                    return interfaceFunction.color;\n                }\n                if (val === 'Opacity' || val === 'opacity') {\n                    return interfaceFunction.opacity;\n                }\n                if (val === 'Stroke Width' || val === 'stroke width') {\n                    return interfaceFunction.strokeWidth;\n                }\n                return null;\n            }\n            Object.defineProperties(interfaceFunction, {\n                color: {\n                    get: ExpressionPropertyInterface(view.c)\n                },\n                opacity: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                strokeWidth: {\n                    get: ExpressionPropertyInterface(view.w)\n                },\n                dash: {\n                    get: function get() {\n                        return dashOb;\n                    }\n                },\n                _name: {\n                    value: shape.nm\n                },\n                mn: {\n                    value: shape.mn\n                }\n            });\n            view.c.setGroupProperty(PropertyInterface('Color', _propertyGroup));\n            view.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n            view.w.setGroupProperty(PropertyInterface('Stroke Width', _propertyGroup));\n            return interfaceFunction;\n        }\n        function trimInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(val) {\n                if (val === shape.e.ix || val === 'End' || val === 'end') {\n                    return interfaceFunction.end;\n                }\n                if (val === shape.s.ix) {\n                    return interfaceFunction.start;\n                }\n                if (val === shape.o.ix) {\n                    return interfaceFunction.offset;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaceFunction.propertyIndex = shape.ix;\n            view.s.setGroupProperty(PropertyInterface('Start', _propertyGroup));\n            view.e.setGroupProperty(PropertyInterface('End', _propertyGroup));\n            view.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));\n            interfaceFunction.propertyIndex = shape.ix;\n            interfaceFunction.propertyGroup = propertyGroup;\n            Object.defineProperties(interfaceFunction, {\n                start: {\n                    get: ExpressionPropertyInterface(view.s)\n                },\n                end: {\n                    get: ExpressionPropertyInterface(view.e)\n                },\n                offset: {\n                    get: ExpressionPropertyInterface(view.o)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function transformInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.a.ix === value || value === 'Anchor Point') {\n                    return interfaceFunction.anchorPoint;\n                }\n                if (shape.o.ix === value || value === 'Opacity') {\n                    return interfaceFunction.opacity;\n                }\n                if (shape.p.ix === value || value === 'Position') {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value || value === 'Rotation' || value === 'ADBE Vector Rotation') {\n                    return interfaceFunction.rotation;\n                }\n                if (shape.s.ix === value || value === 'Scale') {\n                    return interfaceFunction.scale;\n                }\n                if (shape.sk && shape.sk.ix === value || value === 'Skew') {\n                    return interfaceFunction.skew;\n                }\n                if (shape.sa && shape.sa.ix === value || value === 'Skew Axis') {\n                    return interfaceFunction.skewAxis;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            view.transform.mProps.o.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n            view.transform.mProps.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n            view.transform.mProps.a.setGroupProperty(PropertyInterface('Anchor Point', _propertyGroup));\n            view.transform.mProps.s.setGroupProperty(PropertyInterface('Scale', _propertyGroup));\n            view.transform.mProps.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n            if (view.transform.mProps.sk) {\n                view.transform.mProps.sk.setGroupProperty(PropertyInterface('Skew', _propertyGroup));\n                view.transform.mProps.sa.setGroupProperty(PropertyInterface('Skew Angle', _propertyGroup));\n            }\n            view.transform.op.setGroupProperty(PropertyInterface('Opacity', _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                opacity: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.o)\n                },\n                position: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.p)\n                },\n                anchorPoint: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.a)\n                },\n                scale: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.s)\n                },\n                rotation: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.r)\n                },\n                skew: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.sk)\n                },\n                skewAxis: {\n                    get: ExpressionPropertyInterface(view.transform.mProps.sa)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.ty = 'tr';\n            interfaceFunction.mn = shape.mn;\n            interfaceFunction.propertyGroup = propertyGroup;\n            return interfaceFunction;\n        }\n        function ellipseInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.s.ix === value) {\n                    return interfaceFunction.size;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            interfaceFunction.propertyIndex = shape.ix;\n            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n            prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));\n            prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                size: {\n                    get: ExpressionPropertyInterface(prop.s)\n                },\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function starInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value) {\n                    return interfaceFunction.rotation;\n                }\n                if (shape.pt.ix === value) {\n                    return interfaceFunction.points;\n                }\n                if (shape.or.ix === value || value === 'ADBE Vector Star Outer Radius') {\n                    return interfaceFunction.outerRadius;\n                }\n                if (shape.os.ix === value) {\n                    return interfaceFunction.outerRoundness;\n                }\n                if (shape.ir && (shape.ir.ix === value || value === 'ADBE Vector Star Inner Radius')) {\n                    return interfaceFunction.innerRadius;\n                }\n                if (shape.is && shape.is.ix === value) {\n                    return interfaceFunction.innerRoundness;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.or.setGroupProperty(PropertyInterface('Outer Radius', _propertyGroup));\n            prop.os.setGroupProperty(PropertyInterface('Outer Roundness', _propertyGroup));\n            prop.pt.setGroupProperty(PropertyInterface('Points', _propertyGroup));\n            prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n            prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n            if (shape.ir) {\n                prop.ir.setGroupProperty(PropertyInterface('Inner Radius', _propertyGroup));\n                prop.is.setGroupProperty(PropertyInterface('Inner Roundness', _propertyGroup));\n            }\n            Object.defineProperties(interfaceFunction, {\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                rotation: {\n                    get: ExpressionPropertyInterface(prop.r)\n                },\n                points: {\n                    get: ExpressionPropertyInterface(prop.pt)\n                },\n                outerRadius: {\n                    get: ExpressionPropertyInterface(prop.or)\n                },\n                outerRoundness: {\n                    get: ExpressionPropertyInterface(prop.os)\n                },\n                innerRadius: {\n                    get: ExpressionPropertyInterface(prop.ir)\n                },\n                innerRoundness: {\n                    get: ExpressionPropertyInterface(prop.is)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function rectInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.p.ix === value) {\n                    return interfaceFunction.position;\n                }\n                if (shape.r.ix === value) {\n                    return interfaceFunction.roundness;\n                }\n                if (shape.s.ix === value || value === 'Size' || value === 'ADBE Vector Rect Size') {\n                    return interfaceFunction.size;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view.sh.ty === 'tm' ? view.sh.prop : view.sh;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.p.setGroupProperty(PropertyInterface('Position', _propertyGroup));\n            prop.s.setGroupProperty(PropertyInterface('Size', _propertyGroup));\n            prop.r.setGroupProperty(PropertyInterface('Rotation', _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                position: {\n                    get: ExpressionPropertyInterface(prop.p)\n                },\n                roundness: {\n                    get: ExpressionPropertyInterface(prop.r)\n                },\n                size: {\n                    get: ExpressionPropertyInterface(prop.s)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function roundedInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.r.ix === value || value === 'Round Corners 1') {\n                    return interfaceFunction.radius;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.rd.setGroupProperty(PropertyInterface('Radius', _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                radius: {\n                    get: ExpressionPropertyInterface(prop.rd)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        function repeaterInterfaceFactory(shape, view, propertyGroup) {\n            function interfaceFunction(value) {\n                if (shape.c.ix === value || value === 'Copies') {\n                    return interfaceFunction.copies;\n                }\n                if (shape.o.ix === value || value === 'Offset') {\n                    return interfaceFunction.offset;\n                }\n                return null;\n            }\n            var _propertyGroup = propertyGroupFactory(interfaceFunction, propertyGroup);\n            var prop = view;\n            interfaceFunction.propertyIndex = shape.ix;\n            prop.c.setGroupProperty(PropertyInterface('Copies', _propertyGroup));\n            prop.o.setGroupProperty(PropertyInterface('Offset', _propertyGroup));\n            Object.defineProperties(interfaceFunction, {\n                copies: {\n                    get: ExpressionPropertyInterface(prop.c)\n                },\n                offset: {\n                    get: ExpressionPropertyInterface(prop.o)\n                },\n                _name: {\n                    value: shape.nm\n                }\n            });\n            interfaceFunction.mn = shape.mn;\n            return interfaceFunction;\n        }\n        return function(shapes, view, propertyGroup) {\n            var interfaces;\n            function _interfaceFunction(value) {\n                if (typeof value === 'number') {\n                    value = value === undefined ? 1 : value;\n                    if (value === 0) {\n                        return propertyGroup;\n                    }\n                    return interfaces[value - 1];\n                }\n                var i = 0;\n                var len = interfaces.length;\n                while(i < len){\n                    if (interfaces[i]._name === value) {\n                        return interfaces[i];\n                    }\n                    i += 1;\n                }\n                return null;\n            }\n            function parentGroupWrapper() {\n                return propertyGroup;\n            }\n            _interfaceFunction.propertyGroup = propertyGroupFactory(_interfaceFunction, parentGroupWrapper);\n            interfaces = iterateElements(shapes, view, _interfaceFunction.propertyGroup);\n            _interfaceFunction.numProperties = interfaces.length;\n            _interfaceFunction._name = 'Contents';\n            return _interfaceFunction;\n        };\n    }();\n    var TextExpressionInterface = function() {\n        return function(elem) {\n            var _sourceText;\n            function _thisLayerFunction(name) {\n                switch(name){\n                    case 'ADBE Text Document':\n                        return _thisLayerFunction.sourceText;\n                    default:\n                        return null;\n                }\n            }\n            Object.defineProperty(_thisLayerFunction, 'sourceText', {\n                get: function get() {\n                    elem.textProperty.getValue();\n                    var stringValue = elem.textProperty.currentData.t;\n                    if (!_sourceText || stringValue !== _sourceText.value) {\n                        _sourceText = new String(stringValue); // eslint-disable-line no-new-wrappers\n                        // If stringValue is an empty string, eval returns undefined, so it has to be returned as a String primitive\n                        _sourceText.value = stringValue || new String(stringValue); // eslint-disable-line no-new-wrappers\n                        Object.defineProperty(_sourceText, 'style', {\n                            get: function get() {\n                                return {\n                                    fillColor: elem.textProperty.currentData.fc\n                                };\n                            }\n                        });\n                    }\n                    return _sourceText;\n                }\n            });\n            return _thisLayerFunction;\n        };\n    }();\n    function _typeof(o) {\n        \"@babel/helpers - typeof\";\n        return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function(o) {\n            return typeof o;\n        } : function(o) {\n            return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o;\n        }, _typeof(o);\n    }\n    var FootageInterface = function() {\n        var outlineInterfaceFactory = function outlineInterfaceFactory(elem) {\n            var currentPropertyName = '';\n            var currentProperty = elem.getFootageData();\n            function init() {\n                currentPropertyName = '';\n                currentProperty = elem.getFootageData();\n                return searchProperty;\n            }\n            function searchProperty(value) {\n                if (currentProperty[value]) {\n                    currentPropertyName = value;\n                    currentProperty = currentProperty[value];\n                    if (_typeof(currentProperty) === 'object') {\n                        return searchProperty;\n                    }\n                    return currentProperty;\n                }\n                var propertyNameIndex = value.indexOf(currentPropertyName);\n                if (propertyNameIndex !== -1) {\n                    var index = parseInt(value.substr(propertyNameIndex + currentPropertyName.length), 10);\n                    currentProperty = currentProperty[index];\n                    if (_typeof(currentProperty) === 'object') {\n                        return searchProperty;\n                    }\n                    return currentProperty;\n                }\n                return '';\n            }\n            return init;\n        };\n        var dataInterfaceFactory = function dataInterfaceFactory(elem) {\n            function interfaceFunction(value) {\n                if (value === 'Outline') {\n                    return interfaceFunction.outlineInterface();\n                }\n                return null;\n            }\n            interfaceFunction._name = 'Outline';\n            interfaceFunction.outlineInterface = outlineInterfaceFactory(elem);\n            return interfaceFunction;\n        };\n        return function(elem) {\n            function _interfaceFunction(value) {\n                if (value === 'Data') {\n                    return _interfaceFunction.dataInterface;\n                }\n                return null;\n            }\n            _interfaceFunction._name = 'Data';\n            _interfaceFunction.dataInterface = dataInterfaceFactory(elem);\n            return _interfaceFunction;\n        };\n    }();\n    var interfaces = {\n        layer: LayerExpressionInterface,\n        effects: EffectsExpressionInterface,\n        comp: CompExpressionInterface,\n        shape: ShapeExpressionInterface,\n        text: TextExpressionInterface,\n        footage: FootageInterface\n    };\n    function getInterface(type) {\n        return interfaces[type] || null;\n    }\n    var expressionHelpers = function() {\n        function searchExpressions(elem, data, prop) {\n            if (data.x) {\n                prop.k = true;\n                prop.x = true;\n                prop.initiateExpression = ExpressionManager.initiateExpression;\n                prop.effectsSequence.push(prop.initiateExpression(elem, data, prop).bind(prop));\n            }\n        }\n        function getValueAtTime(frameNum) {\n            frameNum *= this.elem.globalData.frameRate;\n            frameNum -= this.offsetTime;\n            if (frameNum !== this._cachingAtTime.lastFrame) {\n                this._cachingAtTime.lastIndex = this._cachingAtTime.lastFrame < frameNum ? this._cachingAtTime.lastIndex : 0;\n                this._cachingAtTime.value = this.interpolateValue(frameNum, this._cachingAtTime);\n                this._cachingAtTime.lastFrame = frameNum;\n            }\n            return this._cachingAtTime.value;\n        }\n        function getSpeedAtTime(frameNum) {\n            var delta = -0.01;\n            var v1 = this.getValueAtTime(frameNum);\n            var v2 = this.getValueAtTime(frameNum + delta);\n            var speed = 0;\n            if (v1.length) {\n                var i;\n                for(i = 0; i < v1.length; i += 1){\n                    speed += Math.pow(v2[i] - v1[i], 2);\n                }\n                speed = Math.sqrt(speed) * 100;\n            } else {\n                speed = 0;\n            }\n            return speed;\n        }\n        function getVelocityAtTime(frameNum) {\n            if (this.vel !== undefined) {\n                return this.vel;\n            }\n            var delta = -0.001;\n            // frameNum += this.elem.data.st;\n            var v1 = this.getValueAtTime(frameNum);\n            var v2 = this.getValueAtTime(frameNum + delta);\n            var velocity;\n            if (v1.length) {\n                velocity = createTypedArray('float32', v1.length);\n                var i;\n                for(i = 0; i < v1.length; i += 1){\n                    // removing frameRate\n                    // if needed, don't add it here\n                    // velocity[i] = this.elem.globalData.frameRate*((v2[i] - v1[i])/delta);\n                    velocity[i] = (v2[i] - v1[i]) / delta;\n                }\n            } else {\n                velocity = (v2 - v1) / delta;\n            }\n            return velocity;\n        }\n        function getStaticValueAtTime() {\n            return this.pv;\n        }\n        function setGroupProperty(propertyGroup) {\n            this.propertyGroup = propertyGroup;\n        }\n        return {\n            searchExpressions: searchExpressions,\n            getSpeedAtTime: getSpeedAtTime,\n            getVelocityAtTime: getVelocityAtTime,\n            getValueAtTime: getValueAtTime,\n            getStaticValueAtTime: getStaticValueAtTime,\n            setGroupProperty: setGroupProperty\n        };\n    }();\n    function addPropertyDecorator() {\n        function loopOut(type, duration, durationFlag) {\n            if (!this.k || !this.keyframes) {\n                return this.pv;\n            }\n            type = type ? type.toLowerCase() : '';\n            var currentFrame = this.comp.renderedFrame;\n            var keyframes = this.keyframes;\n            var lastKeyFrame = keyframes[keyframes.length - 1].t;\n            if (currentFrame <= lastKeyFrame) {\n                return this.pv;\n            }\n            var cycleDuration;\n            var firstKeyFrame;\n            if (!durationFlag) {\n                if (!duration || duration > keyframes.length - 1) {\n                    duration = keyframes.length - 1;\n                }\n                firstKeyFrame = keyframes[keyframes.length - 1 - duration].t;\n                cycleDuration = lastKeyFrame - firstKeyFrame;\n            } else {\n                if (!duration) {\n                    cycleDuration = Math.max(0, lastKeyFrame - this.elem.data.ip);\n                } else {\n                    cycleDuration = Math.abs(lastKeyFrame - this.elem.comp.globalData.frameRate * duration);\n                }\n                firstKeyFrame = lastKeyFrame - cycleDuration;\n            }\n            var i;\n            var len;\n            var ret;\n            if (type === 'pingpong') {\n                var iterations = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n                if (iterations % 2 !== 0) {\n                    return this.getValueAtTime((cycleDuration - (currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                }\n            } else if (type === 'offset') {\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var current = this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                var repeats = Math.floor((currentFrame - firstKeyFrame) / cycleDuration);\n                if (this.pv.length) {\n                    ret = new Array(initV.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = (endV[i] - initV[i]) * repeats + current[i];\n                    }\n                    return ret;\n                }\n                return (endV - initV) * repeats + current;\n            } else if (type === 'continue') {\n                var lastValue = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var nextLastValue = this.getValueAtTime((lastKeyFrame - 0.001) / this.comp.globalData.frameRate, 0);\n                if (this.pv.length) {\n                    ret = new Array(lastValue.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = lastValue[i] + (lastValue[i] - nextLastValue[i]) * ((currentFrame - lastKeyFrame) / this.comp.globalData.frameRate) / 0.0005; // eslint-disable-line\n                    }\n                    return ret;\n                }\n                return lastValue + (lastValue - nextLastValue) * ((currentFrame - lastKeyFrame) / 0.001);\n            }\n            return this.getValueAtTime(((currentFrame - firstKeyFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n        function loopIn(type, duration, durationFlag) {\n            if (!this.k) {\n                return this.pv;\n            }\n            type = type ? type.toLowerCase() : '';\n            var currentFrame = this.comp.renderedFrame;\n            var keyframes = this.keyframes;\n            var firstKeyFrame = keyframes[0].t;\n            if (currentFrame >= firstKeyFrame) {\n                return this.pv;\n            }\n            var cycleDuration;\n            var lastKeyFrame;\n            if (!durationFlag) {\n                if (!duration || duration > keyframes.length - 1) {\n                    duration = keyframes.length - 1;\n                }\n                lastKeyFrame = keyframes[duration].t;\n                cycleDuration = lastKeyFrame - firstKeyFrame;\n            } else {\n                if (!duration) {\n                    cycleDuration = Math.max(0, this.elem.data.op - firstKeyFrame);\n                } else {\n                    cycleDuration = Math.abs(this.elem.comp.globalData.frameRate * duration);\n                }\n                lastKeyFrame = firstKeyFrame + cycleDuration;\n            }\n            var i;\n            var len;\n            var ret;\n            if (type === 'pingpong') {\n                var iterations = Math.floor((firstKeyFrame - currentFrame) / cycleDuration);\n                if (iterations % 2 === 0) {\n                    return this.getValueAtTime(((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n                }\n            } else if (type === 'offset') {\n                var initV = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var endV = this.getValueAtTime(lastKeyFrame / this.comp.globalData.frameRate, 0);\n                var current = this.getValueAtTime((cycleDuration - (firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame) / this.comp.globalData.frameRate, 0);\n                var repeats = Math.floor((firstKeyFrame - currentFrame) / cycleDuration) + 1;\n                if (this.pv.length) {\n                    ret = new Array(initV.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = current[i] - (endV[i] - initV[i]) * repeats;\n                    }\n                    return ret;\n                }\n                return current - (endV - initV) * repeats;\n            } else if (type === 'continue') {\n                var firstValue = this.getValueAtTime(firstKeyFrame / this.comp.globalData.frameRate, 0);\n                var nextFirstValue = this.getValueAtTime((firstKeyFrame + 0.001) / this.comp.globalData.frameRate, 0);\n                if (this.pv.length) {\n                    ret = new Array(firstValue.length);\n                    len = ret.length;\n                    for(i = 0; i < len; i += 1){\n                        ret[i] = firstValue[i] + (firstValue[i] - nextFirstValue[i]) * (firstKeyFrame - currentFrame) / 0.001;\n                    }\n                    return ret;\n                }\n                return firstValue + (firstValue - nextFirstValue) * (firstKeyFrame - currentFrame) / 0.001;\n            }\n            return this.getValueAtTime((cycleDuration - ((firstKeyFrame - currentFrame) % cycleDuration + firstKeyFrame)) / this.comp.globalData.frameRate, 0); // eslint-disable-line\n        }\n        function smooth(width, samples) {\n            if (!this.k) {\n                return this.pv;\n            }\n            width = (width || 0.4) * 0.5;\n            samples = Math.floor(samples || 5);\n            if (samples <= 1) {\n                return this.pv;\n            }\n            var currentTime = this.comp.renderedFrame / this.comp.globalData.frameRate;\n            var initFrame = currentTime - width;\n            var endFrame = currentTime + width;\n            var sampleFrequency = samples > 1 ? (endFrame - initFrame) / (samples - 1) : 1;\n            var i = 0;\n            var j = 0;\n            var value;\n            if (this.pv.length) {\n                value = createTypedArray('float32', this.pv.length);\n            } else {\n                value = 0;\n            }\n            var sampleValue;\n            while(i < samples){\n                sampleValue = this.getValueAtTime(initFrame + i * sampleFrequency);\n                if (this.pv.length) {\n                    for(j = 0; j < this.pv.length; j += 1){\n                        value[j] += sampleValue[j];\n                    }\n                } else {\n                    value += sampleValue;\n                }\n                i += 1;\n            }\n            if (this.pv.length) {\n                for(j = 0; j < this.pv.length; j += 1){\n                    value[j] /= samples;\n                }\n            } else {\n                value /= samples;\n            }\n            return value;\n        }\n        function getTransformValueAtTime(time) {\n            if (!this._transformCachingAtTime) {\n                this._transformCachingAtTime = {\n                    v: new Matrix()\n                };\n            }\n            /// /\n            var matrix = this._transformCachingAtTime.v;\n            matrix.cloneFromProps(this.pre.props);\n            if (this.appliedTransformations < 1) {\n                var anchor = this.a.getValueAtTime(time);\n                matrix.translate(-anchor[0] * this.a.mult, -anchor[1] * this.a.mult, anchor[2] * this.a.mult);\n            }\n            if (this.appliedTransformations < 2) {\n                var scale = this.s.getValueAtTime(time);\n                matrix.scale(scale[0] * this.s.mult, scale[1] * this.s.mult, scale[2] * this.s.mult);\n            }\n            if (this.sk && this.appliedTransformations < 3) {\n                var skew = this.sk.getValueAtTime(time);\n                var skewAxis = this.sa.getValueAtTime(time);\n                matrix.skewFromAxis(-skew * this.sk.mult, skewAxis * this.sa.mult);\n            }\n            if (this.r && this.appliedTransformations < 4) {\n                var rotation = this.r.getValueAtTime(time);\n                matrix.rotate(-rotation * this.r.mult);\n            } else if (!this.r && this.appliedTransformations < 4) {\n                var rotationZ = this.rz.getValueAtTime(time);\n                var rotationY = this.ry.getValueAtTime(time);\n                var rotationX = this.rx.getValueAtTime(time);\n                var orientation = this.or.getValueAtTime(time);\n                matrix.rotateZ(-rotationZ * this.rz.mult).rotateY(rotationY * this.ry.mult).rotateX(rotationX * this.rx.mult).rotateZ(-orientation[2] * this.or.mult).rotateY(orientation[1] * this.or.mult).rotateX(orientation[0] * this.or.mult);\n            }\n            if (this.data.p && this.data.p.s) {\n                var positionX = this.px.getValueAtTime(time);\n                var positionY = this.py.getValueAtTime(time);\n                if (this.data.p.z) {\n                    var positionZ = this.pz.getValueAtTime(time);\n                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, -positionZ * this.pz.mult);\n                } else {\n                    matrix.translate(positionX * this.px.mult, positionY * this.py.mult, 0);\n                }\n            } else {\n                var position = this.p.getValueAtTime(time);\n                matrix.translate(position[0] * this.p.mult, position[1] * this.p.mult, -position[2] * this.p.mult);\n            }\n            return matrix;\n        /// /\n        }\n        function getTransformStaticValueAtTime() {\n            return this.v.clone(new Matrix());\n        }\n        var getTransformProperty = TransformPropertyFactory.getTransformProperty;\n        TransformPropertyFactory.getTransformProperty = function(elem, data, container) {\n            var prop = getTransformProperty(elem, data, container);\n            if (prop.dynamicProperties.length) {\n                prop.getValueAtTime = getTransformValueAtTime.bind(prop);\n            } else {\n                prop.getValueAtTime = getTransformStaticValueAtTime.bind(prop);\n            }\n            prop.setGroupProperty = expressionHelpers.setGroupProperty;\n            return prop;\n        };\n        var propertyGetProp = PropertyFactory.getProp;\n        PropertyFactory.getProp = function(elem, data, type, mult, container) {\n            var prop = propertyGetProp(elem, data, type, mult, container);\n            // prop.getVelocityAtTime = getVelocityAtTime;\n            // prop.loopOut = loopOut;\n            // prop.loopIn = loopIn;\n            if (prop.kf) {\n                prop.getValueAtTime = expressionHelpers.getValueAtTime.bind(prop);\n            } else {\n                prop.getValueAtTime = expressionHelpers.getStaticValueAtTime.bind(prop);\n            }\n            prop.setGroupProperty = expressionHelpers.setGroupProperty;\n            prop.loopOut = loopOut;\n            prop.loopIn = loopIn;\n            prop.smooth = smooth;\n            prop.getVelocityAtTime = expressionHelpers.getVelocityAtTime.bind(prop);\n            prop.getSpeedAtTime = expressionHelpers.getSpeedAtTime.bind(prop);\n            prop.numKeys = data.a === 1 ? data.k.length : 0;\n            prop.propertyIndex = data.ix;\n            var value = 0;\n            if (type !== 0) {\n                value = createTypedArray('float32', data.a === 1 ? data.k[0].s.length : data.k.length);\n            }\n            prop._cachingAtTime = {\n                lastFrame: initialDefaultFrame,\n                lastIndex: 0,\n                value: value\n            };\n            expressionHelpers.searchExpressions(elem, data, prop);\n            if (prop.k) {\n                container.addDynamicProperty(prop);\n            }\n            return prop;\n        };\n        function getShapeValueAtTime(frameNum) {\n            // For now this caching object is created only when needed instead of creating it when the shape is initialized.\n            if (!this._cachingAtTime) {\n                this._cachingAtTime = {\n                    shapeValue: shapePool.clone(this.pv),\n                    lastIndex: 0,\n                    lastTime: initialDefaultFrame\n                };\n            }\n            frameNum *= this.elem.globalData.frameRate;\n            frameNum -= this.offsetTime;\n            if (frameNum !== this._cachingAtTime.lastTime) {\n                this._cachingAtTime.lastIndex = this._cachingAtTime.lastTime < frameNum ? this._caching.lastIndex : 0;\n                this._cachingAtTime.lastTime = frameNum;\n                this.interpolateShape(frameNum, this._cachingAtTime.shapeValue, this._cachingAtTime);\n            }\n            return this._cachingAtTime.shapeValue;\n        }\n        var ShapePropertyConstructorFunction = ShapePropertyFactory.getConstructorFunction();\n        var KeyframedShapePropertyConstructorFunction = ShapePropertyFactory.getKeyframedConstructorFunction();\n        function ShapeExpressions() {}\n        ShapeExpressions.prototype = {\n            vertices: function vertices(prop, time) {\n                if (this.k) {\n                    this.getValue();\n                }\n                var shapePath = this.v;\n                if (time !== undefined) {\n                    shapePath = this.getValueAtTime(time, 0);\n                }\n                var i;\n                var len = shapePath._length;\n                var vertices = shapePath[prop];\n                var points = shapePath.v;\n                var arr = createSizedArray(len);\n                for(i = 0; i < len; i += 1){\n                    if (prop === 'i' || prop === 'o') {\n                        arr[i] = [\n                            vertices[i][0] - points[i][0],\n                            vertices[i][1] - points[i][1]\n                        ];\n                    } else {\n                        arr[i] = [\n                            vertices[i][0],\n                            vertices[i][1]\n                        ];\n                    }\n                }\n                return arr;\n            },\n            points: function points(time) {\n                return this.vertices('v', time);\n            },\n            inTangents: function inTangents(time) {\n                return this.vertices('i', time);\n            },\n            outTangents: function outTangents(time) {\n                return this.vertices('o', time);\n            },\n            isClosed: function isClosed() {\n                return this.v.c;\n            },\n            pointOnPath: function pointOnPath(perc, time) {\n                var shapePath = this.v;\n                if (time !== undefined) {\n                    shapePath = this.getValueAtTime(time, 0);\n                }\n                if (!this._segmentsLength) {\n                    this._segmentsLength = bez.getSegmentsLength(shapePath);\n                }\n                var segmentsLength = this._segmentsLength;\n                var lengths = segmentsLength.lengths;\n                var lengthPos = segmentsLength.totalLength * perc;\n                var i = 0;\n                var len = lengths.length;\n                var accumulatedLength = 0;\n                var pt;\n                while(i < len){\n                    if (accumulatedLength + lengths[i].addedLength > lengthPos) {\n                        var initIndex = i;\n                        var endIndex = shapePath.c && i === len - 1 ? 0 : i + 1;\n                        var segmentPerc = (lengthPos - accumulatedLength) / lengths[i].addedLength;\n                        pt = bez.getPointInSegment(shapePath.v[initIndex], shapePath.v[endIndex], shapePath.o[initIndex], shapePath.i[endIndex], segmentPerc, lengths[i]);\n                        break;\n                    } else {\n                        accumulatedLength += lengths[i].addedLength;\n                    }\n                    i += 1;\n                }\n                if (!pt) {\n                    pt = shapePath.c ? [\n                        shapePath.v[0][0],\n                        shapePath.v[0][1]\n                    ] : [\n                        shapePath.v[shapePath._length - 1][0],\n                        shapePath.v[shapePath._length - 1][1]\n                    ];\n                }\n                return pt;\n            },\n            vectorOnPath: function vectorOnPath(perc, time, vectorType) {\n                // perc doesn't use triple equality because it can be a Number object as well as a primitive.\n                if (perc == 1) {\n                    // eslint-disable-line eqeqeq\n                    perc = this.v.c;\n                } else if (perc == 0) {\n                    // eslint-disable-line eqeqeq\n                    perc = 0.999;\n                }\n                var pt1 = this.pointOnPath(perc, time);\n                var pt2 = this.pointOnPath(perc + 0.001, time);\n                var xLength = pt2[0] - pt1[0];\n                var yLength = pt2[1] - pt1[1];\n                var magnitude = Math.sqrt(Math.pow(xLength, 2) + Math.pow(yLength, 2));\n                if (magnitude === 0) {\n                    return [\n                        0,\n                        0\n                    ];\n                }\n                var unitVector = vectorType === 'tangent' ? [\n                    xLength / magnitude,\n                    yLength / magnitude\n                ] : [\n                    -yLength / magnitude,\n                    xLength / magnitude\n                ];\n                return unitVector;\n            },\n            tangentOnPath: function tangentOnPath(perc, time) {\n                return this.vectorOnPath(perc, time, 'tangent');\n            },\n            normalOnPath: function normalOnPath(perc, time) {\n                return this.vectorOnPath(perc, time, 'normal');\n            },\n            setGroupProperty: expressionHelpers.setGroupProperty,\n            getValueAtTime: expressionHelpers.getStaticValueAtTime\n        };\n        extendPrototype([\n            ShapeExpressions\n        ], ShapePropertyConstructorFunction);\n        extendPrototype([\n            ShapeExpressions\n        ], KeyframedShapePropertyConstructorFunction);\n        KeyframedShapePropertyConstructorFunction.prototype.getValueAtTime = getShapeValueAtTime;\n        KeyframedShapePropertyConstructorFunction.prototype.initiateExpression = ExpressionManager.initiateExpression;\n        var propertyGetShapeProp = ShapePropertyFactory.getShapeProp;\n        ShapePropertyFactory.getShapeProp = function(elem, data, type, arr, trims) {\n            var prop = propertyGetShapeProp(elem, data, type, arr, trims);\n            prop.propertyIndex = data.ix;\n            prop.lock = false;\n            if (type === 3) {\n                expressionHelpers.searchExpressions(elem, data.pt, prop);\n            } else if (type === 4) {\n                expressionHelpers.searchExpressions(elem, data.ks, prop);\n            }\n            if (prop.k) {\n                elem.addDynamicProperty(prop);\n            }\n            return prop;\n        };\n    }\n    function initialize$1() {\n        addPropertyDecorator();\n    }\n    function addDecorator() {\n        function searchExpressions() {\n            if (this.data.d.x) {\n                this.calculateExpression = ExpressionManager.initiateExpression.bind(this)(this.elem, this.data.d, this);\n                this.addEffect(this.getExpressionValue.bind(this));\n                return true;\n            }\n            return null;\n        }\n        TextProperty.prototype.getExpressionValue = function(currentValue, text) {\n            var newValue = this.calculateExpression(text);\n            if (currentValue.t !== newValue) {\n                var newData = {};\n                this.copyData(newData, currentValue);\n                newData.t = newValue.toString();\n                newData.__complete = false;\n                return newData;\n            }\n            return currentValue;\n        };\n        TextProperty.prototype.searchProperty = function() {\n            var isKeyframed = this.searchKeyframes();\n            var hasExpressions = this.searchExpressions();\n            this.kf = isKeyframed || hasExpressions;\n            return this.kf;\n        };\n        TextProperty.prototype.searchExpressions = searchExpressions;\n    }\n    function initialize() {\n        addDecorator();\n    }\n    function SVGComposableEffect() {}\n    SVGComposableEffect.prototype = {\n        createMergeNode: function createMergeNode(resultId, ins) {\n            var feMerge = createNS('feMerge');\n            feMerge.setAttribute('result', resultId);\n            var feMergeNode;\n            var i;\n            for(i = 0; i < ins.length; i += 1){\n                feMergeNode = createNS('feMergeNode');\n                feMergeNode.setAttribute('in', ins[i]);\n                feMerge.appendChild(feMergeNode);\n                feMerge.appendChild(feMergeNode);\n            }\n            return feMerge;\n        }\n    };\n    var linearFilterValue = '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0';\n    function SVGTintFilter(filter, filterManager, elem, id, source) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS('feColorMatrix');\n        feColorMatrix.setAttribute('type', 'matrix');\n        feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');\n        feColorMatrix.setAttribute('values', linearFilterValue + ' 1 0');\n        this.linearFilter = feColorMatrix;\n        feColorMatrix.setAttribute('result', id + '_tint_1');\n        filter.appendChild(feColorMatrix);\n        feColorMatrix = createNS('feColorMatrix');\n        feColorMatrix.setAttribute('type', 'matrix');\n        feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n        feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\n        feColorMatrix.setAttribute('result', id + '_tint_2');\n        filter.appendChild(feColorMatrix);\n        this.matrixFilter = feColorMatrix;\n        var feMerge = this.createMergeNode(id, [\n            source,\n            id + '_tint_1',\n            id + '_tint_2'\n        ]);\n        filter.appendChild(feMerge);\n    }\n    extendPrototype([\n        SVGComposableEffect\n    ], SVGTintFilter);\n    SVGTintFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var colorBlack = this.filterManager.effectElements[0].p.v;\n            var colorWhite = this.filterManager.effectElements[1].p.v;\n            var opacity = this.filterManager.effectElements[2].p.v / 100;\n            this.linearFilter.setAttribute('values', linearFilterValue + ' ' + opacity + ' 0');\n            this.matrixFilter.setAttribute('values', colorWhite[0] - colorBlack[0] + ' 0 0 0 ' + colorBlack[0] + ' ' + (colorWhite[1] - colorBlack[1]) + ' 0 0 0 ' + colorBlack[1] + ' ' + (colorWhite[2] - colorBlack[2]) + ' 0 0 0 ' + colorBlack[2] + ' 0 0 0 1 0');\n        }\n    };\n    function SVGFillFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS('feColorMatrix');\n        feColorMatrix.setAttribute('type', 'matrix');\n        feColorMatrix.setAttribute('color-interpolation-filters', 'sRGB');\n        feColorMatrix.setAttribute('values', '1 0 0 0 0 0 1 0 0 0 0 0 1 0 0 0 0 0 1 0');\n        feColorMatrix.setAttribute('result', id);\n        filter.appendChild(feColorMatrix);\n        this.matrixFilter = feColorMatrix;\n    }\n    SVGFillFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var color = this.filterManager.effectElements[2].p.v;\n            var opacity = this.filterManager.effectElements[6].p.v;\n            this.matrixFilter.setAttribute('values', '0 0 0 0 ' + color[0] + ' 0 0 0 0 ' + color[1] + ' 0 0 0 0 ' + color[2] + ' 0 0 0 ' + opacity + ' 0');\n        }\n    };\n    function SVGStrokeEffect(fil, filterManager, elem) {\n        this.initialized = false;\n        this.filterManager = filterManager;\n        this.elem = elem;\n        this.paths = [];\n    }\n    SVGStrokeEffect.prototype.initialize = function() {\n        var elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n        var path;\n        var groupPath;\n        var i;\n        var len;\n        if (this.filterManager.effectElements[1].p.v === 1) {\n            len = this.elem.maskManager.masksProperties.length;\n            i = 0;\n        } else {\n            i = this.filterManager.effectElements[0].p.v - 1;\n            len = i + 1;\n        }\n        groupPath = createNS('g');\n        groupPath.setAttribute('fill', 'none');\n        groupPath.setAttribute('stroke-linecap', 'round');\n        groupPath.setAttribute('stroke-dashoffset', 1);\n        for(i; i < len; i += 1){\n            path = createNS('path');\n            groupPath.appendChild(path);\n            this.paths.push({\n                p: path,\n                m: i\n            });\n        }\n        if (this.filterManager.effectElements[10].p.v === 3) {\n            var mask = createNS('mask');\n            var id = createElementID();\n            mask.setAttribute('id', id);\n            mask.setAttribute('mask-type', 'alpha');\n            mask.appendChild(groupPath);\n            this.elem.globalData.defs.appendChild(mask);\n            var g = createNS('g');\n            g.setAttribute('mask', 'url(' + getLocationHref() + '#' + id + ')');\n            while(elemChildren[0]){\n                g.appendChild(elemChildren[0]);\n            }\n            this.elem.layerElement.appendChild(g);\n            this.masker = mask;\n            groupPath.setAttribute('stroke', '#fff');\n        } else if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n            if (this.filterManager.effectElements[10].p.v === 2) {\n                elemChildren = this.elem.layerElement.children || this.elem.layerElement.childNodes;\n                while(elemChildren.length){\n                    this.elem.layerElement.removeChild(elemChildren[0]);\n                }\n            }\n            this.elem.layerElement.appendChild(groupPath);\n            this.elem.layerElement.removeAttribute('mask');\n            groupPath.setAttribute('stroke', '#fff');\n        }\n        this.initialized = true;\n        this.pathMasker = groupPath;\n    };\n    SVGStrokeEffect.prototype.renderFrame = function(forceRender) {\n        if (!this.initialized) {\n            this.initialize();\n        }\n        var i;\n        var len = this.paths.length;\n        var mask;\n        var path;\n        for(i = 0; i < len; i += 1){\n            if (this.paths[i].m !== -1) {\n                mask = this.elem.maskManager.viewData[this.paths[i].m];\n                path = this.paths[i].p;\n                if (forceRender || this.filterManager._mdf || mask.prop._mdf) {\n                    path.setAttribute('d', mask.lastPath);\n                }\n                if (forceRender || this.filterManager.effectElements[9].p._mdf || this.filterManager.effectElements[4].p._mdf || this.filterManager.effectElements[7].p._mdf || this.filterManager.effectElements[8].p._mdf || mask.prop._mdf) {\n                    var dasharrayValue;\n                    if (this.filterManager.effectElements[7].p.v !== 0 || this.filterManager.effectElements[8].p.v !== 100) {\n                        var s = Math.min(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n                        var e = Math.max(this.filterManager.effectElements[7].p.v, this.filterManager.effectElements[8].p.v) * 0.01;\n                        var l = path.getTotalLength();\n                        dasharrayValue = '0 0 0 ' + l * s + ' ';\n                        var lineLength = l * (e - s);\n                        var segment = 1 + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n                        var units = Math.floor(lineLength / segment);\n                        var j;\n                        for(j = 0; j < units; j += 1){\n                            dasharrayValue += '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01 + ' ';\n                        }\n                        dasharrayValue += '0 ' + l * 10 + ' 0 0';\n                    } else {\n                        dasharrayValue = '1 ' + this.filterManager.effectElements[4].p.v * 2 * this.filterManager.effectElements[9].p.v * 0.01;\n                    }\n                    path.setAttribute('stroke-dasharray', dasharrayValue);\n                }\n            }\n        }\n        if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n            this.pathMasker.setAttribute('stroke-width', this.filterManager.effectElements[4].p.v * 2);\n        }\n        if (forceRender || this.filterManager.effectElements[6].p._mdf) {\n            this.pathMasker.setAttribute('opacity', this.filterManager.effectElements[6].p.v);\n        }\n        if (this.filterManager.effectElements[10].p.v === 1 || this.filterManager.effectElements[10].p.v === 2) {\n            if (forceRender || this.filterManager.effectElements[3].p._mdf) {\n                var color = this.filterManager.effectElements[3].p.v;\n                this.pathMasker.setAttribute('stroke', 'rgb(' + bmFloor(color[0] * 255) + ',' + bmFloor(color[1] * 255) + ',' + bmFloor(color[2] * 255) + ')');\n            }\n        }\n    };\n    function SVGTritoneFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var feColorMatrix = createNS('feColorMatrix');\n        feColorMatrix.setAttribute('type', 'matrix');\n        feColorMatrix.setAttribute('color-interpolation-filters', 'linearRGB');\n        feColorMatrix.setAttribute('values', '0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0.3333 0.3333 0.3333 0 0 0 0 0 1 0');\n        filter.appendChild(feColorMatrix);\n        var feComponentTransfer = createNS('feComponentTransfer');\n        feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n        feComponentTransfer.setAttribute('result', id);\n        this.matrixFilter = feComponentTransfer;\n        var feFuncR = createNS('feFuncR');\n        feFuncR.setAttribute('type', 'table');\n        feComponentTransfer.appendChild(feFuncR);\n        this.feFuncR = feFuncR;\n        var feFuncG = createNS('feFuncG');\n        feFuncG.setAttribute('type', 'table');\n        feComponentTransfer.appendChild(feFuncG);\n        this.feFuncG = feFuncG;\n        var feFuncB = createNS('feFuncB');\n        feFuncB.setAttribute('type', 'table');\n        feComponentTransfer.appendChild(feFuncB);\n        this.feFuncB = feFuncB;\n        filter.appendChild(feComponentTransfer);\n    }\n    SVGTritoneFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var color1 = this.filterManager.effectElements[0].p.v;\n            var color2 = this.filterManager.effectElements[1].p.v;\n            var color3 = this.filterManager.effectElements[2].p.v;\n            var tableR = color3[0] + ' ' + color2[0] + ' ' + color1[0];\n            var tableG = color3[1] + ' ' + color2[1] + ' ' + color1[1];\n            var tableB = color3[2] + ' ' + color2[2] + ' ' + color1[2];\n            this.feFuncR.setAttribute('tableValues', tableR);\n            this.feFuncG.setAttribute('tableValues', tableG);\n            this.feFuncB.setAttribute('tableValues', tableB);\n        }\n    };\n    function SVGProLevelsFilter(filter, filterManager, elem, id) {\n        this.filterManager = filterManager;\n        var effectElements = this.filterManager.effectElements;\n        var feComponentTransfer = createNS('feComponentTransfer');\n        // Red\n        if (effectElements[10].p.k || effectElements[10].p.v !== 0 || effectElements[11].p.k || effectElements[11].p.v !== 1 || effectElements[12].p.k || effectElements[12].p.v !== 1 || effectElements[13].p.k || effectElements[13].p.v !== 0 || effectElements[14].p.k || effectElements[14].p.v !== 1) {\n            this.feFuncR = this.createFeFunc('feFuncR', feComponentTransfer);\n        }\n        // Green\n        if (effectElements[17].p.k || effectElements[17].p.v !== 0 || effectElements[18].p.k || effectElements[18].p.v !== 1 || effectElements[19].p.k || effectElements[19].p.v !== 1 || effectElements[20].p.k || effectElements[20].p.v !== 0 || effectElements[21].p.k || effectElements[21].p.v !== 1) {\n            this.feFuncG = this.createFeFunc('feFuncG', feComponentTransfer);\n        }\n        // Blue\n        if (effectElements[24].p.k || effectElements[24].p.v !== 0 || effectElements[25].p.k || effectElements[25].p.v !== 1 || effectElements[26].p.k || effectElements[26].p.v !== 1 || effectElements[27].p.k || effectElements[27].p.v !== 0 || effectElements[28].p.k || effectElements[28].p.v !== 1) {\n            this.feFuncB = this.createFeFunc('feFuncB', feComponentTransfer);\n        }\n        // Alpha\n        if (effectElements[31].p.k || effectElements[31].p.v !== 0 || effectElements[32].p.k || effectElements[32].p.v !== 1 || effectElements[33].p.k || effectElements[33].p.v !== 1 || effectElements[34].p.k || effectElements[34].p.v !== 0 || effectElements[35].p.k || effectElements[35].p.v !== 1) {\n            this.feFuncA = this.createFeFunc('feFuncA', feComponentTransfer);\n        }\n        // RGB\n        if (this.feFuncR || this.feFuncG || this.feFuncB || this.feFuncA) {\n            feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n            filter.appendChild(feComponentTransfer);\n        }\n        if (effectElements[3].p.k || effectElements[3].p.v !== 0 || effectElements[4].p.k || effectElements[4].p.v !== 1 || effectElements[5].p.k || effectElements[5].p.v !== 1 || effectElements[6].p.k || effectElements[6].p.v !== 0 || effectElements[7].p.k || effectElements[7].p.v !== 1) {\n            feComponentTransfer = createNS('feComponentTransfer');\n            feComponentTransfer.setAttribute('color-interpolation-filters', 'sRGB');\n            feComponentTransfer.setAttribute('result', id);\n            filter.appendChild(feComponentTransfer);\n            this.feFuncRComposed = this.createFeFunc('feFuncR', feComponentTransfer);\n            this.feFuncGComposed = this.createFeFunc('feFuncG', feComponentTransfer);\n            this.feFuncBComposed = this.createFeFunc('feFuncB', feComponentTransfer);\n        }\n    }\n    SVGProLevelsFilter.prototype.createFeFunc = function(type, feComponentTransfer) {\n        var feFunc = createNS(type);\n        feFunc.setAttribute('type', 'table');\n        feComponentTransfer.appendChild(feFunc);\n        return feFunc;\n    };\n    SVGProLevelsFilter.prototype.getTableValue = function(inputBlack, inputWhite, gamma, outputBlack, outputWhite) {\n        var cnt = 0;\n        var segments = 256;\n        var perc;\n        var min = Math.min(inputBlack, inputWhite);\n        var max = Math.max(inputBlack, inputWhite);\n        var table = Array.call(null, {\n            length: segments\n        });\n        var colorValue;\n        var pos = 0;\n        var outputDelta = outputWhite - outputBlack;\n        var inputDelta = inputWhite - inputBlack;\n        while(cnt <= 256){\n            perc = cnt / 256;\n            if (perc <= min) {\n                colorValue = inputDelta < 0 ? outputWhite : outputBlack;\n            } else if (perc >= max) {\n                colorValue = inputDelta < 0 ? outputBlack : outputWhite;\n            } else {\n                colorValue = outputBlack + outputDelta * Math.pow((perc - inputBlack) / inputDelta, 1 / gamma);\n            }\n            table[pos] = colorValue;\n            pos += 1;\n            cnt += 256 / (segments - 1);\n        }\n        return table.join(' ');\n    };\n    SVGProLevelsFilter.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            var val;\n            var effectElements = this.filterManager.effectElements;\n            if (this.feFuncRComposed && (forceRender || effectElements[3].p._mdf || effectElements[4].p._mdf || effectElements[5].p._mdf || effectElements[6].p._mdf || effectElements[7].p._mdf)) {\n                val = this.getTableValue(effectElements[3].p.v, effectElements[4].p.v, effectElements[5].p.v, effectElements[6].p.v, effectElements[7].p.v);\n                this.feFuncRComposed.setAttribute('tableValues', val);\n                this.feFuncGComposed.setAttribute('tableValues', val);\n                this.feFuncBComposed.setAttribute('tableValues', val);\n            }\n            if (this.feFuncR && (forceRender || effectElements[10].p._mdf || effectElements[11].p._mdf || effectElements[12].p._mdf || effectElements[13].p._mdf || effectElements[14].p._mdf)) {\n                val = this.getTableValue(effectElements[10].p.v, effectElements[11].p.v, effectElements[12].p.v, effectElements[13].p.v, effectElements[14].p.v);\n                this.feFuncR.setAttribute('tableValues', val);\n            }\n            if (this.feFuncG && (forceRender || effectElements[17].p._mdf || effectElements[18].p._mdf || effectElements[19].p._mdf || effectElements[20].p._mdf || effectElements[21].p._mdf)) {\n                val = this.getTableValue(effectElements[17].p.v, effectElements[18].p.v, effectElements[19].p.v, effectElements[20].p.v, effectElements[21].p.v);\n                this.feFuncG.setAttribute('tableValues', val);\n            }\n            if (this.feFuncB && (forceRender || effectElements[24].p._mdf || effectElements[25].p._mdf || effectElements[26].p._mdf || effectElements[27].p._mdf || effectElements[28].p._mdf)) {\n                val = this.getTableValue(effectElements[24].p.v, effectElements[25].p.v, effectElements[26].p.v, effectElements[27].p.v, effectElements[28].p.v);\n                this.feFuncB.setAttribute('tableValues', val);\n            }\n            if (this.feFuncA && (forceRender || effectElements[31].p._mdf || effectElements[32].p._mdf || effectElements[33].p._mdf || effectElements[34].p._mdf || effectElements[35].p._mdf)) {\n                val = this.getTableValue(effectElements[31].p.v, effectElements[32].p.v, effectElements[33].p.v, effectElements[34].p.v, effectElements[35].p.v);\n                this.feFuncA.setAttribute('tableValues', val);\n            }\n        }\n    };\n    function SVGDropShadowEffect(filter, filterManager, elem, id, source) {\n        var globalFilterSize = filterManager.container.globalData.renderConfig.filterSize;\n        var filterSize = filterManager.data.fs || globalFilterSize;\n        filter.setAttribute('x', filterSize.x || globalFilterSize.x);\n        filter.setAttribute('y', filterSize.y || globalFilterSize.y);\n        filter.setAttribute('width', filterSize.width || globalFilterSize.width);\n        filter.setAttribute('height', filterSize.height || globalFilterSize.height);\n        this.filterManager = filterManager;\n        var feGaussianBlur = createNS('feGaussianBlur');\n        feGaussianBlur.setAttribute('in', 'SourceAlpha');\n        feGaussianBlur.setAttribute('result', id + '_drop_shadow_1');\n        feGaussianBlur.setAttribute('stdDeviation', '0');\n        this.feGaussianBlur = feGaussianBlur;\n        filter.appendChild(feGaussianBlur);\n        var feOffset = createNS('feOffset');\n        feOffset.setAttribute('dx', '25');\n        feOffset.setAttribute('dy', '0');\n        feOffset.setAttribute('in', id + '_drop_shadow_1');\n        feOffset.setAttribute('result', id + '_drop_shadow_2');\n        this.feOffset = feOffset;\n        filter.appendChild(feOffset);\n        var feFlood = createNS('feFlood');\n        feFlood.setAttribute('flood-color', '#00ff00');\n        feFlood.setAttribute('flood-opacity', '1');\n        feFlood.setAttribute('result', id + '_drop_shadow_3');\n        this.feFlood = feFlood;\n        filter.appendChild(feFlood);\n        var feComposite = createNS('feComposite');\n        feComposite.setAttribute('in', id + '_drop_shadow_3');\n        feComposite.setAttribute('in2', id + '_drop_shadow_2');\n        feComposite.setAttribute('operator', 'in');\n        feComposite.setAttribute('result', id + '_drop_shadow_4');\n        filter.appendChild(feComposite);\n        var feMerge = this.createMergeNode(id, [\n            id + '_drop_shadow_4',\n            source\n        ]);\n        filter.appendChild(feMerge);\n    //\n    }\n    extendPrototype([\n        SVGComposableEffect\n    ], SVGDropShadowEffect);\n    SVGDropShadowEffect.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            if (forceRender || this.filterManager.effectElements[4].p._mdf) {\n                this.feGaussianBlur.setAttribute('stdDeviation', this.filterManager.effectElements[4].p.v / 4);\n            }\n            if (forceRender || this.filterManager.effectElements[0].p._mdf) {\n                var col = this.filterManager.effectElements[0].p.v;\n                this.feFlood.setAttribute('flood-color', rgbToHex(Math.round(col[0] * 255), Math.round(col[1] * 255), Math.round(col[2] * 255)));\n            }\n            if (forceRender || this.filterManager.effectElements[1].p._mdf) {\n                this.feFlood.setAttribute('flood-opacity', this.filterManager.effectElements[1].p.v / 255);\n            }\n            if (forceRender || this.filterManager.effectElements[2].p._mdf || this.filterManager.effectElements[3].p._mdf) {\n                var distance = this.filterManager.effectElements[3].p.v;\n                var angle = (this.filterManager.effectElements[2].p.v - 90) * degToRads;\n                var x = distance * Math.cos(angle);\n                var y = distance * Math.sin(angle);\n                this.feOffset.setAttribute('dx', x);\n                this.feOffset.setAttribute('dy', y);\n            }\n        }\n    };\n    var _svgMatteSymbols = [];\n    function SVGMatte3Effect(filterElem, filterManager, elem) {\n        this.initialized = false;\n        this.filterManager = filterManager;\n        this.filterElem = filterElem;\n        this.elem = elem;\n        elem.matteElement = createNS('g');\n        elem.matteElement.appendChild(elem.layerElement);\n        elem.matteElement.appendChild(elem.transformedElement);\n        elem.baseElement = elem.matteElement;\n    }\n    SVGMatte3Effect.prototype.findSymbol = function(mask) {\n        var i = 0;\n        var len = _svgMatteSymbols.length;\n        while(i < len){\n            if (_svgMatteSymbols[i] === mask) {\n                return _svgMatteSymbols[i];\n            }\n            i += 1;\n        }\n        return null;\n    };\n    SVGMatte3Effect.prototype.replaceInParent = function(mask, symbolId) {\n        var parentNode = mask.layerElement.parentNode;\n        if (!parentNode) {\n            return;\n        }\n        var children = parentNode.children;\n        var i = 0;\n        var len = children.length;\n        while(i < len){\n            if (children[i] === mask.layerElement) {\n                break;\n            }\n            i += 1;\n        }\n        var nextChild;\n        if (i <= len - 2) {\n            nextChild = children[i + 1];\n        }\n        var useElem = createNS('use');\n        useElem.setAttribute('href', '#' + symbolId);\n        if (nextChild) {\n            parentNode.insertBefore(useElem, nextChild);\n        } else {\n            parentNode.appendChild(useElem);\n        }\n    };\n    SVGMatte3Effect.prototype.setElementAsMask = function(elem, mask) {\n        if (!this.findSymbol(mask)) {\n            var symbolId = createElementID();\n            var masker = createNS('mask');\n            masker.setAttribute('id', mask.layerId);\n            masker.setAttribute('mask-type', 'alpha');\n            _svgMatteSymbols.push(mask);\n            var defs = elem.globalData.defs;\n            defs.appendChild(masker);\n            var symbol = createNS('symbol');\n            symbol.setAttribute('id', symbolId);\n            this.replaceInParent(mask, symbolId);\n            symbol.appendChild(mask.layerElement);\n            defs.appendChild(symbol);\n            var useElem = createNS('use');\n            useElem.setAttribute('href', '#' + symbolId);\n            masker.appendChild(useElem);\n            mask.data.hd = false;\n            mask.show();\n        }\n        elem.setMatte(mask.layerId);\n    };\n    SVGMatte3Effect.prototype.initialize = function() {\n        var ind = this.filterManager.effectElements[0].p.v;\n        var elements = this.elem.comp.elements;\n        var i = 0;\n        var len = elements.length;\n        while(i < len){\n            if (elements[i] && elements[i].data.ind === ind) {\n                this.setElementAsMask(this.elem, elements[i]);\n            }\n            i += 1;\n        }\n        this.initialized = true;\n    };\n    SVGMatte3Effect.prototype.renderFrame = function() {\n        if (!this.initialized) {\n            this.initialize();\n        }\n    };\n    function SVGGaussianBlurEffect(filter, filterManager, elem, id) {\n        // Outset the filter region by 100% on all sides to accommodate blur expansion.\n        filter.setAttribute('x', '-100%');\n        filter.setAttribute('y', '-100%');\n        filter.setAttribute('width', '300%');\n        filter.setAttribute('height', '300%');\n        this.filterManager = filterManager;\n        var feGaussianBlur = createNS('feGaussianBlur');\n        feGaussianBlur.setAttribute('result', id);\n        filter.appendChild(feGaussianBlur);\n        this.feGaussianBlur = feGaussianBlur;\n    }\n    SVGGaussianBlurEffect.prototype.renderFrame = function(forceRender) {\n        if (forceRender || this.filterManager._mdf) {\n            // Empirical value, matching AE's blur appearance.\n            var kBlurrinessToSigma = 0.3;\n            var sigma = this.filterManager.effectElements[0].p.v * kBlurrinessToSigma;\n            // Dimensions mapping:\n            //\n            //   1 -> horizontal & vertical\n            //   2 -> horizontal only\n            //   3 -> vertical only\n            //\n            var dimensions = this.filterManager.effectElements[1].p.v;\n            var sigmaX = dimensions == 3 ? 0 : sigma; // eslint-disable-line eqeqeq\n            var sigmaY = dimensions == 2 ? 0 : sigma; // eslint-disable-line eqeqeq\n            this.feGaussianBlur.setAttribute('stdDeviation', sigmaX + ' ' + sigmaY);\n            // Repeat edges mapping:\n            //\n            //   0 -> off -> duplicate\n            //   1 -> on  -> wrap\n            var edgeMode = this.filterManager.effectElements[2].p.v == 1 ? 'wrap' : 'duplicate'; // eslint-disable-line eqeqeq\n            this.feGaussianBlur.setAttribute('edgeMode', edgeMode);\n        }\n    };\n    function TransformEffect() {}\n    TransformEffect.prototype.init = function(effectsManager) {\n        this.effectsManager = effectsManager;\n        this.type = effectTypes.TRANSFORM_EFFECT;\n        this.matrix = new Matrix();\n        this.opacity = -1;\n        this._mdf = false;\n        this._opMdf = false;\n    };\n    TransformEffect.prototype.renderFrame = function(forceFrame) {\n        this._opMdf = false;\n        this._mdf = false;\n        if (forceFrame || this.effectsManager._mdf) {\n            var effectElements = this.effectsManager.effectElements;\n            var anchor = effectElements[0].p.v;\n            var position = effectElements[1].p.v;\n            var isUniformScale = effectElements[2].p.v === 1;\n            var scaleHeight = effectElements[3].p.v;\n            var scaleWidth = isUniformScale ? scaleHeight : effectElements[4].p.v;\n            var skew = effectElements[5].p.v;\n            var skewAxis = effectElements[6].p.v;\n            var rotation = effectElements[7].p.v;\n            this.matrix.reset();\n            this.matrix.translate(-anchor[0], -anchor[1], anchor[2]);\n            this.matrix.scale(scaleWidth * 0.01, scaleHeight * 0.01, 1);\n            this.matrix.rotate(-rotation * degToRads);\n            this.matrix.skewFromAxis(-skew * degToRads, (skewAxis + 90) * degToRads);\n            this.matrix.translate(position[0], position[1], 0);\n            this._mdf = true;\n            if (this.opacity !== effectElements[8].p.v) {\n                this.opacity = effectElements[8].p.v;\n                this._opMdf = true;\n            }\n        }\n    };\n    function SVGTransformEffect(_, filterManager) {\n        this.init(filterManager);\n    }\n    extendPrototype([\n        TransformEffect\n    ], SVGTransformEffect);\n    function CVTransformEffect(effectsManager) {\n        this.init(effectsManager);\n    }\n    extendPrototype([\n        TransformEffect\n    ], CVTransformEffect);\n    // Registering renderers\n    registerRenderer('canvas', CanvasRenderer);\n    registerRenderer('html', HybridRenderer);\n    registerRenderer('svg', SVGRenderer);\n    // Registering shape modifiers\n    ShapeModifiers.registerModifier('tm', TrimModifier);\n    ShapeModifiers.registerModifier('pb', PuckerAndBloatModifier);\n    ShapeModifiers.registerModifier('rp', RepeaterModifier);\n    ShapeModifiers.registerModifier('rd', RoundCornersModifier);\n    ShapeModifiers.registerModifier('zz', ZigZagModifier);\n    ShapeModifiers.registerModifier('op', OffsetPathModifier);\n    // Registering expression plugin\n    setExpressionsPlugin(Expressions);\n    setExpressionInterfaces(getInterface);\n    initialize$1();\n    initialize();\n    // Registering svg effects\n    registerEffect$1(20, SVGTintFilter, true);\n    registerEffect$1(21, SVGFillFilter, true);\n    registerEffect$1(22, SVGStrokeEffect, false);\n    registerEffect$1(23, SVGTritoneFilter, true);\n    registerEffect$1(24, SVGProLevelsFilter, true);\n    registerEffect$1(25, SVGDropShadowEffect, true);\n    registerEffect$1(28, SVGMatte3Effect, false);\n    registerEffect$1(29, SVGGaussianBlurEffect, true);\n    registerEffect$1(35, SVGTransformEffect, false);\n    registerEffect(35, CVTransformEffect);\n    return lottie;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9sb3R0aWUtd2ViL2J1aWxkL3BsYXllci9sb3R0aWUuanMiLCJtYXBwaW5ncyI6IjtBQUFDLE9BQU9BLGFBQWEsZUFBaUIsT0FBT0MsY0FBYyxlQUFnQixTQUFXQyxNQUFNLEVBQUVDLE9BQU87SUFDbkcsS0FBNEQsR0FBR0UsT0FBT0QsT0FBTyxHQUFHRCxZQUNoRixDQUNvRztBQUN0RyxFQUFHLFFBQU87SUFBYztJQUV0QixJQUFJUSxRQUFRO0lBQ1osSUFBSUMsZUFBZTtJQUNuQixJQUFJQyxnQkFBZ0I7SUFDcEIsSUFBSUMsc0JBQXNCLENBQUM7SUFDM0IsSUFBSUMsZUFBZSxTQUFTQSxhQUFhQyxJQUFJO1FBQzNDSCxnQkFBZ0IsQ0FBQyxDQUFDRztJQUNwQjtJQUNBLElBQUlDLGVBQWUsU0FBU0E7UUFDMUIsT0FBT0o7SUFDVDtJQUNBLElBQUlLLGtCQUFrQixTQUFTQSxnQkFBZ0JDLEtBQUs7UUFDbERQLGVBQWVPO0lBQ2pCO0lBQ0EsSUFBSUMsa0JBQWtCLFNBQVNBO1FBQzdCLE9BQU9SO0lBQ1Q7SUFFQSxTQUFTUyxVQUFVQyxJQUFJO1FBQ3JCLHVFQUF1RTtRQUN2RSxPQUFPdEIsU0FBU3VCLGFBQWEsQ0FBQ0Q7SUFDaEM7SUFFQSxTQUFTRSxnQkFBZ0JDLE9BQU8sRUFBRUMsV0FBVztRQUMzQyxJQUFJQztRQUNKLElBQUlDLE1BQU1ILFFBQVFJLE1BQU07UUFDeEIsSUFBSUM7UUFDSixJQUFLSCxJQUFJLEdBQUdBLElBQUlDLEtBQUtELEtBQUssRUFBRztZQUMzQkcsa0JBQWtCTCxPQUFPLENBQUNFLEVBQUUsQ0FBQ0ksU0FBUztZQUN0QyxJQUFLLElBQUlDLFFBQVFGLGdCQUFpQjtnQkFDaEMsSUFBSUcsT0FBT0YsU0FBUyxDQUFDRyxjQUFjLENBQUNDLElBQUksQ0FBQ0wsaUJBQWlCRSxPQUFPTixZQUFZSyxTQUFTLENBQUNDLEtBQUssR0FBR0YsZUFBZSxDQUFDRSxLQUFLO1lBQ3RI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QUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsRUFBRSxFQUFFQSxXQUFXLENBQUMsR0FBRyxFQUFFQSxXQUFXLENBQUMsR0FBRyxFQUFFQSxXQUFXLENBQUMsR0FBRyxFQUFFQSxXQUFXLENBQUMsR0FBRyxFQUFFQSxXQUFXLENBQUMsR0FBRyxFQUFFQSxXQUFXLENBQUMsR0FBRztRQUM1UjtRQUNBLFNBQVNDO1lBQ1AsSUFBSSxDQUFDLElBQUksQ0FBQ2xCLG1CQUFtQixFQUFFO2dCQUM3QixJQUFJLENBQUNtQixTQUFTLEdBQUcsQ0FBRSxLQUFJLENBQUN2RCxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsRUFBRSxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxDQUFDQSxLQUFLLENBQUMsR0FBRyxLQUFLLEtBQUssSUFBSSxDQUFDQSxL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LEdBQUc7b0JBQzdFO29CQUNBLElBQUksQ0FBQ2pJLE1BQU0sQ0FBQ2hDLFNBQVMsQ0FBQ3VNLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxFQUFFLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHLEVBQUVBLE1BQU0sQ0FBQyxHQUFHO29CQUMxTSxJQUFJLENBQUN2SyxNQUFNLENBQUNoQyxTQUFTLENBQUN3TSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsRUFBRSxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRyxFQUFFQSxNQUFNLENBQUMsR0FBRztvQkFDMU0sSUFBSSxDQUFDeEssTUFBTSxDQUFDaEMsU0FBUyxDQUFDc00sTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUsRUFBRUEsTUFBTSxDQUFDLEVBQUUs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LGlCQUFpQixVQUFVeXNEO0lBQzNCenNELGlCQUFpQixRQUFRaXpEO0lBQ3pCanpELGlCQUFpQixPQUFPOGdEO0lBRXhCLDhCQUE4QjtJQUM5Qm41QixlQUFlRSxnQkFBZ0IsQ0FBQyxNQUFNTztJQUN0Q1QsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTXFDO0lBQ3RDdkMsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTWlFO0lBQ3RDbkUsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTTRHO0lBQ3RDOUcsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTWdMO0lBQ3RDbEwsZUFBZUUsZ0JBQWdCLENBQUMsTUFBTW1PO0lBRXRDLGdDQUFnQztJQUNoQ3ZrQyxxQkFBcUIwc0U7SUFDckJ4c0Usd0JBQXdCOHpFO0lBQ3hCMEQ7SUFDQU07SUFFQSwwQkFBMEI7SUFDMUJwZ0MsaUJBQWlCLElBQUk0Z0MsZUFBZTtJQUNwQzVnQyxpQkFBaUIsSUFBSWloQyxlQUFlO0lBQ3BDamhDLGlCQUFpQixJQUFJa2hDLGlCQUFpQjtJQUN0Q2xoQyxpQkFBaUIsSUFBSTZoQyxrQkFBa0I7SUFDdkM3aEMsaUJBQWlCLElBQUl3aUMsb0JBQW9CO0lBQ3pDeGlDLGlCQUFpQixJQUFJd2pDLHFCQUFxQjtJQUMxQ3hqQyxpQkFBaUIsSUFBSWdrQyxpQkFBaUI7SUFDdENoa0MsaUJBQWlCLElBQUl5a0MsdUJBQXVCO0lBQzVDemtDLGlCQUFpQixJQUFJcWxDLG9CQUFvQjtJQUN6QzNyQixlQUFlLElBQUk0ckI7SUFFbkIsT0FBTzVuRjtBQUVUIiwic291cmNlcyI6WyIvVXNlcnMvanNvbnJpYmVpcm8vRG9jdW1lbnRzL3dvcmtzcGFjZS92aXJ0dWFsYnJhbmQvY2xpZW50ZXMvaG9tc2llbmdlbmhhcmlhL25vZGVfbW9kdWxlcy9sb3R0aWUtd2ViL2J1aWxkL3BsYXllci9sb3R0aWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikgJiYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIpICYmIChmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG4gIHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcbiAgdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmxvdHRpZSA9IGZhY3RvcnkoKSk7XG59KSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbiAgdmFyIHN2Z05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJztcbiAgdmFyIGxvY2F0aW9uSHJlZiA9ICcnO1xuICB2YXIgX3VzZVdlYldvcmtlciA9IGZhbHNlO1xuICB2YXIgaW5pdGlhbERlZmF1bHRGcmFtZSA9IC05OTk5OTk7XG4gIHZhciBzZXRXZWJXb3JrZXIgPSBmdW5jdGlvbiBzZXRXZWJXb3JrZXIoZmxhZykge1xuICAgIF91c2VXZWJXb3JrZXIgPSAhIWZsYWc7XG4gIH07XG4gIHZhciBnZXRXZWJXb3JrZXIgPSBmdW5jdGlvbiBnZXRXZWJXb3JrZXIoKSB7XG4gICAgcmV0dXJuIF91c2VXZWJXb3JrZXI7XG4gIH07XG4gIHZhciBzZXRMb2NhdGlvbkhyZWYgPSBmdW5jdGlvbiBzZXRMb2NhdGlvbkhyZWYodmFsdWUpIHtcbiAgICBsb2NhdGlvbkhyZWYgPSB2YWx1ZTtcbiAgfTtcbiAgdmFyIGdldExvY2F0aW9uSHJlZiA9IGZ1bmN0aW9uIGdldExvY2F0aW9uSHJlZigpIHtcbiAgICByZXR1cm4gbG9jYXRpb25IcmVmO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZVRhZyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGV4dGVuZFByb3RvdHlwZShzb3VyY2VzLCBkZXN0aW5hdGlvbikge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzb3VyY2VzLmxlbmd0aDtcbiAgICB2YXIgc291cmNlUHJvdG90eXBlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc291cmNlUHJvdG90eXBlID0gc291cmNlc1tpXS5wcm90b3R5cGU7XG4gICAgICBmb3IgKHZhciBhdHRyIGluIHNvdXJjZVByb3RvdHlwZSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZVByb3RvdHlwZSwgYXR0cikpIGRlc3RpbmF0aW9uLnByb3RvdHlwZVthdHRyXSA9IHNvdXJjZVByb3RvdHlwZVthdHRyXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RGVzY3JpcHRvcihvYmplY3QsIHByb3ApIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3ApO1xuICB9XG4gIGZ1bmN0aW9uIGNyZWF0ZVByb3h5RnVuY3Rpb24ocHJvdG90eXBlKSB7XG4gICAgZnVuY3Rpb24gUHJveHlGdW5jdGlvbigpIHt9XG4gICAgUHJveHlGdW5jdGlvbi5wcm90b3R5cGUgPSBwcm90b3R5cGU7XG4gICAgcmV0dXJuIFByb3h5RnVuY3Rpb247XG4gIH1cblxuICAvLyBpbXBvcnQgSG93bCBmcm9tICcuLi8uLi8zcmRfcGFydHkvaG93bGVyJztcblxuICB2YXIgYXVkaW9Db250cm9sbGVyRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBdWRpb0NvbnRyb2xsZXIoYXVkaW9GYWN0b3J5KSB7XG4gICAgICB0aGlzLmF1ZGlvcyA9IFtdO1xuICAgICAgdGhpcy5hdWRpb0ZhY3RvcnkgPSBhdWRpb0ZhY3Rvcnk7XG4gICAgICB0aGlzLl92b2x1bWUgPSAxO1xuICAgICAgdGhpcy5faXNNdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBBdWRpb0NvbnRyb2xsZXIucHJvdG90eXBlID0ge1xuICAgICAgYWRkQXVkaW86IGZ1bmN0aW9uIGFkZEF1ZGlvKGF1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW9zLnB1c2goYXVkaW8pO1xuICAgICAgfSxcbiAgICAgIHBhdXNlOiBmdW5jdGlvbiBwYXVzZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuYXVkaW9zW2ldLnBhdXNlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICByZXN1bWU6IGZ1bmN0aW9uIHJlc3VtZSgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuYXVkaW9zW2ldLnJlc3VtZSgpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2V0UmF0ZTogZnVuY3Rpb24gc2V0UmF0ZShyYXRlVmFsdWUpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmF1ZGlvcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuYXVkaW9zW2ldLnNldFJhdGUocmF0ZVZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGNyZWF0ZUF1ZGlvOiBmdW5jdGlvbiBjcmVhdGVBdWRpbyhhc3NldFBhdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuYXVkaW9GYWN0b3J5KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuYXVkaW9GYWN0b3J5KGFzc2V0UGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpbmRvdy5Ib3dsKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyB3aW5kb3cuSG93bCh7XG4gICAgICAgICAgICBzcmM6IFthc3NldFBhdGhdXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpc1BsYXlpbmc6IGZhbHNlLFxuICAgICAgICAgIHBsYXk6IGZ1bmN0aW9uIHBsYXkoKSB7XG4gICAgICAgICAgICB0aGlzLmlzUGxheWluZyA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBzZWVrOiBmdW5jdGlvbiBzZWVrKCkge1xuICAgICAgICAgICAgdGhpcy5pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHBsYXlpbmc6IGZ1bmN0aW9uIHBsYXlpbmcoKSB7fSxcbiAgICAgICAgICByYXRlOiBmdW5jdGlvbiByYXRlKCkge30sXG4gICAgICAgICAgc2V0Vm9sdW1lOiBmdW5jdGlvbiBzZXRWb2x1bWUoKSB7fVxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICAgIHNldEF1ZGlvRmFjdG9yeTogZnVuY3Rpb24gc2V0QXVkaW9GYWN0b3J5KGF1ZGlvRmFjdG9yeSkge1xuICAgICAgICB0aGlzLmF1ZGlvRmFjdG9yeSA9IGF1ZGlvRmFjdG9yeTtcbiAgICAgIH0sXG4gICAgICBzZXRWb2x1bWU6IGZ1bmN0aW9uIHNldFZvbHVtZSh2YWx1ZSkge1xuICAgICAgICB0aGlzLl92b2x1bWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVm9sdW1lKCk7XG4gICAgICB9LFxuICAgICAgbXV0ZTogZnVuY3Rpb24gbXV0ZSgpIHtcbiAgICAgICAgdGhpcy5faXNNdXRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIHVubXV0ZTogZnVuY3Rpb24gdW5tdXRlKCkge1xuICAgICAgICB0aGlzLl9pc011dGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVZvbHVtZSgpO1xuICAgICAgfSxcbiAgICAgIGdldFZvbHVtZTogZnVuY3Rpb24gZ2V0Vm9sdW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdm9sdW1lO1xuICAgICAgfSxcbiAgICAgIF91cGRhdGVWb2x1bWU6IGZ1bmN0aW9uIF91cGRhdGVWb2x1bWUoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5hdWRpb3MubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLmF1ZGlvc1tpXS52b2x1bWUodGhpcy5fdm9sdW1lICogKHRoaXMuX2lzTXV0ZWQgPyAwIDogMSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIG5ldyBBdWRpb0NvbnRyb2xsZXIoKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGNyZWF0ZVR5cGVkQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVndWxhckFycmF5KHR5cGUsIGxlbikge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ2ludDE2JzpcbiAgICAgICAgY2FzZSAndWludDhjJzpcbiAgICAgICAgICB2YWx1ZSA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdmFsdWUgPSAxLjE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYXJyLnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlVHlwZWRBcnJheUZhY3RvcnkodHlwZSwgbGVuKSB7XG4gICAgICBpZiAodHlwZSA9PT0gJ2Zsb2F0MzInKSB7XG4gICAgICAgIHJldHVybiBuZXcgRmxvYXQzMkFycmF5KGxlbik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZSA9PT0gJ2ludDE2Jykge1xuICAgICAgICByZXR1cm4gbmV3IEludDE2QXJyYXkobGVuKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlID09PSAndWludDhjJykge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KGxlbik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3JlYXRlUmVndWxhckFycmF5KHR5cGUsIGxlbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIEZsb2F0MzJBcnJheSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIGNyZWF0ZVR5cGVkQXJyYXlGYWN0b3J5O1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlUmVndWxhckFycmF5O1xuICB9KCk7XG4gIGZ1bmN0aW9uIGNyZWF0ZVNpemVkQXJyYXkobGVuKSB7XG4gICAgcmV0dXJuIEFycmF5LmFwcGx5KG51bGwsIHtcbiAgICAgIGxlbmd0aDogbGVuXG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBfdHlwZW9mJDYobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mJDYgPSBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcInN5bWJvbFwiID09IHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPyBmdW5jdGlvbiAobykgeyByZXR1cm4gdHlwZW9mIG87IH0gOiBmdW5jdGlvbiAobykgeyByZXR1cm4gbyAmJiBcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBvLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgbyAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2YgbzsgfSwgX3R5cGVvZiQ2KG8pOyB9XG4gIHZhciBzdWJmcmFtZUVuYWJsZWQgPSB0cnVlO1xuICB2YXIgZXhwcmVzc2lvbnNQbHVnaW4gPSBudWxsO1xuICB2YXIgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gbnVsbDtcbiAgdmFyIGlkUHJlZml4JDEgPSAnJztcbiAgdmFyIGlzU2FmYXJpID0gL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgdmFyIF9zaG91bGRSb3VuZFZhbHVlcyA9IGZhbHNlO1xuICB2YXIgYm1Qb3cgPSBNYXRoLnBvdztcbiAgdmFyIGJtU3FydCA9IE1hdGguc3FydDtcbiAgdmFyIGJtRmxvb3IgPSBNYXRoLmZsb29yO1xuICB2YXIgYm1NYXggPSBNYXRoLm1heDtcbiAgdmFyIGJtTWluID0gTWF0aC5taW47XG4gIHZhciBCTU1hdGggPSB7fTtcbiAgKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJvcGVydHlOYW1lcyA9IFsnYWJzJywgJ2Fjb3MnLCAnYWNvc2gnLCAnYXNpbicsICdhc2luaCcsICdhdGFuJywgJ2F0YW5oJywgJ2F0YW4yJywgJ2NlaWwnLCAnY2JydCcsICdleHBtMScsICdjbHozMicsICdjb3MnLCAnY29zaCcsICdleHAnLCAnZmxvb3InLCAnZnJvdW5kJywgJ2h5cG90JywgJ2ltdWwnLCAnbG9nJywgJ2xvZzFwJywgJ2xvZzInLCAnbG9nMTAnLCAnbWF4JywgJ21pbicsICdwb3cnLCAncmFuZG9tJywgJ3JvdW5kJywgJ3NpZ24nLCAnc2luJywgJ3NpbmgnLCAnc3FydCcsICd0YW4nLCAndGFuaCcsICd0cnVuYycsICdFJywgJ0xOMTAnLCAnTE4yJywgJ0xPRzEwRScsICdMT0cyRScsICdQSScsICdTUVJUMV8yJywgJ1NRUlQyJ107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHByb3BlcnR5TmFtZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgQk1NYXRoW3Byb3BlcnR5TmFtZXNbaV1dID0gTWF0aFtwcm9wZXJ0eU5hbWVzW2ldXTtcbiAgICB9XG4gIH0pKCk7XG4gIGZ1bmN0aW9uIFByb2plY3RJbnRlcmZhY2UkMSgpIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgQk1NYXRoLnJhbmRvbSA9IE1hdGgucmFuZG9tO1xuICBCTU1hdGguYWJzID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHZhciB0T2ZWYWwgPSBfdHlwZW9mJDYodmFsKTtcbiAgICBpZiAodE9mVmFsID09PSAnb2JqZWN0JyAmJiB2YWwubGVuZ3RoKSB7XG4gICAgICB2YXIgYWJzQXJyID0gY3JlYXRlU2l6ZWRBcnJheSh2YWwubGVuZ3RoKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHZhbC5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYWJzQXJyW2ldID0gTWF0aC5hYnModmFsW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhYnNBcnI7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmFicyh2YWwpO1xuICB9O1xuICB2YXIgZGVmYXVsdEN1cnZlU2VnbWVudHMgPSAxNTA7XG4gIHZhciBkZWdUb1JhZHMgPSBNYXRoLlBJIC8gMTgwO1xuICB2YXIgcm91bmRDb3JuZXIgPSAwLjU1MTk7XG4gIGZ1bmN0aW9uIHJvdW5kVmFsdWVzKGZsYWcpIHtcbiAgICBfc2hvdWxkUm91bmRWYWx1ZXMgPSAhIWZsYWc7XG4gIH1cbiAgZnVuY3Rpb24gYm1SbmQodmFsdWUpIHtcbiAgICBpZiAoX3Nob3VsZFJvdW5kVmFsdWVzKSB7XG4gICAgICByZXR1cm4gTWF0aC5yb3VuZCh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBmdW5jdGlvbiBzdHlsZURpdihlbGVtZW50KSB7XG4gICAgZWxlbWVudC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgZWxlbWVudC5zdHlsZS50b3AgPSAwO1xuICAgIGVsZW1lbnQuc3R5bGUubGVmdCA9IDA7XG4gICAgZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBlbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9ICcwIDAnO1xuICAgIGVsZW1lbnQuc3R5bGUud2Via2l0VHJhbnNmb3JtT3JpZ2luID0gJzAgMCc7XG4gICAgZWxlbWVudC5zdHlsZS5iYWNrZmFjZVZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRCYWNrZmFjZVZpc2liaWxpdHkgPSAndmlzaWJsZSc7XG4gICAgZWxlbWVudC5zdHlsZS50cmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgZWxlbWVudC5zdHlsZS53ZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gICAgZWxlbWVudC5zdHlsZS5tb3pUcmFuc2Zvcm1TdHlsZSA9ICdwcmVzZXJ2ZS0zZCc7XG4gIH1cbiAgZnVuY3Rpb24gQk1FbnRlckZyYW1lRXZlbnQodHlwZSwgY3VycmVudFRpbWUsIHRvdGFsVGltZSwgZnJhbWVNdWx0aXBsaWVyKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmN1cnJlbnRUaW1lID0gY3VycmVudFRpbWU7XG4gICAgdGhpcy50b3RhbFRpbWUgPSB0b3RhbFRpbWU7XG4gICAgdGhpcy5kaXJlY3Rpb24gPSBmcmFtZU11bHRpcGxpZXIgPCAwID8gLTEgOiAxO1xuICB9XG4gIGZ1bmN0aW9uIEJNQ29tcGxldGVFdmVudCh0eXBlLCBmcmFtZU11bHRpcGxpZXIpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuICBmdW5jdGlvbiBCTUNvbXBsZXRlTG9vcEV2ZW50KHR5cGUsIHRvdGFsTG9vcHMsIGN1cnJlbnRMb29wLCBmcmFtZU11bHRpcGxpZXIpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMuY3VycmVudExvb3AgPSBjdXJyZW50TG9vcDtcbiAgICB0aGlzLnRvdGFsTG9vcHMgPSB0b3RhbExvb3BzO1xuICAgIHRoaXMuZGlyZWN0aW9uID0gZnJhbWVNdWx0aXBsaWVyIDwgMCA/IC0xIDogMTtcbiAgfVxuICBmdW5jdGlvbiBCTVNlZ21lbnRTdGFydEV2ZW50KHR5cGUsIGZpcnN0RnJhbWUsIHRvdGFsRnJhbWVzKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBmaXJzdEZyYW1lO1xuICAgIHRoaXMudG90YWxGcmFtZXMgPSB0b3RhbEZyYW1lcztcbiAgfVxuICBmdW5jdGlvbiBCTURlc3Ryb3lFdmVudCh0eXBlLCB0YXJnZXQpIHtcbiAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xuICB9XG4gIGZ1bmN0aW9uIEJNUmVuZGVyRnJhbWVFcnJvckV2ZW50KG5hdGl2ZUVycm9yLCBjdXJyZW50VGltZSkge1xuICAgIHRoaXMudHlwZSA9ICdyZW5kZXJGcmFtZUVycm9yJztcbiAgICB0aGlzLm5hdGl2ZUVycm9yID0gbmF0aXZlRXJyb3I7XG4gICAgdGhpcy5jdXJyZW50VGltZSA9IGN1cnJlbnRUaW1lO1xuICB9XG4gIGZ1bmN0aW9uIEJNQ29uZmlnRXJyb3JFdmVudChuYXRpdmVFcnJvcikge1xuICAgIHRoaXMudHlwZSA9ICdjb25maWdFcnJvcic7XG4gICAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICB9XG4gIGZ1bmN0aW9uIEJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCh0eXBlLCBuYXRpdmVFcnJvcikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5uYXRpdmVFcnJvciA9IG5hdGl2ZUVycm9yO1xuICB9XG4gIHZhciBjcmVhdGVFbGVtZW50SUQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jb3VudCA9IDA7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNyZWF0ZUlEKCkge1xuICAgICAgX2NvdW50ICs9IDE7XG4gICAgICByZXR1cm4gaWRQcmVmaXgkMSArICdfX2xvdHRpZV9lbGVtZW50XycgKyBfY291bnQ7XG4gICAgfTtcbiAgfSgpO1xuICBmdW5jdGlvbiBIU1Z0b1JHQihoLCBzLCB2KSB7XG4gICAgdmFyIHI7XG4gICAgdmFyIGc7XG4gICAgdmFyIGI7XG4gICAgdmFyIGk7XG4gICAgdmFyIGY7XG4gICAgdmFyIHA7XG4gICAgdmFyIHE7XG4gICAgdmFyIHQ7XG4gICAgaSA9IE1hdGguZmxvb3IoaCAqIDYpO1xuICAgIGYgPSBoICogNiAtIGk7XG4gICAgcCA9IHYgKiAoMSAtIHMpO1xuICAgIHEgPSB2ICogKDEgLSBmICogcyk7XG4gICAgdCA9IHYgKiAoMSAtICgxIC0gZikgKiBzKTtcbiAgICBzd2l0Y2ggKGkgJSA2KSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHIgPSB2O1xuICAgICAgICBnID0gdDtcbiAgICAgICAgYiA9IHA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByID0gcTtcbiAgICAgICAgZyA9IHY7XG4gICAgICAgIGIgPSBwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjpcbiAgICAgICAgciA9IHA7XG4gICAgICAgIGcgPSB2O1xuICAgICAgICBiID0gdDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHIgPSBwO1xuICAgICAgICBnID0gcTtcbiAgICAgICAgYiA9IHY7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA0OlxuICAgICAgICByID0gdDtcbiAgICAgICAgZyA9IHA7XG4gICAgICAgIGIgPSB2O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgciA9IHY7XG4gICAgICAgIGcgPSBwO1xuICAgICAgICBiID0gcTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFtyLCBnLCBiXTtcbiAgfVxuICBmdW5jdGlvbiBSR0J0b0hTVihyLCBnLCBiKSB7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KHIsIGcsIGIpO1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICB2YXIgZCA9IG1heCAtIG1pbjtcbiAgICB2YXIgaDtcbiAgICB2YXIgcyA9IG1heCA9PT0gMCA/IDAgOiBkIC8gbWF4O1xuICAgIHZhciB2ID0gbWF4IC8gMjU1O1xuICAgIHN3aXRjaCAobWF4KSB7XG4gICAgICBjYXNlIG1pbjpcbiAgICAgICAgaCA9IDA7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSByOlxuICAgICAgICBoID0gZyAtIGIgKyBkICogKGcgPCBiID8gNiA6IDApO1xuICAgICAgICBoIC89IDYgKiBkO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgZzpcbiAgICAgICAgaCA9IGIgLSByICsgZCAqIDI7XG4gICAgICAgIGggLz0gNiAqIGQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBiOlxuICAgICAgICBoID0gciAtIGcgKyBkICogNDtcbiAgICAgICAgaCAvPSA2ICogZDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIFtoLCBzLCB2XTtcbiAgfVxuICBmdW5jdGlvbiBhZGRTYXR1cmF0aW9uVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMV0gKz0gb2Zmc2V0O1xuICAgIGlmIChoc3ZbMV0gPiAxKSB7XG4gICAgICBoc3ZbMV0gPSAxO1xuICAgIH0gZWxzZSBpZiAoaHN2WzFdIDw9IDApIHtcbiAgICAgIGhzdlsxXSA9IDA7XG4gICAgfVxuICAgIHJldHVybiBIU1Z0b1JHQihoc3ZbMF0sIGhzdlsxXSwgaHN2WzJdKTtcbiAgfVxuICBmdW5jdGlvbiBhZGRCcmlnaHRuZXNzVG9SR0IoY29sb3IsIG9mZnNldCkge1xuICAgIHZhciBoc3YgPSBSR0J0b0hTVihjb2xvclswXSAqIDI1NSwgY29sb3JbMV0gKiAyNTUsIGNvbG9yWzJdICogMjU1KTtcbiAgICBoc3ZbMl0gKz0gb2Zmc2V0O1xuICAgIGlmIChoc3ZbMl0gPiAxKSB7XG4gICAgICBoc3ZbMl0gPSAxO1xuICAgIH0gZWxzZSBpZiAoaHN2WzJdIDwgMCkge1xuICAgICAgaHN2WzJdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIEhTVnRvUkdCKGhzdlswXSwgaHN2WzFdLCBoc3ZbMl0pO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEh1ZVRvUkdCKGNvbG9yLCBvZmZzZXQpIHtcbiAgICB2YXIgaHN2ID0gUkdCdG9IU1YoY29sb3JbMF0gKiAyNTUsIGNvbG9yWzFdICogMjU1LCBjb2xvclsyXSAqIDI1NSk7XG4gICAgaHN2WzBdICs9IG9mZnNldCAvIDM2MDtcbiAgICBpZiAoaHN2WzBdID4gMSkge1xuICAgICAgaHN2WzBdIC09IDE7XG4gICAgfSBlbHNlIGlmIChoc3ZbMF0gPCAwKSB7XG4gICAgICBoc3ZbMF0gKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIEhTVnRvUkdCKGhzdlswXSwgaHN2WzFdLCBoc3ZbMl0pO1xuICB9XG4gIHZhciByZ2JUb0hleCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgY29sb3JNYXAgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgaGV4O1xuICAgIGZvciAoaSA9IDA7IGkgPCAyNTY7IGkgKz0gMSkge1xuICAgICAgaGV4ID0gaS50b1N0cmluZygxNik7XG4gICAgICBjb2xvck1hcFtpXSA9IGhleC5sZW5ndGggPT09IDEgPyAnMCcgKyBoZXggOiBoZXg7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAociwgZywgYikge1xuICAgICAgaWYgKHIgPCAwKSB7XG4gICAgICAgIHIgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGcgPCAwKSB7XG4gICAgICAgIGcgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGIgPCAwKSB7XG4gICAgICAgIGIgPSAwO1xuICAgICAgfVxuICAgICAgcmV0dXJuICcjJyArIGNvbG9yTWFwW3JdICsgY29sb3JNYXBbZ10gKyBjb2xvck1hcFtiXTtcbiAgICB9O1xuICB9KCk7XG4gIHZhciBzZXRTdWJmcmFtZUVuYWJsZWQgPSBmdW5jdGlvbiBzZXRTdWJmcmFtZUVuYWJsZWQoZmxhZykge1xuICAgIHN1YmZyYW1lRW5hYmxlZCA9ICEhZmxhZztcbiAgfTtcbiAgdmFyIGdldFN1YmZyYW1lRW5hYmxlZCA9IGZ1bmN0aW9uIGdldFN1YmZyYW1lRW5hYmxlZCgpIHtcbiAgICByZXR1cm4gc3ViZnJhbWVFbmFibGVkO1xuICB9O1xuICB2YXIgc2V0RXhwcmVzc2lvbnNQbHVnaW4gPSBmdW5jdGlvbiBzZXRFeHByZXNzaW9uc1BsdWdpbih2YWx1ZSkge1xuICAgIGV4cHJlc3Npb25zUGx1Z2luID0gdmFsdWU7XG4gIH07XG4gIHZhciBnZXRFeHByZXNzaW9uc1BsdWdpbiA9IGZ1bmN0aW9uIGdldEV4cHJlc3Npb25zUGx1Z2luKCkge1xuICAgIHJldHVybiBleHByZXNzaW9uc1BsdWdpbjtcbiAgfTtcbiAgdmFyIHNldEV4cHJlc3Npb25JbnRlcmZhY2VzID0gZnVuY3Rpb24gc2V0RXhwcmVzc2lvbkludGVyZmFjZXModmFsdWUpIHtcbiAgICBleHByZXNzaW9uc0ludGVyZmFjZXMgPSB2YWx1ZTtcbiAgfTtcbiAgdmFyIGdldEV4cHJlc3Npb25JbnRlcmZhY2VzID0gZnVuY3Rpb24gZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMoKSB7XG4gICAgcmV0dXJuIGV4cHJlc3Npb25zSW50ZXJmYWNlcztcbiAgfTtcbiAgdmFyIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzID0gZnVuY3Rpb24gc2V0RGVmYXVsdEN1cnZlU2VnbWVudHModmFsdWUpIHtcbiAgICBkZWZhdWx0Q3VydmVTZWdtZW50cyA9IHZhbHVlO1xuICB9O1xuICB2YXIgZ2V0RGVmYXVsdEN1cnZlU2VnbWVudHMgPSBmdW5jdGlvbiBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpIHtcbiAgICByZXR1cm4gZGVmYXVsdEN1cnZlU2VnbWVudHM7XG4gIH07XG4gIHZhciBzZXRJZFByZWZpeCA9IGZ1bmN0aW9uIHNldElkUHJlZml4KHZhbHVlKSB7XG4gICAgaWRQcmVmaXgkMSA9IHZhbHVlO1xuICB9O1xuICB2YXIgZ2V0SWRQcmVmaXggPSBmdW5jdGlvbiBnZXRJZFByZWZpeCgpIHtcbiAgICByZXR1cm4gaWRQcmVmaXgkMTtcbiAgfTtcblxuICBmdW5jdGlvbiBjcmVhdGVOUyh0eXBlKSB7XG4gICAgLy8gcmV0dXJuIHthcHBlbmRDaGlsZDpmdW5jdGlvbigpe30sc2V0QXR0cmlidXRlOmZ1bmN0aW9uKCl7fSxzdHlsZTp7fX1cbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKHN2Z05TLCB0eXBlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNShvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YkNSA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mJDUobyk7IH1cbiAgdmFyIGRhdGFNYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfY291bnRlcklkID0gMTtcbiAgICB2YXIgcHJvY2Vzc2VzID0gW107XG4gICAgdmFyIHdvcmtlckZuO1xuICAgIHZhciB3b3JrZXJJbnN0YW5jZTtcbiAgICB2YXIgd29ya2VyUHJveHkgPSB7XG4gICAgICBvbm1lc3NhZ2U6IGZ1bmN0aW9uIG9ubWVzc2FnZSgpIHt9LFxuICAgICAgcG9zdE1lc3NhZ2U6IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKHBhdGgpIHtcbiAgICAgICAgd29ya2VyRm4oe1xuICAgICAgICAgIGRhdGE6IHBhdGhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgX3dvcmtlclNlbGYgPSB7XG4gICAgICBwb3N0TWVzc2FnZTogZnVuY3Rpb24gcG9zdE1lc3NhZ2UoZGF0YSkge1xuICAgICAgICB3b3JrZXJQcm94eS5vbm1lc3NhZ2Uoe1xuICAgICAgICAgIGRhdGE6IGRhdGFcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVXb3JrZXIoZm4pIHtcbiAgICAgIGlmICh3aW5kb3cuV29ya2VyICYmIHdpbmRvdy5CbG9iICYmIGdldFdlYldvcmtlcigpKSB7XG4gICAgICAgIHZhciBibG9iID0gbmV3IEJsb2IoWyd2YXIgX3dvcmtlclNlbGYgPSBzZWxmOyBzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7XG4gICAgICAgICAgdHlwZTogJ3RleHQvamF2YXNjcmlwdCdcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIHZhciBibG9iID0gbmV3IEJsb2IoWydzZWxmLm9ubWVzc2FnZSA9ICcsIGZuLnRvU3RyaW5nKCldLCB7IHR5cGU6ICd0ZXh0L2phdmFzY3JpcHQnIH0pO1xuICAgICAgICB2YXIgdXJsID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcbiAgICAgICAgcmV0dXJuIG5ldyBXb3JrZXIodXJsKTtcbiAgICAgIH1cbiAgICAgIHdvcmtlckZuID0gZm47XG4gICAgICByZXR1cm4gd29ya2VyUHJveHk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldHVwV29ya2VyKCkge1xuICAgICAgaWYgKCF3b3JrZXJJbnN0YW5jZSkge1xuICAgICAgICB3b3JrZXJJbnN0YW5jZSA9IGNyZWF0ZVdvcmtlcihmdW5jdGlvbiB3b3JrZXJTdGFydChlKSB7XG4gICAgICAgICAgZnVuY3Rpb24gZGF0YUZ1bmN0aW9uTWFuYWdlcigpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlTGF5ZXJzKGxheWVycywgY29tcHMpIHtcbiAgICAgICAgICAgICAgdmFyIGxheWVyRGF0YTtcbiAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgIHZhciBrO1xuICAgICAgICAgICAgICB2YXIga0xlbjtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgbGF5ZXJEYXRhID0gbGF5ZXJzW2ldO1xuICAgICAgICAgICAgICAgIGlmICgna3MnIGluIGxheWVyRGF0YSAmJiAhbGF5ZXJEYXRhLmNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgICAgbGF5ZXJEYXRhLmNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tQcm9wcyA9IGxheWVyRGF0YS5tYXNrc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0LmspO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrTGVuID0gbWFza1Byb3BzW2pdLnB0LmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWFza1Byb3BzW2pdLnB0Lmtba10ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMobWFza1Byb3BzW2pdLnB0Lmtba10uc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKG1hc2tQcm9wc1tqXS5wdC5rW2tdLmVbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLnR5ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGxheWVyRGF0YS5sYXllcnMgPSBmaW5kQ29tcExheWVycyhsYXllckRhdGEucmVmSWQsIGNvbXBzKTtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVMYXllcnMobGF5ZXJEYXRhLmxheWVycywgY29tcHMpO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChsYXllckRhdGEudHkgPT09IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGxldGVTaGFwZXMobGF5ZXJEYXRhLnNoYXBlcyk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyRGF0YS50eSA9PT0gNSkge1xuICAgICAgICAgICAgICAgICAgICBjb21wbGV0ZVRleHQobGF5ZXJEYXRhKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlQ2hhcnMoY2hhcnMsIGFzc2V0cykge1xuICAgICAgICAgICAgICBpZiAoY2hhcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGNoYXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChjaGFyc1tpXS50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHZhciBjb21wRGF0YSA9IGZpbmRDb21wKGNoYXJzW2ldLmRhdGEucmVmSWQsIGFzc2V0cyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJzW2ldLmRhdGEubGF5ZXJzID0gZmluZENvbXBMYXllcnMoY2hhcnNbaV0uZGF0YS5yZWZJZCwgYXNzZXRzKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5pcCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEub3AgPSA5OTk5OTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNoYXJzW2ldLmRhdGEuc3IgPSAxO1xuICAgICAgICAgICAgICAgICAgICAvLyBjaGFyc1tpXS53ID0gY29tcERhdGEudztcbiAgICAgICAgICAgICAgICAgICAgLy8gY2hhcnNbaV0uZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gICBhOiB7IGs6IFswLCAwLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHA6IHsgazogWzAsIC1jb21wRGF0YS5oLCAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHI6IHsgazogMCwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIHM6IHsgazogWzEwMCwgMTAwXSwgYTogMCB9LFxuICAgICAgICAgICAgICAgICAgICAvLyAgIG86IHsgazogMTAwLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgICAgIC8vIH07XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlTGF5ZXJzKGNoYXJzW2ldLmRhdGEubGF5ZXJzLCBhc3NldHMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gZmluZENvbXAoaWQsIGNvbXBzKSB7XG4gICAgICAgICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgICAgICAgdmFyIGxlbiA9IGNvbXBzLmxlbmd0aDtcbiAgICAgICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHNbaV0uaWQgPT09IGlkKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29tcHNbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbmRDb21wTGF5ZXJzKGlkLCBjb21wcykge1xuICAgICAgICAgICAgICB2YXIgY29tcCA9IGZpbmRDb21wKGlkLCBjb21wcyk7XG4gICAgICAgICAgICAgIGlmIChjb21wKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFjb21wLmxheWVycy5fX3VzZWQpIHtcbiAgICAgICAgICAgICAgICAgIGNvbXAubGF5ZXJzLl9fdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gY29tcC5sYXllcnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNvbXAubGF5ZXJzKSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wbGV0ZVNoYXBlcyhhcnIpIHtcbiAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFycltpXS50eSA9PT0gJ3NoJykge1xuICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhhcnJbaV0ua3Muayk7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBqTGVuID0gYXJyW2ldLmtzLmsubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMoYXJyW2ldLmtzLmtbal0uc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Mua1tqXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb252ZXJ0UGF0aHNUb0Fic29sdXRlVmFsdWVzKGFycltpXS5rcy5rW2pdLmVbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgICAgICAgICBjb21wbGV0ZVNoYXBlcyhhcnJbaV0uaXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY29udmVydFBhdGhzVG9BYnNvbHV0ZVZhbHVlcyhwYXRoKSB7XG4gICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICB2YXIgbGVuID0gcGF0aC5pLmxlbmd0aDtcbiAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5pW2ldWzBdICs9IHBhdGgudltpXVswXTtcbiAgICAgICAgICAgICAgICBwYXRoLmlbaV1bMV0gKz0gcGF0aC52W2ldWzFdO1xuICAgICAgICAgICAgICAgIHBhdGgub1tpXVswXSArPSBwYXRoLnZbaV1bMF07XG4gICAgICAgICAgICAgICAgcGF0aC5vW2ldWzFdICs9IHBhdGgudltpXVsxXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tWZXJzaW9uKG1pbmltdW0sIGFuaW1WZXJzaW9uU3RyaW5nKSB7XG4gICAgICAgICAgICAgIHZhciBhbmltVmVyc2lvbiA9IGFuaW1WZXJzaW9uU3RyaW5nID8gYW5pbVZlcnNpb25TdHJpbmcuc3BsaXQoJy4nKSA6IFsxMDAsIDEwMCwgMTAwXTtcbiAgICAgICAgICAgICAgaWYgKG1pbmltdW1bMF0gPiBhbmltVmVyc2lvblswXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhbmltVmVyc2lvblswXSA+IG1pbmltdW1bMF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1pbmltdW1bMV0gPiBhbmltVmVyc2lvblsxXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhbmltVmVyc2lvblsxXSA+IG1pbmltdW1bMV0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKG1pbmltdW1bMl0gPiBhbmltVmVyc2lvblsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChhbmltVmVyc2lvblsyXSA+IG1pbmltdW1bMl0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY2hlY2tUZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNCwgMTRdO1xuICAgICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVUZXh0TGF5ZXIodGV4dExheWVyKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRvY3VtZW50RGF0YSA9IHRleHRMYXllci50LmQ7XG4gICAgICAgICAgICAgICAgdGV4dExheWVyLnQuZCA9IHtcbiAgICAgICAgICAgICAgICAgIGs6IFt7XG4gICAgICAgICAgICAgICAgICAgIHM6IGRvY3VtZW50RGF0YSxcbiAgICAgICAgICAgICAgICAgICAgdDogMFxuICAgICAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVMYXllcnMobGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJzW2ldLnR5ID09PSA1KSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVRleHRMYXllcihsYXllcnNbaV0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgIHZhciBjaGVja0NoYXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgNywgOTldO1xuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5jaGFycyAmJiAhY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XG4gICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmNoYXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2hhckRhdGEgPSBhbmltYXRpb25EYXRhLmNoYXJzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhckRhdGEuZGF0YSAmJiBjaGFyRGF0YS5kYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlU2hhcGVzKGNoYXJEYXRhLmRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLmlwID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLm9wID0gOTk5OTk7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zdCA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5zciA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhckRhdGEuZGF0YS5rcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgazogWzAsIDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMCwgMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYTogMFxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKCFhbmltYXRpb25EYXRhLmNoYXJzW2ldLnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJEYXRhLmRhdGEuc2hhcGVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICB0eTogJ25vJ1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGFyRGF0YS5kYXRhLnNoYXBlc1swXS5pdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFswLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IFswLCAwXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrOiAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGE6IDBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbzoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGs6IDEwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNrOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHNhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgazogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhOiAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5OiAndHInXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICB2YXIgY2hlY2tQYXRoUHJvcGVydGllcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzUsIDcsIDE1XTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKHRleHRMYXllcikge1xuICAgICAgICAgICAgICAgIHZhciBwYXRoRGF0YSA9IHRleHRMYXllci50LnA7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5hID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgcGF0aERhdGEuYSA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgICAgICAgazogcGF0aERhdGEuYVxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5wID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgcGF0aERhdGEucCA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgICAgICAgazogcGF0aERhdGEucFxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXRoRGF0YS5yID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgcGF0aERhdGEuciA9IHtcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgICAgICAgazogcGF0aERhdGEuclxuICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnVuY3Rpb24gaXRlcmF0ZUxheWVycyhsYXllcnMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgIGlmIChsYXllcnNbaV0udHkgPT09IDUpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dExheWVyKGxheWVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChjaGVja1ZlcnNpb24obWluaW11bVZlcnNpb24sIGFuaW1hdGlvbkRhdGEudikpIHtcbiAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbGVuID0gYW5pbWF0aW9uRGF0YS5hc3NldHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycyk7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgICAgdmFyIGNoZWNrQ29sb3JzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbWluaW11bVZlcnNpb24gPSBbNCwgMSwgOV07XG4gICAgICAgICAgICAgIGZ1bmN0aW9uIGl0ZXJhdGVTaGFwZXMoc2hhcGVzKSB7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IHNoYXBlcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVTaGFwZXMoc2hhcGVzW2ldLml0KTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZmwnIHx8IHNoYXBlc1tpXS50eSA9PT0gJ3N0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2hhcGVzW2ldLmMuayAmJiBzaGFwZXNbaV0uYy5rWzBdLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICBqTGVuID0gc2hhcGVzW2ldLmMuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmtbal0ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLnNbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNoYXBlc1tpXS5jLmtbal0uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbMF0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbMV0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbMl0gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rW2pdLmVbM10gLz0gMjU1O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rWzBdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rWzFdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rWzJdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgICBzaGFwZXNbaV0uYy5rWzNdIC89IDI1NTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgaWYgKGxheWVyc1tpXS50eSA9PT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpdGVyYXRlU2hhcGVzKGxheWVyc1tpXS5zaGFwZXMpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGFuaW1hdGlvbkRhdGEpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tWZXJzaW9uKG1pbmltdW1WZXJzaW9uLCBhbmltYXRpb25EYXRhLnYpKSB7XG4gICAgICAgICAgICAgICAgICBpdGVyYXRlTGF5ZXJzKGFuaW1hdGlvbkRhdGEubGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0cykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxlbiA9IGFuaW1hdGlvbkRhdGEuYXNzZXRzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbkRhdGEuYXNzZXRzW2ldLmxheWVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0oKTtcbiAgICAgICAgICAgIHZhciBjaGVja1NoYXBlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIG1pbmltdW1WZXJzaW9uID0gWzQsIDQsIDE4XTtcbiAgICAgICAgICAgICAgZnVuY3Rpb24gY29tcGxldGVDbG9zaW5nU2hhcGVzKGFycikge1xuICAgICAgICAgICAgICAgIHZhciBpO1xuICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHZhciBqO1xuICAgICAgICAgICAgICAgIHZhciBqTGVuO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLnR5ID09PSAnc2gnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhcnJbaV0ua3Muay5pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmsuYyA9IGFycltpXS5jbG9zZWQ7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgakxlbiA9IGFycltpXS5rcy5rLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJyW2ldLmtzLmtbal0ucykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJbaV0ua3Mua1tqXS5zWzBdLmMgPSBhcnJbaV0uY2xvc2VkO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFycltpXS5rcy5rW2pdLmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXJyW2ldLmtzLmtbal0uZVswXS5jID0gYXJyW2ldLmNsb3NlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhhcnJbaV0uaXQpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBpdGVyYXRlTGF5ZXJzKGxheWVycykge1xuICAgICAgICAgICAgICAgIHZhciBsYXllckRhdGE7XG4gICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgdmFyIGxlbiA9IGxheWVycy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgdmFyIGo7XG4gICAgICAgICAgICAgICAgdmFyIGpMZW47XG4gICAgICAgICAgICAgICAgdmFyIGs7XG4gICAgICAgICAgICAgICAgdmFyIGtMZW47XG4gICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICBsYXllckRhdGEgPSBsYXllcnNbaV07XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLmhhc01hc2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIG1hc2tQcm9wcyA9IGxheWVyRGF0YS5tYXNrc1Byb3BlcnRpZXM7XG4gICAgICAgICAgICAgICAgICAgIGpMZW4gPSBtYXNrUHJvcHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG1hc2tQcm9wc1tqXS5wdC5rLmkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hc2tQcm9wc1tqXS5wdC5rLmMgPSBtYXNrUHJvcHNbal0uY2w7XG4gICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGtMZW4gPSBtYXNrUHJvcHNbal0ucHQuay5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQua1trXS5zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza1Byb3BzW2pdLnB0Lmtba10uc1swXS5jID0gbWFza1Byb3BzW2pdLmNsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtYXNrUHJvcHNbal0ucHQua1trXS5lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWFza1Byb3BzW2pdLnB0Lmtba10uZVswXS5jID0gbWFza1Byb3BzW2pdLmNsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAobGF5ZXJEYXRhLnR5ID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBsZXRlQ2xvc2luZ1NoYXBlcyhsYXllckRhdGEuc2hhcGVzKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChhbmltYXRpb25EYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrVmVyc2lvbihtaW5pbXVtVmVyc2lvbiwgYW5pbWF0aW9uRGF0YS52KSkge1xuICAgICAgICAgICAgICAgICAgaXRlcmF0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycyk7XG4gICAgICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5hc3NldHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgICAgICAgICAgIHZhciBsZW4gPSBhbmltYXRpb25EYXRhLmFzc2V0cy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChhbmltYXRpb25EYXRhLmFzc2V0c1tpXS5sYXllcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZXJhdGVMYXllcnMoYW5pbWF0aW9uRGF0YS5hc3NldHNbaV0ubGF5ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KCk7XG4gICAgICAgICAgICBmdW5jdGlvbiBjb21wbGV0ZURhdGEoYW5pbWF0aW9uRGF0YSkge1xuICAgICAgICAgICAgICBpZiAoYW5pbWF0aW9uRGF0YS5fX2NvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoZWNrQ29sb3JzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjaGVja1RleHQoYW5pbWF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgIGNoZWNrQ2hhcnMoYW5pbWF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgIGNoZWNrUGF0aFByb3BlcnRpZXMoYW5pbWF0aW9uRGF0YSk7XG4gICAgICAgICAgICAgIGNoZWNrU2hhcGVzKGFuaW1hdGlvbkRhdGEpO1xuICAgICAgICAgICAgICBjb21wbGV0ZUxheWVycyhhbmltYXRpb25EYXRhLmxheWVycywgYW5pbWF0aW9uRGF0YS5hc3NldHMpO1xuICAgICAgICAgICAgICBjb21wbGV0ZUNoYXJzKGFuaW1hdGlvbkRhdGEuY2hhcnMsIGFuaW1hdGlvbkRhdGEuYXNzZXRzKTtcbiAgICAgICAgICAgICAgYW5pbWF0aW9uRGF0YS5fX2NvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBsZXRlVGV4dChkYXRhKSB7XG4gICAgICAgICAgICAgIGlmIChkYXRhLnQuYS5sZW5ndGggPT09IDAgJiYgISgnbScgaW4gZGF0YS50LnApKSB7XG4gICAgICAgICAgICAgICAgLy8gZGF0YS5zaW5nbGVTaGFwZSA9IHRydWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBtb2R1bGVPYiA9IHt9O1xuICAgICAgICAgICAgbW9kdWxlT2IuY29tcGxldGVEYXRhID0gY29tcGxldGVEYXRhO1xuICAgICAgICAgICAgbW9kdWxlT2IuY2hlY2tDb2xvcnMgPSBjaGVja0NvbG9ycztcbiAgICAgICAgICAgIG1vZHVsZU9iLmNoZWNrQ2hhcnMgPSBjaGVja0NoYXJzO1xuICAgICAgICAgICAgbW9kdWxlT2IuY2hlY2tQYXRoUHJvcGVydGllcyA9IGNoZWNrUGF0aFByb3BlcnRpZXM7XG4gICAgICAgICAgICBtb2R1bGVPYi5jaGVja1NoYXBlcyA9IGNoZWNrU2hhcGVzO1xuICAgICAgICAgICAgbW9kdWxlT2IuY29tcGxldGVMYXllcnMgPSBjb21wbGV0ZUxheWVycztcbiAgICAgICAgICAgIHJldHVybiBtb2R1bGVPYjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFfd29ya2VyU2VsZi5kYXRhTWFuYWdlcikge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuZGF0YU1hbmFnZXIgPSBkYXRhRnVuY3Rpb25NYW5hZ2VyKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICghX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBmdW5jdGlvbiBmb3JtYXRSZXNwb25zZSh4aHIpIHtcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0eXBlb2YgZG91YmxlcyB0aGUgdGltZSBvZiBleGVjdXRpb24gb2YgdGhpcyBtZXRob2QsXG4gICAgICAgICAgICAgICAgLy8gc28gaWYgYXZhaWxhYmxlLCBpdCdzIGJldHRlciB0byB1c2UgdGhlIGhlYWRlciB0byB2YWxpZGF0ZSB0aGUgdHlwZVxuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZUhlYWRlciA9IHhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC10eXBlJyk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnRUeXBlSGVhZGVyICYmIHhoci5yZXNwb25zZVR5cGUgPT09ICdqc29uJyAmJiBjb250ZW50VHlwZUhlYWRlci5pbmRleE9mKCdqc29uJykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4geGhyLnJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoeGhyLnJlc3BvbnNlICYmIF90eXBlb2YkNSh4aHIucmVzcG9uc2UpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIHhoci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZSAmJiB0eXBlb2YgeGhyLnJlc3BvbnNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHhoci5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBmdW5jdGlvbiBsb2FkQXNzZXQocGF0aCwgZnVsbFBhdGgsIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlO1xuICAgICAgICAgICAgICAgIHZhciB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgICAgICAvLyBzZXQgcmVzcG9uc2VUeXBlIGFmdGVyIGNhbGxpbmcgb3BlbiBvciBJRSB3aWxsIGJyZWFrLlxuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGlzIGNyYXNoZXMgb24gQW5kcm9pZCBXZWJWaWV3IHByaW9yIHRvIEtpdEthdFxuICAgICAgICAgICAgICAgICAgeGhyLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZW1wdHlcbiAgICAgICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh4aHIuc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZvcm1hdFJlc3BvbnNlKHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2socmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IGZvcm1hdFJlc3BvbnNlKHhocik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3JDYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgLy8gSGFjayB0byB3b3JrYXJvdW5kIGJhbm5lciB2YWxpZGF0aW9uXG4gICAgICAgICAgICAgICAgICB4aHIub3BlbihbJ0cnLCAnRScsICdUJ10uam9pbignJyksIHBhdGgsIHRydWUpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAvLyBIYWNrIHRvIHdvcmthcm91bmQgYmFubmVyIHZhbGlkYXRpb25cbiAgICAgICAgICAgICAgICAgIHhoci5vcGVuKFsnRycsICdFJywgJ1QnXS5qb2luKCcnKSwgZnVsbFBhdGggKyAnLycgKyBwYXRoLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgeGhyLnNlbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGxvYWQ6IGxvYWRBc3NldFxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkQW5pbWF0aW9uJykge1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuYXNzZXRMb2FkZXIubG9hZChlLmRhdGEucGF0aCwgZS5kYXRhLmZ1bGxQYXRoLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgICBfd29ya2VyU2VsZi5kYXRhTWFuYWdlci5jb21wbGV0ZURhdGEoZGF0YSk7XG4gICAgICAgICAgICAgIF93b3JrZXJTZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgIHBheWxvYWQ6IGRhdGEsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcydcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIF93b3JrZXJTZWxmLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgICAgICBpZDogZS5kYXRhLmlkLFxuICAgICAgICAgICAgICAgIHN0YXR1czogJ2Vycm9yJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnR5cGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgICAgICAgIHZhciBhbmltYXRpb24gPSBlLmRhdGEuYW5pbWF0aW9uO1xuICAgICAgICAgICAgX3dvcmtlclNlbGYuZGF0YU1hbmFnZXIuY29tcGxldGVEYXRhKGFuaW1hdGlvbik7XG4gICAgICAgICAgICBfd29ya2VyU2VsZi5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgIHBheWxvYWQ6IGFuaW1hdGlvbixcbiAgICAgICAgICAgICAgc3RhdHVzOiAnc3VjY2VzcydcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZS5kYXRhLnR5cGUgPT09ICdsb2FkRGF0YScpIHtcbiAgICAgICAgICAgIF93b3JrZXJTZWxmLmFzc2V0TG9hZGVyLmxvYWQoZS5kYXRhLnBhdGgsIGUuZGF0YS5mdWxsUGF0aCwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgcGF5bG9hZDogZGF0YSxcbiAgICAgICAgICAgICAgICBzdGF0dXM6ICdzdWNjZXNzJ1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgX3dvcmtlclNlbGYucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgICAgIGlkOiBlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgc3RhdHVzOiAnZXJyb3InXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgd29ya2VySW5zdGFuY2Uub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgICAgIHZhciBpZCA9IGRhdGEuaWQ7XG4gICAgICAgICAgdmFyIHByb2Nlc3MgPSBwcm9jZXNzZXNbaWRdO1xuICAgICAgICAgIHByb2Nlc3Nlc1tpZF0gPSBudWxsO1xuICAgICAgICAgIGlmIChkYXRhLnN0YXR1cyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm9uQ29tcGxldGUoZGF0YS5wYXlsb2FkKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3Mub25FcnJvcikge1xuICAgICAgICAgICAgcHJvY2Vzcy5vbkVycm9yKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVQcm9jZXNzKG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIF9jb3VudGVySWQgKz0gMTtcbiAgICAgIHZhciBpZCA9ICdwcm9jZXNzSWRfJyArIF9jb3VudGVySWQ7XG4gICAgICBwcm9jZXNzZXNbaWRdID0ge1xuICAgICAgICBvbkNvbXBsZXRlOiBvbkNvbXBsZXRlLFxuICAgICAgICBvbkVycm9yOiBvbkVycm9yXG4gICAgICB9O1xuICAgICAgcmV0dXJuIGlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhdGgsIG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIHNldHVwV29ya2VyKCk7XG4gICAgICB2YXIgcHJvY2Vzc0lkID0gY3JlYXRlUHJvY2VzcyhvbkNvbXBsZXRlLCBvbkVycm9yKTtcbiAgICAgIHdvcmtlckluc3RhbmNlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ2xvYWRBbmltYXRpb24nLFxuICAgICAgICBwYXRoOiBwYXRoLFxuICAgICAgICBmdWxsUGF0aDogd2luZG93LmxvY2F0aW9uLm9yaWdpbiArIHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgaWQ6IHByb2Nlc3NJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWREYXRhKHBhdGgsIG9uQ29tcGxldGUsIG9uRXJyb3IpIHtcbiAgICAgIHNldHVwV29ya2VyKCk7XG4gICAgICB2YXIgcHJvY2Vzc0lkID0gY3JlYXRlUHJvY2VzcyhvbkNvbXBsZXRlLCBvbkVycm9yKTtcbiAgICAgIHdvcmtlckluc3RhbmNlLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgdHlwZTogJ2xvYWREYXRhJyxcbiAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgZnVsbFBhdGg6IHdpbmRvdy5sb2NhdGlvbi5vcmlnaW4gKyB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWUsXG4gICAgICAgIGlkOiBwcm9jZXNzSWRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wbGV0ZUFuaW1hdGlvbihhbmltLCBvbkNvbXBsZXRlLCBvbkVycm9yKSB7XG4gICAgICBzZXR1cFdvcmtlcigpO1xuICAgICAgdmFyIHByb2Nlc3NJZCA9IGNyZWF0ZVByb2Nlc3Mob25Db21wbGV0ZSwgb25FcnJvcik7XG4gICAgICB3b3JrZXJJbnN0YW5jZS5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5cGU6ICdjb21wbGV0ZScsXG4gICAgICAgIGFuaW1hdGlvbjogYW5pbSxcbiAgICAgICAgaWQ6IHByb2Nlc3NJZFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBsb2FkQW5pbWF0aW9uOiBsb2FkQW5pbWF0aW9uLFxuICAgICAgbG9hZERhdGE6IGxvYWREYXRhLFxuICAgICAgY29tcGxldGVBbmltYXRpb246IGNvbXBsZXRlQW5pbWF0aW9uXG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBJbWFnZVByZWxvYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcHJveHlJbWFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gMTtcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSAxO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgY3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgIGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgIHJldHVybiBjYW52YXM7XG4gICAgfSgpO1xuICAgIGZ1bmN0aW9uIGltYWdlTG9hZGVkKCkge1xuICAgICAgdGhpcy5sb2FkZWRBc3NldHMgKz0gMTtcbiAgICAgIGlmICh0aGlzLmxvYWRlZEFzc2V0cyA9PT0gdGhpcy50b3RhbEltYWdlcyAmJiB0aGlzLmxvYWRlZEZvb3RhZ2VzQ291bnQgPT09IHRoaXMudG90YWxGb290YWdlcykge1xuICAgICAgICBpZiAodGhpcy5pbWFnZXNMb2FkZWRDYikge1xuICAgICAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IobnVsbCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZm9vdGFnZUxvYWRlZCgpIHtcbiAgICAgIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCArPSAxO1xuICAgICAgaWYgKHRoaXMubG9hZGVkQXNzZXRzID09PSB0aGlzLnRvdGFsSW1hZ2VzICYmIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCA9PT0gdGhpcy50b3RhbEZvb3RhZ2VzKSB7XG4gICAgICAgIGlmICh0aGlzLmltYWdlc0xvYWRlZENiKSB7XG4gICAgICAgICAgdGhpcy5pbWFnZXNMb2FkZWRDYihudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRBc3NldHNQYXRoKGFzc2V0RGF0YSwgYXNzZXRzUGF0aCwgb3JpZ2luYWxQYXRoKSB7XG4gICAgICB2YXIgcGF0aCA9ICcnO1xuICAgICAgaWYgKGFzc2V0RGF0YS5lKSB7XG4gICAgICAgIHBhdGggPSBhc3NldERhdGEucDtcbiAgICAgIH0gZWxzZSBpZiAoYXNzZXRzUGF0aCkge1xuICAgICAgICB2YXIgaW1hZ2VQYXRoID0gYXNzZXREYXRhLnA7XG4gICAgICAgIGlmIChpbWFnZVBhdGguaW5kZXhPZignaW1hZ2VzLycpICE9PSAtMSkge1xuICAgICAgICAgIGltYWdlUGF0aCA9IGltYWdlUGF0aC5zcGxpdCgnLycpWzFdO1xuICAgICAgICB9XG4gICAgICAgIHBhdGggPSBhc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGF0aCA9IG9yaWdpbmFsUGF0aDtcbiAgICAgICAgcGF0aCArPSBhc3NldERhdGEudSA/IGFzc2V0RGF0YS51IDogJyc7XG4gICAgICAgIHBhdGggKz0gYXNzZXREYXRhLnA7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGF0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gdGVzdEltYWdlTG9hZGVkKGltZykge1xuICAgICAgdmFyIF9jb3VudCA9IDA7XG4gICAgICB2YXIgaW50ZXJ2YWxJZCA9IHNldEludGVydmFsKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGJveCA9IGltZy5nZXRCQm94KCk7XG4gICAgICAgIGlmIChib3gud2lkdGggfHwgX2NvdW50ID4gNTAwKSB7XG4gICAgICAgICAgdGhpcy5faW1hZ2VMb2FkZWQoKTtcbiAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsSWQpO1xuICAgICAgICB9XG4gICAgICAgIF9jb3VudCArPSAxO1xuICAgICAgfS5iaW5kKHRoaXMpLCA1MCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUltYWdlRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVOUygnaW1hZ2UnKTtcbiAgICAgIGlmIChpc1NhZmFyaSkge1xuICAgICAgICB0aGlzLnRlc3RJbWFnZUxvYWRlZChpbWcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCB0aGlzLl9pbWFnZUxvYWRlZCwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBvYi5pbWcgPSBwcm94eUltYWdlO1xuICAgICAgICB0aGlzLl9pbWFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmYWxzZSk7XG4gICAgICBpbWcuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIHBhdGgpO1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnRIZWxwZXIuYXBwZW5kKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnRIZWxwZXIuYXBwZW5kKGltZyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9lbGVtZW50SGVscGVyLmFwcGVuZENoaWxkKGltZyk7XG4gICAgICB9XG4gICAgICB2YXIgb2IgPSB7XG4gICAgICAgIGltZzogaW1nLFxuICAgICAgICBhc3NldERhdGE6IGFzc2V0RGF0YVxuICAgICAgfTtcbiAgICAgIHJldHVybiBvYjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlSW1nRGF0YShhc3NldERhdGEpIHtcbiAgICAgIHZhciBwYXRoID0gZ2V0QXNzZXRzUGF0aChhc3NldERhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIHZhciBpbWcgPSBjcmVhdGVUYWcoJ2ltZycpO1xuICAgICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX2ltYWdlTG9hZGVkLCBmYWxzZSk7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHByb3h5SW1hZ2U7XG4gICAgICAgIHRoaXMuX2ltYWdlTG9hZGVkKCk7XG4gICAgICB9LmJpbmQodGhpcyksIGZhbHNlKTtcbiAgICAgIGltZy5zcmMgPSBwYXRoO1xuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBpbWc6IGltZyxcbiAgICAgICAgYXNzZXREYXRhOiBhc3NldERhdGFcbiAgICAgIH07XG4gICAgICByZXR1cm4gb2I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUZvb3RhZ2VEYXRhKGRhdGEpIHtcbiAgICAgIHZhciBvYiA9IHtcbiAgICAgICAgYXNzZXREYXRhOiBkYXRhXG4gICAgICB9O1xuICAgICAgdmFyIHBhdGggPSBnZXRBc3NldHNQYXRoKGRhdGEsIHRoaXMuYXNzZXRzUGF0aCwgdGhpcy5wYXRoKTtcbiAgICAgIGRhdGFNYW5hZ2VyLmxvYWREYXRhKHBhdGgsIGZ1bmN0aW9uIChmb290YWdlRGF0YSkge1xuICAgICAgICBvYi5pbWcgPSBmb290YWdlRGF0YTtcbiAgICAgICAgdGhpcy5fZm9vdGFnZUxvYWRlZCgpO1xuICAgICAgfS5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9iLmltZyA9IHt9O1xuICAgICAgICB0aGlzLl9mb290YWdlTG9hZGVkKCk7XG4gICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgcmV0dXJuIG9iO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkQXNzZXRzKGFzc2V0cywgY2IpIHtcbiAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IgPSBjYjtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGFzc2V0cy5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKCFhc3NldHNbaV0ubGF5ZXJzKSB7XG4gICAgICAgICAgaWYgKCFhc3NldHNbaV0udCB8fCBhc3NldHNbaV0udCA9PT0gJ3NlcScpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxJbWFnZXMgKz0gMTtcbiAgICAgICAgICAgIHRoaXMuaW1hZ2VzLnB1c2godGhpcy5fY3JlYXRlSW1hZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoYXNzZXRzW2ldLnQgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMudG90YWxGb290YWdlcyArPSAxO1xuICAgICAgICAgICAgdGhpcy5pbWFnZXMucHVzaCh0aGlzLmNyZWF0ZUZvb3RhZ2VEYXRhKGFzc2V0c1tpXSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRQYXRoKHBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHBhdGggfHwgJyc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldEFzc2V0c1BhdGgocGF0aCkge1xuICAgICAgdGhpcy5hc3NldHNQYXRoID0gcGF0aCB8fCAnJztcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0QXNzZXQoYXNzZXREYXRhKSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5pbWFnZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuaW1hZ2VzW2ldLmFzc2V0RGF0YSA9PT0gYXNzZXREYXRhKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuaW1hZ2VzW2ldLmltZztcbiAgICAgICAgfVxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgIHRoaXMuaW1hZ2VzTG9hZGVkQ2IgPSBudWxsO1xuICAgICAgdGhpcy5pbWFnZXMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9hZGVkSW1hZ2VzKCkge1xuICAgICAgcmV0dXJuIHRoaXMudG90YWxJbWFnZXMgPT09IHRoaXMubG9hZGVkQXNzZXRzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkZWRGb290YWdlcygpIHtcbiAgICAgIHJldHVybiB0aGlzLnRvdGFsRm9vdGFnZXMgPT09IHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVUeXBlKHR5cGUsIGVsZW1lbnRIZWxwZXIpIHtcbiAgICAgIGlmICh0eXBlID09PSAnc3ZnJykge1xuICAgICAgICB0aGlzLl9lbGVtZW50SGVscGVyID0gZWxlbWVudEhlbHBlcjtcbiAgICAgICAgdGhpcy5fY3JlYXRlSW1hZ2VEYXRhID0gdGhpcy5jcmVhdGVJbWFnZURhdGEuYmluZCh0aGlzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NyZWF0ZUltYWdlRGF0YSA9IHRoaXMuY3JlYXRlSW1nRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBJbWFnZVByZWxvYWRlckZhY3RvcnkoKSB7XG4gICAgICB0aGlzLl9pbWFnZUxvYWRlZCA9IGltYWdlTG9hZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLl9mb290YWdlTG9hZGVkID0gZm9vdGFnZUxvYWRlZC5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy50ZXN0SW1hZ2VMb2FkZWQgPSB0ZXN0SW1hZ2VMb2FkZWQuYmluZCh0aGlzKTtcbiAgICAgIHRoaXMuY3JlYXRlRm9vdGFnZURhdGEgPSBjcmVhdGVGb290YWdlRGF0YS5iaW5kKHRoaXMpO1xuICAgICAgdGhpcy5hc3NldHNQYXRoID0gJyc7XG4gICAgICB0aGlzLnBhdGggPSAnJztcbiAgICAgIHRoaXMudG90YWxJbWFnZXMgPSAwO1xuICAgICAgdGhpcy50b3RhbEZvb3RhZ2VzID0gMDtcbiAgICAgIHRoaXMubG9hZGVkQXNzZXRzID0gMDtcbiAgICAgIHRoaXMubG9hZGVkRm9vdGFnZXNDb3VudCA9IDA7XG4gICAgICB0aGlzLmltYWdlc0xvYWRlZENiID0gbnVsbDtcbiAgICAgIHRoaXMuaW1hZ2VzID0gW107XG4gICAgfVxuICAgIEltYWdlUHJlbG9hZGVyRmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICBsb2FkQXNzZXRzOiBsb2FkQXNzZXRzLFxuICAgICAgc2V0QXNzZXRzUGF0aDogc2V0QXNzZXRzUGF0aCxcbiAgICAgIHNldFBhdGg6IHNldFBhdGgsXG4gICAgICBsb2FkZWRJbWFnZXM6IGxvYWRlZEltYWdlcyxcbiAgICAgIGxvYWRlZEZvb3RhZ2VzOiBsb2FkZWRGb290YWdlcyxcbiAgICAgIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gICAgICBnZXRBc3NldDogZ2V0QXNzZXQsXG4gICAgICBjcmVhdGVJbWdEYXRhOiBjcmVhdGVJbWdEYXRhLFxuICAgICAgY3JlYXRlSW1hZ2VEYXRhOiBjcmVhdGVJbWFnZURhdGEsXG4gICAgICBpbWFnZUxvYWRlZDogaW1hZ2VMb2FkZWQsXG4gICAgICBmb290YWdlTG9hZGVkOiBmb290YWdlTG9hZGVkLFxuICAgICAgc2V0Q2FjaGVUeXBlOiBzZXRDYWNoZVR5cGVcbiAgICB9O1xuICAgIHJldHVybiBJbWFnZVByZWxvYWRlckZhY3Rvcnk7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBCYXNlRXZlbnQoKSB7fVxuICBCYXNlRXZlbnQucHJvdG90eXBlID0ge1xuICAgIHRyaWdnZXJFdmVudDogZnVuY3Rpb24gdHJpZ2dlckV2ZW50KGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgaWYgKHRoaXMuX2Nic1tldmVudE5hbWVdKSB7XG4gICAgICAgIHZhciBjYWxsYmFja3MgPSB0aGlzLl9jYnNbZXZlbnROYW1lXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBjYWxsYmFja3NbaV0oYXJncyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCF0aGlzLl9jYnNbZXZlbnROYW1lXSkge1xuICAgICAgICB0aGlzLl9jYnNbZXZlbnROYW1lXSA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0ucHVzaChjYWxsYmFjayk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBjYWxsYmFjayk7XG4gICAgICB9LmJpbmQodGhpcyk7XG4gICAgfSxcbiAgICByZW1vdmVFdmVudExpc3RlbmVyOiBmdW5jdGlvbiByZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0gPSBudWxsO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLl9jYnNbZXZlbnROYW1lXSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9jYnNbZXZlbnROYW1lXS5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKHRoaXMuX2Nic1tldmVudE5hbWVdW2ldID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2JzW2V2ZW50TmFtZV0uc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaSAtPSAxO1xuICAgICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2Nic1tldmVudE5hbWVdLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX2Nic1tldmVudE5hbWVdID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgbWFya2VyUGFyc2VyID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHBhcnNlUGF5bG9hZExpbmVzKHBheWxvYWQpIHtcbiAgICAgIHZhciBsaW5lcyA9IHBheWxvYWQuc3BsaXQoJ1xcclxcbicpO1xuICAgICAgdmFyIGtleXMgPSB7fTtcbiAgICAgIHZhciBsaW5lO1xuICAgICAgdmFyIGtleXNDb3VudCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGxpbmUgPSBsaW5lc1tpXS5zcGxpdCgnOicpO1xuICAgICAgICBpZiAobGluZS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgICBrZXlzW2xpbmVbMF1dID0gbGluZVsxXS50cmltKCk7XG4gICAgICAgICAga2V5c0NvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXlzQ291bnQgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4ga2V5cztcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChfbWFya2Vycykge1xuICAgICAgdmFyIG1hcmtlcnMgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgX21hcmtlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgdmFyIF9tYXJrZXIgPSBfbWFya2Vyc1tpXTtcbiAgICAgICAgdmFyIG1hcmtlckRhdGEgPSB7XG4gICAgICAgICAgdGltZTogX21hcmtlci50bSxcbiAgICAgICAgICBkdXJhdGlvbjogX21hcmtlci5kclxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IEpTT04ucGFyc2UoX21hcmtlcnNbaV0uY20pO1xuICAgICAgICB9IGNhdGNoIChfKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIG1hcmtlckRhdGEucGF5bG9hZCA9IHBhcnNlUGF5bG9hZExpbmVzKF9tYXJrZXJzW2ldLmNtKTtcbiAgICAgICAgICB9IGNhdGNoIChfXykge1xuICAgICAgICAgICAgbWFya2VyRGF0YS5wYXlsb2FkID0ge1xuICAgICAgICAgICAgICBuYW1lOiBfbWFya2Vyc1tpXS5jbVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbWFya2Vycy5wdXNoKG1hcmtlckRhdGEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmtlcnM7XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBQcm9qZWN0SW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIHJlZ2lzdGVyQ29tcG9zaXRpb24oY29tcCkge1xuICAgICAgdGhpcy5jb21wb3NpdGlvbnMucHVzaChjb21wKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzUHJvamVjdEZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5jb21wb3NpdGlvbnMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2l0aW9uc1tpXS5kYXRhICYmIHRoaXMuY29tcG9zaXRpb25zW2ldLmRhdGEubm0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBvc2l0aW9uc1tpXS5wcmVwYXJlRnJhbWUgJiYgdGhpcy5jb21wb3NpdGlvbnNbaV0uZGF0YS54dCkge1xuICAgICAgICAgICAgICB0aGlzLmNvbXBvc2l0aW9uc1tpXS5wcmVwYXJlRnJhbWUodGhpcy5jdXJyZW50RnJhbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9zaXRpb25zW2ldLmNvbXBJbnRlcmZhY2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLmNvbXBvc2l0aW9ucyA9IFtdO1xuICAgICAgX3RoaXNQcm9qZWN0RnVuY3Rpb24uY3VycmVudEZyYW1lID0gMDtcbiAgICAgIF90aGlzUHJvamVjdEZ1bmN0aW9uLnJlZ2lzdGVyQ29tcG9zaXRpb24gPSByZWdpc3RlckNvbXBvc2l0aW9uO1xuICAgICAgcmV0dXJuIF90aGlzUHJvamVjdEZ1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcmVuZGVyZXJzID0ge307XG4gIHZhciByZWdpc3RlclJlbmRlcmVyID0gZnVuY3Rpb24gcmVnaXN0ZXJSZW5kZXJlcihrZXksIHZhbHVlKSB7XG4gICAgcmVuZGVyZXJzW2tleV0gPSB2YWx1ZTtcbiAgfTtcbiAgZnVuY3Rpb24gZ2V0UmVuZGVyZXIoa2V5KSB7XG4gICAgcmV0dXJuIHJlbmRlcmVyc1trZXldO1xuICB9XG4gIGZ1bmN0aW9uIGdldFJlZ2lzdGVyZWRSZW5kZXJlcigpIHtcbiAgICAvLyBSZXR1cm5zIGNhbnZhcyBieSBkZWZhdWx0IGZvciBjb21wYXRpYmlsaXR5XG4gICAgaWYgKHJlbmRlcmVycy5jYW52YXMpIHtcbiAgICAgIHJldHVybiAnY2FudmFzJztcbiAgICB9XG4gICAgLy8gUmV0dXJucyBhbnkgcmVuZGVyZXIgdGhhdCBpcyByZWdpc3RlcmVkXG4gICAgZm9yICh2YXIga2V5IGluIHJlbmRlcmVycykge1xuICAgICAgaWYgKHJlbmRlcmVyc1trZXldKSB7XG4gICAgICAgIHJldHVybiBrZXk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGZ1bmN0aW9uIF90eXBlb2YkNChvKSB7IFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjsgcmV0dXJuIF90eXBlb2YkNCA9IFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIFwic3ltYm9sXCIgPT0gdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA/IGZ1bmN0aW9uIChvKSB7IHJldHVybiB0eXBlb2YgbzsgfSA6IGZ1bmN0aW9uIChvKSB7IHJldHVybiBvICYmIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgU3ltYm9sICYmIG8uY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvOyB9LCBfdHlwZW9mJDQobyk7IH1cbiAgdmFyIEFuaW1hdGlvbkl0ZW0gPSBmdW5jdGlvbiBBbmltYXRpb25JdGVtKCkge1xuICAgIHRoaXMuX2NicyA9IFtdO1xuICAgIHRoaXMubmFtZSA9ICcnO1xuICAgIHRoaXMucGF0aCA9ICcnO1xuICAgIHRoaXMuaXNMb2FkZWQgPSBmYWxzZTtcbiAgICB0aGlzLmN1cnJlbnRGcmFtZSA9IDA7XG4gICAgdGhpcy5jdXJyZW50UmF3RnJhbWUgPSAwO1xuICAgIHRoaXMuZmlyc3RGcmFtZSA9IDA7XG4gICAgdGhpcy50b3RhbEZyYW1lcyA9IDA7XG4gICAgdGhpcy5mcmFtZVJhdGUgPSAwO1xuICAgIHRoaXMuZnJhbWVNdWx0ID0gMDtcbiAgICB0aGlzLnBsYXlTcGVlZCA9IDE7XG4gICAgdGhpcy5wbGF5RGlyZWN0aW9uID0gMTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0ge307XG4gICAgdGhpcy5hc3NldHMgPSBbXTtcbiAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLmF1dG9wbGF5ID0gZmFsc2U7XG4gICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbnVsbDtcbiAgICB0aGlzLmFuaW1hdGlvbklEID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdGhpcy5hc3NldHNQYXRoID0gJyc7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gMDtcbiAgICB0aGlzLnNlZ21lbnRQb3MgPSAwO1xuICAgIHRoaXMuaXNTdWJmcmFtZUVuYWJsZWQgPSBnZXRTdWJmcmFtZUVuYWJsZWQoKTtcbiAgICB0aGlzLnNlZ21lbnRzID0gW107XG4gICAgdGhpcy5faWRsZSA9IHRydWU7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMucHJvamVjdEludGVyZmFjZSA9IFByb2plY3RJbnRlcmZhY2UoKTtcbiAgICB0aGlzLmltYWdlUHJlbG9hZGVyID0gbmV3IEltYWdlUHJlbG9hZGVyKCk7XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIgPSBhdWRpb0NvbnRyb2xsZXJGYWN0b3J5KCk7XG4gICAgdGhpcy5tYXJrZXJzID0gW107XG4gICAgdGhpcy5jb25maWdBbmltYXRpb24gPSB0aGlzLmNvbmZpZ0FuaW1hdGlvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMub25TZXR1cEVycm9yID0gdGhpcy5vblNldHVwRXJyb3IuYmluZCh0aGlzKTtcbiAgICB0aGlzLm9uU2VnbWVudENvbXBsZXRlID0gdGhpcy5vblNlZ21lbnRDb21wbGV0ZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50ID0gbmV3IEJNRW50ZXJGcmFtZUV2ZW50KCdkcmF3bkZyYW1lJywgMCwgMCwgMCk7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IGdldEV4cHJlc3Npb25zUGx1Z2luKCk7XG4gIH07XG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUV2ZW50XSwgQW5pbWF0aW9uSXRlbSk7XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFBhcmFtcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICBpZiAocGFyYW1zLndyYXBwZXIgfHwgcGFyYW1zLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy53cmFwcGVyID0gcGFyYW1zLndyYXBwZXIgfHwgcGFyYW1zLmNvbnRhaW5lcjtcbiAgICB9XG4gICAgdmFyIGFuaW1UeXBlID0gJ3N2Zyc7XG4gICAgaWYgKHBhcmFtcy5hbmltVHlwZSkge1xuICAgICAgYW5pbVR5cGUgPSBwYXJhbXMuYW5pbVR5cGU7XG4gICAgfSBlbHNlIGlmIChwYXJhbXMucmVuZGVyZXIpIHtcbiAgICAgIGFuaW1UeXBlID0gcGFyYW1zLnJlbmRlcmVyO1xuICAgIH1cbiAgICB2YXIgUmVuZGVyZXJDbGFzcyA9IGdldFJlbmRlcmVyKGFuaW1UeXBlKTtcbiAgICB0aGlzLnJlbmRlcmVyID0gbmV3IFJlbmRlcmVyQ2xhc3ModGhpcywgcGFyYW1zLnJlbmRlcmVyU2V0dGluZ3MpO1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0Q2FjaGVUeXBlKGFuaW1UeXBlLCB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZGVmcyk7XG4gICAgdGhpcy5yZW5kZXJlci5zZXRQcm9qZWN0SW50ZXJmYWNlKHRoaXMucHJvamVjdEludGVyZmFjZSk7XG4gICAgdGhpcy5hbmltVHlwZSA9IGFuaW1UeXBlO1xuICAgIGlmIChwYXJhbXMubG9vcCA9PT0gJycgfHwgcGFyYW1zLmxvb3AgPT09IG51bGwgfHwgcGFyYW1zLmxvb3AgPT09IHVuZGVmaW5lZCB8fCBwYXJhbXMubG9vcCA9PT0gdHJ1ZSkge1xuICAgICAgdGhpcy5sb29wID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBhcmFtcy5sb29wID09PSBmYWxzZSkge1xuICAgICAgdGhpcy5sb29wID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubG9vcCA9IHBhcnNlSW50KHBhcmFtcy5sb29wLCAxMCk7XG4gICAgfVxuICAgIHRoaXMuYXV0b3BsYXkgPSAnYXV0b3BsYXknIGluIHBhcmFtcyA/IHBhcmFtcy5hdXRvcGxheSA6IHRydWU7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1zLm5hbWUgPyBwYXJhbXMubmFtZSA6ICcnO1xuICAgIHRoaXMuYXV0b2xvYWRTZWdtZW50cyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChwYXJhbXMsICdhdXRvbG9hZFNlZ21lbnRzJykgPyBwYXJhbXMuYXV0b2xvYWRTZWdtZW50cyA6IHRydWU7XG4gICAgdGhpcy5hc3NldHNQYXRoID0gcGFyYW1zLmFzc2V0c1BhdGg7XG4gICAgdGhpcy5pbml0aWFsU2VnbWVudCA9IHBhcmFtcy5pbml0aWFsU2VnbWVudDtcbiAgICBpZiAocGFyYW1zLmF1ZGlvRmFjdG9yeSkge1xuICAgICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIuc2V0QXVkaW9GYWN0b3J5KHBhcmFtcy5hdWRpb0ZhY3RvcnkpO1xuICAgIH1cbiAgICBpZiAocGFyYW1zLmFuaW1hdGlvbkRhdGEpIHtcbiAgICAgIHRoaXMuc2V0dXBBbmltYXRpb24ocGFyYW1zLmFuaW1hdGlvbkRhdGEpO1xuICAgIH0gZWxzZSBpZiAocGFyYW1zLnBhdGgpIHtcbiAgICAgIGlmIChwYXJhbXMucGF0aC5sYXN0SW5kZXhPZignXFxcXCcpICE9PSAtMSkge1xuICAgICAgICB0aGlzLnBhdGggPSBwYXJhbXMucGF0aC5zdWJzdHIoMCwgcGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJ1xcXFwnKSArIDEpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXRoID0gcGFyYW1zLnBhdGguc3Vic3RyKDAsIHBhcmFtcy5wYXRoLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuZmlsZU5hbWUgPSBwYXJhbXMucGF0aC5zdWJzdHIocGFyYW1zLnBhdGgubGFzdEluZGV4T2YoJy8nKSArIDEpO1xuICAgICAgdGhpcy5maWxlTmFtZSA9IHRoaXMuZmlsZU5hbWUuc3Vic3RyKDAsIHRoaXMuZmlsZU5hbWUubGFzdEluZGV4T2YoJy5qc29uJykpO1xuICAgICAgZGF0YU1hbmFnZXIubG9hZEFuaW1hdGlvbihwYXJhbXMucGF0aCwgdGhpcy5jb25maWdBbmltYXRpb24sIHRoaXMub25TZXR1cEVycm9yKTtcbiAgICB9XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLm9uU2V0dXBFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldHVwQW5pbWF0aW9uID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBkYXRhTWFuYWdlci5jb21wbGV0ZUFuaW1hdGlvbihkYXRhLCB0aGlzLmNvbmZpZ0FuaW1hdGlvbik7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldERhdGEgPSBmdW5jdGlvbiAod3JhcHBlciwgYW5pbWF0aW9uRGF0YSkge1xuICAgIGlmIChhbmltYXRpb25EYXRhKSB7XG4gICAgICBpZiAoX3R5cGVvZiQ0KGFuaW1hdGlvbkRhdGEpICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBhbmltYXRpb25EYXRhID0gSlNPTi5wYXJzZShhbmltYXRpb25EYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIHBhcmFtcyA9IHtcbiAgICAgIHdyYXBwZXI6IHdyYXBwZXIsXG4gICAgICBhbmltYXRpb25EYXRhOiBhbmltYXRpb25EYXRhXG4gICAgfTtcbiAgICB2YXIgd3JhcHBlckF0dHJpYnV0ZXMgPSB3cmFwcGVyLmF0dHJpYnV0ZXM7XG4gICAgcGFyYW1zLnBhdGggPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbWF0aW9uLXBhdGgnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbWF0aW9uLXBhdGgnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wYXRoJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXBhdGgnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcGF0aCcpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1wYXRoJykudmFsdWUgOiAnJztcbiAgICBwYXJhbXMuYW5pbVR5cGUgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXR5cGUnKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tdHlwZScpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS10eXBlJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS10eXBlJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcmVuZGVyZXInKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tcmVuZGVyZXInKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcmVuZGVyZXInKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcmVuZGVyZXInKS52YWx1ZSA6IGdldFJlZ2lzdGVyZWRSZW5kZXJlcigpIHx8ICdjYW52YXMnO1xuICAgIHZhciBsb29wID0gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWFuaW0tbG9vcCcpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWxvb3AnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1sb29wJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXN0ZWQtdGVybmFyeVxuICAgID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLWxvb3AnKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbG9vcCcpID8gd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdibS1sb29wJykudmFsdWUgOiAnJztcbiAgICBpZiAobG9vcCA9PT0gJ2ZhbHNlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGxvb3AgPT09ICd0cnVlJykge1xuICAgICAgcGFyYW1zLmxvb3AgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAobG9vcCAhPT0gJycpIHtcbiAgICAgIHBhcmFtcy5sb29wID0gcGFyc2VJbnQobG9vcCwgMTApO1xuICAgIH1cbiAgICB2YXIgYXV0b3BsYXkgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYW5pbS1hdXRvcGxheScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLWF1dG9wbGF5JykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tYXV0b3BsYXknKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLW5lc3RlZC10ZXJuYXJ5XG4gICAgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tYXV0b3BsYXknKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tYXV0b3BsYXknKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tYXV0b3BsYXknKS52YWx1ZSA6IHRydWU7XG4gICAgcGFyYW1zLmF1dG9wbGF5ID0gYXV0b3BsYXkgIT09ICdmYWxzZSc7XG4gICAgcGFyYW1zLm5hbWUgPSB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtbmFtZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1uYW1lJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2RhdGEtYm0tbmFtZScpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1uYW1lJykudmFsdWUgOiB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLW5hbWUnKSA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tbmFtZScpLnZhbHVlIDogJyc7XG4gICAgdmFyIHByZXJlbmRlciA9IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXByZXJlbmRlcicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1hbmltLXByZXJlbmRlcicpLnZhbHVlIDogd3JhcHBlckF0dHJpYnV0ZXMuZ2V0TmFtZWRJdGVtKCdkYXRhLWJtLXByZXJlbmRlcicpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmVzdGVkLXRlcm5hcnlcbiAgICA/IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnZGF0YS1ibS1wcmVyZW5kZXInKS52YWx1ZSA6IHdyYXBwZXJBdHRyaWJ1dGVzLmdldE5hbWVkSXRlbSgnYm0tcHJlcmVuZGVyJykgPyB3cmFwcGVyQXR0cmlidXRlcy5nZXROYW1lZEl0ZW0oJ2JtLXByZXJlbmRlcicpLnZhbHVlIDogJyc7XG4gICAgaWYgKHByZXJlbmRlciA9PT0gJ2ZhbHNlJykge1xuICAgICAgcGFyYW1zLnByZXJlbmRlciA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIXBhcmFtcy5wYXRoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2Rlc3Ryb3knKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRQYXJhbXMocGFyYW1zKTtcbiAgICB9XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmluY2x1ZGVMYXllcnMgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmIChkYXRhLm9wID4gdGhpcy5hbmltYXRpb25EYXRhLm9wKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkRhdGEub3AgPSBkYXRhLm9wO1xuICAgICAgdGhpcy50b3RhbEZyYW1lcyA9IE1hdGguZmxvb3IoZGF0YS5vcCAtIHRoaXMuYW5pbWF0aW9uRGF0YS5pcCk7XG4gICAgfVxuICAgIHZhciBsYXllcnMgPSB0aGlzLmFuaW1hdGlvbkRhdGEubGF5ZXJzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBsYXllcnMubGVuZ3RoO1xuICAgIHZhciBuZXdMYXllcnMgPSBkYXRhLmxheWVycztcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbiA9IG5ld0xheWVycy5sZW5ndGg7XG4gICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAobGF5ZXJzW2ldLmlkID09PSBuZXdMYXllcnNbal0uaWQpIHtcbiAgICAgICAgICBsYXllcnNbaV0gPSBuZXdMYXllcnNbal07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS5jaGFycyB8fCBkYXRhLmZvbnRzKSB7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoZGF0YS5jaGFycyk7XG4gICAgICB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkRm9udHMoZGF0YS5mb250cywgdGhpcy5yZW5kZXJlci5nbG9iYWxEYXRhLmRlZnMpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5hc3NldHMpIHtcbiAgICAgIGxlbiA9IGRhdGEuYXNzZXRzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzLnB1c2goZGF0YS5hc3NldHNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmFuaW1hdGlvbkRhdGEuX19jb21wbGV0ZSA9IGZhbHNlO1xuICAgIGRhdGFNYW5hZ2VyLmNvbXBsZXRlQW5pbWF0aW9uKHRoaXMuYW5pbWF0aW9uRGF0YSwgdGhpcy5vblNlZ21lbnRDb21wbGV0ZSk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLm9uU2VnbWVudENvbXBsZXRlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkRhdGEgPSBkYXRhO1xuICAgIHZhciBleHByZXNzaW9uc1BsdWdpbiA9IGdldEV4cHJlc3Npb25zUGx1Z2luKCk7XG4gICAgaWYgKGV4cHJlc3Npb25zUGx1Z2luKSB7XG4gICAgICBleHByZXNzaW9uc1BsdWdpbi5pbml0RXhwcmVzc2lvbnModGhpcyk7XG4gICAgfVxuICAgIHRoaXMubG9hZE5leHRTZWdtZW50KCk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmxvYWROZXh0U2VnbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VnbWVudHMgPSB0aGlzLmFuaW1hdGlvbkRhdGEuc2VnbWVudHM7XG4gICAgaWYgKCFzZWdtZW50cyB8fCBzZWdtZW50cy5sZW5ndGggPT09IDAgfHwgIXRoaXMuYXV0b2xvYWRTZWdtZW50cykge1xuICAgICAgdGhpcy50cmlnZ2VyKCdkYXRhX3JlYWR5Jyk7XG4gICAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzLnNoaWZ0KCk7XG4gICAgdGhpcy50aW1lQ29tcGxldGVkID0gc2VnbWVudC50aW1lICogdGhpcy5mcmFtZVJhdGU7XG4gICAgdmFyIHNlZ21lbnRQYXRoID0gdGhpcy5wYXRoICsgdGhpcy5maWxlTmFtZSArICdfJyArIHRoaXMuc2VnbWVudFBvcyArICcuanNvbic7XG4gICAgdGhpcy5zZWdtZW50UG9zICs9IDE7XG4gICAgZGF0YU1hbmFnZXIubG9hZERhdGEoc2VnbWVudFBhdGgsIHRoaXMuaW5jbHVkZUxheWVycy5iaW5kKHRoaXMpLCBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2RhdGFfZmFpbGVkJyk7XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubG9hZFNlZ21lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWdtZW50cyA9IHRoaXMuYW5pbWF0aW9uRGF0YS5zZWdtZW50cztcbiAgICBpZiAoIXNlZ21lbnRzKSB7XG4gICAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xuICAgIH1cbiAgICB0aGlzLmxvYWROZXh0U2VnbWVudCgpO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5pbWFnZXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy50cmlnZ2VyKCdsb2FkZWRfaW1hZ2VzJyk7XG4gICAgdGhpcy5jaGVja0xvYWRlZCgpO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5wcmVsb2FkSW1hZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0c1BhdGgpO1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIuc2V0UGF0aCh0aGlzLnBhdGgpO1xuICAgIHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZEFzc2V0cyh0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzLCB0aGlzLmltYWdlc0xvYWRlZC5iaW5kKHRoaXMpKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlcmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkRhdGEgPSBhbmltRGF0YTtcbiAgICAgIGlmICh0aGlzLmluaXRpYWxTZWdtZW50KSB7XG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKHRoaXMuaW5pdGlhbFNlZ21lbnRbMV0gLSB0aGlzLmluaXRpYWxTZWdtZW50WzBdKTtcbiAgICAgICAgdGhpcy5maXJzdEZyYW1lID0gTWF0aC5yb3VuZCh0aGlzLmluaXRpYWxTZWdtZW50WzBdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBNYXRoLmZsb29yKHRoaXMuYW5pbWF0aW9uRGF0YS5vcCAtIHRoaXMuYW5pbWF0aW9uRGF0YS5pcCk7XG4gICAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IE1hdGgucm91bmQodGhpcy5hbmltYXRpb25EYXRhLmlwKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyZXIuY29uZmlnQW5pbWF0aW9uKGFuaW1EYXRhKTtcbiAgICAgIGlmICghYW5pbURhdGEuYXNzZXRzKSB7XG4gICAgICAgIGFuaW1EYXRhLmFzc2V0cyA9IFtdO1xuICAgICAgfVxuICAgICAgdGhpcy5hc3NldHMgPSB0aGlzLmFuaW1hdGlvbkRhdGEuYXNzZXRzO1xuICAgICAgdGhpcy5mcmFtZVJhdGUgPSB0aGlzLmFuaW1hdGlvbkRhdGEuZnI7XG4gICAgICB0aGlzLmZyYW1lTXVsdCA9IHRoaXMuYW5pbWF0aW9uRGF0YS5mciAvIDEwMDA7XG4gICAgICB0aGlzLnJlbmRlcmVyLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zKGFuaW1EYXRhLmFzc2V0cyk7XG4gICAgICB0aGlzLm1hcmtlcnMgPSBtYXJrZXJQYXJzZXIoYW5pbURhdGEubWFya2VycyB8fCBbXSk7XG4gICAgICB0aGlzLnRyaWdnZXIoJ2NvbmZpZ19yZWFkeScpO1xuICAgICAgdGhpcy5wcmVsb2FkSW1hZ2VzKCk7XG4gICAgICB0aGlzLmxvYWRTZWdtZW50cygpO1xuICAgICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xuICAgICAgdGhpcy53YWl0Rm9yRm9udHNMb2FkZWQoKTtcbiAgICAgIGlmICh0aGlzLmlzUGF1c2VkKSB7XG4gICAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnBhdXNlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRoaXMudHJpZ2dlckNvbmZpZ0Vycm9yKGVycm9yKTtcbiAgICB9XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLndhaXRGb3JGb250c0xvYWRlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVuZGVyZXIuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5pc0xvYWRlZCkge1xuICAgICAgdGhpcy5jaGVja0xvYWRlZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXRUaW1lb3V0KHRoaXMud2FpdEZvckZvbnRzTG9hZGVkLmJpbmQodGhpcyksIDIwKTtcbiAgICB9XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmNoZWNrTG9hZGVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pc0xvYWRlZCAmJiB0aGlzLnJlbmRlcmVyLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuaXNMb2FkZWQgJiYgKHRoaXMuaW1hZ2VQcmVsb2FkZXIubG9hZGVkSW1hZ2VzKCkgfHwgdGhpcy5yZW5kZXJlci5yZW5kZXJlclR5cGUgIT09ICdjYW52YXMnKSAmJiB0aGlzLmltYWdlUHJlbG9hZGVyLmxvYWRlZEZvb3RhZ2VzKCkpIHtcbiAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgdmFyIGV4cHJlc3Npb25zUGx1Z2luID0gZ2V0RXhwcmVzc2lvbnNQbHVnaW4oKTtcbiAgICAgIGlmIChleHByZXNzaW9uc1BsdWdpbikge1xuICAgICAgICBleHByZXNzaW9uc1BsdWdpbi5pbml0RXhwcmVzc2lvbnModGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLmluaXRJdGVtcygpO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignRE9NTG9hZGVkJyk7XG4gICAgICB9LmJpbmQodGhpcyksIDApO1xuICAgICAgdGhpcy5nb3RvRnJhbWUoKTtcbiAgICAgIGlmICh0aGlzLmF1dG9wbGF5KSB7XG4gICAgICAgIHRoaXMucGxheSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUucmVzaXplID0gZnVuY3Rpb24gKHdpZHRoLCBoZWlnaHQpIHtcbiAgICAvLyBBZGRpbmcgdGhpcyB2YWxpZGF0aW9uIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBpbiBjYXNlIGFuIGV2ZW50IG9iamVjdCB3YXMgYmVpbmcgcGFzc2VkIGRvd25cbiAgICB2YXIgX3dpZHRoID0gdHlwZW9mIHdpZHRoID09PSAnbnVtYmVyJyA/IHdpZHRoIDogdW5kZWZpbmVkO1xuICAgIHZhciBfaGVpZ2h0ID0gdHlwZW9mIGhlaWdodCA9PT0gJ251bWJlcicgPyBoZWlnaHQgOiB1bmRlZmluZWQ7XG4gICAgdGhpcy5yZW5kZXJlci51cGRhdGVDb250YWluZXJTaXplKF93aWR0aCwgX2hlaWdodCk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFN1YmZyYW1lID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICB0aGlzLmlzU3ViZnJhbWVFbmFibGVkID0gISFmbGFnO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb3RvRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jdXJyZW50RnJhbWUgPSB0aGlzLmlzU3ViZnJhbWVFbmFibGVkID8gdGhpcy5jdXJyZW50UmF3RnJhbWUgOiB+fnRoaXMuY3VycmVudFJhd0ZyYW1lOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcblxuICAgIGlmICh0aGlzLnRpbWVDb21wbGV0ZWQgIT09IHRoaXMudG90YWxGcmFtZXMgJiYgdGhpcy5jdXJyZW50RnJhbWUgPiB0aGlzLnRpbWVDb21wbGV0ZWQpIHtcbiAgICAgIHRoaXMuY3VycmVudEZyYW1lID0gdGhpcy50aW1lQ29tcGxldGVkO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoJ2VudGVyRnJhbWUnKTtcbiAgICB0aGlzLnJlbmRlckZyYW1lKCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkcmF3bkZyYW1lJyk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmlzTG9hZGVkID09PSBmYWxzZSB8fCAhdGhpcy5yZW5kZXJlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuZXhwcmVzc2lvbnNQbHVnaW4pIHtcbiAgICAgICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbi5yZXNldEZyYW1lKCk7XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlcmVyLnJlbmRlckZyYW1lKHRoaXMuY3VycmVudEZyYW1lICsgdGhpcy5maXJzdEZyYW1lKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy50cmlnZ2VyUmVuZGVyRnJhbWVFcnJvcihlcnJvcik7XG4gICAgfVxuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5wbGF5ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUpIHtcbiAgICAgIHRoaXMuaXNQYXVzZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHJpZ2dlcignX3BsYXknKTtcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnJlc3VtZSgpO1xuICAgICAgaWYgKHRoaXMuX2lkbGUpIHtcbiAgICAgICAgdGhpcy5faWRsZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ19hY3RpdmUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmlzUGF1c2VkID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignX3BhdXNlJyk7XG4gICAgICB0aGlzLl9pZGxlID0gdHJ1ZTtcbiAgICAgIHRoaXMudHJpZ2dlcignX2lkbGUnKTtcbiAgICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLnBhdXNlKCk7XG4gICAgfVxuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS50b2dnbGVQYXVzZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLmlzUGF1c2VkID09PSB0cnVlKSB7XG4gICAgICB0aGlzLnBsYXkoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wYXVzZSgpO1xuICAgIH1cbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGF1c2UoKTtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgdGhpcy5fY29tcGxldGVkTG9vcCA9IGZhbHNlO1xuICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMCk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldE1hcmtlckRhdGEgPSBmdW5jdGlvbiAobWFya2VyTmFtZSkge1xuICAgIHZhciBtYXJrZXI7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm1hcmtlcnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIG1hcmtlciA9IHRoaXMubWFya2Vyc1tpXTtcbiAgICAgIGlmIChtYXJrZXIucGF5bG9hZCAmJiBtYXJrZXIucGF5bG9hZC5uYW1lID09PSBtYXJrZXJOYW1lKSB7XG4gICAgICAgIHJldHVybiBtYXJrZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb1RvQW5kU3RvcCA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNGcmFtZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmIChpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmdldE1hcmtlckRhdGEodmFsdWUpO1xuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICB0aGlzLmdvVG9BbmRTdG9wKG1hcmtlci50aW1lLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzRnJhbWUpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUodmFsdWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKHZhbHVlICogdGhpcy5mcmFtZU1vZGlmaWVyKTtcbiAgICB9XG4gICAgdGhpcy5wYXVzZSgpO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5nb1RvQW5kUGxheSA9IGZ1bmN0aW9uICh2YWx1ZSwgaXNGcmFtZSwgbmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgbnVtVmFsdWUgPSBOdW1iZXIodmFsdWUpO1xuICAgIGlmIChpc05hTihudW1WYWx1ZSkpIHtcbiAgICAgIHZhciBtYXJrZXIgPSB0aGlzLmdldE1hcmtlckRhdGEodmFsdWUpO1xuICAgICAgaWYgKG1hcmtlcikge1xuICAgICAgICBpZiAoIW1hcmtlci5kdXJhdGlvbikge1xuICAgICAgICAgIHRoaXMuZ29Ub0FuZFN0b3AobWFya2VyLnRpbWUsIHRydWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGxheVNlZ21lbnRzKFttYXJrZXIudGltZSwgbWFya2VyLnRpbWUgKyBtYXJrZXIuZHVyYXRpb25dLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdvVG9BbmRTdG9wKG51bVZhbHVlLCBpc0ZyYW1lLCBuYW1lKTtcbiAgICB9XG4gICAgdGhpcy5wbGF5KCk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmFkdmFuY2VUaW1lID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNQYXVzZWQgPT09IHRydWUgfHwgdGhpcy5pc0xvYWRlZCA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIG5leHRWYWx1ZSA9IHRoaXMuY3VycmVudFJhd0ZyYW1lICsgdmFsdWUgKiB0aGlzLmZyYW1lTW9kaWZpZXI7XG4gICAgdmFyIF9pc0NvbXBsZXRlID0gZmFsc2U7XG4gICAgLy8gQ2hlY2tpbmcgaWYgbmV4dFZhbHVlID4gdG90YWxGcmFtZXMgLSAxIGZvciBhZGRyZXNzaW5nIG5vbiBsb29waW5nIGFuZCBsb29waW5nIGFuaW1hdGlvbnMuXG4gICAgLy8gSWYgYW5pbWF0aW9uIHdvbid0IGxvb3AsIGl0IHNob3VsZCBzdG9wIGF0IHRvdGFsRnJhbWVzIC0gMS4gSWYgaXQgd2lsbCBsb29wIGl0IHNob3VsZCBjb21wbGV0ZSB0aGUgbGFzdCBmcmFtZSBhbmQgdGhlbiBsb29wLlxuICAgIGlmIChuZXh0VmFsdWUgPj0gdGhpcy50b3RhbEZyYW1lcyAtIDEgJiYgdGhpcy5mcmFtZU1vZGlmaWVyID4gMCkge1xuICAgICAgaWYgKCF0aGlzLmxvb3AgfHwgdGhpcy5wbGF5Q291bnQgPT09IHRoaXMubG9vcCkge1xuICAgICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgPiB0aGlzLnRvdGFsRnJhbWVzID8gbmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyA6IDApKSB7XG4gICAgICAgICAgX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIG5leHRWYWx1ZSA9IHRoaXMudG90YWxGcmFtZXMgLSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG5leHRWYWx1ZSA+PSB0aGlzLnRvdGFsRnJhbWVzKSB7XG4gICAgICAgIHRoaXMucGxheUNvdW50ICs9IDE7XG4gICAgICAgIGlmICghdGhpcy5jaGVja1NlZ21lbnRzKG5leHRWYWx1ZSAlIHRoaXMudG90YWxGcmFtZXMpKSB7XG4gICAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKTtcbiAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLnRyaWdnZXIoJ2xvb3BDb21wbGV0ZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEN1cnJlbnRSYXdGcmFtZVZhbHVlKG5leHRWYWx1ZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChuZXh0VmFsdWUgPCAwKSB7XG4gICAgICBpZiAoIXRoaXMuY2hlY2tTZWdtZW50cyhuZXh0VmFsdWUgJSB0aGlzLnRvdGFsRnJhbWVzKSkge1xuICAgICAgICBpZiAodGhpcy5sb29wICYmICEodGhpcy5wbGF5Q291bnQtLSA8PSAwICYmIHRoaXMubG9vcCAhPT0gdHJ1ZSkpIHtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBsdXNwbHVzXG4gICAgICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh0aGlzLnRvdGFsRnJhbWVzICsgbmV4dFZhbHVlICUgdGhpcy50b3RhbEZyYW1lcyk7XG4gICAgICAgICAgaWYgKCF0aGlzLl9jb21wbGV0ZWRMb29wKSB7XG4gICAgICAgICAgICB0aGlzLl9jb21wbGV0ZWRMb29wID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy50cmlnZ2VyKCdsb29wQ29tcGxldGUnKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgX2lzQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgIG5leHRWYWx1ZSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZShuZXh0VmFsdWUpO1xuICAgIH1cbiAgICBpZiAoX2lzQ29tcGxldGUpIHtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUobmV4dFZhbHVlKTtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMudHJpZ2dlcignY29tcGxldGUnKTtcbiAgICB9XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmFkanVzdFNlZ21lbnQgPSBmdW5jdGlvbiAoYXJyLCBvZmZzZXQpIHtcbiAgICB0aGlzLnBsYXlDb3VudCA9IDA7XG4gICAgaWYgKGFyclsxXSA8IGFyclswXSkge1xuICAgICAgaWYgKHRoaXMuZnJhbWVNb2RpZmllciA+IDApIHtcbiAgICAgICAgaWYgKHRoaXMucGxheVNwZWVkIDwgMCkge1xuICAgICAgICAgIHRoaXMuc2V0U3BlZWQoLXRoaXMucGxheVNwZWVkKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbigtMSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMudG90YWxGcmFtZXMgPSBhcnJbMF0gLSBhcnJbMV07XG4gICAgICB0aGlzLnRpbWVDb21wbGV0ZWQgPSB0aGlzLnRvdGFsRnJhbWVzO1xuICAgICAgdGhpcy5maXJzdEZyYW1lID0gYXJyWzFdO1xuICAgICAgdGhpcy5zZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSh0aGlzLnRvdGFsRnJhbWVzIC0gMC4wMDEgLSBvZmZzZXQpO1xuICAgIH0gZWxzZSBpZiAoYXJyWzFdID4gYXJyWzBdKSB7XG4gICAgICBpZiAodGhpcy5mcmFtZU1vZGlmaWVyIDwgMCkge1xuICAgICAgICBpZiAodGhpcy5wbGF5U3BlZWQgPCAwKSB7XG4gICAgICAgICAgdGhpcy5zZXRTcGVlZCgtdGhpcy5wbGF5U3BlZWQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnRvdGFsRnJhbWVzID0gYXJyWzFdIC0gYXJyWzBdO1xuICAgICAgdGhpcy50aW1lQ29tcGxldGVkID0gdGhpcy50b3RhbEZyYW1lcztcbiAgICAgIHRoaXMuZmlyc3RGcmFtZSA9IGFyclswXTtcbiAgICAgIHRoaXMuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUoMC4wMDEgKyBvZmZzZXQpO1xuICAgIH1cbiAgICB0aGlzLnRyaWdnZXIoJ3NlZ21lbnRTdGFydCcpO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRTZWdtZW50ID0gZnVuY3Rpb24gKGluaXQsIGVuZCkge1xuICAgIHZhciBwZW5kaW5nRnJhbWUgPSAtMTtcbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgaWYgKHRoaXMuY3VycmVudFJhd0ZyYW1lICsgdGhpcy5maXJzdEZyYW1lIDwgaW5pdCkge1xuICAgICAgICBwZW5kaW5nRnJhbWUgPSBpbml0O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmN1cnJlbnRSYXdGcmFtZSArIHRoaXMuZmlyc3RGcmFtZSA+IGVuZCkge1xuICAgICAgICBwZW5kaW5nRnJhbWUgPSBlbmQgLSBpbml0O1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmZpcnN0RnJhbWUgPSBpbml0O1xuICAgIHRoaXMudG90YWxGcmFtZXMgPSBlbmQgLSBpbml0O1xuICAgIHRoaXMudGltZUNvbXBsZXRlZCA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgaWYgKHBlbmRpbmdGcmFtZSAhPT0gLTEpIHtcbiAgICAgIHRoaXMuZ29Ub0FuZFN0b3AocGVuZGluZ0ZyYW1lLCB0cnVlKTtcbiAgICB9XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnBsYXlTZWdtZW50cyA9IGZ1bmN0aW9uIChhcnIsIGZvcmNlRmxhZykge1xuICAgIGlmIChmb3JjZUZsYWcpIHtcbiAgICAgIHRoaXMuc2VnbWVudHMubGVuZ3RoID0gMDtcbiAgICB9XG4gICAgaWYgKF90eXBlb2YkNChhcnJbMF0pID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnNlZ21lbnRzLnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZWdtZW50cy5wdXNoKGFycik7XG4gICAgfVxuICAgIGlmICh0aGlzLnNlZ21lbnRzLmxlbmd0aCAmJiBmb3JjZUZsYWcpIHtcbiAgICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIDApO1xuICAgIH1cbiAgICBpZiAodGhpcy5pc1BhdXNlZCkge1xuICAgICAgdGhpcy5wbGF5KCk7XG4gICAgfVxuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5yZXNldFNlZ21lbnRzID0gZnVuY3Rpb24gKGZvcmNlRmxhZykge1xuICAgIHRoaXMuc2VnbWVudHMubGVuZ3RoID0gMDtcbiAgICB0aGlzLnNlZ21lbnRzLnB1c2goW3RoaXMuYW5pbWF0aW9uRGF0YS5pcCwgdGhpcy5hbmltYXRpb25EYXRhLm9wXSk7XG4gICAgaWYgKGZvcmNlRmxhZykge1xuICAgICAgdGhpcy5jaGVja1NlZ21lbnRzKDApO1xuICAgIH1cbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuY2hlY2tTZWdtZW50cyA9IGZ1bmN0aW9uIChvZmZzZXQpIHtcbiAgICBpZiAodGhpcy5zZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuYWRqdXN0U2VnbWVudCh0aGlzLnNlZ21lbnRzLnNoaWZ0KCksIG9mZnNldCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUgfHwgIXRoaXMucmVuZGVyZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJlci5kZXN0cm95KCk7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlci5kZXN0cm95KCk7XG4gICAgdGhpcy50cmlnZ2VyKCdkZXN0cm95Jyk7XG4gICAgdGhpcy5fY2JzID0gbnVsbDtcbiAgICB0aGlzLm9uRW50ZXJGcmFtZSA9IG51bGw7XG4gICAgdGhpcy5vbkxvb3BDb21wbGV0ZSA9IG51bGw7XG4gICAgdGhpcy5vbkNvbXBsZXRlID0gbnVsbDtcbiAgICB0aGlzLm9uU2VnbWVudFN0YXJ0ID0gbnVsbDtcbiAgICB0aGlzLm9uRGVzdHJveSA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlciA9IG51bGw7XG4gICAgdGhpcy5leHByZXNzaW9uc1BsdWdpbiA9IG51bGw7XG4gICAgdGhpcy5pbWFnZVByZWxvYWRlciA9IG51bGw7XG4gICAgdGhpcy5wcm9qZWN0SW50ZXJmYWNlID0gbnVsbDtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0Q3VycmVudFJhd0ZyYW1lVmFsdWUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmN1cnJlbnRSYXdGcmFtZSA9IHZhbHVlO1xuICAgIHRoaXMuZ290b0ZyYW1lKCk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnNldFNwZWVkID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMucGxheVNwZWVkID0gdmFsO1xuICAgIHRoaXMudXBkYUZyYW1lTW9kaWZpZXIoKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0RGlyZWN0aW9uID0gZnVuY3Rpb24gKHZhbCkge1xuICAgIHRoaXMucGxheURpcmVjdGlvbiA9IHZhbCA8IDAgPyAtMSA6IDE7XG4gICAgdGhpcy51cGRhRnJhbWVNb2RpZmllcigpO1xuICB9O1xuICBBbmltYXRpb25JdGVtLnByb3RvdHlwZS5zZXRMb29wID0gZnVuY3Rpb24gKGlzTG9vcGluZykge1xuICAgIHRoaXMubG9vcCA9IGlzTG9vcGluZztcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2V0Vm9sdW1lID0gZnVuY3Rpb24gKHZhbCwgbmFtZSkge1xuICAgIGlmIChuYW1lICYmIHRoaXMubmFtZSAhPT0gbmFtZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmF1ZGlvQ29udHJvbGxlci5zZXRWb2x1bWUodmFsKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0Vm9sdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLmF1ZGlvQ29udHJvbGxlci5nZXRWb2x1bWUoKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUubXV0ZSA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUgJiYgdGhpcy5uYW1lICE9PSBuYW1lKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYXVkaW9Db250cm9sbGVyLm11dGUoKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudW5tdXRlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSAmJiB0aGlzLm5hbWUgIT09IG5hbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIudW5tdXRlKCk7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLnVwZGFGcmFtZU1vZGlmaWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnJhbWVNb2RpZmllciA9IHRoaXMuZnJhbWVNdWx0ICogdGhpcy5wbGF5U3BlZWQgKiB0aGlzLnBsYXlEaXJlY3Rpb247XG4gICAgdGhpcy5hdWRpb0NvbnRyb2xsZXIuc2V0UmF0ZSh0aGlzLnBsYXlTcGVlZCAqIHRoaXMucGxheURpcmVjdGlvbik7XG4gIH07XG4gIEFuaW1hdGlvbkl0ZW0ucHJvdG90eXBlLmdldFBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aDtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0QXNzZXRzUGF0aCA9IGZ1bmN0aW9uIChhc3NldERhdGEpIHtcbiAgICB2YXIgcGF0aCA9ICcnO1xuICAgIGlmIChhc3NldERhdGEuZSkge1xuICAgICAgcGF0aCA9IGFzc2V0RGF0YS5wO1xuICAgIH0gZWxzZSBpZiAodGhpcy5hc3NldHNQYXRoKSB7XG4gICAgICB2YXIgaW1hZ2VQYXRoID0gYXNzZXREYXRhLnA7XG4gICAgICBpZiAoaW1hZ2VQYXRoLmluZGV4T2YoJ2ltYWdlcy8nKSAhPT0gLTEpIHtcbiAgICAgICAgaW1hZ2VQYXRoID0gaW1hZ2VQYXRoLnNwbGl0KCcvJylbMV07XG4gICAgICB9XG4gICAgICBwYXRoID0gdGhpcy5hc3NldHNQYXRoICsgaW1hZ2VQYXRoO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXRoID0gdGhpcy5wYXRoO1xuICAgICAgcGF0aCArPSBhc3NldERhdGEudSA/IGFzc2V0RGF0YS51IDogJyc7XG4gICAgICBwYXRoICs9IGFzc2V0RGF0YS5wO1xuICAgIH1cbiAgICByZXR1cm4gcGF0aDtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0QXNzZXREYXRhID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLmFzc2V0cy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmIChpZCA9PT0gdGhpcy5hc3NldHNbaV0uaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXNzZXRzW2ldO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLmhpZGUoKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlbmRlcmVyLnNob3coKTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoaXNGcmFtZSkge1xuICAgIHJldHVybiBpc0ZyYW1lID8gdGhpcy50b3RhbEZyYW1lcyA6IHRoaXMudG90YWxGcmFtZXMgLyB0aGlzLmZyYW1lUmF0ZTtcbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnREYXRhID0gZnVuY3Rpb24gKHBhdGgsIGRvY3VtZW50RGF0YSwgaW5kZXgpIHtcbiAgICB0cnkge1xuICAgICAgdmFyIGVsZW1lbnQgPSB0aGlzLnJlbmRlcmVyLmdldEVsZW1lbnRCeVBhdGgocGF0aCk7XG4gICAgICBlbGVtZW50LnVwZGF0ZURvY3VtZW50RGF0YShkb2N1bWVudERhdGEsIGluZGV4KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgLy8gVE9ETzogZGVjaWRlIGhvdyB0byBoYW5kbGUgY2F0Y2ggY2FzZVxuICAgIH1cbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudHJpZ2dlciA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKHRoaXMuX2NicyAmJiB0aGlzLl9jYnNbbmFtZV0pIHtcbiAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICBjYXNlICdlbnRlckZyYW1lJzpcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLCBuZXcgQk1FbnRlckZyYW1lRXZlbnQobmFtZSwgdGhpcy5jdXJyZW50RnJhbWUsIHRoaXMudG90YWxGcmFtZXMsIHRoaXMuZnJhbWVNb2RpZmllcikpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkcmF3bkZyYW1lJzpcbiAgICAgICAgICB0aGlzLmRyYXduRnJhbWVFdmVudC5jdXJyZW50VGltZSA9IHRoaXMuY3VycmVudEZyYW1lO1xuICAgICAgICAgIHRoaXMuZHJhd25GcmFtZUV2ZW50LnRvdGFsVGltZSA9IHRoaXMudG90YWxGcmFtZXM7XG4gICAgICAgICAgdGhpcy5kcmF3bkZyYW1lRXZlbnQuZGlyZWN0aW9uID0gdGhpcy5mcmFtZU1vZGlmaWVyO1xuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIHRoaXMuZHJhd25GcmFtZUV2ZW50KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbG9vcENvbXBsZXRlJzpcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLCBuZXcgQk1Db21wbGV0ZUxvb3BFdmVudChuYW1lLCB0aGlzLmxvb3AsIHRoaXMucGxheUNvdW50LCB0aGlzLmZyYW1lTXVsdCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjb21wbGV0ZSc6XG4gICAgICAgICAgdGhpcy50cmlnZ2VyRXZlbnQobmFtZSwgbmV3IEJNQ29tcGxldGVFdmVudChuYW1lLCB0aGlzLmZyYW1lTXVsdCkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzZWdtZW50U3RhcnQnOlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUsIG5ldyBCTVNlZ21lbnRTdGFydEV2ZW50KG5hbWUsIHRoaXMuZmlyc3RGcmFtZSwgdGhpcy50b3RhbEZyYW1lcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdkZXN0cm95JzpcbiAgICAgICAgICB0aGlzLnRyaWdnZXJFdmVudChuYW1lLCBuZXcgQk1EZXN0cm95RXZlbnQobmFtZSwgdGhpcykpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRoaXMudHJpZ2dlckV2ZW50KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2VudGVyRnJhbWUnICYmIHRoaXMub25FbnRlckZyYW1lKSB7XG4gICAgICB0aGlzLm9uRW50ZXJGcmFtZS5jYWxsKHRoaXMsIG5ldyBCTUVudGVyRnJhbWVFdmVudChuYW1lLCB0aGlzLmN1cnJlbnRGcmFtZSwgdGhpcy50b3RhbEZyYW1lcywgdGhpcy5mcmFtZU11bHQpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdsb29wQ29tcGxldGUnICYmIHRoaXMub25Mb29wQ29tcGxldGUpIHtcbiAgICAgIHRoaXMub25Mb29wQ29tcGxldGUuY2FsbCh0aGlzLCBuZXcgQk1Db21wbGV0ZUxvb3BFdmVudChuYW1lLCB0aGlzLmxvb3AsIHRoaXMucGxheUNvdW50LCB0aGlzLmZyYW1lTXVsdCkpO1xuICAgIH1cbiAgICBpZiAobmFtZSA9PT0gJ2NvbXBsZXRlJyAmJiB0aGlzLm9uQ29tcGxldGUpIHtcbiAgICAgIHRoaXMub25Db21wbGV0ZS5jYWxsKHRoaXMsIG5ldyBCTUNvbXBsZXRlRXZlbnQobmFtZSwgdGhpcy5mcmFtZU11bHQpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdzZWdtZW50U3RhcnQnICYmIHRoaXMub25TZWdtZW50U3RhcnQpIHtcbiAgICAgIHRoaXMub25TZWdtZW50U3RhcnQuY2FsbCh0aGlzLCBuZXcgQk1TZWdtZW50U3RhcnRFdmVudChuYW1lLCB0aGlzLmZpcnN0RnJhbWUsIHRoaXMudG90YWxGcmFtZXMpKTtcbiAgICB9XG4gICAgaWYgKG5hbWUgPT09ICdkZXN0cm95JyAmJiB0aGlzLm9uRGVzdHJveSkge1xuICAgICAgdGhpcy5vbkRlc3Ryb3kuY2FsbCh0aGlzLCBuZXcgQk1EZXN0cm95RXZlbnQobmFtZSwgdGhpcykpO1xuICAgIH1cbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudHJpZ2dlclJlbmRlckZyYW1lRXJyb3IgPSBmdW5jdGlvbiAobmF0aXZlRXJyb3IpIHtcbiAgICB2YXIgZXJyb3IgPSBuZXcgQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQobmF0aXZlRXJyb3IsIHRoaXMuY3VycmVudEZyYW1lKTtcbiAgICB0aGlzLnRyaWdnZXJFdmVudCgnZXJyb3InLCBlcnJvcik7XG4gICAgaWYgKHRoaXMub25FcnJvcikge1xuICAgICAgdGhpcy5vbkVycm9yLmNhbGwodGhpcywgZXJyb3IpO1xuICAgIH1cbiAgfTtcbiAgQW5pbWF0aW9uSXRlbS5wcm90b3R5cGUudHJpZ2dlckNvbmZpZ0Vycm9yID0gZnVuY3Rpb24gKG5hdGl2ZUVycm9yKSB7XG4gICAgdmFyIGVycm9yID0gbmV3IEJNQ29uZmlnRXJyb3JFdmVudChuYXRpdmVFcnJvciwgdGhpcy5jdXJyZW50RnJhbWUpO1xuICAgIHRoaXMudHJpZ2dlckV2ZW50KCdlcnJvcicsIGVycm9yKTtcbiAgICBpZiAodGhpcy5vbkVycm9yKSB7XG4gICAgICB0aGlzLm9uRXJyb3IuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9O1xuXG4gIHZhciBhbmltYXRpb25NYW5hZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBtb2R1bGVPYiA9IHt9O1xuICAgIHZhciByZWdpc3RlcmVkQW5pbWF0aW9ucyA9IFtdO1xuICAgIHZhciBpbml0VGltZSA9IDA7XG4gICAgdmFyIGxlbiA9IDA7XG4gICAgdmFyIHBsYXlpbmdBbmltYXRpb25zTnVtID0gMDtcbiAgICB2YXIgX3N0b3BwZWQgPSB0cnVlO1xuICAgIHZhciBfaXNGcm96ZW4gPSBmYWxzZTtcbiAgICBmdW5jdGlvbiByZW1vdmVFbGVtZW50KGV2KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgYW5pbUl0ZW0gPSBldi50YXJnZXQ7XG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uID09PSBhbmltSXRlbSkge1xuICAgICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zLnNwbGljZShpLCAxKTtcbiAgICAgICAgICBpIC09IDE7XG4gICAgICAgICAgbGVuIC09IDE7XG4gICAgICAgICAgaWYgKCFhbmltSXRlbS5pc1BhdXNlZCkge1xuICAgICAgICAgICAgc3VidHJhY3RQbGF5aW5nQ291bnQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiByZWdpc3RlckFuaW1hdGlvbihlbGVtZW50LCBhbmltYXRpb25EYXRhKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uZWxlbSA9PT0gZWxlbWVudCAmJiByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5lbGVtICE9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpICs9IDE7XG4gICAgICB9XG4gICAgICB2YXIgYW5pbUl0ZW0gPSBuZXcgQW5pbWF0aW9uSXRlbSgpO1xuICAgICAgc2V0dXBBbmltYXRpb24oYW5pbUl0ZW0sIGVsZW1lbnQpO1xuICAgICAgYW5pbUl0ZW0uc2V0RGF0YShlbGVtZW50LCBhbmltYXRpb25EYXRhKTtcbiAgICAgIHJldHVybiBhbmltSXRlbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnMoKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW5BbmltcyA9IHJlZ2lzdGVyZWRBbmltYXRpb25zLmxlbmd0aDtcbiAgICAgIHZhciBhbmltYXRpb25zID0gW107XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuQW5pbXM7IGkgKz0gMSkge1xuICAgICAgICBhbmltYXRpb25zLnB1c2gocmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhbmltYXRpb25zO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRQbGF5aW5nQ291bnQoKSB7XG4gICAgICBwbGF5aW5nQW5pbWF0aW9uc051bSArPSAxO1xuICAgICAgYWN0aXZhdGUoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3VidHJhY3RQbGF5aW5nQ291bnQoKSB7XG4gICAgICBwbGF5aW5nQW5pbWF0aW9uc051bSAtPSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXR1cEFuaW1hdGlvbihhbmltSXRlbSwgZWxlbWVudCkge1xuICAgICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignZGVzdHJveScsIHJlbW92ZUVsZW1lbnQpO1xuICAgICAgYW5pbUl0ZW0uYWRkRXZlbnRMaXN0ZW5lcignX2FjdGl2ZScsIGFkZFBsYXlpbmdDb3VudCk7XG4gICAgICBhbmltSXRlbS5hZGRFdmVudExpc3RlbmVyKCdfaWRsZScsIHN1YnRyYWN0UGxheWluZ0NvdW50KTtcbiAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zLnB1c2goe1xuICAgICAgICBlbGVtOiBlbGVtZW50LFxuICAgICAgICBhbmltYXRpb246IGFuaW1JdGVtXG4gICAgICB9KTtcbiAgICAgIGxlbiArPSAxO1xuICAgIH1cbiAgICBmdW5jdGlvbiBsb2FkQW5pbWF0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGFuaW1JdGVtID0gbmV3IEFuaW1hdGlvbkl0ZW0oKTtcbiAgICAgIHNldHVwQW5pbWF0aW9uKGFuaW1JdGVtLCBudWxsKTtcbiAgICAgIGFuaW1JdGVtLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgICAgcmV0dXJuIGFuaW1JdGVtO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRTcGVlZCh2YWwsIGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldFNwZWVkKHZhbCwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0RGlyZWN0aW9uKHZhbCwgYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uc2V0RGlyZWN0aW9uKHZhbCwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcGxheShhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5wbGF5KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlc3VtZShub3dUaW1lKSB7XG4gICAgICB2YXIgZWxhcHNlZFRpbWUgPSBub3dUaW1lIC0gaW5pdFRpbWU7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24uYWR2YW5jZVRpbWUoZWxhcHNlZFRpbWUpO1xuICAgICAgfVxuICAgICAgaW5pdFRpbWUgPSBub3dUaW1lO1xuICAgICAgaWYgKHBsYXlpbmdBbmltYXRpb25zTnVtICYmICFfaXNGcm96ZW4pIHtcbiAgICAgICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZShyZXN1bWUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3N0b3BwZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmaXJzdChub3dUaW1lKSB7XG4gICAgICBpbml0VGltZSA9IG5vd1RpbWU7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKHJlc3VtZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnBhdXNlKGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdvVG9BbmRTdG9wKHZhbHVlLCBpc0ZyYW1lLCBhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5nb1RvQW5kU3RvcCh2YWx1ZSwgaXNGcmFtZSwgYW5pbWF0aW9uKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcChhbmltYXRpb24pIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5zdG9wKGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvZ2dsZVBhdXNlKGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnRvZ2dsZVBhdXNlKGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlc3Ryb3koYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIHJlZ2lzdGVyZWRBbmltYXRpb25zW2ldLmFuaW1hdGlvbi5kZXN0cm95KGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNlYXJjaEFuaW1hdGlvbnMoYW5pbWF0aW9uRGF0YSwgc3RhbmRhbG9uZSwgcmVuZGVyZXIpIHtcbiAgICAgIHZhciBhbmltRWxlbWVudHMgPSBbXS5jb25jYXQoW10uc2xpY2UuY2FsbChkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsb3R0aWUnKSksIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnYm9keW1vdmluJykpKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbkFuaW1zID0gYW5pbUVsZW1lbnRzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5BbmltczsgaSArPSAxKSB7XG4gICAgICAgIGlmIChyZW5kZXJlcikge1xuICAgICAgICAgIGFuaW1FbGVtZW50c1tpXS5zZXRBdHRyaWJ1dGUoJ2RhdGEtYm0tdHlwZScsIHJlbmRlcmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZWdpc3RlckFuaW1hdGlvbihhbmltRWxlbWVudHNbaV0sIGFuaW1hdGlvbkRhdGEpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YW5kYWxvbmUgJiYgbGVuQW5pbXMgPT09IDApIHtcbiAgICAgICAgaWYgKCFyZW5kZXJlcikge1xuICAgICAgICAgIHJlbmRlcmVyID0gJ3N2Zyc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJvZHkgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgICBib2R5LmlubmVyVGV4dCA9ICcnO1xuICAgICAgICB2YXIgZGl2ID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICAgICAgZGl2LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgICBkaXYuc3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgICBkaXYuc2V0QXR0cmlidXRlKCdkYXRhLWJtLXR5cGUnLCByZW5kZXJlcik7XG4gICAgICAgIGJvZHkuYXBwZW5kQ2hpbGQoZGl2KTtcbiAgICAgICAgcmVnaXN0ZXJBbmltYXRpb24oZGl2LCBhbmltYXRpb25EYXRhKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzaXplKCkge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnJlc2l6ZSgpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhY3RpdmF0ZSgpIHtcbiAgICAgIGlmICghX2lzRnJvemVuICYmIHBsYXlpbmdBbmltYXRpb25zTnVtKSB7XG4gICAgICAgIGlmIChfc3RvcHBlZCkge1xuICAgICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZmlyc3QpO1xuICAgICAgICAgIF9zdG9wcGVkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZnJlZXplKCkge1xuICAgICAgX2lzRnJvemVuID0gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdW5mcmVlemUoKSB7XG4gICAgICBfaXNGcm96ZW4gPSBmYWxzZTtcbiAgICAgIGFjdGl2YXRlKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbikge1xuICAgICAgdmFyIGk7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgcmVnaXN0ZXJlZEFuaW1hdGlvbnNbaV0uYW5pbWF0aW9uLnNldFZvbHVtZSh2YWwsIGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11dGUoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24ubXV0ZShhbmltYXRpb24pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiB1bm11dGUoYW5pbWF0aW9uKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICByZWdpc3RlcmVkQW5pbWF0aW9uc1tpXS5hbmltYXRpb24udW5tdXRlKGFuaW1hdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIG1vZHVsZU9iLnJlZ2lzdGVyQW5pbWF0aW9uID0gcmVnaXN0ZXJBbmltYXRpb247XG4gICAgbW9kdWxlT2IubG9hZEFuaW1hdGlvbiA9IGxvYWRBbmltYXRpb247XG4gICAgbW9kdWxlT2Iuc2V0U3BlZWQgPSBzZXRTcGVlZDtcbiAgICBtb2R1bGVPYi5zZXREaXJlY3Rpb24gPSBzZXREaXJlY3Rpb247XG4gICAgbW9kdWxlT2IucGxheSA9IHBsYXk7XG4gICAgbW9kdWxlT2IucGF1c2UgPSBwYXVzZTtcbiAgICBtb2R1bGVPYi5zdG9wID0gc3RvcDtcbiAgICBtb2R1bGVPYi50b2dnbGVQYXVzZSA9IHRvZ2dsZVBhdXNlO1xuICAgIG1vZHVsZU9iLnNlYXJjaEFuaW1hdGlvbnMgPSBzZWFyY2hBbmltYXRpb25zO1xuICAgIG1vZHVsZU9iLnJlc2l6ZSA9IHJlc2l6ZTtcbiAgICAvLyBtb2R1bGVPYi5zdGFydCA9IHN0YXJ0O1xuICAgIG1vZHVsZU9iLmdvVG9BbmRTdG9wID0gZ29Ub0FuZFN0b3A7XG4gICAgbW9kdWxlT2IuZGVzdHJveSA9IGRlc3Ryb3k7XG4gICAgbW9kdWxlT2IuZnJlZXplID0gZnJlZXplO1xuICAgIG1vZHVsZU9iLnVuZnJlZXplID0gdW5mcmVlemU7XG4gICAgbW9kdWxlT2Iuc2V0Vm9sdW1lID0gc2V0Vm9sdW1lO1xuICAgIG1vZHVsZU9iLm11dGUgPSBtdXRlO1xuICAgIG1vZHVsZU9iLnVubXV0ZSA9IHVubXV0ZTtcbiAgICBtb2R1bGVPYi5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyA9IGdldFJlZ2lzdGVyZWRBbmltYXRpb25zO1xuICAgIHJldHVybiBtb2R1bGVPYjtcbiAgfSgpO1xuXG4gIC8qIGVzbGludC1kaXNhYmxlICovXG4gIHZhciBCZXppZXJGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIC8qKlxuICAgICAgICogQmV6aWVyRWFzaW5nIC0gdXNlIGJlemllciBjdXJ2ZSBmb3IgdHJhbnNpdGlvbiBlYXNpbmcgZnVuY3Rpb25cbiAgICAgICAqIGJ5IEdhw6t0YW4gUmVuYXVkZWF1IDIwMTQgLSAyMDE1IOKAkyBNSVQgTGljZW5zZVxuICAgICAgICpcbiAgICAgICAqIENyZWRpdHM6IGlzIGJhc2VkIG9uIEZpcmVmb3gncyBuc1NNSUxLZXlTcGxpbmUuY3BwXG4gICAgICAgKiBVc2FnZTpcbiAgICAgICAqIHZhciBzcGxpbmUgPSBCZXppZXJFYXNpbmcoWyAwLjI1LCAwLjEsIDAuMjUsIDEuMCBdKVxuICAgICAgICogc3BsaW5lLmdldCh4KSA9PiByZXR1cm5zIHRoZSBlYXNpbmcgdmFsdWUgfCB4IG11c3QgYmUgaW4gWzAsIDFdIHJhbmdlXG4gICAgICAgKlxuICAgICAgICovXG5cbiAgICB2YXIgb2IgPSB7fTtcbiAgICBvYi5nZXRCZXppZXJFYXNpbmcgPSBnZXRCZXppZXJFYXNpbmc7XG4gICAgdmFyIGJlemllcnMgPSB7fTtcbiAgICBmdW5jdGlvbiBnZXRCZXppZXJFYXNpbmcoYSwgYiwgYywgZCwgbm0pIHtcbiAgICAgIHZhciBzdHIgPSBubSB8fCAoJ2Jlel8nICsgYSArICdfJyArIGIgKyAnXycgKyBjICsgJ18nICsgZCkucmVwbGFjZSgvXFwuL2csICdwJyk7XG4gICAgICBpZiAoYmV6aWVyc1tzdHJdKSB7XG4gICAgICAgIHJldHVybiBiZXppZXJzW3N0cl07XG4gICAgICB9XG4gICAgICB2YXIgYmV6RWFzaW5nID0gbmV3IEJlemllckVhc2luZyhbYSwgYiwgYywgZF0pO1xuICAgICAgYmV6aWVyc1tzdHJdID0gYmV6RWFzaW5nO1xuICAgICAgcmV0dXJuIGJlekVhc2luZztcbiAgICB9XG5cbiAgICAvLyBUaGVzZSB2YWx1ZXMgYXJlIGVzdGFibGlzaGVkIGJ5IGVtcGlyaWNpc20gd2l0aCB0ZXN0cyAodHJhZGVvZmY6IHBlcmZvcm1hbmNlIFZTIHByZWNpc2lvbilcbiAgICB2YXIgTkVXVE9OX0lURVJBVElPTlMgPSA0O1xuICAgIHZhciBORVdUT05fTUlOX1NMT1BFID0gMC4wMDE7XG4gICAgdmFyIFNVQkRJVklTSU9OX1BSRUNJU0lPTiA9IDAuMDAwMDAwMTtcbiAgICB2YXIgU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMgPSAxMDtcbiAgICB2YXIga1NwbGluZVRhYmxlU2l6ZSA9IDExO1xuICAgIHZhciBrU2FtcGxlU3RlcFNpemUgPSAxLjAgLyAoa1NwbGluZVRhYmxlU2l6ZSAtIDEuMCk7XG4gICAgdmFyIGZsb2F0MzJBcnJheVN1cHBvcnRlZCA9IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICdmdW5jdGlvbic7XG4gICAgZnVuY3Rpb24gQShhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDEuMCAtIDMuMCAqIGFBMiArIDMuMCAqIGFBMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQihhQTEsIGFBMikge1xuICAgICAgcmV0dXJuIDMuMCAqIGFBMiAtIDYuMCAqIGFBMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gQyhhQTEpIHtcbiAgICAgIHJldHVybiAzLjAgKiBhQTE7XG4gICAgfVxuXG4gICAgLy8gUmV0dXJucyB4KHQpIGdpdmVuIHQsIHgxLCBhbmQgeDIsIG9yIHkodCkgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbiAgICBmdW5jdGlvbiBjYWxjQmV6aWVyKGFULCBhQTEsIGFBMikge1xuICAgICAgcmV0dXJuICgoQShhQTEsIGFBMikgKiBhVCArIEIoYUExLCBhQTIpKSAqIGFUICsgQyhhQTEpKSAqIGFUO1xuICAgIH1cblxuICAgIC8vIFJldHVybnMgZHgvZHQgZ2l2ZW4gdCwgeDEsIGFuZCB4Miwgb3IgZHkvZHQgZ2l2ZW4gdCwgeTEsIGFuZCB5Mi5cbiAgICBmdW5jdGlvbiBnZXRTbG9wZShhVCwgYUExLCBhQTIpIHtcbiAgICAgIHJldHVybiAzLjAgKiBBKGFBMSwgYUEyKSAqIGFUICogYVQgKyAyLjAgKiBCKGFBMSwgYUEyKSAqIGFUICsgQyhhQTEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBiaW5hcnlTdWJkaXZpZGUoYVgsIGFBLCBhQiwgbVgxLCBtWDIpIHtcbiAgICAgIHZhciBjdXJyZW50WCxcbiAgICAgICAgY3VycmVudFQsXG4gICAgICAgIGkgPSAwO1xuICAgICAgZG8ge1xuICAgICAgICBjdXJyZW50VCA9IGFBICsgKGFCIC0gYUEpIC8gMi4wO1xuICAgICAgICBjdXJyZW50WCA9IGNhbGNCZXppZXIoY3VycmVudFQsIG1YMSwgbVgyKSAtIGFYO1xuICAgICAgICBpZiAoY3VycmVudFggPiAwLjApIHtcbiAgICAgICAgICBhQiA9IGN1cnJlbnRUO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFBID0gY3VycmVudFQ7XG4gICAgICAgIH1cbiAgICAgIH0gd2hpbGUgKE1hdGguYWJzKGN1cnJlbnRYKSA+IFNVQkRJVklTSU9OX1BSRUNJU0lPTiAmJiArK2kgPCBTVUJESVZJU0lPTl9NQVhfSVRFUkFUSU9OUyk7XG4gICAgICByZXR1cm4gY3VycmVudFQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG5ld3RvblJhcGhzb25JdGVyYXRlKGFYLCBhR3Vlc3NULCBtWDEsIG1YMikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBORVdUT05fSVRFUkFUSU9OUzsgKytpKSB7XG4gICAgICAgIHZhciBjdXJyZW50U2xvcGUgPSBnZXRTbG9wZShhR3Vlc3NULCBtWDEsIG1YMik7XG4gICAgICAgIGlmIChjdXJyZW50U2xvcGUgPT09IDAuMCkgcmV0dXJuIGFHdWVzc1Q7XG4gICAgICAgIHZhciBjdXJyZW50WCA9IGNhbGNCZXppZXIoYUd1ZXNzVCwgbVgxLCBtWDIpIC0gYVg7XG4gICAgICAgIGFHdWVzc1QgLT0gY3VycmVudFggLyBjdXJyZW50U2xvcGU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYUd1ZXNzVDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgICAqIHBvaW50cyBpcyBhbiBhcnJheSBvZiBbIG1YMSwgbVkxLCBtWDIsIG1ZMiBdXG4gICAgICAgKi9cbiAgICBmdW5jdGlvbiBCZXppZXJFYXNpbmcocG9pbnRzKSB7XG4gICAgICB0aGlzLl9wID0gcG9pbnRzO1xuICAgICAgdGhpcy5fbVNhbXBsZVZhbHVlcyA9IGZsb2F0MzJBcnJheVN1cHBvcnRlZCA/IG5ldyBGbG9hdDMyQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSkgOiBuZXcgQXJyYXkoa1NwbGluZVRhYmxlU2l6ZSk7XG4gICAgICB0aGlzLl9wcmVjb21wdXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5nZXQgPSB0aGlzLmdldC5iaW5kKHRoaXMpO1xuICAgIH1cbiAgICBCZXppZXJFYXNpbmcucHJvdG90eXBlID0ge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoeCkge1xuICAgICAgICB2YXIgbVgxID0gdGhpcy5fcFswXSxcbiAgICAgICAgICBtWTEgPSB0aGlzLl9wWzFdLFxuICAgICAgICAgIG1YMiA9IHRoaXMuX3BbMl0sXG4gICAgICAgICAgbVkyID0gdGhpcy5fcFszXTtcbiAgICAgICAgaWYgKCF0aGlzLl9wcmVjb21wdXRlZCkgdGhpcy5fcHJlY29tcHV0ZSgpO1xuICAgICAgICBpZiAobVgxID09PSBtWTEgJiYgbVgyID09PSBtWTIpIHJldHVybiB4OyAvLyBsaW5lYXJcbiAgICAgICAgLy8gQmVjYXVzZSBKYXZhU2NyaXB0IG51bWJlciBhcmUgaW1wcmVjaXNlLCB3ZSBzaG91bGQgZ3VhcmFudGVlIHRoZSBleHRyZW1lcyBhcmUgcmlnaHQuXG4gICAgICAgIGlmICh4ID09PSAwKSByZXR1cm4gMDtcbiAgICAgICAgaWYgKHggPT09IDEpIHJldHVybiAxO1xuICAgICAgICByZXR1cm4gY2FsY0Jlemllcih0aGlzLl9nZXRURm9yWCh4KSwgbVkxLCBtWTIpO1xuICAgICAgfSxcbiAgICAgIC8vIFByaXZhdGUgcGFydFxuXG4gICAgICBfcHJlY29tcHV0ZTogZnVuY3Rpb24gX3ByZWNvbXB1dGUoKSB7XG4gICAgICAgIHZhciBtWDEgPSB0aGlzLl9wWzBdLFxuICAgICAgICAgIG1ZMSA9IHRoaXMuX3BbMV0sXG4gICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcbiAgICAgICAgICBtWTIgPSB0aGlzLl9wWzNdO1xuICAgICAgICB0aGlzLl9wcmVjb21wdXRlZCA9IHRydWU7XG4gICAgICAgIGlmIChtWDEgIT09IG1ZMSB8fCBtWDIgIT09IG1ZMikge1xuICAgICAgICAgIHRoaXMuX2NhbGNTYW1wbGVWYWx1ZXMoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIF9jYWxjU2FtcGxlVmFsdWVzOiBmdW5jdGlvbiBfY2FsY1NhbXBsZVZhbHVlcygpIHtcbiAgICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXG4gICAgICAgICAgbVgyID0gdGhpcy5fcFsyXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrU3BsaW5lVGFibGVTaXplOyArK2kpIHtcbiAgICAgICAgICB0aGlzLl9tU2FtcGxlVmFsdWVzW2ldID0gY2FsY0JlemllcihpICoga1NhbXBsZVN0ZXBTaXplLCBtWDEsIG1YMik7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvKipcbiAgICAgICAgICAgKiBnZXRURm9yWCBjaG9zZSB0aGUgZmFzdGVzdCBoZXVyaXN0aWMgdG8gZGV0ZXJtaW5lIHRoZSBwZXJjZW50YWdlIHZhbHVlIHByZWNpc2VseSBmcm9tIGEgZ2l2ZW4gWCBwcm9qZWN0aW9uLlxuICAgICAgICAgICAqL1xuICAgICAgX2dldFRGb3JYOiBmdW5jdGlvbiBfZ2V0VEZvclgoYVgpIHtcbiAgICAgICAgdmFyIG1YMSA9IHRoaXMuX3BbMF0sXG4gICAgICAgICAgbVgyID0gdGhpcy5fcFsyXSxcbiAgICAgICAgICBtU2FtcGxlVmFsdWVzID0gdGhpcy5fbVNhbXBsZVZhbHVlcztcbiAgICAgICAgdmFyIGludGVydmFsU3RhcnQgPSAwLjA7XG4gICAgICAgIHZhciBjdXJyZW50U2FtcGxlID0gMTtcbiAgICAgICAgdmFyIGxhc3RTYW1wbGUgPSBrU3BsaW5lVGFibGVTaXplIC0gMTtcbiAgICAgICAgZm9yICg7IGN1cnJlbnRTYW1wbGUgIT09IGxhc3RTYW1wbGUgJiYgbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSA8PSBhWDsgKytjdXJyZW50U2FtcGxlKSB7XG4gICAgICAgICAgaW50ZXJ2YWxTdGFydCArPSBrU2FtcGxlU3RlcFNpemU7XG4gICAgICAgIH1cbiAgICAgICAgLS1jdXJyZW50U2FtcGxlO1xuXG4gICAgICAgIC8vIEludGVycG9sYXRlIHRvIHByb3ZpZGUgYW4gaW5pdGlhbCBndWVzcyBmb3IgdFxuICAgICAgICB2YXIgZGlzdCA9IChhWCAtIG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZV0pIC8gKG1TYW1wbGVWYWx1ZXNbY3VycmVudFNhbXBsZSArIDFdIC0gbVNhbXBsZVZhbHVlc1tjdXJyZW50U2FtcGxlXSk7XG4gICAgICAgIHZhciBndWVzc0ZvclQgPSBpbnRlcnZhbFN0YXJ0ICsgZGlzdCAqIGtTYW1wbGVTdGVwU2l6ZTtcbiAgICAgICAgdmFyIGluaXRpYWxTbG9wZSA9IGdldFNsb3BlKGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICBpZiAoaW5pdGlhbFNsb3BlID49IE5FV1RPTl9NSU5fU0xPUEUpIHtcbiAgICAgICAgICByZXR1cm4gbmV3dG9uUmFwaHNvbkl0ZXJhdGUoYVgsIGd1ZXNzRm9yVCwgbVgxLCBtWDIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbml0aWFsU2xvcGUgPT09IDAuMCkge1xuICAgICAgICAgIHJldHVybiBndWVzc0ZvclQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJpbmFyeVN1YmRpdmlkZShhWCwgaW50ZXJ2YWxTdGFydCwgaW50ZXJ2YWxTdGFydCArIGtTYW1wbGVTdGVwU2l6ZSwgbVgxLCBtWDIpO1xuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIHBvb2xpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gX2RvdWJsZShhcnIpIHtcbiAgICAgIHJldHVybiBhcnIuY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkoYXJyLmxlbmd0aCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgXCJkb3VibGVcIjogX2RvdWJsZVxuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcG9vbEZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbml0aWFsTGVuZ3RoLCBfY3JlYXRlLCBfcmVsZWFzZSkge1xuICAgICAgdmFyIF9sZW5ndGggPSAwO1xuICAgICAgdmFyIF9tYXhMZW5ndGggPSBpbml0aWFsTGVuZ3RoO1xuICAgICAgdmFyIHBvb2wgPSBjcmVhdGVTaXplZEFycmF5KF9tYXhMZW5ndGgpO1xuICAgICAgdmFyIG9iID0ge1xuICAgICAgICBuZXdFbGVtZW50OiBuZXdFbGVtZW50LFxuICAgICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgICB9O1xuICAgICAgZnVuY3Rpb24gbmV3RWxlbWVudCgpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQ7XG4gICAgICAgIGlmIChfbGVuZ3RoKSB7XG4gICAgICAgICAgX2xlbmd0aCAtPSAxO1xuICAgICAgICAgIGVsZW1lbnQgPSBwb29sW19sZW5ndGhdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVsZW1lbnQgPSBfY3JlYXRlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWxlYXNlKGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKF9sZW5ndGggPT09IF9tYXhMZW5ndGgpIHtcbiAgICAgICAgICBwb29sID0gcG9vbGluZ1tcImRvdWJsZVwiXShwb29sKTtcbiAgICAgICAgICBfbWF4TGVuZ3RoICo9IDI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9yZWxlYXNlKSB7XG4gICAgICAgICAgX3JlbGVhc2UoZWxlbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgcG9vbFtfbGVuZ3RoXSA9IGVsZW1lbnQ7XG4gICAgICAgIF9sZW5ndGggKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGJlemllckxlbmd0aFBvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gY3JlYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYWRkZWRMZW5ndGg6IDAsXG4gICAgICAgIHBlcmNlbnRzOiBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZ2V0RGVmYXVsdEN1cnZlU2VnbWVudHMoKSksXG4gICAgICAgIGxlbmd0aHM6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpKVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHBvb2xGYWN0b3J5KDgsIGNyZWF0ZSk7XG4gIH0oKTtcblxuICB2YXIgc2VnbWVudHNMZW5ndGhQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGxlbmd0aHM6IFtdLFxuICAgICAgICB0b3RhbExlbmd0aDogMFxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZShlbGVtZW50KSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBlbGVtZW50Lmxlbmd0aHMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGJlemllckxlbmd0aFBvb2wucmVsZWFzZShlbGVtZW50Lmxlbmd0aHNbaV0pO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5sZW5ndGhzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBwb29sRmFjdG9yeSg4LCBjcmVhdGUsIHJlbGVhc2UpO1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gYmV6RnVuY3Rpb24oKSB7XG4gICAgdmFyIG1hdGggPSBNYXRoO1xuICAgIGZ1bmN0aW9uIHBvaW50T25MaW5lMkQoeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgICAgdmFyIGRldDEgPSB4MSAqIHkyICsgeTEgKiB4MyArIHgyICogeTMgLSB4MyAqIHkyIC0geTMgKiB4MSAtIHgyICogeTE7XG4gICAgICByZXR1cm4gZGV0MSA+IC0wLjAwMSAmJiBkZXQxIDwgMC4wMDE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvaW50T25MaW5lM0QoeDEsIHkxLCB6MSwgeDIsIHkyLCB6MiwgeDMsIHkzLCB6Mykge1xuICAgICAgaWYgKHoxID09PSAwICYmIHoyID09PSAwICYmIHozID09PSAwKSB7XG4gICAgICAgIHJldHVybiBwb2ludE9uTGluZTJEKHgxLCB5MSwgeDIsIHkyLCB4MywgeTMpO1xuICAgICAgfVxuICAgICAgdmFyIGRpc3QxID0gbWF0aC5zcXJ0KG1hdGgucG93KHgyIC0geDEsIDIpICsgbWF0aC5wb3coeTIgLSB5MSwgMikgKyBtYXRoLnBvdyh6MiAtIHoxLCAyKSk7XG4gICAgICB2YXIgZGlzdDIgPSBtYXRoLnNxcnQobWF0aC5wb3coeDMgLSB4MSwgMikgKyBtYXRoLnBvdyh5MyAtIHkxLCAyKSArIG1hdGgucG93KHozIC0gejEsIDIpKTtcbiAgICAgIHZhciBkaXN0MyA9IG1hdGguc3FydChtYXRoLnBvdyh4MyAtIHgyLCAyKSArIG1hdGgucG93KHkzIC0geTIsIDIpICsgbWF0aC5wb3coejMgLSB6MiwgMikpO1xuICAgICAgdmFyIGRpZmZEaXN0O1xuICAgICAgaWYgKGRpc3QxID4gZGlzdDIpIHtcbiAgICAgICAgaWYgKGRpc3QxID4gZGlzdDMpIHtcbiAgICAgICAgICBkaWZmRGlzdCA9IGRpc3QxIC0gZGlzdDIgLSBkaXN0MztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkaWZmRGlzdCA9IGRpc3QzIC0gZGlzdDIgLSBkaXN0MTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChkaXN0MyA+IGRpc3QyKSB7XG4gICAgICAgIGRpZmZEaXN0ID0gZGlzdDMgLSBkaXN0MiAtIGRpc3QxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGlmZkRpc3QgPSBkaXN0MiAtIGRpc3QxIC0gZGlzdDM7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGlmZkRpc3QgPiAtMC4wMDAxICYmIGRpZmZEaXN0IDwgMC4wMDAxO1xuICAgIH1cbiAgICB2YXIgZ2V0QmV6aWVyTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcbiAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICB2YXIgaztcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciBwdENvb3JkO1xuICAgICAgICB2YXIgcGVyYztcbiAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0RGlzdGFuY2U7XG4gICAgICAgIHZhciBwb2ludCA9IFtdO1xuICAgICAgICB2YXIgbGFzdFBvaW50ID0gW107XG4gICAgICAgIHZhciBsZW5ndGhEYXRhID0gYmV6aWVyTGVuZ3RoUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XG4gICAgICAgIGZvciAoayA9IDA7IGsgPCBjdXJ2ZVNlZ21lbnRzOyBrICs9IDEpIHtcbiAgICAgICAgICBwZXJjID0gayAvIChjdXJ2ZVNlZ21lbnRzIC0gMSk7XG4gICAgICAgICAgcHREaXN0YW5jZSA9IDA7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBwdENvb3JkID0gYm1Qb3coMSAtIHBlcmMsIDMpICogcHQxW2ldICsgMyAqIGJtUG93KDEgLSBwZXJjLCAyKSAqIHBlcmMgKiBwdDNbaV0gKyAzICogKDEgLSBwZXJjKSAqIGJtUG93KHBlcmMsIDIpICogcHQ0W2ldICsgYm1Qb3cocGVyYywgMykgKiBwdDJbaV07XG4gICAgICAgICAgICBwb2ludFtpXSA9IHB0Q29vcmQ7XG4gICAgICAgICAgICBpZiAobGFzdFBvaW50W2ldICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHB0RGlzdGFuY2UgKz0gYm1Qb3cocG9pbnRbaV0gLSBsYXN0UG9pbnRbaV0sIDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGFzdFBvaW50W2ldID0gcG9pbnRbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChwdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBwdERpc3RhbmNlID0gYm1TcXJ0KHB0RGlzdGFuY2UpO1xuICAgICAgICAgICAgYWRkZWRMZW5ndGggKz0gcHREaXN0YW5jZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuZ3RoRGF0YS5wZXJjZW50c1trXSA9IHBlcmM7XG4gICAgICAgICAgbGVuZ3RoRGF0YS5sZW5ndGhzW2tdID0gYWRkZWRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgbGVuZ3RoRGF0YS5hZGRlZExlbmd0aCA9IGFkZGVkTGVuZ3RoO1xuICAgICAgICByZXR1cm4gbGVuZ3RoRGF0YTtcbiAgICAgIH07XG4gICAgfSgpO1xuICAgIGZ1bmN0aW9uIGdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlRGF0YSkge1xuICAgICAgdmFyIHNlZ21lbnRzTGVuZ3RoID0gc2VnbWVudHNMZW5ndGhQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHZhciBjbG9zZWQgPSBzaGFwZURhdGEuYztcbiAgICAgIHZhciBwYXRoViA9IHNoYXBlRGF0YS52O1xuICAgICAgdmFyIHBhdGhPID0gc2hhcGVEYXRhLm87XG4gICAgICB2YXIgcGF0aEkgPSBzaGFwZURhdGEuaTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHNoYXBlRGF0YS5fbGVuZ3RoO1xuICAgICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xuICAgICAgdmFyIHRvdGFsTGVuZ3RoID0gMDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW4gLSAxOyBpICs9IDEpIHtcbiAgICAgICAgbGVuZ3Roc1tpXSA9IGdldEJlemllckxlbmd0aChwYXRoVltpXSwgcGF0aFZbaSArIDFdLCBwYXRoT1tpXSwgcGF0aElbaSArIDFdKTtcbiAgICAgICAgdG90YWxMZW5ndGggKz0gbGVuZ3Roc1tpXS5hZGRlZExlbmd0aDtcbiAgICAgIH1cbiAgICAgIGlmIChjbG9zZWQgJiYgbGVuKSB7XG4gICAgICAgIGxlbmd0aHNbaV0gPSBnZXRCZXppZXJMZW5ndGgocGF0aFZbaV0sIHBhdGhWWzBdLCBwYXRoT1tpXSwgcGF0aElbMF0pO1xuICAgICAgICB0b3RhbExlbmd0aCArPSBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xuICAgICAgfVxuICAgICAgc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggPSB0b3RhbExlbmd0aDtcbiAgICAgIHJldHVybiBzZWdtZW50c0xlbmd0aDtcbiAgICB9XG4gICAgZnVuY3Rpb24gQmV6aWVyRGF0YShsZW5ndGgpIHtcbiAgICAgIHRoaXMuc2VnbWVudExlbmd0aCA9IDA7XG4gICAgICB0aGlzLnBvaW50cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBQb2ludERhdGEocGFydGlhbCwgcG9pbnQpIHtcbiAgICAgIHRoaXMucGFydGlhbExlbmd0aCA9IHBhcnRpYWw7XG4gICAgICB0aGlzLnBvaW50ID0gcG9pbnQ7XG4gICAgfVxuICAgIHZhciBidWlsZEJlemllckRhdGEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2YXIgc3RvcmVkRGF0YSA9IHt9O1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIChwdDEsIHB0MiwgcHQzLCBwdDQpIHtcbiAgICAgICAgdmFyIGJlemllck5hbWUgPSAocHQxWzBdICsgJ18nICsgcHQxWzFdICsgJ18nICsgcHQyWzBdICsgJ18nICsgcHQyWzFdICsgJ18nICsgcHQzWzBdICsgJ18nICsgcHQzWzFdICsgJ18nICsgcHQ0WzBdICsgJ18nICsgcHQ0WzFdKS5yZXBsYWNlKC9cXC4vZywgJ3AnKTtcbiAgICAgICAgaWYgKCFzdG9yZWREYXRhW2Jlemllck5hbWVdKSB7XG4gICAgICAgICAgdmFyIGN1cnZlU2VnbWVudHMgPSBnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpO1xuICAgICAgICAgIHZhciBrO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBsZW47XG4gICAgICAgICAgdmFyIHB0Q29vcmQ7XG4gICAgICAgICAgdmFyIHBlcmM7XG4gICAgICAgICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICAgICAgICB2YXIgcHREaXN0YW5jZTtcbiAgICAgICAgICB2YXIgcG9pbnQ7XG4gICAgICAgICAgdmFyIGxhc3RQb2ludCA9IG51bGw7XG4gICAgICAgICAgaWYgKHB0MS5sZW5ndGggPT09IDIgJiYgKHB0MVswXSAhPT0gcHQyWzBdIHx8IHB0MVsxXSAhPT0gcHQyWzFdKSAmJiBwb2ludE9uTGluZTJEKHB0MVswXSwgcHQxWzFdLCBwdDJbMF0sIHB0MlsxXSwgcHQxWzBdICsgcHQzWzBdLCBwdDFbMV0gKyBwdDNbMV0pICYmIHBvaW50T25MaW5lMkQocHQxWzBdLCBwdDFbMV0sIHB0MlswXSwgcHQyWzFdLCBwdDJbMF0gKyBwdDRbMF0sIHB0MlsxXSArIHB0NFsxXSkpIHtcbiAgICAgICAgICAgIGN1cnZlU2VnbWVudHMgPSAyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgYmV6aWVyRGF0YSA9IG5ldyBCZXppZXJEYXRhKGN1cnZlU2VnbWVudHMpO1xuICAgICAgICAgIGxlbiA9IHB0My5sZW5ndGg7XG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGN1cnZlU2VnbWVudHM7IGsgKz0gMSkge1xuICAgICAgICAgICAgcG9pbnQgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgICAgICAgICBwZXJjID0gayAvIChjdXJ2ZVNlZ21lbnRzIC0gMSk7XG4gICAgICAgICAgICBwdERpc3RhbmNlID0gMDtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICBwdENvb3JkID0gYm1Qb3coMSAtIHBlcmMsIDMpICogcHQxW2ldICsgMyAqIGJtUG93KDEgLSBwZXJjLCAyKSAqIHBlcmMgKiAocHQxW2ldICsgcHQzW2ldKSArIDMgKiAoMSAtIHBlcmMpICogYm1Qb3cocGVyYywgMikgKiAocHQyW2ldICsgcHQ0W2ldKSArIGJtUG93KHBlcmMsIDMpICogcHQyW2ldO1xuICAgICAgICAgICAgICBwb2ludFtpXSA9IHB0Q29vcmQ7XG4gICAgICAgICAgICAgIGlmIChsYXN0UG9pbnQgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwdERpc3RhbmNlICs9IGJtUG93KHBvaW50W2ldIC0gbGFzdFBvaW50W2ldLCAyKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHREaXN0YW5jZSA9IGJtU3FydChwdERpc3RhbmNlKTtcbiAgICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IHB0RGlzdGFuY2U7XG4gICAgICAgICAgICBiZXppZXJEYXRhLnBvaW50c1trXSA9IG5ldyBQb2ludERhdGEocHREaXN0YW5jZSwgcG9pbnQpO1xuICAgICAgICAgICAgbGFzdFBvaW50ID0gcG9pbnQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJlemllckRhdGEuc2VnbWVudExlbmd0aCA9IGFkZGVkTGVuZ3RoO1xuICAgICAgICAgIHN0b3JlZERhdGFbYmV6aWVyTmFtZV0gPSBiZXppZXJEYXRhO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzdG9yZWREYXRhW2Jlemllck5hbWVdO1xuICAgICAgfTtcbiAgICB9KCk7XG4gICAgZnVuY3Rpb24gZ2V0RGlzdGFuY2VQZXJjKHBlcmMsIGJlemllckRhdGEpIHtcbiAgICAgIHZhciBwZXJjZW50cyA9IGJlemllckRhdGEucGVyY2VudHM7XG4gICAgICB2YXIgbGVuZ3RocyA9IGJlemllckRhdGEubGVuZ3RocztcbiAgICAgIHZhciBsZW4gPSBwZXJjZW50cy5sZW5ndGg7XG4gICAgICB2YXIgaW5pdFBvcyA9IGJtRmxvb3IoKGxlbiAtIDEpICogcGVyYyk7XG4gICAgICB2YXIgbGVuZ3RoUG9zID0gcGVyYyAqIGJlemllckRhdGEuYWRkZWRMZW5ndGg7XG4gICAgICB2YXIgbFBlcmMgPSAwO1xuICAgICAgaWYgKGluaXRQb3MgPT09IGxlbiAtIDEgfHwgaW5pdFBvcyA9PT0gMCB8fCBsZW5ndGhQb3MgPT09IGxlbmd0aHNbaW5pdFBvc10pIHtcbiAgICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdO1xuICAgICAgfVxuICAgICAgdmFyIGRpciA9IGxlbmd0aHNbaW5pdFBvc10gPiBsZW5ndGhQb3MgPyAtMSA6IDE7XG4gICAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICBpZiAobGVuZ3Roc1tpbml0UG9zXSA8PSBsZW5ndGhQb3MgJiYgbGVuZ3Roc1tpbml0UG9zICsgMV0gPiBsZW5ndGhQb3MpIHtcbiAgICAgICAgICBsUGVyYyA9IChsZW5ndGhQb3MgLSBsZW5ndGhzW2luaXRQb3NdKSAvIChsZW5ndGhzW2luaXRQb3MgKyAxXSAtIGxlbmd0aHNbaW5pdFBvc10pO1xuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpbml0UG9zICs9IGRpcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW5pdFBvcyA8IDAgfHwgaW5pdFBvcyA+PSBsZW4gLSAxKSB7XG4gICAgICAgICAgLy8gRklYIGZvciBUeXBlZEFycmF5cyB0aGF0IGRvbid0IHN0b3JlIGZsb2F0aW5nIHBvaW50IHZhbHVlcyB3aXRoIGVub3VnaCBhY2N1cmFjeVxuICAgICAgICAgIGlmIChpbml0UG9zID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gcGVyY2VudHNbaW5pdFBvc107XG4gICAgICAgICAgfVxuICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHBlcmNlbnRzW2luaXRQb3NdICsgKHBlcmNlbnRzW2luaXRQb3MgKyAxXSAtIHBlcmNlbnRzW2luaXRQb3NdKSAqIGxQZXJjO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRQb2ludEluU2VnbWVudChwdDEsIHB0MiwgcHQzLCBwdDQsIHBlcmNlbnQsIGJlemllckRhdGEpIHtcbiAgICAgIHZhciB0MSA9IGdldERpc3RhbmNlUGVyYyhwZXJjZW50LCBiZXppZXJEYXRhKTtcbiAgICAgIHZhciB1MSA9IDEgLSB0MTtcbiAgICAgIHZhciBwdFggPSBtYXRoLnJvdW5kKCh1MSAqIHUxICogdTEgKiBwdDFbMF0gKyAodDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxKSAqIHB0M1swXSArICh0MSAqIHQxICogdTEgKyB1MSAqIHQxICogdDEgKyB0MSAqIHUxICogdDEpICogcHQ0WzBdICsgdDEgKiB0MSAqIHQxICogcHQyWzBdKSAqIDEwMDApIC8gMTAwMDtcbiAgICAgIHZhciBwdFkgPSBtYXRoLnJvdW5kKCh1MSAqIHUxICogdTEgKiBwdDFbMV0gKyAodDEgKiB1MSAqIHUxICsgdTEgKiB0MSAqIHUxICsgdTEgKiB1MSAqIHQxKSAqIHB0M1sxXSArICh0MSAqIHQxICogdTEgKyB1MSAqIHQxICogdDEgKyB0MSAqIHUxICogdDEpICogcHQ0WzFdICsgdDEgKiB0MSAqIHQxICogcHQyWzFdKSAqIDEwMDApIC8gMTAwMDtcbiAgICAgIHJldHVybiBbcHRYLCBwdFldO1xuICAgIH1cbiAgICB2YXIgYmV6aWVyU2VnbWVudFBvaW50cyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCA4KTtcbiAgICBmdW5jdGlvbiBnZXROZXdTZWdtZW50KHB0MSwgcHQyLCBwdDMsIHB0NCwgc3RhcnRQZXJjLCBlbmRQZXJjLCBiZXppZXJEYXRhKSB7XG4gICAgICBpZiAoc3RhcnRQZXJjIDwgMCkge1xuICAgICAgICBzdGFydFBlcmMgPSAwO1xuICAgICAgfSBlbHNlIGlmIChzdGFydFBlcmMgPiAxKSB7XG4gICAgICAgIHN0YXJ0UGVyYyA9IDE7XG4gICAgICB9XG4gICAgICB2YXIgdDAgPSBnZXREaXN0YW5jZVBlcmMoc3RhcnRQZXJjLCBiZXppZXJEYXRhKTtcbiAgICAgIGVuZFBlcmMgPSBlbmRQZXJjID4gMSA/IDEgOiBlbmRQZXJjO1xuICAgICAgdmFyIHQxID0gZ2V0RGlzdGFuY2VQZXJjKGVuZFBlcmMsIGJlemllckRhdGEpO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gcHQxLmxlbmd0aDtcbiAgICAgIHZhciB1MCA9IDEgLSB0MDtcbiAgICAgIHZhciB1MSA9IDEgLSB0MTtcbiAgICAgIHZhciB1MHUwdTAgPSB1MCAqIHUwICogdTA7XG4gICAgICB2YXIgdDB1MHUwXzMgPSB0MCAqIHUwICogdTAgKiAzOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgdmFyIHQwdDB1MF8zID0gdDAgKiB0MCAqIHUwICogMzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIHZhciB0MHQwdDAgPSB0MCAqIHQwICogdDA7XG4gICAgICAvL1xuICAgICAgdmFyIHUwdTB1MSA9IHUwICogdTAgKiB1MTtcbiAgICAgIHZhciB0MHUwdTFfMyA9IHQwICogdTAgKiB1MSArIHUwICogdDAgKiB1MSArIHUwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIHZhciB0MHQwdTFfMyA9IHQwICogdDAgKiB1MSArIHUwICogdDAgKiB0MSArIHQwICogdTAgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIHZhciB0MHQwdDEgPSB0MCAqIHQwICogdDE7XG4gICAgICAvL1xuICAgICAgdmFyIHUwdTF1MSA9IHUwICogdTEgKiB1MTtcbiAgICAgIHZhciB0MHUxdTFfMyA9IHQwICogdTEgKiB1MSArIHUwICogdDEgKiB1MSArIHUwICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIHZhciB0MHQxdTFfMyA9IHQwICogdDEgKiB1MSArIHUwICogdDEgKiB0MSArIHQwICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIHZhciB0MHQxdDEgPSB0MCAqIHQxICogdDE7XG4gICAgICAvL1xuICAgICAgdmFyIHUxdTF1MSA9IHUxICogdTEgKiB1MTtcbiAgICAgIHZhciB0MXUxdTFfMyA9IHQxICogdTEgKiB1MSArIHUxICogdDEgKiB1MSArIHUxICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIHZhciB0MXQxdTFfMyA9IHQxICogdDEgKiB1MSArIHUxICogdDEgKiB0MSArIHQxICogdTEgKiB0MTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIHZhciB0MXQxdDEgPSB0MSAqIHQxICogdDE7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNF0gPSBtYXRoLnJvdW5kKCh1MHUwdTAgKiBwdDFbaV0gKyB0MHUwdTBfMyAqIHB0M1tpXSArIHQwdDB1MF8zICogcHQ0W2ldICsgdDB0MHQwICogcHQyW2ldKSAqIDEwMDApIC8gMTAwMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgYmV6aWVyU2VnbWVudFBvaW50c1tpICogNCArIDFdID0gbWF0aC5yb3VuZCgodTB1MHUxICogcHQxW2ldICsgdDB1MHUxXzMgKiBwdDNbaV0gKyB0MHQwdTFfMyAqIHB0NFtpXSArIHQwdDB0MSAqIHB0MltpXSkgKiAxMDAwKSAvIDEwMDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FtZWxjYXNlXG4gICAgICAgIGJlemllclNlZ21lbnRQb2ludHNbaSAqIDQgKyAyXSA9IG1hdGgucm91bmQoKHUwdTF1MSAqIHB0MVtpXSArIHQwdTF1MV8zICogcHQzW2ldICsgdDB0MXUxXzMgKiBwdDRbaV0gKyB0MHQxdDEgKiBwdDJbaV0pICogMTAwMCkgLyAxMDAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbWVsY2FzZVxuICAgICAgICBiZXppZXJTZWdtZW50UG9pbnRzW2kgKiA0ICsgM10gPSBtYXRoLnJvdW5kKCh1MXUxdTEgKiBwdDFbaV0gKyB0MXUxdTFfMyAqIHB0M1tpXSArIHQxdDF1MV8zICogcHQ0W2ldICsgdDF0MXQxICogcHQyW2ldKSAqIDEwMDApIC8gMTAwMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYW1lbGNhc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiBiZXppZXJTZWdtZW50UG9pbnRzO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0U2VnbWVudHNMZW5ndGg6IGdldFNlZ21lbnRzTGVuZ3RoLFxuICAgICAgZ2V0TmV3U2VnbWVudDogZ2V0TmV3U2VnbWVudCxcbiAgICAgIGdldFBvaW50SW5TZWdtZW50OiBnZXRQb2ludEluU2VnbWVudCxcbiAgICAgIGJ1aWxkQmV6aWVyRGF0YTogYnVpbGRCZXppZXJEYXRhLFxuICAgICAgcG9pbnRPbkxpbmUyRDogcG9pbnRPbkxpbmUyRCxcbiAgICAgIHBvaW50T25MaW5lM0Q6IHBvaW50T25MaW5lM0RcbiAgICB9O1xuICB9XG4gIHZhciBiZXogPSBiZXpGdW5jdGlvbigpO1xuXG4gIHZhciBpbml0RnJhbWUgPSBpbml0aWFsRGVmYXVsdEZyYW1lO1xuICB2YXIgbWF0aEFicyA9IE1hdGguYWJzO1xuICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCBjYWNoaW5nKSB7XG4gICAgdmFyIG9mZnNldFRpbWUgPSB0aGlzLm9mZnNldFRpbWU7XG4gICAgdmFyIG5ld1ZhbHVlO1xuICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAnbXVsdGlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG5ld1ZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHRoaXMucHYubGVuZ3RoKTtcbiAgICB9XG4gICAgdmFyIGl0ZXJhdGlvbkluZGV4ID0gY2FjaGluZy5sYXN0SW5kZXg7XG4gICAgdmFyIGkgPSBpdGVyYXRpb25JbmRleDtcbiAgICB2YXIgbGVuID0gdGhpcy5rZXlmcmFtZXMubGVuZ3RoIC0gMTtcbiAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgdmFyIGtleURhdGE7XG4gICAgdmFyIG5leHRLZXlEYXRhO1xuICAgIHZhciBrZXlmcmFtZU1ldGFkYXRhO1xuICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICBrZXlEYXRhID0gdGhpcy5rZXlmcmFtZXNbaV07XG4gICAgICBuZXh0S2V5RGF0YSA9IHRoaXMua2V5ZnJhbWVzW2kgKyAxXTtcbiAgICAgIGlmIChpID09PSBsZW4gLSAxICYmIGZyYW1lTnVtID49IG5leHRLZXlEYXRhLnQgLSBvZmZzZXRUaW1lKSB7XG4gICAgICAgIGlmIChrZXlEYXRhLmgpIHtcbiAgICAgICAgICBrZXlEYXRhID0gbmV4dEtleURhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChuZXh0S2V5RGF0YS50IC0gb2Zmc2V0VGltZSA+IGZyYW1lTnVtKSB7XG4gICAgICAgIGl0ZXJhdGlvbkluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBpZiAoaSA8IGxlbiAtIDEpIHtcbiAgICAgICAgaSArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xuICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIGtleWZyYW1lTWV0YWRhdGEgPSB0aGlzLmtleWZyYW1lc01ldGFkYXRhW2ldIHx8IHt9O1xuICAgIHZhciBrO1xuICAgIHZhciBrTGVuO1xuICAgIHZhciBwZXJjO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBqO1xuICAgIHZhciBmbmM7XG4gICAgdmFyIG5leHRLZXlUaW1lID0gbmV4dEtleURhdGEudCAtIG9mZnNldFRpbWU7XG4gICAgdmFyIGtleVRpbWUgPSBrZXlEYXRhLnQgLSBvZmZzZXRUaW1lO1xuICAgIHZhciBlbmRWYWx1ZTtcbiAgICBpZiAoa2V5RGF0YS50bykge1xuICAgICAgaWYgKCFrZXlmcmFtZU1ldGFkYXRhLmJlemllckRhdGEpIHtcbiAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShrZXlEYXRhLnMsIG5leHRLZXlEYXRhLnMgfHwga2V5RGF0YS5lLCBrZXlEYXRhLnRvLCBrZXlEYXRhLnRpKTtcbiAgICAgIH1cbiAgICAgIHZhciBiZXppZXJEYXRhID0ga2V5ZnJhbWVNZXRhZGF0YS5iZXppZXJEYXRhO1xuICAgICAgaWYgKGZyYW1lTnVtID49IG5leHRLZXlUaW1lIHx8IGZyYW1lTnVtIDwga2V5VGltZSkge1xuICAgICAgICB2YXIgaW5kID0gZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUgPyBiZXppZXJEYXRhLnBvaW50cy5sZW5ndGggLSAxIDogMDtcbiAgICAgICAga0xlbiA9IGJlemllckRhdGEucG9pbnRzW2luZF0ucG9pbnQubGVuZ3RoO1xuICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgbmV3VmFsdWVba10gPSBiZXppZXJEYXRhLnBvaW50c1tpbmRdLnBvaW50W2tdO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoa2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhrZXlEYXRhLm8ueCwga2V5RGF0YS5vLnksIGtleURhdGEuaS54LCBrZXlEYXRhLmkueSwga2V5RGF0YS5uKS5nZXQ7XG4gICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QgPSBmbmM7XG4gICAgICAgIH1cbiAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSBrZXlUaW1lKSAvIChuZXh0S2V5VGltZSAtIGtleVRpbWUpKTtcbiAgICAgICAgdmFyIGRpc3RhbmNlSW5MaW5lID0gYmV6aWVyRGF0YS5zZWdtZW50TGVuZ3RoICogcGVyYztcbiAgICAgICAgdmFyIHNlZ21lbnRQZXJjO1xuICAgICAgICB2YXIgYWRkZWRMZW5ndGggPSBjYWNoaW5nLmxhc3RGcmFtZSA8IGZyYW1lTnVtICYmIGNhY2hpbmcuX2xhc3RLZXlmcmFtZUluZGV4ID09PSBpID8gY2FjaGluZy5fbGFzdEFkZGVkTGVuZ3RoIDogMDtcbiAgICAgICAgaiA9IGNhY2hpbmcubGFzdEZyYW1lIDwgZnJhbWVOdW0gJiYgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPT09IGkgPyBjYWNoaW5nLl9sYXN0UG9pbnQgOiAwO1xuICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgakxlbiA9IGJlemllckRhdGEucG9pbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgIGlmIChkaXN0YW5jZUluTGluZSA9PT0gMCB8fCBwZXJjID09PSAwIHx8IGogPT09IGJlemllckRhdGEucG9pbnRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2UgaWYgKGRpc3RhbmNlSW5MaW5lID49IGFkZGVkTGVuZ3RoICYmIGRpc3RhbmNlSW5MaW5lIDwgYWRkZWRMZW5ndGggKyBiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucGFydGlhbExlbmd0aCkge1xuICAgICAgICAgICAgc2VnbWVudFBlcmMgPSAoZGlzdGFuY2VJbkxpbmUgLSBhZGRlZExlbmd0aCkgLyBiZXppZXJEYXRhLnBvaW50c1tqICsgMV0ucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgIGtMZW4gPSBiZXppZXJEYXRhLnBvaW50c1tqXS5wb2ludC5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwga0xlbjsgayArPSAxKSB7XG4gICAgICAgICAgICAgIG5ld1ZhbHVlW2tdID0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10gKyAoYmV6aWVyRGF0YS5wb2ludHNbaiArIDFdLnBvaW50W2tdIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucG9pbnRba10pICogc2VnbWVudFBlcmM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGogPCBqTGVuIC0gMSkge1xuICAgICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhY2hpbmcuX2xhc3RQb2ludCA9IGo7XG4gICAgICAgIGNhY2hpbmcuX2xhc3RBZGRlZExlbmd0aCA9IGFkZGVkTGVuZ3RoIC0gYmV6aWVyRGF0YS5wb2ludHNbal0ucGFydGlhbExlbmd0aDtcbiAgICAgICAgY2FjaGluZy5fbGFzdEtleWZyYW1lSW5kZXggPSBpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb3V0WDtcbiAgICAgIHZhciBvdXRZO1xuICAgICAgdmFyIGluWDtcbiAgICAgIHZhciBpblk7XG4gICAgICB2YXIga2V5VmFsdWU7XG4gICAgICBsZW4gPSBrZXlEYXRhLnMubGVuZ3RoO1xuICAgICAgZW5kVmFsdWUgPSBuZXh0S2V5RGF0YS5zIHx8IGtleURhdGEuZTtcbiAgICAgIGlmICh0aGlzLnNoICYmIGtleURhdGEuaCAhPT0gMSkge1xuICAgICAgICBpZiAoZnJhbWVOdW0gPj0gbmV4dEtleVRpbWUpIHtcbiAgICAgICAgICBuZXdWYWx1ZVswXSA9IGVuZFZhbHVlWzBdO1xuICAgICAgICAgIG5ld1ZhbHVlWzFdID0gZW5kVmFsdWVbMV07XG4gICAgICAgICAgbmV3VmFsdWVbMl0gPSBlbmRWYWx1ZVsyXTtcbiAgICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA8PSBrZXlUaW1lKSB7XG4gICAgICAgICAgbmV3VmFsdWVbMF0gPSBrZXlEYXRhLnNbMF07XG4gICAgICAgICAgbmV3VmFsdWVbMV0gPSBrZXlEYXRhLnNbMV07XG4gICAgICAgICAgbmV3VmFsdWVbMl0gPSBrZXlEYXRhLnNbMl07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIHF1YXRTdGFydCA9IGNyZWF0ZVF1YXRlcm5pb24oa2V5RGF0YS5zKTtcbiAgICAgICAgICB2YXIgcXVhdEVuZCA9IGNyZWF0ZVF1YXRlcm5pb24oZW5kVmFsdWUpO1xuICAgICAgICAgIHZhciB0aW1lID0gKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKTtcbiAgICAgICAgICBxdWF0ZXJuaW9uVG9FdWxlcihuZXdWYWx1ZSwgc2xlcnAocXVhdFN0YXJ0LCBxdWF0RW5kLCB0aW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIGlmIChrZXlEYXRhLmggIT09IDEpIHtcbiAgICAgICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5VGltZSkge1xuICAgICAgICAgICAgICBwZXJjID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZnJhbWVOdW0gPCBrZXlUaW1lKSB7XG4gICAgICAgICAgICAgIHBlcmMgPSAwO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGtleURhdGEuby54LmNvbnN0cnVjdG9yID09PSBBcnJheSkge1xuICAgICAgICAgICAgICAgIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICAgICAgICAgIGtleWZyYW1lTWV0YWRhdGEuX19mbmN0ID0gW107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3RbaV0pIHtcbiAgICAgICAgICAgICAgICAgIG91dFggPSBrZXlEYXRhLm8ueFtpXSA9PT0gdW5kZWZpbmVkID8ga2V5RGF0YS5vLnhbMF0gOiBrZXlEYXRhLm8ueFtpXTtcbiAgICAgICAgICAgICAgICAgIG91dFkgPSBrZXlEYXRhLm8ueVtpXSA9PT0gdW5kZWZpbmVkID8ga2V5RGF0YS5vLnlbMF0gOiBrZXlEYXRhLm8ueVtpXTtcbiAgICAgICAgICAgICAgICAgIGluWCA9IGtleURhdGEuaS54W2ldID09PSB1bmRlZmluZWQgPyBrZXlEYXRhLmkueFswXSA6IGtleURhdGEuaS54W2ldO1xuICAgICAgICAgICAgICAgICAgaW5ZID0ga2V5RGF0YS5pLnlbaV0gPT09IHVuZGVmaW5lZCA/IGtleURhdGEuaS55WzBdIDoga2V5RGF0YS5pLnlbaV07XG4gICAgICAgICAgICAgICAgICBmbmMgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyhvdXRYLCBvdXRZLCBpblgsIGluWSkuZ2V0O1xuICAgICAgICAgICAgICAgICAga2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3RbaV0gPSBmbmM7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0W2ldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmICgha2V5ZnJhbWVNZXRhZGF0YS5fX2ZuY3QpIHtcbiAgICAgICAgICAgICAgICBvdXRYID0ga2V5RGF0YS5vLng7XG4gICAgICAgICAgICAgICAgb3V0WSA9IGtleURhdGEuby55O1xuICAgICAgICAgICAgICAgIGluWCA9IGtleURhdGEuaS54O1xuICAgICAgICAgICAgICAgIGluWSA9IGtleURhdGEuaS55O1xuICAgICAgICAgICAgICAgIGZuYyA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKG91dFgsIG91dFksIGluWCwgaW5ZKS5nZXQ7XG4gICAgICAgICAgICAgICAga2V5RGF0YS5rZXlmcmFtZU1ldGFkYXRhID0gZm5jO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZuYyA9IGtleWZyYW1lTWV0YWRhdGEuX19mbmN0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHBlcmMgPSBmbmMoKGZyYW1lTnVtIC0ga2V5VGltZSkgLyAobmV4dEtleVRpbWUgLSBrZXlUaW1lKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGVuZFZhbHVlID0gbmV4dEtleURhdGEucyB8fCBrZXlEYXRhLmU7XG4gICAgICAgICAga2V5VmFsdWUgPSBrZXlEYXRhLmggPT09IDEgPyBrZXlEYXRhLnNbaV0gOiBrZXlEYXRhLnNbaV0gKyAoZW5kVmFsdWVbaV0gLSBrZXlEYXRhLnNbaV0pICogcGVyYztcbiAgICAgICAgICBpZiAodGhpcy5wcm9wVHlwZSA9PT0gJ211bHRpZGltZW5zaW9uYWwnKSB7XG4gICAgICAgICAgICBuZXdWYWx1ZVtpXSA9IGtleVZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGtleVZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjYWNoaW5nLmxhc3RJbmRleCA9IGl0ZXJhdGlvbkluZGV4O1xuICAgIHJldHVybiBuZXdWYWx1ZTtcbiAgfVxuXG4gIC8vIGJhc2VkIG9uIEBUb2ppJ3MgaHR0cHM6Ly9naXRodWIuY29tL3RvamkvZ2wtbWF0cml4L1xuICBmdW5jdGlvbiBzbGVycChhLCBiLCB0KSB7XG4gICAgdmFyIG91dCA9IFtdO1xuICAgIHZhciBheCA9IGFbMF07XG4gICAgdmFyIGF5ID0gYVsxXTtcbiAgICB2YXIgYXogPSBhWzJdO1xuICAgIHZhciBhdyA9IGFbM107XG4gICAgdmFyIGJ4ID0gYlswXTtcbiAgICB2YXIgYnkgPSBiWzFdO1xuICAgIHZhciBieiA9IGJbMl07XG4gICAgdmFyIGJ3ID0gYlszXTtcbiAgICB2YXIgb21lZ2E7XG4gICAgdmFyIGNvc29tO1xuICAgIHZhciBzaW5vbTtcbiAgICB2YXIgc2NhbGUwO1xuICAgIHZhciBzY2FsZTE7XG4gICAgY29zb20gPSBheCAqIGJ4ICsgYXkgKiBieSArIGF6ICogYnogKyBhdyAqIGJ3O1xuICAgIGlmIChjb3NvbSA8IDAuMCkge1xuICAgICAgY29zb20gPSAtY29zb207XG4gICAgICBieCA9IC1ieDtcbiAgICAgIGJ5ID0gLWJ5O1xuICAgICAgYnogPSAtYno7XG4gICAgICBidyA9IC1idztcbiAgICB9XG4gICAgaWYgKDEuMCAtIGNvc29tID4gMC4wMDAwMDEpIHtcbiAgICAgIG9tZWdhID0gTWF0aC5hY29zKGNvc29tKTtcbiAgICAgIHNpbm9tID0gTWF0aC5zaW4ob21lZ2EpO1xuICAgICAgc2NhbGUwID0gTWF0aC5zaW4oKDEuMCAtIHQpICogb21lZ2EpIC8gc2lub207XG4gICAgICBzY2FsZTEgPSBNYXRoLnNpbih0ICogb21lZ2EpIC8gc2lub207XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlMCA9IDEuMCAtIHQ7XG4gICAgICBzY2FsZTEgPSB0O1xuICAgIH1cbiAgICBvdXRbMF0gPSBzY2FsZTAgKiBheCArIHNjYWxlMSAqIGJ4O1xuICAgIG91dFsxXSA9IHNjYWxlMCAqIGF5ICsgc2NhbGUxICogYnk7XG4gICAgb3V0WzJdID0gc2NhbGUwICogYXogKyBzY2FsZTEgKiBiejtcbiAgICBvdXRbM10gPSBzY2FsZTAgKiBhdyArIHNjYWxlMSAqIGJ3O1xuICAgIHJldHVybiBvdXQ7XG4gIH1cbiAgZnVuY3Rpb24gcXVhdGVybmlvblRvRXVsZXIob3V0LCBxdWF0KSB7XG4gICAgdmFyIHF4ID0gcXVhdFswXTtcbiAgICB2YXIgcXkgPSBxdWF0WzFdO1xuICAgIHZhciBxeiA9IHF1YXRbMl07XG4gICAgdmFyIHF3ID0gcXVhdFszXTtcbiAgICB2YXIgaGVhZGluZyA9IE1hdGguYXRhbjIoMiAqIHF5ICogcXcgLSAyICogcXggKiBxeiwgMSAtIDIgKiBxeSAqIHF5IC0gMiAqIHF6ICogcXopO1xuICAgIHZhciBhdHRpdHVkZSA9IE1hdGguYXNpbigyICogcXggKiBxeSArIDIgKiBxeiAqIHF3KTtcbiAgICB2YXIgYmFuayA9IE1hdGguYXRhbjIoMiAqIHF4ICogcXcgLSAyICogcXkgKiBxeiwgMSAtIDIgKiBxeCAqIHF4IC0gMiAqIHF6ICogcXopO1xuICAgIG91dFswXSA9IGhlYWRpbmcgLyBkZWdUb1JhZHM7XG4gICAgb3V0WzFdID0gYXR0aXR1ZGUgLyBkZWdUb1JhZHM7XG4gICAgb3V0WzJdID0gYmFuayAvIGRlZ1RvUmFkcztcbiAgfVxuICBmdW5jdGlvbiBjcmVhdGVRdWF0ZXJuaW9uKHZhbHVlcykge1xuICAgIHZhciBoZWFkaW5nID0gdmFsdWVzWzBdICogZGVnVG9SYWRzO1xuICAgIHZhciBhdHRpdHVkZSA9IHZhbHVlc1sxXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYmFuayA9IHZhbHVlc1syXSAqIGRlZ1RvUmFkcztcbiAgICB2YXIgYzEgPSBNYXRoLmNvcyhoZWFkaW5nIC8gMik7XG4gICAgdmFyIGMyID0gTWF0aC5jb3MoYXR0aXR1ZGUgLyAyKTtcbiAgICB2YXIgYzMgPSBNYXRoLmNvcyhiYW5rIC8gMik7XG4gICAgdmFyIHMxID0gTWF0aC5zaW4oaGVhZGluZyAvIDIpO1xuICAgIHZhciBzMiA9IE1hdGguc2luKGF0dGl0dWRlIC8gMik7XG4gICAgdmFyIHMzID0gTWF0aC5zaW4oYmFuayAvIDIpO1xuICAgIHZhciB3ID0gYzEgKiBjMiAqIGMzIC0gczEgKiBzMiAqIHMzO1xuICAgIHZhciB4ID0gczEgKiBzMiAqIGMzICsgYzEgKiBjMiAqIHMzO1xuICAgIHZhciB5ID0gczEgKiBjMiAqIGMzICsgYzEgKiBzMiAqIHMzO1xuICAgIHZhciB6ID0gYzEgKiBzMiAqIGMzIC0gczEgKiBjMiAqIHMzO1xuICAgIHJldHVybiBbeCwgeSwgeiwgd107XG4gIH1cbiAgZnVuY3Rpb24gZ2V0VmFsdWVBdEN1cnJlbnRUaW1lKCkge1xuICAgIHZhciBmcmFtZU51bSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgIHZhciBpbml0VGltZSA9IHRoaXMua2V5ZnJhbWVzWzBdLnQgLSB0aGlzLm9mZnNldFRpbWU7XG4gICAgdmFyIGVuZFRpbWUgPSB0aGlzLmtleWZyYW1lc1t0aGlzLmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgIGlmICghKGZyYW1lTnVtID09PSB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSB8fCB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSAhPT0gaW5pdEZyYW1lICYmICh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA+PSBlbmRUaW1lICYmIGZyYW1lTnVtID49IGVuZFRpbWUgfHwgdGhpcy5fY2FjaGluZy5sYXN0RnJhbWUgPCBpbml0VGltZSAmJiBmcmFtZU51bSA8IGluaXRUaW1lKSkpIHtcbiAgICAgIGlmICh0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZSA+PSBmcmFtZU51bSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nLl9sYXN0S2V5ZnJhbWVJbmRleCA9IC0xO1xuICAgICAgICB0aGlzLl9jYWNoaW5nLmxhc3RJbmRleCA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgcmVuZGVyUmVzdWx0ID0gdGhpcy5pbnRlcnBvbGF0ZVZhbHVlKGZyYW1lTnVtLCB0aGlzLl9jYWNoaW5nKTtcbiAgICAgIHRoaXMucHYgPSByZW5kZXJSZXN1bHQ7XG4gICAgfVxuICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XG4gICAgcmV0dXJuIHRoaXMucHY7XG4gIH1cbiAgZnVuY3Rpb24gc2V0VlZhbHVlKHZhbCkge1xuICAgIHZhciBtdWx0aXBsaWVkVmFsdWU7XG4gICAgaWYgKHRoaXMucHJvcFR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcpIHtcbiAgICAgIG11bHRpcGxpZWRWYWx1ZSA9IHZhbCAqIHRoaXMubXVsdDtcbiAgICAgIGlmIChtYXRoQWJzKHRoaXMudiAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XG4gICAgICAgIHRoaXMudiA9IG11bHRpcGxpZWRWYWx1ZTtcbiAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMudi5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBtdWx0aXBsaWVkVmFsdWUgPSB2YWxbaV0gKiB0aGlzLm11bHQ7XG4gICAgICAgIGlmIChtYXRoQWJzKHRoaXMudltpXSAtIG11bHRpcGxpZWRWYWx1ZSkgPiAwLjAwMDAxKSB7XG4gICAgICAgICAgdGhpcy52W2ldID0gbXVsdGlwbGllZFZhbHVlO1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlKCkge1xuICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgfHwgIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5sb2NrKSB7XG4gICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2NrID0gdHJ1ZTtcbiAgICB0aGlzLl9tZGYgPSB0aGlzLl9pc0ZpcnN0RnJhbWU7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgICB2YXIgZmluYWxWYWx1ZSA9IHRoaXMua2YgPyB0aGlzLnB2IDogdGhpcy5kYXRhLms7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuc2V0VlZhbHVlKGZpbmFsVmFsdWUpO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gIH1cbiAgZnVuY3Rpb24gYWRkRWZmZWN0KGVmZmVjdEZ1bmN0aW9uKSB7XG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UucHVzaChlZmZlY3RGdW5jdGlvbik7XG4gICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICB9XG4gIGZ1bmN0aW9uIFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wcm9wVHlwZSA9ICd1bmlkaW1lbnNpb25hbCc7XG4gICAgdGhpcy5tdWx0ID0gbXVsdCB8fCAxO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgdGhpcy52ID0gbXVsdCA/IGRhdGEuayAqIG11bHQgOiBkYXRhLms7XG4gICAgdGhpcy5wdiA9IGRhdGEuaztcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgdGhpcy52ZWwgPSAwO1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcbiAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcbiAgfVxuICBmdW5jdGlvbiBNdWx0aURpbWVuc2lvbmFsUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wcm9wVHlwZSA9ICdtdWx0aWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLm11bHQgPSBtdWx0IHx8IDE7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGRhdGEuay5sZW5ndGg7XG4gICAgdGhpcy52ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgIHRoaXMudmVsID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLnZbaV0gPSBkYXRhLmtbaV0gKiB0aGlzLm11bHQ7XG4gICAgICB0aGlzLnB2W2ldID0gZGF0YS5rW2ldO1xuICAgIH1cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgdGhpcy5zZXRWVmFsdWUgPSBzZXRWVmFsdWU7XG4gICAgdGhpcy5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gIH1cbiAgZnVuY3Rpb24gS2V5ZnJhbWVkVmFsdWVQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcbiAgICB0aGlzLnByb3BUeXBlID0gJ3VuaWRpbWVuc2lvbmFsJztcbiAgICB0aGlzLmtleWZyYW1lcyA9IGRhdGEuaztcbiAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgdGhpcy5vZmZzZXRUaW1lID0gZWxlbS5kYXRhLnN0O1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuX2NhY2hpbmcgPSB7XG4gICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgIHZhbHVlOiAwLFxuICAgICAgX2xhc3RLZXlmcmFtZUluZGV4OiAtMVxuICAgIH07XG4gICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB0aGlzLmtmID0gdHJ1ZTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLnYgPSBpbml0RnJhbWU7XG4gICAgdGhpcy5wdiA9IGluaXRGcmFtZTtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIHRoaXMuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIHRoaXMuaW50ZXJwb2xhdGVWYWx1ZSA9IGludGVycG9sYXRlVmFsdWU7XG4gICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbZ2V0VmFsdWVBdEN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIHRoaXMuYWRkRWZmZWN0ID0gYWRkRWZmZWN0O1xuICB9XG4gIGZ1bmN0aW9uIEtleWZyYW1lZE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eShlbGVtLCBkYXRhLCBtdWx0LCBjb250YWluZXIpIHtcbiAgICB0aGlzLnByb3BUeXBlID0gJ211bHRpZGltZW5zaW9uYWwnO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBkYXRhLmsubGVuZ3RoO1xuICAgIHZhciBzO1xuICAgIHZhciBlO1xuICAgIHZhciB0bztcbiAgICB2YXIgdGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbiAtIDE7IGkgKz0gMSkge1xuICAgICAgaWYgKGRhdGEua1tpXS50byAmJiBkYXRhLmtbaV0ucyAmJiBkYXRhLmtbaSArIDFdICYmIGRhdGEua1tpICsgMV0ucykge1xuICAgICAgICBzID0gZGF0YS5rW2ldLnM7XG4gICAgICAgIGUgPSBkYXRhLmtbaSArIDFdLnM7XG4gICAgICAgIHRvID0gZGF0YS5rW2ldLnRvO1xuICAgICAgICB0aSA9IGRhdGEua1tpXS50aTtcbiAgICAgICAgaWYgKHMubGVuZ3RoID09PSAyICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdKSAmJiBiZXoucG9pbnRPbkxpbmUyRChzWzBdLCBzWzFdLCBlWzBdLCBlWzFdLCBzWzBdICsgdG9bMF0sIHNbMV0gKyB0b1sxXSkgJiYgYmV6LnBvaW50T25MaW5lMkQoc1swXSwgc1sxXSwgZVswXSwgZVsxXSwgZVswXSArIHRpWzBdLCBlWzFdICsgdGlbMV0pIHx8IHMubGVuZ3RoID09PSAzICYmICEoc1swXSA9PT0gZVswXSAmJiBzWzFdID09PSBlWzFdICYmIHNbMl0gPT09IGVbMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIHNbMF0gKyB0b1swXSwgc1sxXSArIHRvWzFdLCBzWzJdICsgdG9bMl0pICYmIGJlei5wb2ludE9uTGluZTNEKHNbMF0sIHNbMV0sIHNbMl0sIGVbMF0sIGVbMV0sIGVbMl0sIGVbMF0gKyB0aVswXSwgZVsxXSArIHRpWzFdLCBlWzJdICsgdGlbMl0pKSB7XG4gICAgICAgICAgZGF0YS5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgICBkYXRhLmtbaV0udGkgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzWzBdID09PSBlWzBdICYmIHNbMV0gPT09IGVbMV0gJiYgdG9bMF0gPT09IDAgJiYgdG9bMV0gPT09IDAgJiYgdGlbMF0gPT09IDAgJiYgdGlbMV0gPT09IDApIHtcbiAgICAgICAgICBpZiAocy5sZW5ndGggPT09IDIgfHwgc1syXSA9PT0gZVsyXSAmJiB0b1syXSA9PT0gMCAmJiB0aVsyXSA9PT0gMCkge1xuICAgICAgICAgICAgZGF0YS5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgICAgIGRhdGEua1tpXS50aSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW2dldFZhbHVlQXRDdXJyZW50VGltZS5iaW5kKHRoaXMpXTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMua2V5ZnJhbWVzID0gZGF0YS5rO1xuICAgIHRoaXMua2V5ZnJhbWVzTWV0YWRhdGEgPSBbXTtcbiAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgdGhpcy5rID0gdHJ1ZTtcbiAgICB0aGlzLmtmID0gdHJ1ZTtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMubXVsdCA9IG11bHQgfHwgMTtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICB0aGlzLmdldFZhbHVlID0gcHJvY2Vzc0VmZmVjdHNTZXF1ZW5jZTtcbiAgICB0aGlzLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcbiAgICB0aGlzLmludGVycG9sYXRlVmFsdWUgPSBpbnRlcnBvbGF0ZVZhbHVlO1xuICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgIHZhciBhcnJMZW4gPSBkYXRhLmtbMF0ucy5sZW5ndGg7XG4gICAgdGhpcy52ID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGFyckxlbik7XG4gICAgdGhpcy5wdiA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhcnJMZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy52W2ldID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5wdltpXSA9IGluaXRGcmFtZTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGluZyA9IHtcbiAgICAgIGxhc3RGcmFtZTogaW5pdEZyYW1lLFxuICAgICAgbGFzdEluZGV4OiAwLFxuICAgICAgdmFsdWU6IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBhcnJMZW4pXG4gICAgfTtcbiAgICB0aGlzLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcbiAgfVxuICB2YXIgUHJvcGVydHlGYWN0b3J5ID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldFByb3AoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgICBpZiAoZGF0YS5zaWQpIHtcbiAgICAgICAgZGF0YSA9IGVsZW0uZ2xvYmFsRGF0YS5zbG90TWFuYWdlci5nZXRQcm9wKGRhdGEpO1xuICAgICAgfVxuICAgICAgdmFyIHA7XG4gICAgICBpZiAoIWRhdGEuay5sZW5ndGgpIHtcbiAgICAgICAgcCA9IG5ldyBWYWx1ZVByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBkYXRhLmtbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHAgPSBuZXcgTXVsdGlEaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICBwID0gbmV3IEtleWZyYW1lZFZhbHVlUHJvcGVydHkoZWxlbSwgZGF0YSwgbXVsdCwgY29udGFpbmVyKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHAgPSBuZXcgS2V5ZnJhbWVkTXVsdGlkaW1lbnNpb25hbFByb3BlcnR5KGVsZW0sIGRhdGEsIG11bHQsIGNvbnRhaW5lcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChwLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICB2YXIgb2IgPSB7XG4gICAgICBnZXRQcm9wOiBnZXRQcm9wXG4gICAgfTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBEeW5hbWljUHJvcGVydHlDb250YWluZXIoKSB7fVxuICBEeW5hbWljUHJvcGVydHlDb250YWluZXIucHJvdG90eXBlID0ge1xuICAgIGFkZER5bmFtaWNQcm9wZXJ0eTogZnVuY3Rpb24gYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApIHtcbiAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmluZGV4T2YocHJvcCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMucHVzaChwcm9wKTtcbiAgICAgICAgdGhpcy5jb250YWluZXIuYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICAgICAgICB0aGlzLl9pc0FuaW1hdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGl0ZXJhdGVEeW5hbWljUHJvcGVydGllczogZnVuY3Rpb24gaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCkge1xuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLmdldFZhbHVlKCk7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLl9tZGYpIHtcbiAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyOiBmdW5jdGlvbiBpbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHBvaW50UG9vbCA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBjcmVhdGUoKSB7XG4gICAgICByZXR1cm4gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDIpO1xuICAgIH1cbiAgICByZXR1cm4gcG9vbEZhY3RvcnkoOCwgY3JlYXRlKTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIFNoYXBlUGF0aCgpIHtcbiAgICB0aGlzLmMgPSBmYWxzZTtcbiAgICB0aGlzLl9sZW5ndGggPSAwO1xuICAgIHRoaXMuX21heExlbmd0aCA9IDg7XG4gICAgdGhpcy52ID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpO1xuICAgIHRoaXMubyA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcbiAgICB0aGlzLmkgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCk7XG4gIH1cbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRQYXRoRGF0YSA9IGZ1bmN0aW9uIChjbG9zZWQsIGxlbikge1xuICAgIHRoaXMuYyA9IGNsb3NlZDtcbiAgICB0aGlzLnNldExlbmd0aChsZW4pO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgdGhpcy52W2ldID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHRoaXMub1tpXSA9IHBvaW50UG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLmlbaV0gPSBwb2ludFBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRMZW5ndGggPSBmdW5jdGlvbiAobGVuKSB7XG4gICAgd2hpbGUgKHRoaXMuX21heExlbmd0aCA8IGxlbikge1xuICAgICAgdGhpcy5kb3VibGVBcnJheUxlbmd0aCgpO1xuICAgIH1cbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gIH07XG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuZG91YmxlQXJyYXlMZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52ID0gdGhpcy52LmNvbmNhdChjcmVhdGVTaXplZEFycmF5KHRoaXMuX21heExlbmd0aCkpO1xuICAgIHRoaXMuaSA9IHRoaXMuaS5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcbiAgICB0aGlzLm8gPSB0aGlzLm8uY29uY2F0KGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKSk7XG4gICAgdGhpcy5fbWF4TGVuZ3RoICo9IDI7XG4gIH07XG4gIFNoYXBlUGF0aC5wcm90b3R5cGUuc2V0WFlBdCA9IGZ1bmN0aW9uICh4LCB5LCB0eXBlLCBwb3MsIHJlcGxhY2UpIHtcbiAgICB2YXIgYXJyO1xuICAgIHRoaXMuX2xlbmd0aCA9IE1hdGgubWF4KHRoaXMuX2xlbmd0aCwgcG9zICsgMSk7XG4gICAgaWYgKHRoaXMuX2xlbmd0aCA+PSB0aGlzLl9tYXhMZW5ndGgpIHtcbiAgICAgIHRoaXMuZG91YmxlQXJyYXlMZW5ndGgoKTtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICd2JzpcbiAgICAgICAgYXJyID0gdGhpcy52O1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2knOlxuICAgICAgICBhcnIgPSB0aGlzLmk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnbyc6XG4gICAgICAgIGFyciA9IHRoaXMubztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcnIgPSBbXTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmICghYXJyW3Bvc10gfHwgYXJyW3Bvc10gJiYgIXJlcGxhY2UpIHtcbiAgICAgIGFycltwb3NdID0gcG9pbnRQb29sLm5ld0VsZW1lbnQoKTtcbiAgICB9XG4gICAgYXJyW3Bvc11bMF0gPSB4O1xuICAgIGFycltwb3NdWzFdID0geTtcbiAgfTtcbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5zZXRUcmlwbGVBdCA9IGZ1bmN0aW9uICh2WCwgdlksIG9YLCBvWSwgaVgsIGlZLCBwb3MsIHJlcGxhY2UpIHtcbiAgICB0aGlzLnNldFhZQXQodlgsIHZZLCAndicsIHBvcywgcmVwbGFjZSk7XG4gICAgdGhpcy5zZXRYWUF0KG9YLCBvWSwgJ28nLCBwb3MsIHJlcGxhY2UpO1xuICAgIHRoaXMuc2V0WFlBdChpWCwgaVksICdpJywgcG9zLCByZXBsYWNlKTtcbiAgfTtcbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5yZXZlcnNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBuZXdQYXRoID0gbmV3IFNoYXBlUGF0aCgpO1xuICAgIG5ld1BhdGguc2V0UGF0aERhdGEodGhpcy5jLCB0aGlzLl9sZW5ndGgpO1xuICAgIHZhciB2ZXJ0aWNlcyA9IHRoaXMudjtcbiAgICB2YXIgb3V0UG9pbnRzID0gdGhpcy5vO1xuICAgIHZhciBpblBvaW50cyA9IHRoaXMuaTtcbiAgICB2YXIgaW5pdCA9IDA7XG4gICAgaWYgKHRoaXMuYykge1xuICAgICAgbmV3UGF0aC5zZXRUcmlwbGVBdCh2ZXJ0aWNlc1swXVswXSwgdmVydGljZXNbMF1bMV0sIGluUG9pbnRzWzBdWzBdLCBpblBvaW50c1swXVsxXSwgb3V0UG9pbnRzWzBdWzBdLCBvdXRQb2ludHNbMF1bMV0sIDAsIGZhbHNlKTtcbiAgICAgIGluaXQgPSAxO1xuICAgIH1cbiAgICB2YXIgY250ID0gdGhpcy5fbGVuZ3RoIC0gMTtcbiAgICB2YXIgbGVuID0gdGhpcy5fbGVuZ3RoO1xuICAgIHZhciBpO1xuICAgIGZvciAoaSA9IGluaXQ7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgbmV3UGF0aC5zZXRUcmlwbGVBdCh2ZXJ0aWNlc1tjbnRdWzBdLCB2ZXJ0aWNlc1tjbnRdWzFdLCBpblBvaW50c1tjbnRdWzBdLCBpblBvaW50c1tjbnRdWzFdLCBvdXRQb2ludHNbY250XVswXSwgb3V0UG9pbnRzW2NudF1bMV0sIGksIGZhbHNlKTtcbiAgICAgIGNudCAtPSAxO1xuICAgIH1cbiAgICByZXR1cm4gbmV3UGF0aDtcbiAgfTtcbiAgU2hhcGVQYXRoLnByb3RvdHlwZS5sZW5ndGggPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbiAgfTtcblxuICB2YXIgc2hhcGVQb29sID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGNyZWF0ZSgpIHtcbiAgICAgIHJldHVybiBuZXcgU2hhcGVQYXRoKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbGVhc2Uoc2hhcGVQYXRoKSB7XG4gICAgICB2YXIgbGVuID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBwb2ludFBvb2wucmVsZWFzZShzaGFwZVBhdGgudltpXSk7XG4gICAgICAgIHBvaW50UG9vbC5yZWxlYXNlKHNoYXBlUGF0aC5pW2ldKTtcbiAgICAgICAgcG9pbnRQb29sLnJlbGVhc2Uoc2hhcGVQYXRoLm9baV0pO1xuICAgICAgICBzaGFwZVBhdGgudltpXSA9IG51bGw7XG4gICAgICAgIHNoYXBlUGF0aC5pW2ldID0gbnVsbDtcbiAgICAgICAgc2hhcGVQYXRoLm9baV0gPSBudWxsO1xuICAgICAgfVxuICAgICAgc2hhcGVQYXRoLl9sZW5ndGggPSAwO1xuICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmUoc2hhcGUpIHtcbiAgICAgIHZhciBjbG9uZWQgPSBmYWN0b3J5Lm5ld0VsZW1lbnQoKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHNoYXBlLl9sZW5ndGggPT09IHVuZGVmaW5lZCA/IHNoYXBlLnYubGVuZ3RoIDogc2hhcGUuX2xlbmd0aDtcbiAgICAgIGNsb25lZC5zZXRMZW5ndGgobGVuKTtcbiAgICAgIGNsb25lZC5jID0gc2hhcGUuYztcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBjbG9uZWQuc2V0VHJpcGxlQXQoc2hhcGUudltpXVswXSwgc2hhcGUudltpXVsxXSwgc2hhcGUub1tpXVswXSwgc2hhcGUub1tpXVsxXSwgc2hhcGUuaVtpXVswXSwgc2hhcGUuaVtpXVsxXSwgaSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2xvbmVkO1xuICAgIH1cbiAgICB2YXIgZmFjdG9yeSA9IHBvb2xGYWN0b3J5KDQsIGNyZWF0ZSwgcmVsZWFzZSk7XG4gICAgZmFjdG9yeS5jbG9uZSA9IGNsb25lO1xuICAgIHJldHVybiBmYWN0b3J5O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gU2hhcGVDb2xsZWN0aW9uKCkge1xuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWF4TGVuZ3RoID0gNDtcbiAgICB0aGlzLnNoYXBlcyA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fbWF4TGVuZ3RoKTtcbiAgfVxuICBTaGFwZUNvbGxlY3Rpb24ucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKHNoYXBlRGF0YSkge1xuICAgIGlmICh0aGlzLl9sZW5ndGggPT09IHRoaXMuX21heExlbmd0aCkge1xuICAgICAgdGhpcy5zaGFwZXMgPSB0aGlzLnNoYXBlcy5jb25jYXQoY3JlYXRlU2l6ZWRBcnJheSh0aGlzLl9tYXhMZW5ndGgpKTtcbiAgICAgIHRoaXMuX21heExlbmd0aCAqPSAyO1xuICAgIH1cbiAgICB0aGlzLnNoYXBlc1t0aGlzLl9sZW5ndGhdID0gc2hhcGVEYXRhO1xuICAgIHRoaXMuX2xlbmd0aCArPSAxO1xuICB9O1xuICBTaGFwZUNvbGxlY3Rpb24ucHJvdG90eXBlLnJlbGVhc2VTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMuX2xlbmd0aDsgaSArPSAxKSB7XG4gICAgICBzaGFwZVBvb2wucmVsZWFzZSh0aGlzLnNoYXBlc1tpXSk7XG4gICAgfVxuICAgIHRoaXMuX2xlbmd0aCA9IDA7XG4gIH07XG5cbiAgdmFyIHNoYXBlQ29sbGVjdGlvblBvb2wgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge1xuICAgICAgbmV3U2hhcGVDb2xsZWN0aW9uOiBuZXdTaGFwZUNvbGxlY3Rpb24sXG4gICAgICByZWxlYXNlOiByZWxlYXNlXG4gICAgfTtcbiAgICB2YXIgX2xlbmd0aCA9IDA7XG4gICAgdmFyIF9tYXhMZW5ndGggPSA0O1xuICAgIHZhciBwb29sID0gY3JlYXRlU2l6ZWRBcnJheShfbWF4TGVuZ3RoKTtcbiAgICBmdW5jdGlvbiBuZXdTaGFwZUNvbGxlY3Rpb24oKSB7XG4gICAgICB2YXIgc2hhcGVDb2xsZWN0aW9uO1xuICAgICAgaWYgKF9sZW5ndGgpIHtcbiAgICAgICAgX2xlbmd0aCAtPSAxO1xuICAgICAgICBzaGFwZUNvbGxlY3Rpb24gPSBwb29sW19sZW5ndGhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2hhcGVDb2xsZWN0aW9uID0gbmV3IFNoYXBlQ29sbGVjdGlvbigpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNoYXBlQ29sbGVjdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVsZWFzZShzaGFwZUNvbGxlY3Rpb24pIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHNoYXBlQ29sbGVjdGlvbi5fbGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlUG9vbC5yZWxlYXNlKHNoYXBlQ29sbGVjdGlvbi5zaGFwZXNbaV0pO1xuICAgICAgfVxuICAgICAgc2hhcGVDb2xsZWN0aW9uLl9sZW5ndGggPSAwO1xuICAgICAgaWYgKF9sZW5ndGggPT09IF9tYXhMZW5ndGgpIHtcbiAgICAgICAgcG9vbCA9IHBvb2xpbmdbXCJkb3VibGVcIl0ocG9vbCk7XG4gICAgICAgIF9tYXhMZW5ndGggKj0gMjtcbiAgICAgIH1cbiAgICAgIHBvb2xbX2xlbmd0aF0gPSBzaGFwZUNvbGxlY3Rpb247XG4gICAgICBfbGVuZ3RoICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBvYjtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaW5pdEZyYW1lID0gLTk5OTk5OTtcbiAgICBmdW5jdGlvbiBpbnRlcnBvbGF0ZVNoYXBlKGZyYW1lTnVtLCBwcmV2aW91c1ZhbHVlLCBjYWNoaW5nKSB7XG4gICAgICB2YXIgaXRlcmF0aW9uSW5kZXggPSBjYWNoaW5nLmxhc3RJbmRleDtcbiAgICAgIHZhciBrZXlQcm9wUztcbiAgICAgIHZhciBrZXlQcm9wRTtcbiAgICAgIHZhciBpc0hvbGQ7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBrO1xuICAgICAgdmFyIGpMZW47XG4gICAgICB2YXIga0xlbjtcbiAgICAgIHZhciBwZXJjO1xuICAgICAgdmFyIHZlcnRleFZhbHVlO1xuICAgICAgdmFyIGtmID0gdGhpcy5rZXlmcmFtZXM7XG4gICAgICBpZiAoZnJhbWVOdW0gPCBrZlswXS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgIGtleVByb3BTID0ga2ZbMF0uc1swXTtcbiAgICAgICAgaXNIb2xkID0gdHJ1ZTtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSAwO1xuICAgICAgfSBlbHNlIGlmIChmcmFtZU51bSA+PSBrZltrZi5sZW5ndGggLSAxXS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0ucyA/IGtmW2tmLmxlbmd0aCAtIDFdLnNbMF0gOiBrZltrZi5sZW5ndGggLSAyXS5lWzBdO1xuICAgICAgICAvKiBpZihrZltrZi5sZW5ndGggLSAxXS5zKXtcbiAgICAgICAgICAgICAgICAgIGtleVByb3BTID0ga2Zba2YubGVuZ3RoIC0gMV0uc1swXTtcbiAgICAgICAgICAgICAgfWVsc2V7XG4gICAgICAgICAgICAgICAgICBrZXlQcm9wUyA9IGtmW2tmLmxlbmd0aCAtIDJdLmVbMF07XG4gICAgICAgICAgICAgIH0gKi9cbiAgICAgICAgaXNIb2xkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciBpID0gaXRlcmF0aW9uSW5kZXg7XG4gICAgICAgIHZhciBsZW4gPSBrZi5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgICAgIHZhciBrZXlEYXRhO1xuICAgICAgICB2YXIgbmV4dEtleURhdGE7XG4gICAgICAgIHZhciBrZXlmcmFtZU1ldGFkYXRhO1xuICAgICAgICB3aGlsZSAoZmxhZykge1xuICAgICAgICAgIGtleURhdGEgPSBrZltpXTtcbiAgICAgICAgICBuZXh0S2V5RGF0YSA9IGtmW2kgKyAxXTtcbiAgICAgICAgICBpZiAobmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSA+IGZyYW1lTnVtKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGkgPCBsZW4gLSAxKSB7XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAga2V5ZnJhbWVNZXRhZGF0YSA9IHRoaXMua2V5ZnJhbWVzTWV0YWRhdGFbaV0gfHwge307XG4gICAgICAgIGlzSG9sZCA9IGtleURhdGEuaCA9PT0gMTtcbiAgICAgICAgaXRlcmF0aW9uSW5kZXggPSBpO1xuICAgICAgICBpZiAoIWlzSG9sZCkge1xuICAgICAgICAgIGlmIChmcmFtZU51bSA+PSBuZXh0S2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGZyYW1lTnVtIDwga2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSB7XG4gICAgICAgICAgICBwZXJjID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGZuYztcbiAgICAgICAgICAgIGlmIChrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdCkge1xuICAgICAgICAgICAgICBmbmMgPSBrZXlmcmFtZU1ldGFkYXRhLl9fZm5jdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGZuYyA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKGtleURhdGEuby54LCBrZXlEYXRhLm8ueSwga2V5RGF0YS5pLngsIGtleURhdGEuaS55KS5nZXQ7XG4gICAgICAgICAgICAgIGtleWZyYW1lTWV0YWRhdGEuX19mbmN0ID0gZm5jO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGVyYyA9IGZuYygoZnJhbWVOdW0gLSAoa2V5RGF0YS50IC0gdGhpcy5vZmZzZXRUaW1lKSkgLyAobmV4dEtleURhdGEudCAtIHRoaXMub2Zmc2V0VGltZSAtIChrZXlEYXRhLnQgLSB0aGlzLm9mZnNldFRpbWUpKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGtleVByb3BFID0gbmV4dEtleURhdGEucyA/IG5leHRLZXlEYXRhLnNbMF0gOiBrZXlEYXRhLmVbMF07XG4gICAgICAgIH1cbiAgICAgICAga2V5UHJvcFMgPSBrZXlEYXRhLnNbMF07XG4gICAgICB9XG4gICAgICBqTGVuID0gcHJldmlvdXNWYWx1ZS5fbGVuZ3RoO1xuICAgICAga0xlbiA9IGtleVByb3BTLmlbMF0ubGVuZ3RoO1xuICAgICAgY2FjaGluZy5sYXN0SW5kZXggPSBpdGVyYXRpb25JbmRleDtcbiAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgIHZlcnRleFZhbHVlID0gaXNIb2xkID8ga2V5UHJvcFMuaVtqXVtrXSA6IGtleVByb3BTLmlbal1ba10gKyAoa2V5UHJvcEUuaVtqXVtrXSAtIGtleVByb3BTLmlbal1ba10pICogcGVyYztcbiAgICAgICAgICBwcmV2aW91c1ZhbHVlLmlbal1ba10gPSB2ZXJ0ZXhWYWx1ZTtcbiAgICAgICAgICB2ZXJ0ZXhWYWx1ZSA9IGlzSG9sZCA/IGtleVByb3BTLm9bal1ba10gOiBrZXlQcm9wUy5vW2pdW2tdICsgKGtleVByb3BFLm9bal1ba10gLSBrZXlQcm9wUy5vW2pdW2tdKSAqIHBlcmM7XG4gICAgICAgICAgcHJldmlvdXNWYWx1ZS5vW2pdW2tdID0gdmVydGV4VmFsdWU7XG4gICAgICAgICAgdmVydGV4VmFsdWUgPSBpc0hvbGQgPyBrZXlQcm9wUy52W2pdW2tdIDoga2V5UHJvcFMudltqXVtrXSArIChrZXlQcm9wRS52W2pdW2tdIC0ga2V5UHJvcFMudltqXVtrXSkgKiBwZXJjO1xuICAgICAgICAgIHByZXZpb3VzVmFsdWUudltqXVtrXSA9IHZlcnRleFZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludGVycG9sYXRlU2hhcGVDdXJyZW50VGltZSgpIHtcbiAgICAgIHZhciBmcmFtZU51bSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgdmFyIGluaXRUaW1lID0gdGhpcy5rZXlmcmFtZXNbMF0udCAtIHRoaXMub2Zmc2V0VGltZTtcbiAgICAgIHZhciBlbmRUaW1lID0gdGhpcy5rZXlmcmFtZXNbdGhpcy5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAtIHRoaXMub2Zmc2V0VGltZTtcbiAgICAgIHZhciBsYXN0RnJhbWUgPSB0aGlzLl9jYWNoaW5nLmxhc3RGcmFtZTtcbiAgICAgIGlmICghKGxhc3RGcmFtZSAhPT0gaW5pdEZyYW1lICYmIChsYXN0RnJhbWUgPCBpbml0VGltZSAmJiBmcmFtZU51bSA8IGluaXRUaW1lIHx8IGxhc3RGcmFtZSA+IGVuZFRpbWUgJiYgZnJhbWVOdW0gPiBlbmRUaW1lKSkpIHtcbiAgICAgICAgLy8vIC9cbiAgICAgICAgdGhpcy5fY2FjaGluZy5sYXN0SW5kZXggPSBsYXN0RnJhbWUgPCBmcmFtZU51bSA/IHRoaXMuX2NhY2hpbmcubGFzdEluZGV4IDogMDtcbiAgICAgICAgdGhpcy5pbnRlcnBvbGF0ZVNoYXBlKGZyYW1lTnVtLCB0aGlzLnB2LCB0aGlzLl9jYWNoaW5nKTtcbiAgICAgICAgLy8vIC9cbiAgICAgIH1cbiAgICAgIHRoaXMuX2NhY2hpbmcubGFzdEZyYW1lID0gZnJhbWVOdW07XG4gICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVzZXRTaGFwZSgpIHtcbiAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzaGFwZXNFcXVhbChzaGFwZTEsIHNoYXBlMikge1xuICAgICAgaWYgKHNoYXBlMS5fbGVuZ3RoICE9PSBzaGFwZTIuX2xlbmd0aCB8fCBzaGFwZTEuYyAhPT0gc2hhcGUyLmMpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGUxLl9sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNoYXBlMS52W2ldWzBdICE9PSBzaGFwZTIudltpXVswXSB8fCBzaGFwZTEudltpXVsxXSAhPT0gc2hhcGUyLnZbaV1bMV0gfHwgc2hhcGUxLm9baV1bMF0gIT09IHNoYXBlMi5vW2ldWzBdIHx8IHNoYXBlMS5vW2ldWzFdICE9PSBzaGFwZTIub1tpXVsxXSB8fCBzaGFwZTEuaVtpXVswXSAhPT0gc2hhcGUyLmlbaV1bMF0gfHwgc2hhcGUxLmlbaV1bMV0gIT09IHNoYXBlMi5pW2ldWzFdKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0VlZhbHVlKG5ld1BhdGgpIHtcbiAgICAgIGlmICghc2hhcGVzRXF1YWwodGhpcy52LCBuZXdQYXRoKSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUobmV3UGF0aCk7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XG4gICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlKCkge1xuICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubG9jaykge1xuICAgICAgICB0aGlzLnNldFZWYWx1ZSh0aGlzLnB2KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5sb2NrID0gdHJ1ZTtcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgICAgdmFyIGZpbmFsVmFsdWU7XG4gICAgICBpZiAodGhpcy5rZikge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5wdjtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLmtzKSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmRhdGEua3MuaztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpbmFsVmFsdWUgPSB0aGlzLmRhdGEucHQuaztcbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0oZmluYWxWYWx1ZSk7XG4gICAgICB9XG4gICAgICB0aGlzLnNldFZWYWx1ZShmaW5hbFZhbHVlKTtcbiAgICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICB9XG4gICAgZnVuY3Rpb24gU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gZWxlbTtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICB0aGlzLmtmID0gZmFsc2U7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICAgIHZhciBwYXRoRGF0YSA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLnYgPSBzaGFwZVBvb2wuY2xvbmUocGF0aERhdGEpO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMucmVzZXQgPSByZXNldFNoYXBlO1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbXTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRWZmZWN0KGVmZmVjdEZ1bmN0aW9uKSB7XG4gICAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKGVmZmVjdEZ1bmN0aW9uKTtcbiAgICAgIHRoaXMuY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgICB9XG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuaW50ZXJwb2xhdGVTaGFwZSA9IGludGVycG9sYXRlU2hhcGU7XG4gICAgU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBwcm9jZXNzRWZmZWN0c1NlcXVlbmNlO1xuICAgIFNoYXBlUHJvcGVydHkucHJvdG90eXBlLnNldFZWYWx1ZSA9IHNldFZWYWx1ZTtcbiAgICBTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5hZGRFZmZlY3QgPSBhZGRFZmZlY3Q7XG4gICAgZnVuY3Rpb24gS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKSB7XG4gICAgICB0aGlzLnByb3BUeXBlID0gJ3NoYXBlJztcbiAgICAgIHRoaXMuY29tcCA9IGVsZW0uY29tcDtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmNvbnRhaW5lciA9IGVsZW07XG4gICAgICB0aGlzLm9mZnNldFRpbWUgPSBlbGVtLmRhdGEuc3Q7XG4gICAgICB0aGlzLmtleWZyYW1lcyA9IHR5cGUgPT09IDMgPyBkYXRhLnB0LmsgOiBkYXRhLmtzLms7XG4gICAgICB0aGlzLmtleWZyYW1lc01ldGFkYXRhID0gW107XG4gICAgICB0aGlzLmsgPSB0cnVlO1xuICAgICAgdGhpcy5rZiA9IHRydWU7XG4gICAgICB2YXIgbGVuID0gdGhpcy5rZXlmcmFtZXNbMF0uc1swXS5pLmxlbmd0aDtcbiAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICB0aGlzLnYuc2V0UGF0aERhdGEodGhpcy5rZXlmcmFtZXNbMF0uc1swXS5jLCBsZW4pO1xuICAgICAgdGhpcy5wdiA9IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnYpO1xuICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlQ29sbGVjdGlvblBvb2wubmV3U2hhcGVDb2xsZWN0aW9uKCk7XG4gICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIHRoaXMucGF0aHMuYWRkU2hhcGUodGhpcy52KTtcbiAgICAgIHRoaXMubGFzdEZyYW1lID0gaW5pdEZyYW1lO1xuICAgICAgdGhpcy5yZXNldCA9IHJlc2V0U2hhcGU7XG4gICAgICB0aGlzLl9jYWNoaW5nID0ge1xuICAgICAgICBsYXN0RnJhbWU6IGluaXRGcmFtZSxcbiAgICAgICAgbGFzdEluZGV4OiAwXG4gICAgICB9O1xuICAgICAgdGhpcy5lZmZlY3RzU2VxdWVuY2UgPSBbaW50ZXJwb2xhdGVTaGFwZUN1cnJlbnRUaW1lLmJpbmQodGhpcyldO1xuICAgIH1cbiAgICBLZXlmcmFtZWRTaGFwZVByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IHByb2Nlc3NFZmZlY3RzU2VxdWVuY2U7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuaW50ZXJwb2xhdGVTaGFwZSA9IGludGVycG9sYXRlU2hhcGU7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eS5wcm90b3R5cGUuc2V0VlZhbHVlID0gc2V0VlZhbHVlO1xuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHkucHJvdG90eXBlLmFkZEVmZmVjdCA9IGFkZEVmZmVjdDtcbiAgICB2YXIgRWxsU2hhcGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjUG9pbnQgPSByb3VuZENvcm5lcjtcbiAgICAgIGZ1bmN0aW9uIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5KGVsZW0sIGRhdGEpIHtcbiAgICAgICAgdGhpcy52ID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgICAgdGhpcy52LnNldFBhdGhEYXRhKHRydWUsIDQpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5wYXRocyA9IHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy52KTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCwgMSwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgMCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5rID0gZmFsc2U7XG4gICAgICAgICAgdGhpcy5jb252ZXJ0RWxsVG9QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIEVsbFNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgcmVzZXQ6IHJlc2V0U2hhcGUsXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgICAgICAgICBpZiAodGhpcy5fbWRmKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRFbGxUb1BhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRFbGxUb1BhdGg6IGZ1bmN0aW9uIGNvbnZlcnRFbGxUb1BhdGgoKSB7XG4gICAgICAgICAgdmFyIHAwID0gdGhpcy5wLnZbMF07XG4gICAgICAgICAgdmFyIHAxID0gdGhpcy5wLnZbMV07XG4gICAgICAgICAgdmFyIHMwID0gdGhpcy5zLnZbMF0gLyAyO1xuICAgICAgICAgIHZhciBzMSA9IHRoaXMucy52WzFdIC8gMjtcbiAgICAgICAgICB2YXIgX2N3ID0gdGhpcy5kICE9PSAzO1xuICAgICAgICAgIHZhciBfdiA9IHRoaXMudjtcbiAgICAgICAgICBfdi52WzBdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YudlsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LnZbMV1bMV0gPSBwMTtcbiAgICAgICAgICBfdi52WzJdWzBdID0gcDA7XG4gICAgICAgICAgX3YudlsyXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3YudlszXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92LnZbM11bMV0gPSBwMTtcbiAgICAgICAgICBfdi5pWzBdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3YuaVswXVsxXSA9IHAxIC0gczE7XG4gICAgICAgICAgX3YuaVsxXVswXSA9IF9jdyA/IHAwICsgczAgOiBwMCAtIHMwO1xuICAgICAgICAgIF92LmlbMV1bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICAgIF92LmlbMl1bMF0gPSBfY3cgPyBwMCArIHMwICogY1BvaW50IDogcDAgLSBzMCAqIGNQb2ludDtcbiAgICAgICAgICBfdi5pWzJdWzFdID0gcDEgKyBzMTtcbiAgICAgICAgICBfdi5pWzNdWzBdID0gX2N3ID8gcDAgLSBzMCA6IHAwICsgczA7XG4gICAgICAgICAgX3YuaVszXVsxXSA9IHAxICsgczEgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1swXVswXSA9IF9jdyA/IHAwICsgczAgKiBjUG9pbnQgOiBwMCAtIHMwICogY1BvaW50O1xuICAgICAgICAgIF92Lm9bMF1bMV0gPSBwMSAtIHMxO1xuICAgICAgICAgIF92Lm9bMV1bMF0gPSBfY3cgPyBwMCArIHMwIDogcDAgLSBzMDtcbiAgICAgICAgICBfdi5vWzFdWzFdID0gcDEgKyBzMSAqIGNQb2ludDtcbiAgICAgICAgICBfdi5vWzJdWzBdID0gX2N3ID8gcDAgLSBzMCAqIGNQb2ludCA6IHAwICsgczAgKiBjUG9pbnQ7XG4gICAgICAgICAgX3Yub1syXVsxXSA9IHAxICsgczE7XG4gICAgICAgICAgX3Yub1szXVswXSA9IF9jdyA/IHAwIC0gczAgOiBwMCArIHMwO1xuICAgICAgICAgIF92Lm9bM11bMV0gPSBwMSAtIHMxICogY1BvaW50O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBFbGxTaGFwZVByb3BlcnR5RmFjdG9yeSk7XG4gICAgICByZXR1cm4gRWxsU2hhcGVQcm9wZXJ0eUZhY3Rvcnk7XG4gICAgfSgpO1xuICAgIHZhciBTdGFyU2hhcGVQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZ1bmN0aW9uIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeShlbGVtLCBkYXRhKSB7XG4gICAgICAgIHRoaXMudiA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgICAgIHRoaXMudi5zZXRQYXRoRGF0YSh0cnVlLCAwKTtcbiAgICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgICAgdGhpcy5jb21wID0gZWxlbS5jb21wO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICAgICAgdGhpcy5kID0gZGF0YS5kO1xuICAgICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICAgIGlmIChkYXRhLnN5ID09PSAxKSB7XG4gICAgICAgICAgdGhpcy5pciA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuaXIsIDAsIDAsIHRoaXMpO1xuICAgICAgICAgIHRoaXMuaXMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmlzLCAwLCAwLjAxLCB0aGlzKTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGggPSB0aGlzLmNvbnZlcnRTdGFyVG9QYXRoO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuY29udmVydFRvUGF0aCA9IHRoaXMuY29udmVydFBvbHlnb25Ub1BhdGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucHQsIDAsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAsIDEsIDAsIHRoaXMpO1xuICAgICAgICB0aGlzLnIgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5vcyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEub3MsIDAsIDAuMDEsIHRoaXMpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnYpO1xuICAgICAgICB0aGlzLnBhdGhzID0gdGhpcy5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGgoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5LnByb3RvdHlwZSA9IHtcbiAgICAgICAgcmVzZXQ6IHJlc2V0U2hhcGUsXG4gICAgICAgIGdldFZhbHVlOiBmdW5jdGlvbiBnZXRWYWx1ZSgpIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgICAgICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgICAgICAgICBpZiAodGhpcy5fbWRmKSB7XG4gICAgICAgICAgICB0aGlzLmNvbnZlcnRUb1BhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRTdGFyVG9QYXRoOiBmdW5jdGlvbiBjb252ZXJ0U3RhclRvUGF0aCgpIHtcbiAgICAgICAgICB2YXIgbnVtUHRzID0gTWF0aC5mbG9vcih0aGlzLnB0LnYpICogMjtcbiAgICAgICAgICB2YXIgYW5nbGUgPSBNYXRoLlBJICogMiAvIG51bVB0cztcbiAgICAgICAgICAvKiB0aGlzLnYudi5sZW5ndGggPSBudW1QdHM7XG4gICAgICAgICAgICAgICAgICB0aGlzLnYuaS5sZW5ndGggPSBudW1QdHM7XG4gICAgICAgICAgICAgICAgICB0aGlzLnYuby5sZW5ndGggPSBudW1QdHM7ICovXG4gICAgICAgICAgdmFyIGxvbmdGbGFnID0gdHJ1ZTtcbiAgICAgICAgICB2YXIgbG9uZ1JhZCA9IHRoaXMub3IudjtcbiAgICAgICAgICB2YXIgc2hvcnRSYWQgPSB0aGlzLmlyLnY7XG4gICAgICAgICAgdmFyIGxvbmdSb3VuZCA9IHRoaXMub3MudjtcbiAgICAgICAgICB2YXIgc2hvcnRSb3VuZCA9IHRoaXMuaXMudjtcbiAgICAgICAgICB2YXIgbG9uZ1BlcmltU2VnbWVudCA9IDIgKiBNYXRoLlBJICogbG9uZ1JhZCAvIChudW1QdHMgKiAyKTtcbiAgICAgICAgICB2YXIgc2hvcnRQZXJpbVNlZ21lbnQgPSAyICogTWF0aC5QSSAqIHNob3J0UmFkIC8gKG51bVB0cyAqIDIpO1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciByYWQ7XG4gICAgICAgICAgdmFyIHJvdW5kbmVzcztcbiAgICAgICAgICB2YXIgcGVyaW1TZWdtZW50O1xuICAgICAgICAgIHZhciBjdXJyZW50QW5nID0gLU1hdGguUEkgLyAyO1xuICAgICAgICAgIGN1cnJlbnRBbmcgKz0gdGhpcy5yLnY7XG4gICAgICAgICAgdmFyIGRpciA9IHRoaXMuZGF0YS5kID09PSAzID8gLTEgOiAxO1xuICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtUHRzOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJhZCA9IGxvbmdGbGFnID8gbG9uZ1JhZCA6IHNob3J0UmFkO1xuICAgICAgICAgICAgcm91bmRuZXNzID0gbG9uZ0ZsYWcgPyBsb25nUm91bmQgOiBzaG9ydFJvdW5kO1xuICAgICAgICAgICAgcGVyaW1TZWdtZW50ID0gbG9uZ0ZsYWcgPyBsb25nUGVyaW1TZWdtZW50IDogc2hvcnRQZXJpbVNlZ21lbnQ7XG4gICAgICAgICAgICB2YXIgeCA9IHJhZCAqIE1hdGguY29zKGN1cnJlbnRBbmcpO1xuICAgICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgdmFyIG95ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IC14IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgeCArPSArdGhpcy5wLnZbMF07XG4gICAgICAgICAgICB5ICs9ICt0aGlzLnAudlsxXTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LCB5LCB4IC0gb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgLSBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeCArIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5ICsgb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIGksIHRydWUpO1xuXG4gICAgICAgICAgICAvKiB0aGlzLnYudltpXSA9IFt4LHldO1xuICAgICAgICAgICAgICAgICAgICAgIHRoaXMudi5pW2ldID0gW3grb3gqcGVyaW1TZWdtZW50KnJvdW5kbmVzcypkaXIseStveSpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcl07XG4gICAgICAgICAgICAgICAgICAgICAgdGhpcy52Lm9baV0gPSBbeC1veCpwZXJpbVNlZ21lbnQqcm91bmRuZXNzKmRpcix5LW95KnBlcmltU2VnbWVudCpyb3VuZG5lc3MqZGlyXTtcbiAgICAgICAgICAgICAgICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IG51bVB0czsgKi9cbiAgICAgICAgICAgIGxvbmdGbGFnID0gIWxvbmdGbGFnO1xuICAgICAgICAgICAgY3VycmVudEFuZyArPSBhbmdsZSAqIGRpcjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGNvbnZlcnRQb2x5Z29uVG9QYXRoOiBmdW5jdGlvbiBjb252ZXJ0UG9seWdvblRvUGF0aCgpIHtcbiAgICAgICAgICB2YXIgbnVtUHRzID0gTWF0aC5mbG9vcih0aGlzLnB0LnYpO1xuICAgICAgICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyIC8gbnVtUHRzO1xuICAgICAgICAgIHZhciByYWQgPSB0aGlzLm9yLnY7XG4gICAgICAgICAgdmFyIHJvdW5kbmVzcyA9IHRoaXMub3MudjtcbiAgICAgICAgICB2YXIgcGVyaW1TZWdtZW50ID0gMiAqIE1hdGguUEkgKiByYWQgLyAobnVtUHRzICogNCk7XG4gICAgICAgICAgdmFyIGk7XG4gICAgICAgICAgdmFyIGN1cnJlbnRBbmcgPSAtTWF0aC5QSSAqIDAuNTtcbiAgICAgICAgICB2YXIgZGlyID0gdGhpcy5kYXRhLmQgPT09IDMgPyAtMSA6IDE7XG4gICAgICAgICAgY3VycmVudEFuZyArPSB0aGlzLnIudjtcbiAgICAgICAgICB0aGlzLnYuX2xlbmd0aCA9IDA7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bVB0czsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHJhZCAqIE1hdGguY29zKGN1cnJlbnRBbmcpO1xuICAgICAgICAgICAgdmFyIHkgPSByYWQgKiBNYXRoLnNpbihjdXJyZW50QW5nKTtcbiAgICAgICAgICAgIHZhciBveCA9IHggPT09IDAgJiYgeSA9PT0gMCA/IDAgOiB5IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgdmFyIG95ID0geCA9PT0gMCAmJiB5ID09PSAwID8gMCA6IC14IC8gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuICAgICAgICAgICAgeCArPSArdGhpcy5wLnZbMF07XG4gICAgICAgICAgICB5ICs9ICt0aGlzLnAudlsxXTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdCh4LCB5LCB4IC0gb3ggKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIHkgLSBveSAqIHBlcmltU2VnbWVudCAqIHJvdW5kbmVzcyAqIGRpciwgeCArIG94ICogcGVyaW1TZWdtZW50ICogcm91bmRuZXNzICogZGlyLCB5ICsgb3kgKiBwZXJpbVNlZ21lbnQgKiByb3VuZG5lc3MgKiBkaXIsIGksIHRydWUpO1xuICAgICAgICAgICAgY3VycmVudEFuZyArPSBhbmdsZSAqIGRpcjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5wYXRocy5sZW5ndGggPSAwO1xuICAgICAgICAgIHRoaXMucGF0aHNbMF0gPSB0aGlzLnY7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFN0YXJTaGFwZVByb3BlcnR5RmFjdG9yeSk7XG4gICAgICByZXR1cm4gU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5O1xuICAgIH0oKTtcbiAgICB2YXIgUmVjdFNoYXBlUHJvcGVydHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBmdW5jdGlvbiBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkoZWxlbSwgZGF0YSkge1xuICAgICAgICB0aGlzLnYgPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICB0aGlzLnYuYyA9IHRydWU7XG4gICAgICAgIHRoaXMubG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZUNvbGxlY3Rpb25Qb29sLm5ld1NoYXBlQ29sbGVjdGlvbigpO1xuICAgICAgICB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uLmFkZFNoYXBlKHRoaXMudik7XG4gICAgICAgIHRoaXMucGF0aHMgPSB0aGlzLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgICB0aGlzLmQgPSBkYXRhLmQ7XG4gICAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihlbGVtKTtcbiAgICAgICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5wLCAxLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zLCAxLCAwLCB0aGlzKTtcbiAgICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yLCAwLCAwLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5rID0gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLmNvbnZlcnRSZWN0VG9QYXRoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeS5wcm90b3R5cGUgPSB7XG4gICAgICAgIGNvbnZlcnRSZWN0VG9QYXRoOiBmdW5jdGlvbiBjb252ZXJ0UmVjdFRvUGF0aCgpIHtcbiAgICAgICAgICB2YXIgcDAgPSB0aGlzLnAudlswXTtcbiAgICAgICAgICB2YXIgcDEgPSB0aGlzLnAudlsxXTtcbiAgICAgICAgICB2YXIgdjAgPSB0aGlzLnMudlswXSAvIDI7XG4gICAgICAgICAgdmFyIHYxID0gdGhpcy5zLnZbMV0gLyAyO1xuICAgICAgICAgIHZhciByb3VuZCA9IGJtTWluKHYwLCB2MSwgdGhpcy5yLnYpO1xuICAgICAgICAgIHZhciBjUG9pbnQgPSByb3VuZCAqICgxIC0gcm91bmRDb3JuZXIpO1xuICAgICAgICAgIHRoaXMudi5fbGVuZ3RoID0gMDtcbiAgICAgICAgICBpZiAodGhpcy5kID09PSAyIHx8IHRoaXMuZCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCArIHYwLCBwMSAtIHYxICsgY1BvaW50LCAwLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwICsgdjAsIHAxICsgdjEgLSBjUG9pbnQsIHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgMSwgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAocm91bmQgIT09IDApIHtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSArIHYxLCBwMCArIHYwIC0gY1BvaW50LCBwMSArIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgKyB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSArIHYxLCAzLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgLSB2MCwgcDEgKyB2MSAtIHJvdW5kLCBwMCAtIHYwLCBwMSArIHYxIC0gY1BvaW50LCA0LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIGNQb2ludCwgcDAgLSB2MCwgcDEgLSB2MSArIHJvdW5kLCA1LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgcDAgLSB2MCArIHJvdW5kLCBwMSAtIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSAtIHYxLCA2LCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgLSB2MSwgcDAgKyB2MCAtIHJvdW5kLCBwMSAtIHYxLCA3LCB0cnVlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSArIHYxLCBwMCAtIHYwICsgY1BvaW50LCBwMSArIHYxLCBwMCAtIHYwLCBwMSArIHYxLCAyKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwIC0gdjAsIHAxIC0gdjEsIHAwIC0gdjAsIHAxIC0gdjEgKyBjUG9pbnQsIHAwIC0gdjAsIHAxIC0gdjEsIDMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgKyB2MCwgcDEgLSB2MSArIHJvdW5kLCBwMCArIHYwLCBwMSAtIHYxICsgY1BvaW50LCBwMCArIHYwLCBwMSAtIHYxICsgcm91bmQsIDAsIHRydWUpO1xuICAgICAgICAgICAgaWYgKHJvdW5kICE9PSAwKSB7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwIC0gcm91bmQsIHAxIC0gdjEsIHAwICsgdjAgLSByb3VuZCwgcDEgLSB2MSwgcDAgKyB2MCAtIGNQb2ludCwgcDEgLSB2MSwgMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwICsgcm91bmQsIHAxIC0gdjEsIHAwIC0gdjAgKyBjUG9pbnQsIHAxIC0gdjEsIHAwIC0gdjAgKyByb3VuZCwgcDEgLSB2MSwgMiwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSAtIHYxICsgcm91bmQsIHAwIC0gdjAsIHAxIC0gdjEgKyByb3VuZCwgcDAgLSB2MCwgcDEgLSB2MSArIGNQb2ludCwgMywgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwIC0gdjAsIHAxICsgdjEgLSBjUG9pbnQsIHAwIC0gdjAsIHAxICsgdjEgLSByb3VuZCwgNCwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwICsgcm91bmQsIHAxICsgdjEsIHAwIC0gdjAgKyByb3VuZCwgcDEgKyB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgKyB2MSwgNSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwIC0gcm91bmQsIHAxICsgdjEsIHAwICsgdjAgLSBjUG9pbnQsIHAxICsgdjEsIHAwICsgdjAgLSByb3VuZCwgcDEgKyB2MSwgNiwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCArIHYwLCBwMSArIHYxIC0gcm91bmQsIHAwICsgdjAsIHAxICsgdjEgLSByb3VuZCwgcDAgKyB2MCwgcDEgKyB2MSAtIGNQb2ludCwgNywgdHJ1ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzLnYuc2V0VHJpcGxlQXQocDAgLSB2MCwgcDEgLSB2MSwgcDAgLSB2MCArIGNQb2ludCwgcDEgLSB2MSwgcDAgLSB2MCwgcDEgLSB2MSwgMSwgdHJ1ZSk7XG4gICAgICAgICAgICAgIHRoaXMudi5zZXRUcmlwbGVBdChwMCAtIHYwLCBwMSArIHYxLCBwMCAtIHYwLCBwMSArIHYxIC0gY1BvaW50LCBwMCAtIHYwLCBwMSArIHYxLCAyLCB0cnVlKTtcbiAgICAgICAgICAgICAgdGhpcy52LnNldFRyaXBsZUF0KHAwICsgdjAsIHAxICsgdjEsIHAwICsgdjAgLSBjUG9pbnQsIHAxICsgdjEsIHAwICsgdjAsIHAxICsgdjEsIDMsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKCkge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5mcmFtZUlkID0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZDtcbiAgICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICAgIHRoaXMuY29udmVydFJlY3RUb1BhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHJlc2V0OiByZXNldFNoYXBlXG4gICAgICB9O1xuICAgICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBSZWN0U2hhcGVQcm9wZXJ0eUZhY3RvcnkpO1xuICAgICAgcmV0dXJuIFJlY3RTaGFwZVByb3BlcnR5RmFjdG9yeTtcbiAgICB9KCk7XG4gICAgZnVuY3Rpb24gZ2V0U2hhcGVQcm9wKGVsZW0sIGRhdGEsIHR5cGUpIHtcbiAgICAgIHZhciBwcm9wO1xuICAgICAgaWYgKHR5cGUgPT09IDMgfHwgdHlwZSA9PT0gNCkge1xuICAgICAgICB2YXIgZGF0YVByb3AgPSB0eXBlID09PSAzID8gZGF0YS5wdCA6IGRhdGEua3M7XG4gICAgICAgIHZhciBrZXlzID0gZGF0YVByb3AuaztcbiAgICAgICAgaWYgKGtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgcHJvcCA9IG5ldyBLZXlmcmFtZWRTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEsIHR5cGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3AgPSBuZXcgU2hhcGVQcm9wZXJ0eShlbGVtLCBkYXRhLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA1KSB7XG4gICAgICAgIHByb3AgPSBuZXcgUmVjdFNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcbiAgICAgICAgcHJvcCA9IG5ldyBFbGxTaGFwZVByb3BlcnR5KGVsZW0sIGRhdGEpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSA3KSB7XG4gICAgICAgIHByb3AgPSBuZXcgU3RhclNoYXBlUHJvcGVydHkoZWxlbSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgIGVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvbnN0cnVjdG9yRnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU2hhcGVQcm9wZXJ0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBLZXlmcmFtZWRTaGFwZVByb3BlcnR5O1xuICAgIH1cbiAgICB2YXIgb2IgPSB7fTtcbiAgICBvYi5nZXRTaGFwZVByb3AgPSBnZXRTaGFwZVByb3A7XG4gICAgb2IuZ2V0Q29uc3RydWN0b3JGdW5jdGlvbiA9IGdldENvbnN0cnVjdG9yRnVuY3Rpb247XG4gICAgb2IuZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbiA9IGdldEtleWZyYW1lZENvbnN0cnVjdG9yRnVuY3Rpb247XG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgLyohXG4gICBUcmFuc2Zvcm1hdGlvbiBNYXRyaXggdjIuMFxuICAgKGMpIEVwaXN0ZW1leCAyMDE0LTIwMTVcbiAgIHd3dy5lcGlzdGVtZXguY29tXG4gICBCeSBLZW4gRnlyc3RlbmJlcmdcbiAgIENvbnRyaWJ1dGlvbnMgYnkgbGVlb25peWEuXG4gICBMaWNlbnNlOiBNSVQsIGhlYWRlciByZXF1aXJlZC5cbiAgICovXG5cbiAgLyoqXG4gICAqIDJEIHRyYW5zZm9ybWF0aW9uIG1hdHJpeCBvYmplY3QgaW5pdGlhbGl6ZWQgd2l0aCBpZGVudGl0eSBtYXRyaXguXG4gICAqXG4gICAqIFRoZSBtYXRyaXggY2FuIHN5bmNocm9uaXplIGEgY2FudmFzIGNvbnRleHQgYnkgc3VwcGx5aW5nIHRoZSBjb250ZXh0XG4gICAqIGFzIGFuIGFyZ3VtZW50LCBvciBsYXRlciBhcHBseSBjdXJyZW50IGFic29sdXRlIHRyYW5zZm9ybSB0byBhblxuICAgKiBleGlzdGluZyBjb250ZXh0LlxuICAgKlxuICAgKiBBbGwgdmFsdWVzIGFyZSBoYW5kbGVkIGFzIGZsb2F0aW5nIHBvaW50IHZhbHVlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR9IFtjb250ZXh0XSAtIE9wdGlvbmFsIGNvbnRleHQgdG8gc3luYyB3aXRoIE1hdHJpeFxuICAgKiBAcHJvcCB7bnVtYmVyfSBhIC0gc2NhbGUgeFxuICAgKiBAcHJvcCB7bnVtYmVyfSBiIC0gc2hlYXIgeVxuICAgKiBAcHJvcCB7bnVtYmVyfSBjIC0gc2hlYXIgeFxuICAgKiBAcHJvcCB7bnVtYmVyfSBkIC0gc2NhbGUgeVxuICAgKiBAcHJvcCB7bnVtYmVyfSBlIC0gdHJhbnNsYXRlIHhcbiAgICogQHByb3Age251bWJlcn0gZiAtIHRyYW5zbGF0ZSB5XG4gICAqIEBwcm9wIHtDYW52YXNSZW5kZXJpbmdDb250ZXh0MkR8bnVsbH0gW2NvbnRleHQ9bnVsbF0gLSBzZXQgb3IgZ2V0IGN1cnJlbnQgY2FudmFzIGNvbnRleHRcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuXG4gIHZhciBNYXRyaXggPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9jb3MgPSBNYXRoLmNvcztcbiAgICB2YXIgX3NpbiA9IE1hdGguc2luO1xuICAgIHZhciBfdGFuID0gTWF0aC50YW47XG4gICAgdmFyIF9ybmQgPSBNYXRoLnJvdW5kO1xuICAgIGZ1bmN0aW9uIHJlc2V0KCkge1xuICAgICAgdGhpcy5wcm9wc1swXSA9IDE7XG4gICAgICB0aGlzLnByb3BzWzFdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbMl0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1szXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzRdID0gMDtcbiAgICAgIHRoaXMucHJvcHNbNV0gPSAxO1xuICAgICAgdGhpcy5wcm9wc1s2XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzddID0gMDtcbiAgICAgIHRoaXMucHJvcHNbOF0gPSAwO1xuICAgICAgdGhpcy5wcm9wc1s5XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzEwXSA9IDE7XG4gICAgICB0aGlzLnByb3BzWzExXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzEyXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzEzXSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzE0XSA9IDA7XG4gICAgICB0aGlzLnByb3BzWzE1XSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRlKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuICAgICAgdmFyIG1TaW4gPSBfc2luKGFuZ2xlKTtcbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcm90YXRlWChhbmdsZSkge1xuICAgICAgaWYgKGFuZ2xlID09PSAwKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCAwLCAwLCAwLCAwLCBtQ29zLCAtbVNpbiwgMCwgMCwgbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJvdGF0ZVkoYW5nbGUpIHtcbiAgICAgIGlmIChhbmdsZSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBtQ29zID0gX2NvcyhhbmdsZSk7XG4gICAgICB2YXIgbVNpbiA9IF9zaW4oYW5nbGUpO1xuICAgICAgcmV0dXJuIHRoaXMuX3QobUNvcywgMCwgbVNpbiwgMCwgMCwgMSwgMCwgMCwgLW1TaW4sIDAsIG1Db3MsIDAsIDAsIDAsIDAsIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3RhdGVaKGFuZ2xlKSB7XG4gICAgICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG4gICAgICB2YXIgbUNvcyA9IF9jb3MoYW5nbGUpO1xuICAgICAgdmFyIG1TaW4gPSBfc2luKGFuZ2xlKTtcbiAgICAgIHJldHVybiB0aGlzLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2hlYXIoc3gsIHN5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fdCgxLCBzeSwgc3gsIDEsIDAsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBza2V3KGF4LCBheSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2hlYXIoX3RhbihheCksIF90YW4oYXkpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2tld0Zyb21BeGlzKGF4LCBhbmdsZSkge1xuICAgICAgdmFyIG1Db3MgPSBfY29zKGFuZ2xlKTtcbiAgICAgIHZhciBtU2luID0gX3NpbihhbmdsZSk7XG4gICAgICByZXR1cm4gdGhpcy5fdChtQ29zLCBtU2luLCAwLCAwLCAtbVNpbiwgbUNvcywgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSkuX3QoMSwgMCwgMCwgMCwgX3RhbihheCksIDEsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDEpLl90KG1Db3MsIC1tU2luLCAwLCAwLCBtU2luLCBtQ29zLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxKTtcbiAgICAgIC8vIHJldHVybiB0aGlzLl90KG1Db3MsIG1TaW4sIC1tU2luLCBtQ29zLCAwLCAwKS5fdCgxLCAwLCBfdGFuKGF4KSwgMSwgMCwgMCkuX3QobUNvcywgLW1TaW4sIG1TaW4sIG1Db3MsIDAsIDApO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzY2FsZShzeCwgc3ksIHN6KSB7XG4gICAgICBpZiAoIXN6ICYmIHN6ICE9PSAwKSB7XG4gICAgICAgIHN6ID0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChzeCA9PT0gMSAmJiBzeSA9PT0gMSAmJiBzeiA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90KHN4LCAwLCAwLCAwLCAwLCBzeSwgMCwgMCwgMCwgMCwgc3osIDAsIDAsIDAsIDAsIDEpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZiwgZywgaCwgaSwgaiwgaywgbCwgbSwgbiwgbywgcCkge1xuICAgICAgdGhpcy5wcm9wc1swXSA9IGE7XG4gICAgICB0aGlzLnByb3BzWzFdID0gYjtcbiAgICAgIHRoaXMucHJvcHNbMl0gPSBjO1xuICAgICAgdGhpcy5wcm9wc1szXSA9IGQ7XG4gICAgICB0aGlzLnByb3BzWzRdID0gZTtcbiAgICAgIHRoaXMucHJvcHNbNV0gPSBmO1xuICAgICAgdGhpcy5wcm9wc1s2XSA9IGc7XG4gICAgICB0aGlzLnByb3BzWzddID0gaDtcbiAgICAgIHRoaXMucHJvcHNbOF0gPSBpO1xuICAgICAgdGhpcy5wcm9wc1s5XSA9IGo7XG4gICAgICB0aGlzLnByb3BzWzEwXSA9IGs7XG4gICAgICB0aGlzLnByb3BzWzExXSA9IGw7XG4gICAgICB0aGlzLnByb3BzWzEyXSA9IG07XG4gICAgICB0aGlzLnByb3BzWzEzXSA9IG47XG4gICAgICB0aGlzLnByb3BzWzE0XSA9IG87XG4gICAgICB0aGlzLnByb3BzWzE1XSA9IHA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNsYXRlKHR4LCB0eSwgdHopIHtcbiAgICAgIHR6ID0gdHogfHwgMDtcbiAgICAgIGlmICh0eCAhPT0gMCB8fCB0eSAhPT0gMCB8fCB0eiAhPT0gMCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdCgxLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAxLCAwLCB0eCwgdHksIHR6LCAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0oYTIsIGIyLCBjMiwgZDIsIGUyLCBmMiwgZzIsIGgyLCBpMiwgajIsIGsyLCBsMiwgbTIsIG4yLCBvMiwgcDIpIHtcbiAgICAgIHZhciBfcCA9IHRoaXMucHJvcHM7XG4gICAgICBpZiAoYTIgPT09IDEgJiYgYjIgPT09IDAgJiYgYzIgPT09IDAgJiYgZDIgPT09IDAgJiYgZTIgPT09IDAgJiYgZjIgPT09IDEgJiYgZzIgPT09IDAgJiYgaDIgPT09IDAgJiYgaTIgPT09IDAgJiYgajIgPT09IDAgJiYgazIgPT09IDEgJiYgbDIgPT09IDApIHtcbiAgICAgICAgLy8gTk9URTogY29tbWVudGluZyB0aGlzIGNvbmRpdGlvbiBiZWNhdXNlIFR1cmJvRmFuIGRlb3B0aW1pemVzIGNvZGUgd2hlbiBwcmVzZW50XG4gICAgICAgIC8vIGlmKG0yICE9PSAwIHx8IG4yICE9PSAwIHx8IG8yICE9PSAwKXtcbiAgICAgICAgX3BbMTJdID0gX3BbMTJdICogYTIgKyBfcFsxNV0gKiBtMjtcbiAgICAgICAgX3BbMTNdID0gX3BbMTNdICogZjIgKyBfcFsxNV0gKiBuMjtcbiAgICAgICAgX3BbMTRdID0gX3BbMTRdICogazIgKyBfcFsxNV0gKiBvMjtcbiAgICAgICAgX3BbMTVdICo9IHAyO1xuICAgICAgICAvLyB9XG4gICAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cbiAgICAgIHZhciBhMSA9IF9wWzBdO1xuICAgICAgdmFyIGIxID0gX3BbMV07XG4gICAgICB2YXIgYzEgPSBfcFsyXTtcbiAgICAgIHZhciBkMSA9IF9wWzNdO1xuICAgICAgdmFyIGUxID0gX3BbNF07XG4gICAgICB2YXIgZjEgPSBfcFs1XTtcbiAgICAgIHZhciBnMSA9IF9wWzZdO1xuICAgICAgdmFyIGgxID0gX3BbN107XG4gICAgICB2YXIgaTEgPSBfcFs4XTtcbiAgICAgIHZhciBqMSA9IF9wWzldO1xuICAgICAgdmFyIGsxID0gX3BbMTBdO1xuICAgICAgdmFyIGwxID0gX3BbMTFdO1xuICAgICAgdmFyIG0xID0gX3BbMTJdO1xuICAgICAgdmFyIG4xID0gX3BbMTNdO1xuICAgICAgdmFyIG8xID0gX3BbMTRdO1xuICAgICAgdmFyIHAxID0gX3BbMTVdO1xuXG4gICAgICAvKiBtYXRyaXggb3JkZXIgKGNhbnZhcyBjb21wYXRpYmxlKTpcbiAgICAgICAgICAgKiBhY2VcbiAgICAgICAgICAgKiBiZGZcbiAgICAgICAgICAgKiAwMDFcbiAgICAgICAgICAgKi9cbiAgICAgIF9wWzBdID0gYTEgKiBhMiArIGIxICogZTIgKyBjMSAqIGkyICsgZDEgKiBtMjtcbiAgICAgIF9wWzFdID0gYTEgKiBiMiArIGIxICogZjIgKyBjMSAqIGoyICsgZDEgKiBuMjtcbiAgICAgIF9wWzJdID0gYTEgKiBjMiArIGIxICogZzIgKyBjMSAqIGsyICsgZDEgKiBvMjtcbiAgICAgIF9wWzNdID0gYTEgKiBkMiArIGIxICogaDIgKyBjMSAqIGwyICsgZDEgKiBwMjtcbiAgICAgIF9wWzRdID0gZTEgKiBhMiArIGYxICogZTIgKyBnMSAqIGkyICsgaDEgKiBtMjtcbiAgICAgIF9wWzVdID0gZTEgKiBiMiArIGYxICogZjIgKyBnMSAqIGoyICsgaDEgKiBuMjtcbiAgICAgIF9wWzZdID0gZTEgKiBjMiArIGYxICogZzIgKyBnMSAqIGsyICsgaDEgKiBvMjtcbiAgICAgIF9wWzddID0gZTEgKiBkMiArIGYxICogaDIgKyBnMSAqIGwyICsgaDEgKiBwMjtcbiAgICAgIF9wWzhdID0gaTEgKiBhMiArIGoxICogZTIgKyBrMSAqIGkyICsgbDEgKiBtMjtcbiAgICAgIF9wWzldID0gaTEgKiBiMiArIGoxICogZjIgKyBrMSAqIGoyICsgbDEgKiBuMjtcbiAgICAgIF9wWzEwXSA9IGkxICogYzIgKyBqMSAqIGcyICsgazEgKiBrMiArIGwxICogbzI7XG4gICAgICBfcFsxMV0gPSBpMSAqIGQyICsgajEgKiBoMiArIGsxICogbDIgKyBsMSAqIHAyO1xuICAgICAgX3BbMTJdID0gbTEgKiBhMiArIG4xICogZTIgKyBvMSAqIGkyICsgcDEgKiBtMjtcbiAgICAgIF9wWzEzXSA9IG0xICogYjIgKyBuMSAqIGYyICsgbzEgKiBqMiArIHAxICogbjI7XG4gICAgICBfcFsxNF0gPSBtMSAqIGMyICsgbjEgKiBnMiArIG8xICogazIgKyBwMSAqIG8yO1xuICAgICAgX3BbMTVdID0gbTEgKiBkMiArIG4xICogaDIgKyBvMSAqIGwyICsgcDEgKiBwMjtcbiAgICAgIHRoaXMuX2lkZW50aXR5Q2FsY3VsYXRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11bHRpcGx5KG1hdHJpeCkge1xuICAgICAgdmFyIG1hdHJpeFByb3BzID0gbWF0cml4LnByb3BzO1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG1hdHJpeFByb3BzWzBdLCBtYXRyaXhQcm9wc1sxXSwgbWF0cml4UHJvcHNbMl0sIG1hdHJpeFByb3BzWzNdLCBtYXRyaXhQcm9wc1s0XSwgbWF0cml4UHJvcHNbNV0sIG1hdHJpeFByb3BzWzZdLCBtYXRyaXhQcm9wc1s3XSwgbWF0cml4UHJvcHNbOF0sIG1hdHJpeFByb3BzWzldLCBtYXRyaXhQcm9wc1sxMF0sIG1hdHJpeFByb3BzWzExXSwgbWF0cml4UHJvcHNbMTJdLCBtYXRyaXhQcm9wc1sxM10sIG1hdHJpeFByb3BzWzE0XSwgbWF0cml4UHJvcHNbMTVdKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNJZGVudGl0eSgpIHtcbiAgICAgIGlmICghdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkKSB7XG4gICAgICAgIHRoaXMuX2lkZW50aXR5ID0gISh0aGlzLnByb3BzWzBdICE9PSAxIHx8IHRoaXMucHJvcHNbMV0gIT09IDAgfHwgdGhpcy5wcm9wc1syXSAhPT0gMCB8fCB0aGlzLnByb3BzWzNdICE9PSAwIHx8IHRoaXMucHJvcHNbNF0gIT09IDAgfHwgdGhpcy5wcm9wc1s1XSAhPT0gMSB8fCB0aGlzLnByb3BzWzZdICE9PSAwIHx8IHRoaXMucHJvcHNbN10gIT09IDAgfHwgdGhpcy5wcm9wc1s4XSAhPT0gMCB8fCB0aGlzLnByb3BzWzldICE9PSAwIHx8IHRoaXMucHJvcHNbMTBdICE9PSAxIHx8IHRoaXMucHJvcHNbMTFdICE9PSAwIHx8IHRoaXMucHJvcHNbMTJdICE9PSAwIHx8IHRoaXMucHJvcHNbMTNdICE9PSAwIHx8IHRoaXMucHJvcHNbMTRdICE9PSAwIHx8IHRoaXMucHJvcHNbMTVdICE9PSAxKTtcbiAgICAgICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9pZGVudGl0eTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZXF1YWxzKG1hdHIpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHdoaWxlIChpIDwgMTYpIHtcbiAgICAgICAgaWYgKG1hdHIucHJvcHNbaV0gIT09IHRoaXMucHJvcHNbaV0pIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsb25lKG1hdHIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgbWF0ci5wcm9wc1tpXSA9IHRoaXMucHJvcHNbaV07XG4gICAgICB9XG4gICAgICByZXR1cm4gbWF0cjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2xvbmVGcm9tUHJvcHMocHJvcHMpIHtcbiAgICAgIHZhciBpO1xuICAgICAgZm9yIChpID0gMDsgaSA8IDE2OyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5wcm9wc1tpXSA9IHByb3BzW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVRvUG9pbnQoeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeDogeCAqIHRoaXMucHJvcHNbMF0gKyB5ICogdGhpcy5wcm9wc1s0XSArIHogKiB0aGlzLnByb3BzWzhdICsgdGhpcy5wcm9wc1sxMl0sXG4gICAgICAgIHk6IHggKiB0aGlzLnByb3BzWzFdICsgeSAqIHRoaXMucHJvcHNbNV0gKyB6ICogdGhpcy5wcm9wc1s5XSArIHRoaXMucHJvcHNbMTNdLFxuICAgICAgICB6OiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF1cbiAgICAgIH07XG4gICAgICAvKiByZXR1cm4ge1xuICAgICAgICAgICB4OiB4ICogbWUuYSArIHkgKiBtZS5jICsgbWUuZSxcbiAgICAgICAgICAgeTogeCAqIG1lLmIgKyB5ICogbWUuZCArIG1lLmZcbiAgICAgICAgICAgfTsgKi9cbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlUb1goeCwgeSwgeikge1xuICAgICAgcmV0dXJuIHggKiB0aGlzLnByb3BzWzBdICsgeSAqIHRoaXMucHJvcHNbNF0gKyB6ICogdGhpcy5wcm9wc1s4XSArIHRoaXMucHJvcHNbMTJdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVRvWSh4LCB5LCB6KSB7XG4gICAgICByZXR1cm4geCAqIHRoaXMucHJvcHNbMV0gKyB5ICogdGhpcy5wcm9wc1s1XSArIHogKiB0aGlzLnByb3BzWzldICsgdGhpcy5wcm9wc1sxM107XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5VG9aKHgsIHksIHopIHtcbiAgICAgIHJldHVybiB4ICogdGhpcy5wcm9wc1syXSArIHkgKiB0aGlzLnByb3BzWzZdICsgeiAqIHRoaXMucHJvcHNbMTBdICsgdGhpcy5wcm9wc1sxNF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldEludmVyc2VNYXRyaXgoKSB7XG4gICAgICB2YXIgZGV0ZXJtaW5hbnQgPSB0aGlzLnByb3BzWzBdICogdGhpcy5wcm9wc1s1XSAtIHRoaXMucHJvcHNbMV0gKiB0aGlzLnByb3BzWzRdO1xuICAgICAgdmFyIGEgPSB0aGlzLnByb3BzWzVdIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB2YXIgYiA9IC10aGlzLnByb3BzWzFdIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB2YXIgYyA9IC10aGlzLnByb3BzWzRdIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB2YXIgZCA9IHRoaXMucHJvcHNbMF0gLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBlID0gKHRoaXMucHJvcHNbNF0gKiB0aGlzLnByb3BzWzEzXSAtIHRoaXMucHJvcHNbNV0gKiB0aGlzLnByb3BzWzEyXSkgLyBkZXRlcm1pbmFudDtcbiAgICAgIHZhciBmID0gLSh0aGlzLnByb3BzWzBdICogdGhpcy5wcm9wc1sxM10gLSB0aGlzLnByb3BzWzFdICogdGhpcy5wcm9wc1sxMl0pIC8gZGV0ZXJtaW5hbnQ7XG4gICAgICB2YXIgaW52ZXJzZU1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbMF0gPSBhO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1sxXSA9IGI7XG4gICAgICBpbnZlcnNlTWF0cml4LnByb3BzWzRdID0gYztcbiAgICAgIGludmVyc2VNYXRyaXgucHJvcHNbNV0gPSBkO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1sxMl0gPSBlO1xuICAgICAgaW52ZXJzZU1hdHJpeC5wcm9wc1sxM10gPSBmO1xuICAgICAgcmV0dXJuIGludmVyc2VNYXRyaXg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludChwdCkge1xuICAgICAgdmFyIGludmVyc2VNYXRyaXggPSB0aGlzLmdldEludmVyc2VNYXRyaXgoKTtcbiAgICAgIHJldHVybiBpbnZlcnNlTWF0cml4LmFwcGx5VG9Qb2ludEFycmF5KHB0WzBdLCBwdFsxXSwgcHRbMl0gfHwgMCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGludmVyc2VQb2ludHMocHRzKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwdHMubGVuZ3RoO1xuICAgICAgdmFyIHJldFB0cyA9IFtdO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHJldFB0c1tpXSA9IGludmVyc2VQb2ludChwdHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJldFB0cztcbiAgICB9XG4gICAgZnVuY3Rpb24gYXBwbHlUb1RyaXBsZVBvaW50cyhwdDEsIHB0MiwgcHQzKSB7XG4gICAgICB2YXIgYXJyID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDYpO1xuICAgICAgaWYgKHRoaXMuaXNJZGVudGl0eSgpKSB7XG4gICAgICAgIGFyclswXSA9IHB0MVswXTtcbiAgICAgICAgYXJyWzFdID0gcHQxWzFdO1xuICAgICAgICBhcnJbMl0gPSBwdDJbMF07XG4gICAgICAgIGFyclszXSA9IHB0MlsxXTtcbiAgICAgICAgYXJyWzRdID0gcHQzWzBdO1xuICAgICAgICBhcnJbNV0gPSBwdDNbMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcDAgPSB0aGlzLnByb3BzWzBdO1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnByb3BzWzFdO1xuICAgICAgICB2YXIgcDQgPSB0aGlzLnByb3BzWzRdO1xuICAgICAgICB2YXIgcDUgPSB0aGlzLnByb3BzWzVdO1xuICAgICAgICB2YXIgcDEyID0gdGhpcy5wcm9wc1sxMl07XG4gICAgICAgIHZhciBwMTMgPSB0aGlzLnByb3BzWzEzXTtcbiAgICAgICAgYXJyWzBdID0gcHQxWzBdICogcDAgKyBwdDFbMV0gKiBwNCArIHAxMjtcbiAgICAgICAgYXJyWzFdID0gcHQxWzBdICogcDEgKyBwdDFbMV0gKiBwNSArIHAxMztcbiAgICAgICAgYXJyWzJdID0gcHQyWzBdICogcDAgKyBwdDJbMV0gKiBwNCArIHAxMjtcbiAgICAgICAgYXJyWzNdID0gcHQyWzBdICogcDEgKyBwdDJbMV0gKiBwNSArIHAxMztcbiAgICAgICAgYXJyWzRdID0gcHQzWzBdICogcDAgKyBwdDNbMV0gKiBwNCArIHAxMjtcbiAgICAgICAgYXJyWzVdID0gcHQzWzBdICogcDEgKyBwdDNbMV0gKiBwNSArIHAxMztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludEFycmF5KHgsIHksIHopIHtcbiAgICAgIHZhciBhcnI7XG4gICAgICBpZiAodGhpcy5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgYXJyID0gW3gsIHksIHpdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJyID0gW3ggKiB0aGlzLnByb3BzWzBdICsgeSAqIHRoaXMucHJvcHNbNF0gKyB6ICogdGhpcy5wcm9wc1s4XSArIHRoaXMucHJvcHNbMTJdLCB4ICogdGhpcy5wcm9wc1sxXSArIHkgKiB0aGlzLnByb3BzWzVdICsgeiAqIHRoaXMucHJvcHNbOV0gKyB0aGlzLnByb3BzWzEzXSwgeCAqIHRoaXMucHJvcHNbMl0gKyB5ICogdGhpcy5wcm9wc1s2XSArIHogKiB0aGlzLnByb3BzWzEwXSArIHRoaXMucHJvcHNbMTRdXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKHgsIHkpIHtcbiAgICAgIGlmICh0aGlzLmlzSWRlbnRpdHkoKSkge1xuICAgICAgICByZXR1cm4geCArICcsJyArIHk7XG4gICAgICB9XG4gICAgICB2YXIgX3AgPSB0aGlzLnByb3BzO1xuICAgICAgcmV0dXJuIE1hdGgucm91bmQoKHggKiBfcFswXSArIHkgKiBfcFs0XSArIF9wWzEyXSkgKiAxMDApIC8gMTAwICsgJywnICsgTWF0aC5yb3VuZCgoeCAqIF9wWzFdICsgeSAqIF9wWzVdICsgX3BbMTNdKSAqIDEwMCkgLyAxMDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvQ1NTKCkge1xuICAgICAgLy8gRG9lc24ndCBtYWtlIG11Y2ggc2Vuc2UgdG8gYWRkIHRoaXMgb3B0aW1pemF0aW9uLiBJZiBpdCBpcyBhbiBpZGVudGl0eSBtYXRyaXgsIGl0J3MgdmVyeSBsaWtlbHkgdGhpcyB3aWxsIGdldCBjYWxsZWQgb25seSBvbmNlIHNpbmNlIGl0IHdvbid0IGJlIGtleWZyYW1lZC5cbiAgICAgIC8qIGlmKHRoaXMuaXNJZGVudGl0eSgpKSB7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICB9ICovXG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgcHJvcHMgPSB0aGlzLnByb3BzO1xuICAgICAgdmFyIGNzc1ZhbHVlID0gJ21hdHJpeDNkKCc7XG4gICAgICB2YXIgdiA9IDEwMDAwO1xuICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICBjc3NWYWx1ZSArPSBfcm5kKHByb3BzW2ldICogdikgLyB2O1xuICAgICAgICBjc3NWYWx1ZSArPSBpID09PSAxNSA/ICcpJyA6ICcsJztcbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNzc1ZhbHVlO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3VuZE1hdHJpeFByb3BlcnR5KHZhbCkge1xuICAgICAgdmFyIHYgPSAxMDAwMDtcbiAgICAgIGlmICh2YWwgPCAwLjAwMDAwMSAmJiB2YWwgPiAwIHx8IHZhbCA+IC0wLjAwMDAwMSAmJiB2YWwgPCAwKSB7XG4gICAgICAgIHJldHVybiBfcm5kKHZhbCAqIHYpIC8gdjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvMmRDU1MoKSB7XG4gICAgICAvLyBEb2Vzbid0IG1ha2UgbXVjaCBzZW5zZSB0byBhZGQgdGhpcyBvcHRpbWl6YXRpb24uIElmIGl0IGlzIGFuIGlkZW50aXR5IG1hdHJpeCwgaXQncyB2ZXJ5IGxpa2VseSB0aGlzIHdpbGwgZ2V0IGNhbGxlZCBvbmx5IG9uY2Ugc2luY2UgaXQgd29uJ3QgYmUga2V5ZnJhbWVkLlxuICAgICAgLyogaWYodGhpcy5pc0lkZW50aXR5KCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICAgIH0gKi9cbiAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XG4gICAgICB2YXIgX2EgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzBdKTtcbiAgICAgIHZhciBfYiA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbMV0pO1xuICAgICAgdmFyIF9jID0gcm91bmRNYXRyaXhQcm9wZXJ0eShwcm9wc1s0XSk7XG4gICAgICB2YXIgX2QgPSByb3VuZE1hdHJpeFByb3BlcnR5KHByb3BzWzVdKTtcbiAgICAgIHZhciBfZSA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbMTJdKTtcbiAgICAgIHZhciBfZiA9IHJvdW5kTWF0cml4UHJvcGVydHkocHJvcHNbMTNdKTtcbiAgICAgIHJldHVybiAnbWF0cml4KCcgKyBfYSArICcsJyArIF9iICsgJywnICsgX2MgKyAnLCcgKyBfZCArICcsJyArIF9lICsgJywnICsgX2YgKyAnKSc7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICB0aGlzLnJlc2V0ID0gcmVzZXQ7XG4gICAgICB0aGlzLnJvdGF0ZSA9IHJvdGF0ZTtcbiAgICAgIHRoaXMucm90YXRlWCA9IHJvdGF0ZVg7XG4gICAgICB0aGlzLnJvdGF0ZVkgPSByb3RhdGVZO1xuICAgICAgdGhpcy5yb3RhdGVaID0gcm90YXRlWjtcbiAgICAgIHRoaXMuc2tldyA9IHNrZXc7XG4gICAgICB0aGlzLnNrZXdGcm9tQXhpcyA9IHNrZXdGcm9tQXhpcztcbiAgICAgIHRoaXMuc2hlYXIgPSBzaGVhcjtcbiAgICAgIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgICAgIHRoaXMuc2V0VHJhbnNmb3JtID0gc2V0VHJhbnNmb3JtO1xuICAgICAgdGhpcy50cmFuc2xhdGUgPSB0cmFuc2xhdGU7XG4gICAgICB0aGlzLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICAgIHRoaXMubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICAgIHRoaXMuYXBwbHlUb1BvaW50ID0gYXBwbHlUb1BvaW50O1xuICAgICAgdGhpcy5hcHBseVRvWCA9IGFwcGx5VG9YO1xuICAgICAgdGhpcy5hcHBseVRvWSA9IGFwcGx5VG9ZO1xuICAgICAgdGhpcy5hcHBseVRvWiA9IGFwcGx5VG9aO1xuICAgICAgdGhpcy5hcHBseVRvUG9pbnRBcnJheSA9IGFwcGx5VG9Qb2ludEFycmF5O1xuICAgICAgdGhpcy5hcHBseVRvVHJpcGxlUG9pbnRzID0gYXBwbHlUb1RyaXBsZVBvaW50cztcbiAgICAgIHRoaXMuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQgPSBhcHBseVRvUG9pbnRTdHJpbmdpZmllZDtcbiAgICAgIHRoaXMudG9DU1MgPSB0b0NTUztcbiAgICAgIHRoaXMudG8yZENTUyA9IHRvMmRDU1M7XG4gICAgICB0aGlzLmNsb25lID0gY2xvbmU7XG4gICAgICB0aGlzLmNsb25lRnJvbVByb3BzID0gY2xvbmVGcm9tUHJvcHM7XG4gICAgICB0aGlzLmVxdWFscyA9IGVxdWFscztcbiAgICAgIHRoaXMuaW52ZXJzZVBvaW50cyA9IGludmVyc2VQb2ludHM7XG4gICAgICB0aGlzLmludmVyc2VQb2ludCA9IGludmVyc2VQb2ludDtcbiAgICAgIHRoaXMuZ2V0SW52ZXJzZU1hdHJpeCA9IGdldEludmVyc2VNYXRyaXg7XG4gICAgICB0aGlzLl90ID0gdGhpcy50cmFuc2Zvcm07XG4gICAgICB0aGlzLmlzSWRlbnRpdHkgPSBpc0lkZW50aXR5O1xuICAgICAgdGhpcy5faWRlbnRpdHkgPSB0cnVlO1xuICAgICAgdGhpcy5faWRlbnRpdHlDYWxjdWxhdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnByb3BzID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDE2KTtcbiAgICAgIHRoaXMucmVzZXQoKTtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQzKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiQzID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2YkMyhvKTsgfVxuICB2YXIgbG90dGllID0ge307XG4gIHZhciBzdGFuZGFsb25lID0gJ19fW1NUQU5EQUxPTkVdX18nO1xuICB2YXIgYW5pbWF0aW9uRGF0YSA9ICdfX1tBTklNQVRJT05EQVRBXV9fJztcbiAgdmFyIHJlbmRlcmVyID0gJyc7XG4gIGZ1bmN0aW9uIHNldExvY2F0aW9uKGhyZWYpIHtcbiAgICBzZXRMb2NhdGlvbkhyZWYoaHJlZik7XG4gIH1cbiAgZnVuY3Rpb24gc2VhcmNoQW5pbWF0aW9ucygpIHtcbiAgICBpZiAoc3RhbmRhbG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5zZWFyY2hBbmltYXRpb25zKGFuaW1hdGlvbkRhdGEsIHN0YW5kYWxvbmUsIHJlbmRlcmVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYW5pbWF0aW9uTWFuYWdlci5zZWFyY2hBbmltYXRpb25zKCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHNldFN1YmZyYW1lUmVuZGVyaW5nKGZsYWcpIHtcbiAgICBzZXRTdWJmcmFtZUVuYWJsZWQoZmxhZyk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0UHJlZml4KHByZWZpeCkge1xuICAgIHNldElkUHJlZml4KHByZWZpeCk7XG4gIH1cbiAgZnVuY3Rpb24gbG9hZEFuaW1hdGlvbihwYXJhbXMpIHtcbiAgICBpZiAoc3RhbmRhbG9uZSA9PT0gdHJ1ZSkge1xuICAgICAgcGFyYW1zLmFuaW1hdGlvbkRhdGEgPSBKU09OLnBhcnNlKGFuaW1hdGlvbkRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gYW5pbWF0aW9uTWFuYWdlci5sb2FkQW5pbWF0aW9uKHBhcmFtcyk7XG4gIH1cbiAgZnVuY3Rpb24gc2V0UXVhbGl0eSh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ2hpZ2gnOlxuICAgICAgICAgIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKDIwMCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGNhc2UgJ21lZGl1bSc6XG4gICAgICAgICAgc2V0RGVmYXVsdEN1cnZlU2VnbWVudHMoNTApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsb3cnOlxuICAgICAgICAgIHNldERlZmF1bHRDdXJ2ZVNlZ21lbnRzKDEwKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFpc05hTih2YWx1ZSkgJiYgdmFsdWUgPiAxKSB7XG4gICAgICBzZXREZWZhdWx0Q3VydmVTZWdtZW50cyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChnZXREZWZhdWx0Q3VydmVTZWdtZW50cygpID49IDUwKSB7XG4gICAgICByb3VuZFZhbHVlcyhmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJvdW5kVmFsdWVzKHRydWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbkJyb3dzZXIoKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnO1xuICB9XG4gIGZ1bmN0aW9uIGluc3RhbGxQbHVnaW4odHlwZSwgcGx1Z2luKSB7XG4gICAgaWYgKHR5cGUgPT09ICdleHByZXNzaW9ucycpIHtcbiAgICAgIHNldEV4cHJlc3Npb25zUGx1Z2luKHBsdWdpbik7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldEZhY3RvcnkobmFtZSkge1xuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAncHJvcGVydHlGYWN0b3J5JzpcbiAgICAgICAgcmV0dXJuIFByb3BlcnR5RmFjdG9yeTtcbiAgICAgIGNhc2UgJ3NoYXBlUHJvcGVydHlGYWN0b3J5JzpcbiAgICAgICAgcmV0dXJuIFNoYXBlUHJvcGVydHlGYWN0b3J5O1xuICAgICAgY2FzZSAnbWF0cml4JzpcbiAgICAgICAgcmV0dXJuIE1hdHJpeDtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBsb3R0aWUucGxheSA9IGFuaW1hdGlvbk1hbmFnZXIucGxheTtcbiAgbG90dGllLnBhdXNlID0gYW5pbWF0aW9uTWFuYWdlci5wYXVzZTtcbiAgbG90dGllLnNldExvY2F0aW9uSHJlZiA9IHNldExvY2F0aW9uO1xuICBsb3R0aWUudG9nZ2xlUGF1c2UgPSBhbmltYXRpb25NYW5hZ2VyLnRvZ2dsZVBhdXNlO1xuICBsb3R0aWUuc2V0U3BlZWQgPSBhbmltYXRpb25NYW5hZ2VyLnNldFNwZWVkO1xuICBsb3R0aWUuc2V0RGlyZWN0aW9uID0gYW5pbWF0aW9uTWFuYWdlci5zZXREaXJlY3Rpb247XG4gIGxvdHRpZS5zdG9wID0gYW5pbWF0aW9uTWFuYWdlci5zdG9wO1xuICBsb3R0aWUuc2VhcmNoQW5pbWF0aW9ucyA9IHNlYXJjaEFuaW1hdGlvbnM7XG4gIGxvdHRpZS5yZWdpc3RlckFuaW1hdGlvbiA9IGFuaW1hdGlvbk1hbmFnZXIucmVnaXN0ZXJBbmltYXRpb247XG4gIGxvdHRpZS5sb2FkQW5pbWF0aW9uID0gbG9hZEFuaW1hdGlvbjtcbiAgbG90dGllLnNldFN1YmZyYW1lUmVuZGVyaW5nID0gc2V0U3ViZnJhbWVSZW5kZXJpbmc7XG4gIGxvdHRpZS5yZXNpemUgPSBhbmltYXRpb25NYW5hZ2VyLnJlc2l6ZTtcbiAgLy8gbG90dGllLnN0YXJ0ID0gc3RhcnQ7XG4gIGxvdHRpZS5nb1RvQW5kU3RvcCA9IGFuaW1hdGlvbk1hbmFnZXIuZ29Ub0FuZFN0b3A7XG4gIGxvdHRpZS5kZXN0cm95ID0gYW5pbWF0aW9uTWFuYWdlci5kZXN0cm95O1xuICBsb3R0aWUuc2V0UXVhbGl0eSA9IHNldFF1YWxpdHk7XG4gIGxvdHRpZS5pbkJyb3dzZXIgPSBpbkJyb3dzZXI7XG4gIGxvdHRpZS5pbnN0YWxsUGx1Z2luID0gaW5zdGFsbFBsdWdpbjtcbiAgbG90dGllLmZyZWV6ZSA9IGFuaW1hdGlvbk1hbmFnZXIuZnJlZXplO1xuICBsb3R0aWUudW5mcmVlemUgPSBhbmltYXRpb25NYW5hZ2VyLnVuZnJlZXplO1xuICBsb3R0aWUuc2V0Vm9sdW1lID0gYW5pbWF0aW9uTWFuYWdlci5zZXRWb2x1bWU7XG4gIGxvdHRpZS5tdXRlID0gYW5pbWF0aW9uTWFuYWdlci5tdXRlO1xuICBsb3R0aWUudW5tdXRlID0gYW5pbWF0aW9uTWFuYWdlci51bm11dGU7XG4gIGxvdHRpZS5nZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyA9IGFuaW1hdGlvbk1hbmFnZXIuZ2V0UmVnaXN0ZXJlZEFuaW1hdGlvbnM7XG4gIGxvdHRpZS51c2VXZWJXb3JrZXIgPSBzZXRXZWJXb3JrZXI7XG4gIGxvdHRpZS5zZXRJRFByZWZpeCA9IHNldFByZWZpeDtcbiAgbG90dGllLl9fZ2V0RmFjdG9yeSA9IGdldEZhY3Rvcnk7XG4gIGxvdHRpZS52ZXJzaW9uID0gJzUuMTMuMCc7XG4gIGZ1bmN0aW9uIGNoZWNrUmVhZHkoKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcbiAgICAgIGNsZWFySW50ZXJ2YWwocmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwpO1xuICAgICAgc2VhcmNoQW5pbWF0aW9ucygpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRRdWVyeVZhcmlhYmxlKHZhcmlhYmxlKSB7XG4gICAgdmFyIHZhcnMgPSBxdWVyeVN0cmluZy5zcGxpdCgnJicpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFycy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIHBhaXIgPSB2YXJzW2ldLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAoZGVjb2RlVVJJQ29tcG9uZW50KHBhaXJbMF0pID09IHZhcmlhYmxlKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQocGFpclsxXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHZhciBxdWVyeVN0cmluZyA9ICcnO1xuICBpZiAoc3RhbmRhbG9uZSkge1xuICAgIHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIHZhciBpbmRleCA9IHNjcmlwdHMubGVuZ3RoIC0gMTtcbiAgICB2YXIgbXlTY3JpcHQgPSBzY3JpcHRzW2luZGV4XSB8fCB7XG4gICAgICBzcmM6ICcnXG4gICAgfTtcbiAgICBxdWVyeVN0cmluZyA9IG15U2NyaXB0LnNyYyA/IG15U2NyaXB0LnNyYy5yZXBsYWNlKC9eW15cXD9dK1xcPz8vLCAnJykgOiAnJzsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11c2VsZXNzLWVzY2FwZVxuICAgIHJlbmRlcmVyID0gZ2V0UXVlcnlWYXJpYWJsZSgncmVuZGVyZXInKTtcbiAgfVxuICB2YXIgcmVhZHlTdGF0ZUNoZWNrSW50ZXJ2YWwgPSBzZXRJbnRlcnZhbChjaGVja1JlYWR5LCAxMDApO1xuXG4gIC8vIHRoaXMgYWRkcyBib2R5bW92aW4gdG8gdGhlIHdpbmRvdyBvYmplY3QgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG4gIHRyeSB7XG4gICAgaWYgKCEoKHR5cGVvZiBleHBvcnRzID09PSBcInVuZGVmaW5lZFwiID8gXCJ1bmRlZmluZWRcIiA6IF90eXBlb2YkMyhleHBvcnRzKSkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKSAmJiAhKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuICAgICkge1xuICAgICAgd2luZG93LmJvZHltb3ZpbiA9IGxvdHRpZTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vXG4gIH1cblxuICB2YXIgU2hhcGVNb2RpZmllcnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgdmFyIG1vZGlmaWVycyA9IHt9O1xuICAgIG9iLnJlZ2lzdGVyTW9kaWZpZXIgPSByZWdpc3Rlck1vZGlmaWVyO1xuICAgIG9iLmdldE1vZGlmaWVyID0gZ2V0TW9kaWZpZXI7XG4gICAgZnVuY3Rpb24gcmVnaXN0ZXJNb2RpZmllcihubSwgZmFjdG9yeSkge1xuICAgICAgaWYgKCFtb2RpZmllcnNbbm1dKSB7XG4gICAgICAgIG1vZGlmaWVyc1tubV0gPSBmYWN0b3J5O1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRNb2RpZmllcihubSwgZWxlbSwgZGF0YSkge1xuICAgICAgcmV0dXJuIG5ldyBtb2RpZmllcnNbbm1dKGVsZW0sIGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcbiAgZnVuY3Rpb24gU2hhcGVNb2RpZmllcigpIHt9XG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoKSB7fTtcbiAgU2hhcGVNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGVUb01vZGlmaWVyID0gZnVuY3Rpb24gKCkge307XG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmFkZFNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuY2xvc2VkKSB7XG4gICAgICAvLyBBZGRpbmcgc2hhcGUgdG8gZHluYW1pYyBwcm9wZXJ0aWVzLiBJdCBjb3ZlcnMgdGhlIGNhc2Ugd2hlcmUgYSBzaGFwZSBoYXMgbm8gZWZmZWN0cyBhcHBsaWVkLCB0byByZXNldCBpdCdzIF9tZGYgc3RhdGUgb24gZXZlcnkgdGljay5cbiAgICAgIGRhdGEuc2guY29udGFpbmVyLmFkZER5bmFtaWNQcm9wZXJ0eShkYXRhLnNoKTtcbiAgICAgIHZhciBzaGFwZURhdGEgPSB7XG4gICAgICAgIHNoYXBlOiBkYXRhLnNoLFxuICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbjogc2hhcGVDb2xsZWN0aW9uUG9vbC5uZXdTaGFwZUNvbGxlY3Rpb24oKVxuICAgICAgfTtcbiAgICAgIHRoaXMuc2hhcGVzLnB1c2goc2hhcGVEYXRhKTtcbiAgICAgIHRoaXMuYWRkU2hhcGVUb01vZGlmaWVyKHNoYXBlRGF0YSk7XG4gICAgICBpZiAodGhpcy5faXNBbmltYXRlZCkge1xuICAgICAgICBkYXRhLnNldEFzQW5pbWF0ZWQoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNoYXBlTW9kaWZpZXIucHJvdG90eXBlLmluaXQgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuc2hhcGVzID0gW107XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzKGVsZW0sIGRhdGEpO1xuICAgIHRoaXMuZnJhbWVJZCA9IGluaXRpYWxEZWZhdWx0RnJhbWU7XG4gICAgdGhpcy5jbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuayA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgfVxuICB9O1xuICBTaGFwZU1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzS2V5cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gICAgdGhpcy5pdGVyYXRlRHluYW1pY1Byb3BlcnRpZXMoKTtcbiAgfTtcbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBTaGFwZU1vZGlmaWVyKTtcblxuICBmdW5jdGlvbiBUcmltTW9kaWZpZXIoKSB7fVxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBUcmltTW9kaWZpZXIpO1xuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMCwgMC4wMSwgdGhpcyk7XG4gICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAsIHRoaXMpO1xuICAgIHRoaXMuc1ZhbHVlID0gMDtcbiAgICB0aGlzLmVWYWx1ZSA9IDA7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5tID0gZGF0YS5tO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoIHx8ICEhdGhpcy5lLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggfHwgISF0aGlzLm8uZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZVRvTW9kaWZpZXIgPSBmdW5jdGlvbiAoc2hhcGVEYXRhKSB7XG4gICAgc2hhcGVEYXRhLnBhdGhzRGF0YSA9IFtdO1xuICB9O1xuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmNhbGN1bGF0ZVNoYXBlRWRnZXMgPSBmdW5jdGlvbiAocywgZSwgc2hhcGVMZW5ndGgsIGFkZGVkTGVuZ3RoLCB0b3RhbE1vZGlmaWVyTGVuZ3RoKSB7XG4gICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgaWYgKGUgPD0gMSkge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IHMsXG4gICAgICAgIGU6IGVcbiAgICAgIH0pO1xuICAgIH0gZWxzZSBpZiAocyA+PSAxKSB7XG4gICAgICBzZWdtZW50cy5wdXNoKHtcbiAgICAgICAgczogcyAtIDEsXG4gICAgICAgIGU6IGUgLSAxXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IHMsXG4gICAgICAgIGU6IDFcbiAgICAgIH0pO1xuICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgIHM6IDAsXG4gICAgICAgIGU6IGUgLSAxXG4gICAgICB9KTtcbiAgICB9XG4gICAgdmFyIHNoYXBlU2VnbWVudHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2VnbWVudHMubGVuZ3RoO1xuICAgIHZhciBzZWdtZW50T2I7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBzZWdtZW50T2IgPSBzZWdtZW50c1tpXTtcbiAgICAgIGlmICghKHNlZ21lbnRPYi5lICogdG90YWxNb2RpZmllckxlbmd0aCA8IGFkZGVkTGVuZ3RoIHx8IHNlZ21lbnRPYi5zICogdG90YWxNb2RpZmllckxlbmd0aCA+IGFkZGVkTGVuZ3RoICsgc2hhcGVMZW5ndGgpKSB7XG4gICAgICAgIHZhciBzaGFwZVM7XG4gICAgICAgIHZhciBzaGFwZUU7XG4gICAgICAgIGlmIChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggPD0gYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZVMgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlUyA9IChzZWdtZW50T2IucyAqIHRvdGFsTW9kaWZpZXJMZW5ndGggLSBhZGRlZExlbmd0aCkgLyBzaGFwZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VnbWVudE9iLmUgKiB0b3RhbE1vZGlmaWVyTGVuZ3RoID49IGFkZGVkTGVuZ3RoICsgc2hhcGVMZW5ndGgpIHtcbiAgICAgICAgICBzaGFwZUUgPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNoYXBlRSA9IChzZWdtZW50T2IuZSAqIHRvdGFsTW9kaWZpZXJMZW5ndGggLSBhZGRlZExlbmd0aCkgLyBzaGFwZUxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzaGFwZVNlZ21lbnRzLnB1c2goW3NoYXBlUywgc2hhcGVFXSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghc2hhcGVTZWdtZW50cy5sZW5ndGgpIHtcbiAgICAgIHNoYXBlU2VnbWVudHMucHVzaChbMCwgMF0pO1xuICAgIH1cbiAgICByZXR1cm4gc2hhcGVTZWdtZW50cztcbiAgfTtcbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5yZWxlYXNlUGF0aHNEYXRhID0gZnVuY3Rpb24gKHBhdGhzRGF0YSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBwYXRoc0RhdGEubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2VnbWVudHNMZW5ndGhQb29sLnJlbGVhc2UocGF0aHNEYXRhW2ldKTtcbiAgICB9XG4gICAgcGF0aHNEYXRhLmxlbmd0aCA9IDA7XG4gICAgcmV0dXJuIHBhdGhzRGF0YTtcbiAgfTtcbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgcztcbiAgICB2YXIgZTtcbiAgICBpZiAodGhpcy5fbWRmIHx8IF9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBvID0gdGhpcy5vLnYgJSAzNjAgLyAzNjA7XG4gICAgICBpZiAobyA8IDApIHtcbiAgICAgICAgbyArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucy52ID4gMSkge1xuICAgICAgICBzID0gMSArIG87XG4gICAgICB9IGVsc2UgaWYgKHRoaXMucy52IDwgMCkge1xuICAgICAgICBzID0gMCArIG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gdGhpcy5zLnYgKyBvO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZS52ID4gMSkge1xuICAgICAgICBlID0gMSArIG87XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZS52IDwgMCkge1xuICAgICAgICBlID0gMCArIG87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlID0gdGhpcy5lLnYgKyBvO1xuICAgICAgfVxuICAgICAgaWYgKHMgPiBlKSB7XG4gICAgICAgIHZhciBfcyA9IHM7XG4gICAgICAgIHMgPSBlO1xuICAgICAgICBlID0gX3M7XG4gICAgICB9XG4gICAgICBzID0gTWF0aC5yb3VuZChzICogMTAwMDApICogMC4wMDAxO1xuICAgICAgZSA9IE1hdGgucm91bmQoZSAqIDEwMDAwKSAqIDAuMDAwMTtcbiAgICAgIHRoaXMuc1ZhbHVlID0gcztcbiAgICAgIHRoaXMuZVZhbHVlID0gZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcyA9IHRoaXMuc1ZhbHVlO1xuICAgICAgZSA9IHRoaXMuZVZhbHVlO1xuICAgIH1cbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBwYXRoc0RhdGE7XG4gICAgdmFyIHBhdGhEYXRhO1xuICAgIHZhciB0b3RhbFNoYXBlTGVuZ3RoO1xuICAgIHZhciB0b3RhbE1vZGlmaWVyTGVuZ3RoID0gMDtcbiAgICBpZiAoZSA9PT0gcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLmxvY2FsU2hhcGVDb2xsZWN0aW9uLnJlbGVhc2VTaGFwZXMoKTtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICAgIHRoaXMuc2hhcGVzW2ldLnNoYXBlLnBhdGhzID0gdGhpcy5zaGFwZXNbaV0ubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgICAgICB0aGlzLnNoYXBlc1tpXS5wYXRoc0RhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIShlID09PSAxICYmIHMgPT09IDAgfHwgZSA9PT0gMCAmJiBzID09PSAxKSkge1xuICAgICAgdmFyIHNlZ21lbnRzID0gW107XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xuICAgICAgICAvLyBpZiBzaGFwZSBoYXNuJ3QgY2hhbmdlZCBhbmQgdHJpbSBwcm9wZXJ0aWVzIGhhdmVuJ3QgY2hhbmdlZCwgY2FjaGVkIHByZXZpb3VzIHBhdGggY2FuIGJlIHVzZWRcbiAgICAgICAgaWYgKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiAhdGhpcy5fbWRmICYmICFfaXNGaXJzdEZyYW1lICYmIHRoaXMubSAhPT0gMikge1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzO1xuICAgICAgICAgIGpMZW4gPSBzaGFwZVBhdGhzLl9sZW5ndGg7XG4gICAgICAgICAgdG90YWxTaGFwZUxlbmd0aCA9IDA7XG4gICAgICAgICAgaWYgKCFzaGFwZURhdGEuc2hhcGUuX21kZiAmJiBzaGFwZURhdGEucGF0aHNEYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgdG90YWxTaGFwZUxlbmd0aCA9IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwYXRoc0RhdGEgPSB0aGlzLnJlbGVhc2VQYXRoc0RhdGEoc2hhcGVEYXRhLnBhdGhzRGF0YSk7XG4gICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhEYXRhID0gYmV6LmdldFNlZ21lbnRzTGVuZ3RoKHNoYXBlUGF0aHMuc2hhcGVzW2pdKTtcbiAgICAgICAgICAgICAgcGF0aHNEYXRhLnB1c2gocGF0aERhdGEpO1xuICAgICAgICAgICAgICB0b3RhbFNoYXBlTGVuZ3RoICs9IHBhdGhEYXRhLnRvdGFsTGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggPSB0b3RhbFNoYXBlTGVuZ3RoO1xuICAgICAgICAgICAgc2hhcGVEYXRhLnBhdGhzRGF0YSA9IHBhdGhzRGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG90YWxNb2RpZmllckxlbmd0aCArPSB0b3RhbFNoYXBlTGVuZ3RoO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHNoYXBlUyA9IHM7XG4gICAgICB2YXIgc2hhcGVFID0gZTtcbiAgICAgIHZhciBhZGRlZExlbmd0aCA9IDA7XG4gICAgICB2YXIgZWRnZXM7XG4gICAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzaGFwZURhdGEgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgaWYgKHNoYXBlRGF0YS5zaGFwZS5fbWRmKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24gPSBzaGFwZURhdGEubG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIC8vIGlmIG0gPT09IDIgbWVhbnMgcGF0aHMgYXJlIHRyaW1tZWQgaW5kaXZpZHVhbGx5IHNvIGVkZ2VzIG5lZWQgdG8gYmUgZm91bmQgZm9yIHRoaXMgc3BlY2lmaWMgc2hhcGUgcmVsYXRpdmUgdG8gd2hvZWwgZ3JvdXBcbiAgICAgICAgICBpZiAodGhpcy5tID09PSAyICYmIGxlbiA+IDEpIHtcbiAgICAgICAgICAgIGVkZ2VzID0gdGhpcy5jYWxjdWxhdGVTaGFwZUVkZ2VzKHMsIGUsIHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoLCBhZGRlZExlbmd0aCwgdG90YWxNb2RpZmllckxlbmd0aCk7XG4gICAgICAgICAgICBhZGRlZExlbmd0aCArPSBzaGFwZURhdGEudG90YWxTaGFwZUxlbmd0aDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZWRnZXMgPSBbW3NoYXBlUywgc2hhcGVFXV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGpMZW4gPSBlZGdlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgc2hhcGVTID0gZWRnZXNbal1bMF07XG4gICAgICAgICAgICBzaGFwZUUgPSBlZGdlc1tqXVsxXTtcbiAgICAgICAgICAgIHNlZ21lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBpZiAoc2hhcGVFIDw9IDEpIHtcbiAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgczogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZVMsXG4gICAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZUVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHNoYXBlUyA+PSAxKSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlUyAtIDEpLFxuICAgICAgICAgICAgICAgIGU6IHNoYXBlRGF0YS50b3RhbFNoYXBlTGVuZ3RoICogKHNoYXBlRSAtIDEpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VnbWVudHMucHVzaCh7XG4gICAgICAgICAgICAgICAgczogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiBzaGFwZVMsXG4gICAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGhcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIHNlZ21lbnRzLnB1c2goe1xuICAgICAgICAgICAgICAgIHM6IDAsXG4gICAgICAgICAgICAgICAgZTogc2hhcGVEYXRhLnRvdGFsU2hhcGVMZW5ndGggKiAoc2hhcGVFIC0gMSlcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbmV3U2hhcGVzRGF0YSA9IHRoaXMuYWRkU2hhcGVzKHNoYXBlRGF0YSwgc2VnbWVudHNbMF0pO1xuICAgICAgICAgICAgaWYgKHNlZ21lbnRzWzBdLnMgIT09IHNlZ21lbnRzWzBdLmUpIHtcbiAgICAgICAgICAgICAgaWYgKHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB2YXIgbGFzdFNoYXBlSW5Db2xsZWN0aW9uID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlc1tzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0U2hhcGVJbkNvbGxlY3Rpb24uYykge1xuICAgICAgICAgICAgICAgICAgdmFyIGxhc3RTaGFwZSA9IG5ld1NoYXBlc0RhdGEucG9wKCk7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIG5ld1NoYXBlc0RhdGEgPSB0aGlzLmFkZFNoYXBlcyhzaGFwZURhdGEsIHNlZ21lbnRzWzFdLCBsYXN0U2hhcGUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICB0aGlzLmFkZFBhdGhzKG5ld1NoYXBlc0RhdGEsIGxvY2FsU2hhcGVDb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgIG5ld1NoYXBlc0RhdGEgPSB0aGlzLmFkZFNoYXBlcyhzaGFwZURhdGEsIHNlZ21lbnRzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdGhpcy5hZGRQYXRocyhuZXdTaGFwZXNEYXRhLCBsb2NhbFNoYXBlQ29sbGVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAvLyBSZWxlYXNpZ24gVHJpbSBDYWNoZWQgcGF0aHMgZGF0YSB3aGVuIG5vIHRyaW0gYXBwbGllZCBpbiBjYXNlIHNoYXBlcyBhcmUgbW9kaWZpZWQgaW5iZXR3ZWVuLlxuICAgICAgICAvLyBEb24ndCByZW1vdmUgdGhpcyBldmVuIGlmIGl0J3MgbG9zaW5nIGNhY2hlZCBpbmZvLlxuICAgICAgICB0aGlzLnNoYXBlc1tpXS5wYXRoc0RhdGEubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5zaGFwZXNbaV0uc2hhcGUuX21kZiA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFBhdGhzID0gZnVuY3Rpb24gKG5ld1BhdGhzLCBsb2NhbFNoYXBlQ29sbGVjdGlvbikge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBuZXdQYXRocy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZShuZXdQYXRoc1tpXSk7XG4gICAgfVxuICB9O1xuICBUcmltTW9kaWZpZXIucHJvdG90eXBlLmFkZFNlZ21lbnQgPSBmdW5jdGlvbiAocHQxLCBwdDIsIHB0MywgcHQ0LCBzaGFwZVBhdGgsIHBvcywgbmV3U2hhcGUpIHtcbiAgICBzaGFwZVBhdGguc2V0WFlBdChwdDJbMF0sIHB0MlsxXSwgJ28nLCBwb3MpO1xuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHB0M1swXSwgcHQzWzFdLCAnaScsIHBvcyArIDEpO1xuICAgIGlmIChuZXdTaGFwZSkge1xuICAgICAgc2hhcGVQYXRoLnNldFhZQXQocHQxWzBdLCBwdDFbMV0sICd2JywgcG9zKTtcbiAgICB9XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocHQ0WzBdLCBwdDRbMV0sICd2JywgcG9zICsgMSk7XG4gIH07XG4gIFRyaW1Nb2RpZmllci5wcm90b3R5cGUuYWRkU2VnbWVudEZyb21BcnJheSA9IGZ1bmN0aW9uIChwb2ludHMsIHNoYXBlUGF0aCwgcG9zLCBuZXdTaGFwZSkge1xuICAgIHNoYXBlUGF0aC5zZXRYWUF0KHBvaW50c1sxXSwgcG9pbnRzWzVdLCAnbycsIHBvcyk7XG4gICAgc2hhcGVQYXRoLnNldFhZQXQocG9pbnRzWzJdLCBwb2ludHNbNl0sICdpJywgcG9zICsgMSk7XG4gICAgaWYgKG5ld1NoYXBlKSB7XG4gICAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbMF0sIHBvaW50c1s0XSwgJ3YnLCBwb3MpO1xuICAgIH1cbiAgICBzaGFwZVBhdGguc2V0WFlBdChwb2ludHNbM10sIHBvaW50c1s3XSwgJ3YnLCBwb3MgKyAxKTtcbiAgfTtcbiAgVHJpbU1vZGlmaWVyLnByb3RvdHlwZS5hZGRTaGFwZXMgPSBmdW5jdGlvbiAoc2hhcGVEYXRhLCBzaGFwZVNlZ21lbnQsIHNoYXBlUGF0aCkge1xuICAgIHZhciBwYXRoc0RhdGEgPSBzaGFwZURhdGEucGF0aHNEYXRhO1xuICAgIHZhciBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGFkZGVkTGVuZ3RoID0gMDtcbiAgICB2YXIgY3VycmVudExlbmd0aERhdGE7XG4gICAgdmFyIHNlZ21lbnRDb3VudDtcbiAgICB2YXIgbGVuZ3RocztcbiAgICB2YXIgc2VnbWVudDtcbiAgICB2YXIgc2hhcGVzID0gW107XG4gICAgdmFyIGluaXRQb3M7XG4gICAgdmFyIG5ld1NoYXBlID0gdHJ1ZTtcbiAgICBpZiAoIXNoYXBlUGF0aCkge1xuICAgICAgc2hhcGVQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICAgIHNlZ21lbnRDb3VudCA9IDA7XG4gICAgICBpbml0UG9zID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VnbWVudENvdW50ID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgICBpbml0UG9zID0gc2hhcGVQYXRoLl9sZW5ndGg7XG4gICAgfVxuICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBsZW5ndGhzID0gcGF0aHNEYXRhW2ldLmxlbmd0aHM7XG4gICAgICBzaGFwZVBhdGguYyA9IHNoYXBlUGF0aHNbaV0uYztcbiAgICAgIGpMZW4gPSBzaGFwZVBhdGhzW2ldLmMgPyBsZW5ndGhzLmxlbmd0aCA6IGxlbmd0aHMubGVuZ3RoICsgMTtcbiAgICAgIGZvciAoaiA9IDE7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgY3VycmVudExlbmd0aERhdGEgPSBsZW5ndGhzW2ogLSAxXTtcbiAgICAgICAgaWYgKGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGggPCBzaGFwZVNlZ21lbnQucykge1xuICAgICAgICAgIGFkZGVkTGVuZ3RoICs9IGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xuICAgICAgICAgIHNoYXBlUGF0aC5jID0gZmFsc2U7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNoYXBlU2VnbWVudC5zIDw9IGFkZGVkTGVuZ3RoICYmIHNoYXBlU2VnbWVudC5lID49IGFkZGVkTGVuZ3RoICsgY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbal0sIHNoYXBlUGF0aHNbaV0udltqXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbal0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVtqXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gY3VycmVudExlbmd0aERhdGEuYWRkZWRMZW5ndGgsIChzaGFwZVNlZ21lbnQuZSAtIGFkZGVkTGVuZ3RoKSAvIGN1cnJlbnRMZW5ndGhEYXRhLmFkZGVkTGVuZ3RoLCBsZW5ndGhzW2ogLSAxXSk7XG4gICAgICAgICAgICB0aGlzLmFkZFNlZ21lbnRGcm9tQXJyYXkoc2VnbWVudCwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIC8vIHRoaXMuYWRkU2VnbWVudChzZWdtZW50LnB0MSwgc2VnbWVudC5wdDMsIHNlZ21lbnQucHQ0LCBzZWdtZW50LnB0Miwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgICBzaGFwZVBhdGguYyA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgICBzZWdtZW50Q291bnQgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNoYXBlUGF0aHNbaV0uYyAmJiBsZW5ndGhzLmxlbmd0aCkge1xuICAgICAgICBjdXJyZW50TGVuZ3RoRGF0YSA9IGxlbmd0aHNbaiAtIDFdO1xuICAgICAgICBpZiAoYWRkZWRMZW5ndGggPD0gc2hhcGVTZWdtZW50LmUpIHtcbiAgICAgICAgICB2YXIgc2VnbWVudExlbmd0aCA9IGxlbmd0aHNbaiAtIDFdLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgIGlmIChzaGFwZVNlZ21lbnQucyA8PSBhZGRlZExlbmd0aCAmJiBzaGFwZVNlZ21lbnQuZSA+PSBhZGRlZExlbmd0aCArIHNlZ21lbnRMZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuYWRkU2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLm9baiAtIDFdLCBzaGFwZVBhdGhzW2ldLmlbMF0sIHNoYXBlUGF0aHNbaV0udlswXSwgc2hhcGVQYXRoLCBzZWdtZW50Q291bnQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIG5ld1NoYXBlID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNlZ21lbnQgPSBiZXouZ2V0TmV3U2VnbWVudChzaGFwZVBhdGhzW2ldLnZbaiAtIDFdLCBzaGFwZVBhdGhzW2ldLnZbMF0sIHNoYXBlUGF0aHNbaV0ub1tqIC0gMV0sIHNoYXBlUGF0aHNbaV0uaVswXSwgKHNoYXBlU2VnbWVudC5zIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgKHNoYXBlU2VnbWVudC5lIC0gYWRkZWRMZW5ndGgpIC8gc2VnbWVudExlbmd0aCwgbGVuZ3Roc1tqIC0gMV0pO1xuICAgICAgICAgICAgdGhpcy5hZGRTZWdtZW50RnJvbUFycmF5KHNlZ21lbnQsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XG4gICAgICAgICAgICAvLyB0aGlzLmFkZFNlZ21lbnQoc2VnbWVudC5wdDEsIHNlZ21lbnQucHQzLCBzZWdtZW50LnB0NCwgc2VnbWVudC5wdDIsIHNoYXBlUGF0aCwgc2VnbWVudENvdW50LCBuZXdTaGFwZSk7XG4gICAgICAgICAgICBuZXdTaGFwZSA9IGZhbHNlO1xuICAgICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVQYXRoLmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBhZGRlZExlbmd0aCArPSBjdXJyZW50TGVuZ3RoRGF0YS5hZGRlZExlbmd0aDtcbiAgICAgICAgc2VnbWVudENvdW50ICs9IDE7XG4gICAgICB9XG4gICAgICBpZiAoc2hhcGVQYXRoLl9sZW5ndGgpIHtcbiAgICAgICAgc2hhcGVQYXRoLnNldFhZQXQoc2hhcGVQYXRoLnZbaW5pdFBvc11bMF0sIHNoYXBlUGF0aC52W2luaXRQb3NdWzFdLCAnaScsIGluaXRQb3MpO1xuICAgICAgICBzaGFwZVBhdGguc2V0WFlBdChzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzBdLCBzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzFdLCAnbycsIHNoYXBlUGF0aC5fbGVuZ3RoIC0gMSk7XG4gICAgICB9XG4gICAgICBpZiAoYWRkZWRMZW5ndGggPiBzaGFwZVNlZ21lbnQuZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChpIDwgbGVuIC0gMSkge1xuICAgICAgICBzaGFwZVBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgICBuZXdTaGFwZSA9IHRydWU7XG4gICAgICAgIHNoYXBlcy5wdXNoKHNoYXBlUGF0aCk7XG4gICAgICAgIHNlZ21lbnRDb3VudCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFwZXM7XG4gIH07XG5cbiAgZnVuY3Rpb24gUHVja2VyQW5kQmxvYXRNb2RpZmllcigpIHt9XG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFB1Y2tlckFuZEJsb2F0TW9kaWZpZXIpO1xuICBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLmFtb3VudCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5hbW91bnQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcbiAgUHVja2VyQW5kQmxvYXRNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1BhdGggPSBmdW5jdGlvbiAocGF0aCwgYW1vdW50KSB7XG4gICAgdmFyIHBlcmNlbnQgPSBhbW91bnQgLyAxMDA7XG4gICAgdmFyIGNlbnRlclBvaW50ID0gWzAsIDBdO1xuICAgIHZhciBwYXRoTGVuZ3RoID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBpID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgcGF0aExlbmd0aDsgaSArPSAxKSB7XG4gICAgICBjZW50ZXJQb2ludFswXSArPSBwYXRoLnZbaV1bMF07XG4gICAgICBjZW50ZXJQb2ludFsxXSArPSBwYXRoLnZbaV1bMV07XG4gICAgfVxuICAgIGNlbnRlclBvaW50WzBdIC89IHBhdGhMZW5ndGg7XG4gICAgY2VudGVyUG9pbnRbMV0gLz0gcGF0aExlbmd0aDtcbiAgICB2YXIgY2xvbmVkUGF0aCA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgY2xvbmVkUGF0aC5jID0gcGF0aC5jO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuICAgIGZvciAoaSA9IDA7IGkgPCBwYXRoTGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHZYID0gcGF0aC52W2ldWzBdICsgKGNlbnRlclBvaW50WzBdIC0gcGF0aC52W2ldWzBdKSAqIHBlcmNlbnQ7XG4gICAgICB2WSA9IHBhdGgudltpXVsxXSArIChjZW50ZXJQb2ludFsxXSAtIHBhdGgudltpXVsxXSkgKiBwZXJjZW50O1xuICAgICAgb1ggPSBwYXRoLm9baV1bMF0gKyAoY2VudGVyUG9pbnRbMF0gLSBwYXRoLm9baV1bMF0pICogLXBlcmNlbnQ7XG4gICAgICBvWSA9IHBhdGgub1tpXVsxXSArIChjZW50ZXJQb2ludFsxXSAtIHBhdGgub1tpXVsxXSkgKiAtcGVyY2VudDtcbiAgICAgIGlYID0gcGF0aC5pW2ldWzBdICsgKGNlbnRlclBvaW50WzBdIC0gcGF0aC5pW2ldWzBdKSAqIC1wZXJjZW50O1xuICAgICAgaVkgPSBwYXRoLmlbaV1bMV0gKyAoY2VudGVyUG9pbnRbMV0gLSBwYXRoLmlbaV1bMV0pICogLXBlcmNlbnQ7XG4gICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGkpO1xuICAgIH1cbiAgICByZXR1cm4gY2xvbmVkUGF0aDtcbiAgfTtcbiAgUHVja2VyQW5kQmxvYXRNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1vdW50ID0gdGhpcy5hbW91bnQudjtcbiAgICBpZiAoYW1vdW50ICE9PSAwKSB7XG4gICAgICB2YXIgc2hhcGVEYXRhO1xuICAgICAgdmFyIGxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHNoYXBlRGF0YSA9IHRoaXMuc2hhcGVzW2ldO1xuICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbiA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgICAgaWYgKCEoIXNoYXBlRGF0YS5zaGFwZS5fbWRmICYmICF0aGlzLl9tZGYgJiYgIV9pc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24ucmVsZWFzZVNoYXBlcygpO1xuICAgICAgICAgIHNoYXBlRGF0YS5zaGFwZS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICBzaGFwZVBhdGhzID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLnNoYXBlcztcbiAgICAgICAgICBqTGVuID0gc2hhcGVEYXRhLnNoYXBlLnBhdGhzLl9sZW5ndGg7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgbG9jYWxTaGFwZUNvbGxlY3Rpb24uYWRkU2hhcGUodGhpcy5wcm9jZXNzUGF0aChzaGFwZVBhdGhzW2pdLCBhbW91bnQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZGVmYXVsdFZlY3RvciA9IFswLCAwXTtcbiAgICBmdW5jdGlvbiBhcHBseVRvTWF0cml4KG1hdCkge1xuICAgICAgdmFyIF9tZGYgPSB0aGlzLl9tZGY7XG4gICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgICAgdGhpcy5fbWRmID0gdGhpcy5fbWRmIHx8IF9tZGY7XG4gICAgICBpZiAodGhpcy5hKSB7XG4gICAgICAgIG1hdC50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnMpIHtcbiAgICAgICAgbWF0LnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2spIHtcbiAgICAgICAgbWF0LnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucikge1xuICAgICAgICBtYXQucm90YXRlKC10aGlzLnIudik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXQucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSkucm90YXRlWSh0aGlzLm9yLnZbMV0pLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEucC5zKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgLXRoaXMucHoudik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgMCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdC50cmFuc2xhdGUodGhpcy5wLnZbMF0sIHRoaXMucC52WzFdLCAtdGhpcy5wLnZbMl0pO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBwcm9jZXNzS2V5cyhmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuZnJhbWVJZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5faXNEaXJ0eSkge1xuICAgICAgICB0aGlzLnByZWNhbGN1bGF0ZU1hdHJpeCgpO1xuICAgICAgICB0aGlzLl9pc0RpcnR5ID0gZmFsc2U7XG4gICAgICB9XG4gICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgICAgaWYgKHRoaXMuX21kZiB8fCBmb3JjZVJlbmRlcikge1xuICAgICAgICB2YXIgZnJhbWVSYXRlO1xuICAgICAgICB0aGlzLnYuY2xvbmVGcm9tUHJvcHModGhpcy5wcmUucHJvcHMpO1xuICAgICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMSkge1xuICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUoLXRoaXMuYS52WzBdLCAtdGhpcy5hLnZbMV0sIHRoaXMuYS52WzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMikge1xuICAgICAgICAgIHRoaXMudi5zY2FsZSh0aGlzLnMudlswXSwgdGhpcy5zLnZbMV0sIHRoaXMucy52WzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zayAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCAzKSB7XG4gICAgICAgICAgdGhpcy52LnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnIgJiYgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgNCkge1xuICAgICAgICAgIHRoaXMudi5yb3RhdGUoLXRoaXMuci52KTtcbiAgICAgICAgfSBlbHNlIGlmICghdGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgICB0aGlzLnYucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSkucm90YXRlWSh0aGlzLm9yLnZbMV0pLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5hdXRvT3JpZW50ZWQpIHtcbiAgICAgICAgICB2YXIgdjE7XG4gICAgICAgICAgdmFyIHYyO1xuICAgICAgICAgIGZyYW1lUmF0ZSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgICBpZiAodGhpcy5wICYmIHRoaXMucC5rZXlmcmFtZXMgJiYgdGhpcy5wLmdldFZhbHVlQXRUaW1lKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wLl9jYWNoaW5nLmxhc3RGcmFtZSArIHRoaXMucC5vZmZzZXRUaW1lIDw9IHRoaXMucC5rZXlmcmFtZXNbMF0udCkge1xuICAgICAgICAgICAgICB2MSA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLmtleWZyYW1lc1swXS50ICsgMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSh0aGlzLnAua2V5ZnJhbWVzWzBdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnAuX2NhY2hpbmcubGFzdEZyYW1lICsgdGhpcy5wLm9mZnNldFRpbWUgPj0gdGhpcy5wLmtleWZyYW1lc1t0aGlzLnAua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQpIHtcbiAgICAgICAgICAgICAgdjEgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUodGhpcy5wLmtleWZyYW1lc1t0aGlzLnAua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MiA9IHRoaXMucC5nZXRWYWx1ZUF0VGltZSgodGhpcy5wLmtleWZyYW1lc1t0aGlzLnAua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSAwLjA1KSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2MSA9IHRoaXMucC5wdjtcbiAgICAgICAgICAgICAgdjIgPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUoKHRoaXMucC5fY2FjaGluZy5sYXN0RnJhbWUgKyB0aGlzLnAub2Zmc2V0VGltZSAtIDAuMDEpIC8gZnJhbWVSYXRlLCB0aGlzLnAub2Zmc2V0VGltZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnB4ICYmIHRoaXMucHgua2V5ZnJhbWVzICYmIHRoaXMucHkua2V5ZnJhbWVzICYmIHRoaXMucHguZ2V0VmFsdWVBdFRpbWUgJiYgdGhpcy5weS5nZXRWYWx1ZUF0VGltZSkge1xuICAgICAgICAgICAgdjEgPSBbXTtcbiAgICAgICAgICAgIHYyID0gW107XG4gICAgICAgICAgICB2YXIgcHggPSB0aGlzLnB4O1xuICAgICAgICAgICAgdmFyIHB5ID0gdGhpcy5weTtcbiAgICAgICAgICAgIGlmIChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lIDw9IHB4LmtleWZyYW1lc1swXS50KSB7XG4gICAgICAgICAgICAgIHYxWzBdID0gcHguZ2V0VmFsdWVBdFRpbWUoKHB4LmtleWZyYW1lc1swXS50ICsgMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MVsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbMF0udCArIDAuMDEpIC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZShweC5rZXlmcmFtZXNbMF0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYyWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUocHkua2V5ZnJhbWVzWzBdLnQgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lID49IHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCkge1xuICAgICAgICAgICAgICB2MVswXSA9IHB4LmdldFZhbHVlQXRUaW1lKHB4LmtleWZyYW1lc1tweC5rZXlmcmFtZXMubGVuZ3RoIC0gMV0udCAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICAgIHYxWzFdID0gcHkuZ2V0VmFsdWVBdFRpbWUocHkua2V5ZnJhbWVzW3B5LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC8gZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgICAgICAgdjJbMF0gPSBweC5nZXRWYWx1ZUF0VGltZSgocHgua2V5ZnJhbWVzW3B4LmtleWZyYW1lcy5sZW5ndGggLSAxXS50IC0gMC4wMSkgLyBmcmFtZVJhdGUsIDApO1xuICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5rZXlmcmFtZXNbcHkua2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQgLSAwLjAxKSAvIGZyYW1lUmF0ZSwgMCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB2MSA9IFtweC5wdiwgcHkucHZdO1xuICAgICAgICAgICAgICB2MlswXSA9IHB4LmdldFZhbHVlQXRUaW1lKChweC5fY2FjaGluZy5sYXN0RnJhbWUgKyBweC5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHB4Lm9mZnNldFRpbWUpO1xuICAgICAgICAgICAgICB2MlsxXSA9IHB5LmdldFZhbHVlQXRUaW1lKChweS5fY2FjaGluZy5sYXN0RnJhbWUgKyBweS5vZmZzZXRUaW1lIC0gMC4wMSkgLyBmcmFtZVJhdGUsIHB5Lm9mZnNldFRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2MiA9IGRlZmF1bHRWZWN0b3I7XG4gICAgICAgICAgICB2MSA9IHYyO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLnYucm90YXRlKC1NYXRoLmF0YW4yKHYxWzFdIC0gdjJbMV0sIHYxWzBdIC0gdjJbMF0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5kYXRhLnAgJiYgdGhpcy5kYXRhLnAucykge1xuICAgICAgICAgIGlmICh0aGlzLmRhdGEucC56KSB7XG4gICAgICAgICAgICB0aGlzLnYudHJhbnNsYXRlKHRoaXMucHgudiwgdGhpcy5weS52LCAtdGhpcy5wei52KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52LnRyYW5zbGF0ZSh0aGlzLnB4LnYsIHRoaXMucHkudiwgMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudi50cmFuc2xhdGUodGhpcy5wLnZbMF0sIHRoaXMucC52WzFdLCAtdGhpcy5wLnZbMl0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIH1cbiAgICBmdW5jdGlvbiBwcmVjYWxjdWxhdGVNYXRyaXgoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAwO1xuICAgICAgdGhpcy5wcmUucmVzZXQoKTtcbiAgICAgIGlmICghdGhpcy5hLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmUudHJhbnNsYXRlKC10aGlzLmEudlswXSwgLXRoaXMuYS52WzFdLCB0aGlzLmEudlsyXSk7XG4gICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucHJlLnNjYWxlKHRoaXMucy52WzBdLCB0aGlzLnMudlsxXSwgdGhpcy5zLnZbMl0pO1xuICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuc2spIHtcbiAgICAgICAgaWYgKCF0aGlzLnNrLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMuc2EuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMucHJlLnNrZXdGcm9tQXhpcygtdGhpcy5zay52LCB0aGlzLnNhLnYpO1xuICAgICAgICAgIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA9IDM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yKSB7XG4gICAgICAgIGlmICghdGhpcy5yLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgICB0aGlzLnByZS5yb3RhdGUoLXRoaXMuci52KTtcbiAgICAgICAgICB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPSA0O1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLnJ6LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggJiYgIXRoaXMucnkuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCAmJiAhdGhpcy5yeC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICYmICF0aGlzLm9yLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5wcmUucm90YXRlWigtdGhpcy5yei52KS5yb3RhdGVZKHRoaXMucnkudikucm90YXRlWCh0aGlzLnJ4LnYpLnJvdGF0ZVooLXRoaXMub3IudlsyXSkucm90YXRlWSh0aGlzLm9yLnZbMV0pLnJvdGF0ZVgodGhpcy5vci52WzBdKTtcbiAgICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gNDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gYXV0b09yaWVudCgpIHtcbiAgICAgIC8vXG4gICAgICAvLyB2YXIgcHJldlAgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGFkZER5bmFtaWNQcm9wZXJ0eShwcm9wKSB7XG4gICAgICB0aGlzLl9hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHByb3ApO1xuICAgICAgdGhpcy5faXNEaXJ0eSA9IHRydWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xuICAgICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICAgIHRoaXMuZnJhbWVJZCA9IC0xO1xuICAgICAgdGhpcy5wcm9wVHlwZSA9ICd0cmFuc2Zvcm0nO1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMudiA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIC8vIFByZWNhbGN1bGF0ZWQgbWF0cml4IHdpdGggbm9uIGFuaW1hdGVkIHByb3BlcnRpZXNcbiAgICAgIHRoaXMucHJlID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zID0gMDtcbiAgICAgIHRoaXMuaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcihjb250YWluZXIgfHwgZWxlbSk7XG4gICAgICBpZiAoZGF0YS5wICYmIGRhdGEucC5zKSB7XG4gICAgICAgIHRoaXMucHggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAueCwgMCwgMCwgdGhpcyk7XG4gICAgICAgIHRoaXMucHkgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAueSwgMCwgMCwgdGhpcyk7XG4gICAgICAgIGlmIChkYXRhLnAueikge1xuICAgICAgICAgIHRoaXMucHogPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnAueiwgMCwgMCwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucCB8fCB7XG4gICAgICAgICAgazogWzAsIDAsIDBdXG4gICAgICAgIH0sIDEsIDAsIHRoaXMpO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucngpIHtcbiAgICAgICAgdGhpcy5yeCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICAgIHRoaXMucnkgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnJ5LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgICB0aGlzLnJ6ID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yeiwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgICAgaWYgKGRhdGEub3Iua1swXS50aSkge1xuICAgICAgICAgIHZhciBpO1xuICAgICAgICAgIHZhciBsZW4gPSBkYXRhLm9yLmsubGVuZ3RoO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgZGF0YS5vci5rW2ldLnRvID0gbnVsbDtcbiAgICAgICAgICAgIGRhdGEub3Iua1tpXS50aSA9IG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMub3IgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgICAvLyBzaCBJbmRpY2F0ZXMgaXQgbmVlZHMgdG8gYmUgY2FwcGVkIGJldHdlZW4gLTE4MCBhbmQgMTgwXG4gICAgICAgIHRoaXMub3Iuc2ggPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5yIHx8IHtcbiAgICAgICAgICBrOiAwXG4gICAgICAgIH0sIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAoZGF0YS5zaykge1xuICAgICAgICB0aGlzLnNrID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zaywgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5zYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuc2EsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgICB9XG4gICAgICB0aGlzLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiBbMCwgMCwgMF1cbiAgICAgIH0sIDEsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5zID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5zIHx8IHtcbiAgICAgICAgazogWzEwMCwgMTAwLCAxMDBdXG4gICAgICB9LCAxLCAwLjAxLCB0aGlzKTtcbiAgICAgIC8vIE9wYWNpdHkgaXMgbm90IHBhcnQgb2YgdGhlIHRyYW5zZm9ybSBwcm9wZXJ0aWVzLCB0aGF0J3Mgd2h5IGl0IHdvbid0IHVzZSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLiBUaGF0IHdheSB0cmFuc2Zvcm1zIHdvbid0IGdldCB1cGRhdGVkIGlmIG9wYWNpdHkgY2hhbmdlcy5cbiAgICAgIGlmIChkYXRhLm8pIHtcbiAgICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vLCAwLCAwLjAxLCBlbGVtKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubyA9IHtcbiAgICAgICAgICBfbWRmOiBmYWxzZSxcbiAgICAgICAgICB2OiAxXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0RpcnR5ID0gdHJ1ZTtcbiAgICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5nZXRWYWx1ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlID0ge1xuICAgICAgYXBwbHlUb01hdHJpeDogYXBwbHlUb01hdHJpeCxcbiAgICAgIGdldFZhbHVlOiBwcm9jZXNzS2V5cyxcbiAgICAgIHByZWNhbGN1bGF0ZU1hdHJpeDogcHJlY2FsY3VsYXRlTWF0cml4LFxuICAgICAgYXV0b09yaWVudDogYXV0b09yaWVudFxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBUcmFuc2Zvcm1Qcm9wZXJ0eSk7XG4gICAgVHJhbnNmb3JtUHJvcGVydHkucHJvdG90eXBlLmFkZER5bmFtaWNQcm9wZXJ0eSA9IGFkZER5bmFtaWNQcm9wZXJ0eTtcbiAgICBUcmFuc2Zvcm1Qcm9wZXJ0eS5wcm90b3R5cGUuX2FkZER5bmFtaWNQcm9wZXJ0eSA9IER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lci5wcm90b3R5cGUuYWRkRHluYW1pY1Byb3BlcnR5O1xuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5KGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xuICAgICAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgZ2V0VHJhbnNmb3JtUHJvcGVydHk6IGdldFRyYW5zZm9ybVByb3BlcnR5XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIFJlcGVhdGVyTW9kaWZpZXIoKSB7fVxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBSZXBlYXRlck1vZGlmaWVyKTtcbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5jID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5jLCAwLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMudHIgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkoZWxlbSwgZGF0YS50ciwgdGhpcyk7XG4gICAgdGhpcy5zbyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudHIuc28sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuZW8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnRyLmVvLCAwLCAwLjAxLCB0aGlzKTtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIGlmICghdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuZ2V0VmFsdWUodHJ1ZSk7XG4gICAgfVxuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgIHRoaXMucE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLnJNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5zTWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMudE1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLm1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcbiAgfTtcbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYXBwbHlUcmFuc2Zvcm1zID0gZnVuY3Rpb24gKHBNYXRyaXgsIHJNYXRyaXgsIHNNYXRyaXgsIHRyYW5zZm9ybSwgcGVyYywgaW52KSB7XG4gICAgdmFyIGRpciA9IGludiA/IC0xIDogMTtcbiAgICB2YXIgc2NhbGVYID0gdHJhbnNmb3JtLnMudlswXSArICgxIC0gdHJhbnNmb3JtLnMudlswXSkgKiAoMSAtIHBlcmMpO1xuICAgIHZhciBzY2FsZVkgPSB0cmFuc2Zvcm0ucy52WzFdICsgKDEgLSB0cmFuc2Zvcm0ucy52WzFdKSAqICgxIC0gcGVyYyk7XG4gICAgcE1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLnAudlswXSAqIGRpciAqIHBlcmMsIHRyYW5zZm9ybS5wLnZbMV0gKiBkaXIgKiBwZXJjLCB0cmFuc2Zvcm0ucC52WzJdKTtcbiAgICByTWF0cml4LnRyYW5zbGF0ZSgtdHJhbnNmb3JtLmEudlswXSwgLXRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICAgIHJNYXRyaXgucm90YXRlKC10cmFuc2Zvcm0uci52ICogZGlyICogcGVyYyk7XG4gICAgck1hdHJpeC50cmFuc2xhdGUodHJhbnNmb3JtLmEudlswXSwgdHJhbnNmb3JtLmEudlsxXSwgdHJhbnNmb3JtLmEudlsyXSk7XG4gICAgc01hdHJpeC50cmFuc2xhdGUoLXRyYW5zZm9ybS5hLnZbMF0sIC10cmFuc2Zvcm0uYS52WzFdLCB0cmFuc2Zvcm0uYS52WzJdKTtcbiAgICBzTWF0cml4LnNjYWxlKGludiA/IDEgLyBzY2FsZVggOiBzY2FsZVgsIGludiA/IDEgLyBzY2FsZVkgOiBzY2FsZVkpO1xuICAgIHNNYXRyaXgudHJhbnNsYXRlKHRyYW5zZm9ybS5hLnZbMF0sIHRyYW5zZm9ybS5hLnZbMV0sIHRyYW5zZm9ybS5hLnZbMl0pO1xuICB9O1xuICBSZXBlYXRlck1vZGlmaWVyLnByb3RvdHlwZS5pbml0ID0gZnVuY3Rpb24gKGVsZW0sIGFyciwgcG9zLCBlbGVtc0RhdGEpIHtcbiAgICB0aGlzLmVsZW0gPSBlbGVtO1xuICAgIHRoaXMuYXJyID0gYXJyO1xuICAgIHRoaXMucG9zID0gcG9zO1xuICAgIHRoaXMuZWxlbXNEYXRhID0gZWxlbXNEYXRhO1xuICAgIHRoaXMuX2N1cnJlbnRDb3BpZXMgPSAwO1xuICAgIHRoaXMuX2VsZW1lbnRzID0gW107XG4gICAgdGhpcy5fZ3JvdXBzID0gW107XG4gICAgdGhpcy5mcmFtZUlkID0gLTE7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuaW5pdE1vZGlmaWVyUHJvcGVydGllcyhlbGVtLCBhcnJbcG9zXSk7XG4gICAgd2hpbGUgKHBvcyA+IDApIHtcbiAgICAgIHBvcyAtPSAxO1xuICAgICAgLy8gdGhpcy5fZWxlbWVudHMudW5zaGlmdChhcnIuc3BsaWNlKHBvcywxKVswXSk7XG4gICAgICB0aGlzLl9lbGVtZW50cy51bnNoaWZ0KGFycltwb3NdKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLmsgPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgIH1cbiAgfTtcbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUucmVzZXRFbGVtZW50cyA9IGZ1bmN0aW9uIChlbGVtZW50cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBlbGVtZW50cy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlbGVtZW50c1tpXS5fcHJvY2Vzc2VkID0gZmFsc2U7XG4gICAgICBpZiAoZWxlbWVudHNbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgdGhpcy5yZXNldEVsZW1lbnRzKGVsZW1lbnRzW2ldLml0KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNsb25lRWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbWVudHMpIHtcbiAgICB2YXIgbmV3RWxlbWVudHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGVsZW1lbnRzKSk7XG4gICAgdGhpcy5yZXNldEVsZW1lbnRzKG5ld0VsZW1lbnRzKTtcbiAgICByZXR1cm4gbmV3RWxlbWVudHM7XG4gIH07XG4gIFJlcGVhdGVyTW9kaWZpZXIucHJvdG90eXBlLmNoYW5nZUdyb3VwUmVuZGVyID0gZnVuY3Rpb24gKGVsZW1lbnRzLCByZW5kZXJGbGFnKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGVsZW1lbnRzW2ldLl9yZW5kZXIgPSByZW5kZXJGbGFnO1xuICAgICAgaWYgKGVsZW1lbnRzW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIHRoaXMuY2hhbmdlR3JvdXBSZW5kZXIoZWxlbWVudHNbaV0uaXQsIHJlbmRlckZsYWcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIGl0ZW1zO1xuICAgIHZhciBpdGVtc1RyYW5zZm9ybTtcbiAgICB2YXIgaTtcbiAgICB2YXIgZGlyO1xuICAgIHZhciBjb250O1xuICAgIHZhciBoYXNSZWxvYWRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLl9tZGYgfHwgX2lzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIGNvcGllcyA9IE1hdGguY2VpbCh0aGlzLmMudik7XG4gICAgICBpZiAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICB3aGlsZSAodGhpcy5fZ3JvdXBzLmxlbmd0aCA8IGNvcGllcykge1xuICAgICAgICAgIHZhciBncm91cCA9IHtcbiAgICAgICAgICAgIGl0OiB0aGlzLmNsb25lRWxlbWVudHModGhpcy5fZWxlbWVudHMpLFxuICAgICAgICAgICAgdHk6ICdncidcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdyb3VwLml0LnB1c2goe1xuICAgICAgICAgICAgYToge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMSxcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbm06ICdUcmFuc2Zvcm0nLFxuICAgICAgICAgICAgbzoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNyxcbiAgICAgICAgICAgICAgazogMTAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcDoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogMixcbiAgICAgICAgICAgICAgazogWzAsIDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcjoge1xuICAgICAgICAgICAgICBhOiAxLFxuICAgICAgICAgICAgICBpeDogNixcbiAgICAgICAgICAgICAgazogW3tcbiAgICAgICAgICAgICAgICBzOiAwLFxuICAgICAgICAgICAgICAgIGU6IDAsXG4gICAgICAgICAgICAgICAgdDogMFxuICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgczogMCxcbiAgICAgICAgICAgICAgICBlOiAwLFxuICAgICAgICAgICAgICAgIHQ6IDFcbiAgICAgICAgICAgICAgfV1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzOiB7XG4gICAgICAgICAgICAgIGE6IDAsXG4gICAgICAgICAgICAgIGl4OiAzLFxuICAgICAgICAgICAgICBrOiBbMTAwLCAxMDBdXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2E6IHtcbiAgICAgICAgICAgICAgYTogMCxcbiAgICAgICAgICAgICAgaXg6IDUsXG4gICAgICAgICAgICAgIGs6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzazoge1xuICAgICAgICAgICAgICBhOiAwLFxuICAgICAgICAgICAgICBpeDogNCxcbiAgICAgICAgICAgICAgazogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHR5OiAndHInXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdGhpcy5hcnIuc3BsaWNlKDAsIDAsIGdyb3VwKTtcbiAgICAgICAgICB0aGlzLl9ncm91cHMuc3BsaWNlKDAsIDAsIGdyb3VwKTtcbiAgICAgICAgICB0aGlzLl9jdXJyZW50Q29waWVzICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbGVtLnJlbG9hZFNoYXBlcygpO1xuICAgICAgICBoYXNSZWxvYWRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBjb250ID0gMDtcbiAgICAgIHZhciByZW5kZXJGbGFnO1xuICAgICAgZm9yIChpID0gMDsgaSA8PSB0aGlzLl9ncm91cHMubGVuZ3RoIC0gMTsgaSArPSAxKSB7XG4gICAgICAgIHJlbmRlckZsYWcgPSBjb250IDwgY29waWVzO1xuICAgICAgICB0aGlzLl9ncm91cHNbaV0uX3JlbmRlciA9IHJlbmRlckZsYWc7XG4gICAgICAgIHRoaXMuY2hhbmdlR3JvdXBSZW5kZXIodGhpcy5fZ3JvdXBzW2ldLml0LCByZW5kZXJGbGFnKTtcbiAgICAgICAgaWYgKCFyZW5kZXJGbGFnKSB7XG4gICAgICAgICAgdmFyIGVsZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgICAgdmFyIHRyYW5zZm9ybURhdGEgPSBlbGVtc1tlbGVtcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAodHJhbnNmb3JtRGF0YS50cmFuc2Zvcm0ub3AudiAhPT0gMCkge1xuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS50cmFuc2Zvcm0ub3AuX21kZiA9IHRydWU7XG4gICAgICAgICAgICB0cmFuc2Zvcm1EYXRhLnRyYW5zZm9ybS5vcC52ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhbnNmb3JtRGF0YS50cmFuc2Zvcm0ub3AuX21kZiA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb250ICs9IDE7XG4gICAgICB9XG4gICAgICB0aGlzLl9jdXJyZW50Q29waWVzID0gY29waWVzO1xuICAgICAgLy8vIC9cblxuICAgICAgdmFyIG9mZnNldCA9IHRoaXMuby52O1xuICAgICAgdmFyIG9mZnNldE1vZHVsbyA9IG9mZnNldCAlIDE7XG4gICAgICB2YXIgcm91bmRPZmZzZXQgPSBvZmZzZXQgPiAwID8gTWF0aC5mbG9vcihvZmZzZXQpIDogTWF0aC5jZWlsKG9mZnNldCk7XG4gICAgICB2YXIgcFByb3BzID0gdGhpcy5wTWF0cml4LnByb3BzO1xuICAgICAgdmFyIHJQcm9wcyA9IHRoaXMuck1hdHJpeC5wcm9wcztcbiAgICAgIHZhciBzUHJvcHMgPSB0aGlzLnNNYXRyaXgucHJvcHM7XG4gICAgICB0aGlzLnBNYXRyaXgucmVzZXQoKTtcbiAgICAgIHRoaXMuck1hdHJpeC5yZXNldCgpO1xuICAgICAgdGhpcy5zTWF0cml4LnJlc2V0KCk7XG4gICAgICB0aGlzLnRNYXRyaXgucmVzZXQoKTtcbiAgICAgIHRoaXMubWF0cml4LnJlc2V0KCk7XG4gICAgICB2YXIgaXRlcmF0aW9uID0gMDtcbiAgICAgIGlmIChvZmZzZXQgPiAwKSB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRpb24gPCByb3VuZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIGZhbHNlKTtcbiAgICAgICAgICBpdGVyYXRpb24gKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2Zmc2V0TW9kdWxvKSB7XG4gICAgICAgICAgdGhpcy5hcHBseVRyYW5zZm9ybXModGhpcy5wTWF0cml4LCB0aGlzLnJNYXRyaXgsIHRoaXMuc01hdHJpeCwgdGhpcy50ciwgb2Zmc2V0TW9kdWxvLCBmYWxzZSk7XG4gICAgICAgICAgaXRlcmF0aW9uICs9IG9mZnNldE1vZHVsbztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvZmZzZXQgPCAwKSB7XG4gICAgICAgIHdoaWxlIChpdGVyYXRpb24gPiByb3VuZE9mZnNldCkge1xuICAgICAgICAgIHRoaXMuYXBwbHlUcmFuc2Zvcm1zKHRoaXMucE1hdHJpeCwgdGhpcy5yTWF0cml4LCB0aGlzLnNNYXRyaXgsIHRoaXMudHIsIDEsIHRydWUpO1xuICAgICAgICAgIGl0ZXJhdGlvbiAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvZmZzZXRNb2R1bG8pIHtcbiAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAtb2Zmc2V0TW9kdWxvLCB0cnVlKTtcbiAgICAgICAgICBpdGVyYXRpb24gLT0gb2Zmc2V0TW9kdWxvO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpID0gdGhpcy5kYXRhLm0gPT09IDEgPyAwIDogdGhpcy5fY3VycmVudENvcGllcyAtIDE7XG4gICAgICBkaXIgPSB0aGlzLmRhdGEubSA9PT0gMSA/IDEgOiAtMTtcbiAgICAgIGNvbnQgPSB0aGlzLl9jdXJyZW50Q29waWVzO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgakxlbjtcbiAgICAgIHdoaWxlIChjb250KSB7XG4gICAgICAgIGl0ZW1zID0gdGhpcy5lbGVtc0RhdGFbaV0uaXQ7XG4gICAgICAgIGl0ZW1zVHJhbnNmb3JtID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy52LnByb3BzO1xuICAgICAgICBqTGVuID0gaXRlbXNUcmFuc2Zvcm0ubGVuZ3RoO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ubVByb3BzLl9tZGYgPSB0cnVlO1xuICAgICAgICBpdGVtc1tpdGVtcy5sZW5ndGggLSAxXS50cmFuc2Zvcm0ub3AuX21kZiA9IHRydWU7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5vcC52ID0gdGhpcy5fY3VycmVudENvcGllcyA9PT0gMSA/IHRoaXMuc28udiA6IHRoaXMuc28udiArICh0aGlzLmVvLnYgLSB0aGlzLnNvLnYpICogKGkgLyAodGhpcy5fY3VycmVudENvcGllcyAtIDEpKTtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbiAhPT0gMCkge1xuICAgICAgICAgIGlmIChpICE9PSAwICYmIGRpciA9PT0gMSB8fCBpICE9PSB0aGlzLl9jdXJyZW50Q29waWVzIC0gMSAmJiBkaXIgPT09IC0xKSB7XG4gICAgICAgICAgICB0aGlzLmFwcGx5VHJhbnNmb3Jtcyh0aGlzLnBNYXRyaXgsIHRoaXMuck1hdHJpeCwgdGhpcy5zTWF0cml4LCB0aGlzLnRyLCAxLCBmYWxzZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShyUHJvcHNbMF0sIHJQcm9wc1sxXSwgclByb3BzWzJdLCByUHJvcHNbM10sIHJQcm9wc1s0XSwgclByb3BzWzVdLCByUHJvcHNbNl0sIHJQcm9wc1s3XSwgclByb3BzWzhdLCByUHJvcHNbOV0sIHJQcm9wc1sxMF0sIHJQcm9wc1sxMV0sIHJQcm9wc1sxMl0sIHJQcm9wc1sxM10sIHJQcm9wc1sxNF0sIHJQcm9wc1sxNV0pO1xuICAgICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShzUHJvcHNbMF0sIHNQcm9wc1sxXSwgc1Byb3BzWzJdLCBzUHJvcHNbM10sIHNQcm9wc1s0XSwgc1Byb3BzWzVdLCBzUHJvcHNbNl0sIHNQcm9wc1s3XSwgc1Byb3BzWzhdLCBzUHJvcHNbOV0sIHNQcm9wc1sxMF0sIHNQcm9wc1sxMV0sIHNQcm9wc1sxMl0sIHNQcm9wc1sxM10sIHNQcm9wc1sxNF0sIHNQcm9wc1sxNV0pO1xuICAgICAgICAgIHRoaXMubWF0cml4LnRyYW5zZm9ybShwUHJvcHNbMF0sIHBQcm9wc1sxXSwgcFByb3BzWzJdLCBwUHJvcHNbM10sIHBQcm9wc1s0XSwgcFByb3BzWzVdLCBwUHJvcHNbNl0sIHBQcm9wc1s3XSwgcFByb3BzWzhdLCBwUHJvcHNbOV0sIHBQcm9wc1sxMF0sIHBQcm9wc1sxMV0sIHBQcm9wc1sxMl0sIHBQcm9wc1sxM10sIHBQcm9wc1sxNF0sIHBQcm9wc1sxNV0pO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGl0ZW1zVHJhbnNmb3JtW2pdID0gdGhpcy5tYXRyaXgucHJvcHNbal07XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMubWF0cml4LnJlc2V0KCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBpdGVtc1RyYW5zZm9ybVtqXSA9IHRoaXMubWF0cml4LnByb3BzW2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpdGVyYXRpb24gKz0gMTtcbiAgICAgICAgY29udCAtPSAxO1xuICAgICAgICBpICs9IGRpcjtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29udCA9IHRoaXMuX2N1cnJlbnRDb3BpZXM7XG4gICAgICBpID0gMDtcbiAgICAgIGRpciA9IDE7XG4gICAgICB3aGlsZSAoY29udCkge1xuICAgICAgICBpdGVtcyA9IHRoaXMuZWxlbXNEYXRhW2ldLml0O1xuICAgICAgICBpdGVtc1RyYW5zZm9ybSA9IGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5tUHJvcHMudi5wcm9wcztcbiAgICAgICAgaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV0udHJhbnNmb3JtLm1Qcm9wcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIGl0ZW1zW2l0ZW1zLmxlbmd0aCAtIDFdLnRyYW5zZm9ybS5vcC5fbWRmID0gZmFsc2U7XG4gICAgICAgIGNvbnQgLT0gMTtcbiAgICAgICAgaSArPSBkaXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBoYXNSZWxvYWRlZDtcbiAgfTtcbiAgUmVwZWF0ZXJNb2RpZmllci5wcm90b3R5cGUuYWRkU2hhcGUgPSBmdW5jdGlvbiAoKSB7fTtcblxuICBmdW5jdGlvbiBSb3VuZENvcm5lcnNNb2RpZmllcigpIHt9XG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIFJvdW5kQ29ybmVyc01vZGlmaWVyKTtcbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLmluaXRNb2RpZmllclByb3BlcnRpZXMgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSkge1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLnByb2Nlc3NLZXlzO1xuICAgIHRoaXMucmQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMucmQuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfTtcbiAgUm91bmRDb3JuZXJzTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKHBhdGgsIHJvdW5kKSB7XG4gICAgdmFyIGNsb25lZFBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgIGNsb25lZFBhdGguYyA9IHBhdGguYztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjdXJyZW50VjtcbiAgICB2YXIgY3VycmVudEk7XG4gICAgdmFyIGN1cnJlbnRPO1xuICAgIHZhciBjbG9zZXJWO1xuICAgIHZhciBkaXN0YW5jZTtcbiAgICB2YXIgbmV3UG9zUGVyYztcbiAgICB2YXIgaW5kZXggPSAwO1xuICAgIHZhciB2WDtcbiAgICB2YXIgdlk7XG4gICAgdmFyIG9YO1xuICAgIHZhciBvWTtcbiAgICB2YXIgaVg7XG4gICAgdmFyIGlZO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY3VycmVudFYgPSBwYXRoLnZbaV07XG4gICAgICBjdXJyZW50TyA9IHBhdGgub1tpXTtcbiAgICAgIGN1cnJlbnRJID0gcGF0aC5pW2ldO1xuICAgICAgaWYgKGN1cnJlbnRWWzBdID09PSBjdXJyZW50T1swXSAmJiBjdXJyZW50VlsxXSA9PT0gY3VycmVudE9bMV0gJiYgY3VycmVudFZbMF0gPT09IGN1cnJlbnRJWzBdICYmIGN1cnJlbnRWWzFdID09PSBjdXJyZW50SVsxXSkge1xuICAgICAgICBpZiAoKGkgPT09IDAgfHwgaSA9PT0gbGVuIC0gMSkgJiYgIXBhdGguYykge1xuICAgICAgICAgIGNsb25lZFBhdGguc2V0VHJpcGxlQXQoY3VycmVudFZbMF0sIGN1cnJlbnRWWzFdLCBjdXJyZW50T1swXSwgY3VycmVudE9bMV0sIGN1cnJlbnRJWzBdLCBjdXJyZW50SVsxXSwgaW5kZXgpO1xuICAgICAgICAgIC8qIGNsb25lZFBhdGgudltpbmRleF0gPSBjdXJyZW50VjtcbiAgICAgICAgICAgICAgICAgIGNsb25lZFBhdGgub1tpbmRleF0gPSBjdXJyZW50TztcbiAgICAgICAgICAgICAgICAgIGNsb25lZFBhdGguaVtpbmRleF0gPSBjdXJyZW50STsgKi9cbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBjbG9zZXJWID0gcGF0aC52W2xlbiAtIDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZXJWID0gcGF0aC52W2kgLSAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0gLSBjbG9zZXJWWzBdLCAyKSArIE1hdGgucG93KGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSwgMikpO1xuICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlIC8gMiwgcm91bmQpIC8gZGlzdGFuY2UgOiAwO1xuICAgICAgICAgIGlYID0gY3VycmVudFZbMF0gKyAoY2xvc2VyVlswXSAtIGN1cnJlbnRWWzBdKSAqIG5ld1Bvc1BlcmM7XG4gICAgICAgICAgdlggPSBpWDtcbiAgICAgICAgICBpWSA9IGN1cnJlbnRWWzFdIC0gKGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZZID0gaVk7XG4gICAgICAgICAgb1ggPSB2WCAtICh2WCAtIGN1cnJlbnRWWzBdKSAqIHJvdW5kQ29ybmVyO1xuICAgICAgICAgIG9ZID0gdlkgLSAodlkgLSBjdXJyZW50VlsxXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgICBjbG9zZXJWID0gcGF0aC52WzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjbG9zZXJWID0gcGF0aC52W2kgKyAxXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3coY3VycmVudFZbMF0gLSBjbG9zZXJWWzBdLCAyKSArIE1hdGgucG93KGN1cnJlbnRWWzFdIC0gY2xvc2VyVlsxXSwgMikpO1xuICAgICAgICAgIG5ld1Bvc1BlcmMgPSBkaXN0YW5jZSA/IE1hdGgubWluKGRpc3RhbmNlIC8gMiwgcm91bmQpIC8gZGlzdGFuY2UgOiAwO1xuICAgICAgICAgIG9YID0gY3VycmVudFZbMF0gKyAoY2xvc2VyVlswXSAtIGN1cnJlbnRWWzBdKSAqIG5ld1Bvc1BlcmM7XG4gICAgICAgICAgdlggPSBvWDtcbiAgICAgICAgICBvWSA9IGN1cnJlbnRWWzFdICsgKGNsb3NlclZbMV0gLSBjdXJyZW50VlsxXSkgKiBuZXdQb3NQZXJjO1xuICAgICAgICAgIHZZID0gb1k7XG4gICAgICAgICAgaVggPSB2WCAtICh2WCAtIGN1cnJlbnRWWzBdKSAqIHJvdW5kQ29ybmVyO1xuICAgICAgICAgIGlZID0gdlkgLSAodlkgLSBjdXJyZW50VlsxXSkgKiByb3VuZENvcm5lcjtcbiAgICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHZYLCB2WSwgb1gsIG9ZLCBpWCwgaVksIGluZGV4KTtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjbG9uZWRQYXRoLnNldFRyaXBsZUF0KHBhdGgudltpXVswXSwgcGF0aC52W2ldWzFdLCBwYXRoLm9baV1bMF0sIHBhdGgub1tpXVsxXSwgcGF0aC5pW2ldWzBdLCBwYXRoLmlbaV1bMV0sIGluZGV4KTtcbiAgICAgICAgaW5kZXggKz0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNsb25lZFBhdGg7XG4gIH07XG4gIFJvdW5kQ29ybmVyc01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzU2hhcGVzID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgc2hhcGVQYXRocztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zaGFwZXMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciByZCA9IHRoaXMucmQudjtcbiAgICBpZiAocmQgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICBpZiAoISghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xuICAgICAgICAgIGpMZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIHJkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHNoYXBlRGF0YS5zaGFwZS5wYXRocyA9IHNoYXBlRGF0YS5sb2NhbFNoYXBlQ29sbGVjdGlvbjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCF0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aCkge1xuICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGZsb2F0RXF1YWwoYSwgYikge1xuICAgIHJldHVybiBNYXRoLmFicyhhIC0gYikgKiAxMDAwMDAgPD0gTWF0aC5taW4oTWF0aC5hYnMoYSksIE1hdGguYWJzKGIpKTtcbiAgfVxuICBmdW5jdGlvbiBmbG9hdFplcm8oZikge1xuICAgIHJldHVybiBNYXRoLmFicyhmKSA8PSAwLjAwMDAxO1xuICB9XG4gIGZ1bmN0aW9uIGxlcnAocDAsIHAxLCBhbW91bnQpIHtcbiAgICByZXR1cm4gcDAgKiAoMSAtIGFtb3VudCkgKyBwMSAqIGFtb3VudDtcbiAgfVxuICBmdW5jdGlvbiBsZXJwUG9pbnQocDAsIHAxLCBhbW91bnQpIHtcbiAgICByZXR1cm4gW2xlcnAocDBbMF0sIHAxWzBdLCBhbW91bnQpLCBsZXJwKHAwWzFdLCBwMVsxXSwgYW1vdW50KV07XG4gIH1cbiAgZnVuY3Rpb24gcXVhZFJvb3RzKGEsIGIsIGMpIHtcbiAgICAvLyBubyByb290XG4gICAgaWYgKGEgPT09IDApIHJldHVybiBbXTtcbiAgICB2YXIgcyA9IGIgKiBiIC0gNCAqIGEgKiBjO1xuICAgIC8vIENvbXBsZXggcm9vdHNcbiAgICBpZiAocyA8IDApIHJldHVybiBbXTtcbiAgICB2YXIgc2luZ2xlUm9vdCA9IC1iIC8gKDIgKiBhKTtcbiAgICAvLyAxIHJvb3RcbiAgICBpZiAocyA9PT0gMCkgcmV0dXJuIFtzaW5nbGVSb290XTtcbiAgICB2YXIgZGVsdGEgPSBNYXRoLnNxcnQocykgLyAoMiAqIGEpO1xuICAgIC8vIDIgcm9vdHNcbiAgICByZXR1cm4gW3NpbmdsZVJvb3QgLSBkZWx0YSwgc2luZ2xlUm9vdCArIGRlbHRhXTtcbiAgfVxuICBmdW5jdGlvbiBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwLCBwMSwgcDIsIHAzKSB7XG4gICAgcmV0dXJuIFstcDAgKyAzICogcDEgLSAzICogcDIgKyBwMywgMyAqIHAwIC0gNiAqIHAxICsgMyAqIHAyLCAtMyAqIHAwICsgMyAqIHAxLCBwMF07XG4gIH1cbiAgZnVuY3Rpb24gc2luZ2xlUG9pbnQocCkge1xuICAgIHJldHVybiBuZXcgUG9seW5vbWlhbEJlemllcihwLCBwLCBwLCBwLCBmYWxzZSk7XG4gIH1cbiAgZnVuY3Rpb24gUG9seW5vbWlhbEJlemllcihwMCwgcDEsIHAyLCBwMywgbGluZWFyaXplKSB7XG4gICAgaWYgKGxpbmVhcml6ZSAmJiBwb2ludEVxdWFsKHAwLCBwMSkpIHtcbiAgICAgIHAxID0gbGVycFBvaW50KHAwLCBwMywgMSAvIDMpO1xuICAgIH1cbiAgICBpZiAobGluZWFyaXplICYmIHBvaW50RXF1YWwocDIsIHAzKSkge1xuICAgICAgcDIgPSBsZXJwUG9pbnQocDAsIHAzLCAyIC8gMyk7XG4gICAgfVxuICAgIHZhciBjb2VmZnggPSBwb2x5bm9taWFsQ29lZmZpY2llbnRzKHAwWzBdLCBwMVswXSwgcDJbMF0sIHAzWzBdKTtcbiAgICB2YXIgY29lZmZ5ID0gcG9seW5vbWlhbENvZWZmaWNpZW50cyhwMFsxXSwgcDFbMV0sIHAyWzFdLCBwM1sxXSk7XG4gICAgdGhpcy5hID0gW2NvZWZmeFswXSwgY29lZmZ5WzBdXTtcbiAgICB0aGlzLmIgPSBbY29lZmZ4WzFdLCBjb2VmZnlbMV1dO1xuICAgIHRoaXMuYyA9IFtjb2VmZnhbMl0sIGNvZWZmeVsyXV07XG4gICAgdGhpcy5kID0gW2NvZWZmeFszXSwgY29lZmZ5WzNdXTtcbiAgICB0aGlzLnBvaW50cyA9IFtwMCwgcDEsIHAyLCBwM107XG4gIH1cbiAgUG9seW5vbWlhbEJlemllci5wcm90b3R5cGUucG9pbnQgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbKCh0aGlzLmFbMF0gKiB0ICsgdGhpcy5iWzBdKSAqIHQgKyB0aGlzLmNbMF0pICogdCArIHRoaXMuZFswXSwgKCh0aGlzLmFbMV0gKiB0ICsgdGhpcy5iWzFdKSAqIHQgKyB0aGlzLmNbMV0pICogdCArIHRoaXMuZFsxXV07XG4gIH07XG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmRlcml2YXRpdmUgPSBmdW5jdGlvbiAodCkge1xuICAgIHJldHVybiBbKDMgKiB0ICogdGhpcy5hWzBdICsgMiAqIHRoaXMuYlswXSkgKiB0ICsgdGhpcy5jWzBdLCAoMyAqIHQgKiB0aGlzLmFbMV0gKyAyICogdGhpcy5iWzFdKSAqIHQgKyB0aGlzLmNbMV1dO1xuICB9O1xuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS50YW5nZW50QW5nbGUgPSBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwID0gdGhpcy5kZXJpdmF0aXZlKHQpO1xuICAgIHJldHVybiBNYXRoLmF0YW4yKHBbMV0sIHBbMF0pO1xuICB9O1xuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5ub3JtYWxBbmdsZSA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAgPSB0aGlzLmRlcml2YXRpdmUodCk7XG4gICAgcmV0dXJuIE1hdGguYXRhbjIocFswXSwgcFsxXSk7XG4gIH07XG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmluZmxlY3Rpb25Qb2ludHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlbm9tID0gdGhpcy5hWzFdICogdGhpcy5iWzBdIC0gdGhpcy5hWzBdICogdGhpcy5iWzFdO1xuICAgIGlmIChmbG9hdFplcm8oZGVub20pKSByZXR1cm4gW107XG4gICAgdmFyIHRjdXNwID0gLTAuNSAqICh0aGlzLmFbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmFbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgdmFyIHNxdWFyZSA9IHRjdXNwICogdGN1c3AgLSAxIC8gMyAqICh0aGlzLmJbMV0gKiB0aGlzLmNbMF0gLSB0aGlzLmJbMF0gKiB0aGlzLmNbMV0pIC8gZGVub207XG4gICAgaWYgKHNxdWFyZSA8IDApIHJldHVybiBbXTtcbiAgICB2YXIgcm9vdCA9IE1hdGguc3FydChzcXVhcmUpO1xuICAgIGlmIChmbG9hdFplcm8ocm9vdCkpIHtcbiAgICAgIGlmIChyb290ID4gMCAmJiByb290IDwgMSkgcmV0dXJuIFt0Y3VzcF07XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBbdGN1c3AgLSByb290LCB0Y3VzcCArIHJvb3RdLmZpbHRlcihmdW5jdGlvbiAocikge1xuICAgICAgcmV0dXJuIHIgPiAwICYmIHIgPCAxO1xuICAgIH0pO1xuICB9O1xuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5zcGxpdCA9IGZ1bmN0aW9uICh0KSB7XG4gICAgaWYgKHQgPD0gMCkgcmV0dXJuIFtzaW5nbGVQb2ludCh0aGlzLnBvaW50c1swXSksIHRoaXNdO1xuICAgIGlmICh0ID49IDEpIHJldHVybiBbdGhpcywgc2luZ2xlUG9pbnQodGhpcy5wb2ludHNbdGhpcy5wb2ludHMubGVuZ3RoIC0gMV0pXTtcbiAgICB2YXIgcDEwID0gbGVycFBvaW50KHRoaXMucG9pbnRzWzBdLCB0aGlzLnBvaW50c1sxXSwgdCk7XG4gICAgdmFyIHAxMSA9IGxlcnBQb2ludCh0aGlzLnBvaW50c1sxXSwgdGhpcy5wb2ludHNbMl0sIHQpO1xuICAgIHZhciBwMTIgPSBsZXJwUG9pbnQodGhpcy5wb2ludHNbMl0sIHRoaXMucG9pbnRzWzNdLCB0KTtcbiAgICB2YXIgcDIwID0gbGVycFBvaW50KHAxMCwgcDExLCB0KTtcbiAgICB2YXIgcDIxID0gbGVycFBvaW50KHAxMSwgcDEyLCB0KTtcbiAgICB2YXIgcDMgPSBsZXJwUG9pbnQocDIwLCBwMjEsIHQpO1xuICAgIHJldHVybiBbbmV3IFBvbHlub21pYWxCZXppZXIodGhpcy5wb2ludHNbMF0sIHAxMCwgcDIwLCBwMywgdHJ1ZSksIG5ldyBQb2x5bm9taWFsQmV6aWVyKHAzLCBwMjEsIHAxMiwgdGhpcy5wb2ludHNbM10sIHRydWUpXTtcbiAgfTtcbiAgZnVuY3Rpb24gZXh0cmVtYShiZXosIGNvbXApIHtcbiAgICB2YXIgbWluID0gYmV6LnBvaW50c1swXVtjb21wXTtcbiAgICB2YXIgbWF4ID0gYmV6LnBvaW50c1tiZXoucG9pbnRzLmxlbmd0aCAtIDFdW2NvbXBdO1xuICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgIHZhciBlID0gbWF4O1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gZTtcbiAgICB9XG4gICAgLy8gRGVyaXZhdGl2ZSByb290cyB0byBmaW5kIG1pbi9tYXhcbiAgICB2YXIgZiA9IHF1YWRSb290cygzICogYmV6LmFbY29tcF0sIDIgKiBiZXouYltjb21wXSwgYmV6LmNbY29tcF0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZi5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgaWYgKGZbaV0gPiAwICYmIGZbaV0gPCAxKSB7XG4gICAgICAgIHZhciB2YWwgPSBiZXoucG9pbnQoZltpXSlbY29tcF07XG4gICAgICAgIGlmICh2YWwgPCBtaW4pIG1pbiA9IHZhbDtlbHNlIGlmICh2YWwgPiBtYXgpIG1heCA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIG1pbjogbWluLFxuICAgICAgbWF4OiBtYXhcbiAgICB9O1xuICB9XG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmJvdW5kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgeDogZXh0cmVtYSh0aGlzLCAwKSxcbiAgICAgIHk6IGV4dHJlbWEodGhpcywgMSlcbiAgICB9O1xuICB9O1xuICBQb2x5bm9taWFsQmV6aWVyLnByb3RvdHlwZS5ib3VuZGluZ0JveCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5ib3VuZHMoKTtcbiAgICByZXR1cm4ge1xuICAgICAgbGVmdDogYm91bmRzLngubWluLFxuICAgICAgcmlnaHQ6IGJvdW5kcy54Lm1heCxcbiAgICAgIHRvcDogYm91bmRzLnkubWluLFxuICAgICAgYm90dG9tOiBib3VuZHMueS5tYXgsXG4gICAgICB3aWR0aDogYm91bmRzLngubWF4IC0gYm91bmRzLngubWluLFxuICAgICAgaGVpZ2h0OiBib3VuZHMueS5tYXggLSBib3VuZHMueS5taW4sXG4gICAgICBjeDogKGJvdW5kcy54Lm1heCArIGJvdW5kcy54Lm1pbikgLyAyLFxuICAgICAgY3k6IChib3VuZHMueS5tYXggKyBib3VuZHMueS5taW4pIC8gMlxuICAgIH07XG4gIH07XG4gIGZ1bmN0aW9uIGludGVyc2VjdERhdGEoYmV6LCB0MSwgdDIpIHtcbiAgICB2YXIgYm94ID0gYmV6LmJvdW5kaW5nQm94KCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGN4OiBib3guY3gsXG4gICAgICBjeTogYm94LmN5LFxuICAgICAgd2lkdGg6IGJveC53aWR0aCxcbiAgICAgIGhlaWdodDogYm94LmhlaWdodCxcbiAgICAgIGJlejogYmV6LFxuICAgICAgdDogKHQxICsgdDIpIC8gMixcbiAgICAgIHQxOiB0MSxcbiAgICAgIHQyOiB0MlxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gc3BsaXREYXRhKGRhdGEpIHtcbiAgICB2YXIgc3BsaXQgPSBkYXRhLmJlei5zcGxpdCgwLjUpO1xuICAgIHJldHVybiBbaW50ZXJzZWN0RGF0YShzcGxpdFswXSwgZGF0YS50MSwgZGF0YS50KSwgaW50ZXJzZWN0RGF0YShzcGxpdFsxXSwgZGF0YS50LCBkYXRhLnQyKV07XG4gIH1cbiAgZnVuY3Rpb24gYm94SW50ZXJzZWN0KGIxLCBiMikge1xuICAgIHJldHVybiBNYXRoLmFicyhiMS5jeCAtIGIyLmN4KSAqIDIgPCBiMS53aWR0aCArIGIyLndpZHRoICYmIE1hdGguYWJzKGIxLmN5IC0gYjIuY3kpICogMiA8IGIxLmhlaWdodCArIGIyLmhlaWdodDtcbiAgfVxuICBmdW5jdGlvbiBpbnRlcnNlY3RzSW1wbChkMSwgZDIsIGRlcHRoLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbikge1xuICAgIGlmICghYm94SW50ZXJzZWN0KGQxLCBkMikpIHJldHVybjtcbiAgICBpZiAoZGVwdGggPj0gbWF4UmVjdXJzaW9uIHx8IGQxLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMS5oZWlnaHQgPD0gdG9sZXJhbmNlICYmIGQyLndpZHRoIDw9IHRvbGVyYW5jZSAmJiBkMi5oZWlnaHQgPD0gdG9sZXJhbmNlKSB7XG4gICAgICBpbnRlcnNlY3Rpb25zLnB1c2goW2QxLnQsIGQyLnRdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGQxcyA9IHNwbGl0RGF0YShkMSk7XG4gICAgdmFyIGQycyA9IHNwbGl0RGF0YShkMik7XG4gICAgaW50ZXJzZWN0c0ltcGwoZDFzWzBdLCBkMnNbMF0sIGRlcHRoICsgMSwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICAgIGludGVyc2VjdHNJbXBsKGQxc1swXSwgZDJzWzFdLCBkZXB0aCArIDEsIHRvbGVyYW5jZSwgaW50ZXJzZWN0aW9ucywgbWF4UmVjdXJzaW9uKTtcbiAgICBpbnRlcnNlY3RzSW1wbChkMXNbMV0sIGQyc1swXSwgZGVwdGggKyAxLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gICAgaW50ZXJzZWN0c0ltcGwoZDFzWzFdLCBkMnNbMV0sIGRlcHRoICsgMSwgdG9sZXJhbmNlLCBpbnRlcnNlY3Rpb25zLCBtYXhSZWN1cnNpb24pO1xuICB9XG4gIFBvbHlub21pYWxCZXppZXIucHJvdG90eXBlLmludGVyc2VjdGlvbnMgPSBmdW5jdGlvbiAob3RoZXIsIHRvbGVyYW5jZSwgbWF4UmVjdXJzaW9uKSB7XG4gICAgaWYgKHRvbGVyYW5jZSA9PT0gdW5kZWZpbmVkKSB0b2xlcmFuY2UgPSAyO1xuICAgIGlmIChtYXhSZWN1cnNpb24gPT09IHVuZGVmaW5lZCkgbWF4UmVjdXJzaW9uID0gNztcbiAgICB2YXIgaW50ZXJzZWN0aW9ucyA9IFtdO1xuICAgIGludGVyc2VjdHNJbXBsKGludGVyc2VjdERhdGEodGhpcywgMCwgMSksIGludGVyc2VjdERhdGEob3RoZXIsIDAsIDEpLCAwLCB0b2xlcmFuY2UsIGludGVyc2VjdGlvbnMsIG1heFJlY3Vyc2lvbik7XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH07XG4gIFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50ID0gZnVuY3Rpb24gKHNoYXBlUGF0aCwgaW5kZXgpIHtcbiAgICB2YXIgbmV4dEluZGV4ID0gKGluZGV4ICsgMSkgJSBzaGFwZVBhdGgubGVuZ3RoKCk7XG4gICAgcmV0dXJuIG5ldyBQb2x5bm9taWFsQmV6aWVyKHNoYXBlUGF0aC52W2luZGV4XSwgc2hhcGVQYXRoLm9baW5kZXhdLCBzaGFwZVBhdGguaVtuZXh0SW5kZXhdLCBzaGFwZVBhdGgudltuZXh0SW5kZXhdLCB0cnVlKTtcbiAgfTtcbiAgUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnRJbnZlcnRlZCA9IGZ1bmN0aW9uIChzaGFwZVBhdGgsIGluZGV4KSB7XG4gICAgdmFyIG5leHRJbmRleCA9IChpbmRleCArIDEpICUgc2hhcGVQYXRoLmxlbmd0aCgpO1xuICAgIHJldHVybiBuZXcgUG9seW5vbWlhbEJlemllcihzaGFwZVBhdGgudltuZXh0SW5kZXhdLCBzaGFwZVBhdGguaVtuZXh0SW5kZXhdLCBzaGFwZVBhdGgub1tpbmRleF0sIHNoYXBlUGF0aC52W2luZGV4XSwgdHJ1ZSk7XG4gIH07XG4gIGZ1bmN0aW9uIGNyb3NzUHJvZHVjdChhLCBiKSB7XG4gICAgcmV0dXJuIFthWzFdICogYlsyXSAtIGFbMl0gKiBiWzFdLCBhWzJdICogYlswXSAtIGFbMF0gKiBiWzJdLCBhWzBdICogYlsxXSAtIGFbMV0gKiBiWzBdXTtcbiAgfVxuICBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uKHN0YXJ0MSwgZW5kMSwgc3RhcnQyLCBlbmQyKSB7XG4gICAgdmFyIHYxID0gW3N0YXJ0MVswXSwgc3RhcnQxWzFdLCAxXTtcbiAgICB2YXIgdjIgPSBbZW5kMVswXSwgZW5kMVsxXSwgMV07XG4gICAgdmFyIHYzID0gW3N0YXJ0MlswXSwgc3RhcnQyWzFdLCAxXTtcbiAgICB2YXIgdjQgPSBbZW5kMlswXSwgZW5kMlsxXSwgMV07XG4gICAgdmFyIHIgPSBjcm9zc1Byb2R1Y3QoY3Jvc3NQcm9kdWN0KHYxLCB2MiksIGNyb3NzUHJvZHVjdCh2MywgdjQpKTtcbiAgICBpZiAoZmxvYXRaZXJvKHJbMl0pKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gW3JbMF0gLyByWzJdLCByWzFdIC8gclsyXV07XG4gIH1cbiAgZnVuY3Rpb24gcG9sYXJPZmZzZXQocCwgYW5nbGUsIGxlbmd0aCkge1xuICAgIHJldHVybiBbcFswXSArIE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCwgcFsxXSAtIE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aF07XG4gIH1cbiAgZnVuY3Rpb24gcG9pbnREaXN0YW5jZShwMSwgcDIpIHtcbiAgICByZXR1cm4gTWF0aC5oeXBvdChwMVswXSAtIHAyWzBdLCBwMVsxXSAtIHAyWzFdKTtcbiAgfVxuICBmdW5jdGlvbiBwb2ludEVxdWFsKHAxLCBwMikge1xuICAgIHJldHVybiBmbG9hdEVxdWFsKHAxWzBdLCBwMlswXSkgJiYgZmxvYXRFcXVhbChwMVsxXSwgcDJbMV0pO1xuICB9XG5cbiAgZnVuY3Rpb24gWmlnWmFnTW9kaWZpZXIoKSB7fVxuICBleHRlbmRQcm90b3R5cGUoW1NoYXBlTW9kaWZpZXJdLCBaaWdaYWdNb2RpZmllcik7XG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5pbml0TW9kaWZpZXJQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLmdldFZhbHVlID0gdGhpcy5wcm9jZXNzS2V5cztcbiAgICB0aGlzLmFtcGxpdHVkZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5mcmVxdWVuY3kgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnIsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMucG9pbnRzVHlwZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucHQsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLmFtcGxpdHVkZS5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwIHx8IHRoaXMuZnJlcXVlbmN5LmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggIT09IDAgfHwgdGhpcy5wb2ludHNUeXBlLmVmZmVjdHNTZXF1ZW5jZS5sZW5ndGggIT09IDA7XG4gIH07XG4gIGZ1bmN0aW9uIHNldFBvaW50KG91dHB1dEJlemllciwgcG9pbnQsIGFuZ2xlLCBkaXJlY3Rpb24sIGFtcGxpdHVkZSwgb3V0QW1wbGl0dWRlLCBpbkFtcGxpdHVkZSkge1xuICAgIHZhciBhbmdPID0gYW5nbGUgLSBNYXRoLlBJIC8gMjtcbiAgICB2YXIgYW5nSSA9IGFuZ2xlICsgTWF0aC5QSSAvIDI7XG4gICAgdmFyIHB4ID0gcG9pbnRbMF0gKyBNYXRoLmNvcyhhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgdmFyIHB5ID0gcG9pbnRbMV0gLSBNYXRoLnNpbihhbmdsZSkgKiBkaXJlY3Rpb24gKiBhbXBsaXR1ZGU7XG4gICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHB4LCBweSwgcHggKyBNYXRoLmNvcyhhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHkgLSBNYXRoLnNpbihhbmdPKSAqIG91dEFtcGxpdHVkZSwgcHggKyBNYXRoLmNvcyhhbmdJKSAqIGluQW1wbGl0dWRlLCBweSAtIE1hdGguc2luKGFuZ0kpICogaW5BbXBsaXR1ZGUsIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0UGVycGVuZGljdWxhclZlY3RvcihwdDEsIHB0Mikge1xuICAgIHZhciB2ZWN0b3IgPSBbcHQyWzBdIC0gcHQxWzBdLCBwdDJbMV0gLSBwdDFbMV1dO1xuICAgIHZhciByb3QgPSAtTWF0aC5QSSAqIDAuNTtcbiAgICB2YXIgcm90YXRlZFZlY3RvciA9IFtNYXRoLmNvcyhyb3QpICogdmVjdG9yWzBdIC0gTWF0aC5zaW4ocm90KSAqIHZlY3RvclsxXSwgTWF0aC5zaW4ocm90KSAqIHZlY3RvclswXSArIE1hdGguY29zKHJvdCkgKiB2ZWN0b3JbMV1dO1xuICAgIHJldHVybiByb3RhdGVkVmVjdG9yO1xuICB9XG4gIGZ1bmN0aW9uIGdldFByb2plY3RpbmdBbmdsZShwYXRoLCBjdXIpIHtcbiAgICB2YXIgcHJldkluZGV4ID0gY3VyID09PSAwID8gcGF0aC5sZW5ndGgoKSAtIDEgOiBjdXIgLSAxO1xuICAgIHZhciBuZXh0SW5kZXggPSAoY3VyICsgMSkgJSBwYXRoLmxlbmd0aCgpO1xuICAgIHZhciBwcmV2UG9pbnQgPSBwYXRoLnZbcHJldkluZGV4XTtcbiAgICB2YXIgbmV4dFBvaW50ID0gcGF0aC52W25leHRJbmRleF07XG4gICAgdmFyIHBWZWN0b3IgPSBnZXRQZXJwZW5kaWN1bGFyVmVjdG9yKHByZXZQb2ludCwgbmV4dFBvaW50KTtcbiAgICByZXR1cm4gTWF0aC5hdGFuMigwLCAxKSAtIE1hdGguYXRhbjIocFZlY3RvclsxXSwgcFZlY3RvclswXSk7XG4gIH1cbiAgZnVuY3Rpb24gemlnWmFnQ29ybmVyKG91dHB1dEJlemllciwgcGF0aCwgY3VyLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlLCBkaXJlY3Rpb24pIHtcbiAgICB2YXIgYW5nbGUgPSBnZXRQcm9qZWN0aW5nQW5nbGUocGF0aCwgY3VyKTtcbiAgICB2YXIgcG9pbnQgPSBwYXRoLnZbY3VyICUgcGF0aC5fbGVuZ3RoXTtcbiAgICB2YXIgcHJldlBvaW50ID0gcGF0aC52W2N1ciA9PT0gMCA/IHBhdGguX2xlbmd0aCAtIDEgOiBjdXIgLSAxXTtcbiAgICB2YXIgbmV4dFBvaW50ID0gcGF0aC52WyhjdXIgKyAxKSAlIHBhdGguX2xlbmd0aF07XG4gICAgdmFyIHByZXZEaXN0ID0gcG9pbnRUeXBlID09PSAyID8gTWF0aC5zcXJ0KE1hdGgucG93KHBvaW50WzBdIC0gcHJldlBvaW50WzBdLCAyKSArIE1hdGgucG93KHBvaW50WzFdIC0gcHJldlBvaW50WzFdLCAyKSkgOiAwO1xuICAgIHZhciBuZXh0RGlzdCA9IHBvaW50VHlwZSA9PT0gMiA/IE1hdGguc3FydChNYXRoLnBvdyhwb2ludFswXSAtIG5leHRQb2ludFswXSwgMikgKyBNYXRoLnBvdyhwb2ludFsxXSAtIG5leHRQb2ludFsxXSwgMikpIDogMDtcbiAgICBzZXRQb2ludChvdXRwdXRCZXppZXIsIHBhdGgudltjdXIgJSBwYXRoLl9sZW5ndGhdLCBhbmdsZSwgZGlyZWN0aW9uLCBhbXBsaXR1ZGUsIG5leHREaXN0IC8gKChmcmVxdWVuY3kgKyAxKSAqIDIpLCBwcmV2RGlzdCAvICgoZnJlcXVlbmN5ICsgMSkgKiAyKSwgcG9pbnRUeXBlKTtcbiAgfVxuICBmdW5jdGlvbiB6aWdaYWdTZWdtZW50KG91dHB1dEJlemllciwgc2VnbWVudCwgYW1wbGl0dWRlLCBmcmVxdWVuY3ksIHBvaW50VHlwZSwgZGlyZWN0aW9uKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmcmVxdWVuY3k7IGkgKz0gMSkge1xuICAgICAgdmFyIHQgPSAoaSArIDEpIC8gKGZyZXF1ZW5jeSArIDEpO1xuICAgICAgdmFyIGRpc3QgPSBwb2ludFR5cGUgPT09IDIgPyBNYXRoLnNxcnQoTWF0aC5wb3coc2VnbWVudC5wb2ludHNbM11bMF0gLSBzZWdtZW50LnBvaW50c1swXVswXSwgMikgKyBNYXRoLnBvdyhzZWdtZW50LnBvaW50c1szXVsxXSAtIHNlZ21lbnQucG9pbnRzWzBdWzFdLCAyKSkgOiAwO1xuICAgICAgdmFyIGFuZ2xlID0gc2VnbWVudC5ub3JtYWxBbmdsZSh0KTtcbiAgICAgIHZhciBwb2ludCA9IHNlZ21lbnQucG9pbnQodCk7XG4gICAgICBzZXRQb2ludChvdXRwdXRCZXppZXIsIHBvaW50LCBhbmdsZSwgZGlyZWN0aW9uLCBhbXBsaXR1ZGUsIGRpc3QgLyAoKGZyZXF1ZW5jeSArIDEpICogMiksIGRpc3QgLyAoKGZyZXF1ZW5jeSArIDEpICogMiksIHBvaW50VHlwZSk7XG4gICAgICBkaXJlY3Rpb24gPSAtZGlyZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gZGlyZWN0aW9uO1xuICB9XG4gIFppZ1phZ01vZGlmaWVyLnByb3RvdHlwZS5wcm9jZXNzUGF0aCA9IGZ1bmN0aW9uIChwYXRoLCBhbXBsaXR1ZGUsIGZyZXF1ZW5jeSwgcG9pbnRUeXBlKSB7XG4gICAgdmFyIGNvdW50ID0gcGF0aC5fbGVuZ3RoO1xuICAgIHZhciBjbG9uZWRQYXRoID0gc2hhcGVQb29sLm5ld0VsZW1lbnQoKTtcbiAgICBjbG9uZWRQYXRoLmMgPSBwYXRoLmM7XG4gICAgaWYgKCFwYXRoLmMpIHtcbiAgICAgIGNvdW50IC09IDE7XG4gICAgfVxuICAgIGlmIChjb3VudCA9PT0gMCkgcmV0dXJuIGNsb25lZFBhdGg7XG4gICAgdmFyIGRpcmVjdGlvbiA9IC0xO1xuICAgIHZhciBzZWdtZW50ID0gUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnQocGF0aCwgMCk7XG4gICAgemlnWmFnQ29ybmVyKGNsb25lZFBhdGgsIHBhdGgsIDAsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIGRpcmVjdGlvbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSArPSAxKSB7XG4gICAgICBkaXJlY3Rpb24gPSB6aWdaYWdTZWdtZW50KGNsb25lZFBhdGgsIHNlZ21lbnQsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIC1kaXJlY3Rpb24pO1xuICAgICAgaWYgKGkgPT09IGNvdW50IC0gMSAmJiAhcGF0aC5jKSB7XG4gICAgICAgIHNlZ21lbnQgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KHBhdGgsIChpICsgMSkgJSBjb3VudCk7XG4gICAgICB9XG4gICAgICB6aWdaYWdDb3JuZXIoY2xvbmVkUGF0aCwgcGF0aCwgaSArIDEsIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUsIGRpcmVjdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBjbG9uZWRQYXRoO1xuICB9O1xuICBaaWdaYWdNb2RpZmllci5wcm90b3R5cGUucHJvY2Vzc1NoYXBlcyA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIHNoYXBlUGF0aHM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgYW1wbGl0dWRlID0gdGhpcy5hbXBsaXR1ZGUudjtcbiAgICB2YXIgZnJlcXVlbmN5ID0gTWF0aC5tYXgoMCwgTWF0aC5yb3VuZCh0aGlzLmZyZXF1ZW5jeS52KSk7XG4gICAgdmFyIHBvaW50VHlwZSA9IHRoaXMucG9pbnRzVHlwZS52O1xuICAgIGlmIChhbXBsaXR1ZGUgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICBpZiAoISghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xuICAgICAgICAgIGpMZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtcGxpdHVkZSwgZnJlcXVlbmN5LCBwb2ludFR5cGUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gbGluZWFyT2Zmc2V0KHAxLCBwMiwgYW1vdW50KSB7XG4gICAgdmFyIGFuZ2xlID0gTWF0aC5hdGFuMihwMlswXSAtIHAxWzBdLCBwMlsxXSAtIHAxWzFdKTtcbiAgICByZXR1cm4gW3BvbGFyT2Zmc2V0KHAxLCBhbmdsZSwgYW1vdW50KSwgcG9sYXJPZmZzZXQocDIsIGFuZ2xlLCBhbW91bnQpXTtcbiAgfVxuICBmdW5jdGlvbiBvZmZzZXRTZWdtZW50KHNlZ21lbnQsIGFtb3VudCkge1xuICAgIHZhciBwMDtcbiAgICB2YXIgcDFhO1xuICAgIHZhciBwMWI7XG4gICAgdmFyIHAyYjtcbiAgICB2YXIgcDJhO1xuICAgIHZhciBwMztcbiAgICB2YXIgZTtcbiAgICBlID0gbGluZWFyT2Zmc2V0KHNlZ21lbnQucG9pbnRzWzBdLCBzZWdtZW50LnBvaW50c1sxXSwgYW1vdW50KTtcbiAgICBwMCA9IGVbMF07XG4gICAgcDFhID0gZVsxXTtcbiAgICBlID0gbGluZWFyT2Zmc2V0KHNlZ21lbnQucG9pbnRzWzFdLCBzZWdtZW50LnBvaW50c1syXSwgYW1vdW50KTtcbiAgICBwMWIgPSBlWzBdO1xuICAgIHAyYiA9IGVbMV07XG4gICAgZSA9IGxpbmVhck9mZnNldChzZWdtZW50LnBvaW50c1syXSwgc2VnbWVudC5wb2ludHNbM10sIGFtb3VudCk7XG4gICAgcDJhID0gZVswXTtcbiAgICBwMyA9IGVbMV07XG4gICAgdmFyIHAxID0gbGluZUludGVyc2VjdGlvbihwMCwgcDFhLCBwMWIsIHAyYik7XG4gICAgaWYgKHAxID09PSBudWxsKSBwMSA9IHAxYTtcbiAgICB2YXIgcDIgPSBsaW5lSW50ZXJzZWN0aW9uKHAyYSwgcDMsIHAxYiwgcDJiKTtcbiAgICBpZiAocDIgPT09IG51bGwpIHAyID0gcDJhO1xuICAgIHJldHVybiBuZXcgUG9seW5vbWlhbEJlemllcihwMCwgcDEsIHAyLCBwMyk7XG4gIH1cbiAgZnVuY3Rpb24gam9pbkxpbmVzKG91dHB1dEJlemllciwgc2VnMSwgc2VnMiwgbGluZUpvaW4sIG1pdGVyTGltaXQpIHtcbiAgICB2YXIgcDAgPSBzZWcxLnBvaW50c1szXTtcbiAgICB2YXIgcDEgPSBzZWcyLnBvaW50c1swXTtcblxuICAgIC8vIEJldmVsXG4gICAgaWYgKGxpbmVKb2luID09PSAzKSByZXR1cm4gcDA7XG5cbiAgICAvLyBDb25uZWN0ZWQsIHRoZXkgZG9uJ3QgbmVlZCBhIGpvaW50XG4gICAgaWYgKHBvaW50RXF1YWwocDAsIHAxKSkgcmV0dXJuIHAwO1xuXG4gICAgLy8gUm91bmRcbiAgICBpZiAobGluZUpvaW4gPT09IDIpIHtcbiAgICAgIHZhciBhbmdsZU91dCA9IC1zZWcxLnRhbmdlbnRBbmdsZSgxKTtcbiAgICAgIHZhciBhbmdsZUluID0gLXNlZzIudGFuZ2VudEFuZ2xlKDApICsgTWF0aC5QSTtcbiAgICAgIHZhciBjZW50ZXIgPSBsaW5lSW50ZXJzZWN0aW9uKHAwLCBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQgKyBNYXRoLlBJIC8gMiwgMTAwKSwgcDEsIHBvbGFyT2Zmc2V0KHAxLCBhbmdsZU91dCArIE1hdGguUEkgLyAyLCAxMDApKTtcbiAgICAgIHZhciByYWRpdXMgPSBjZW50ZXIgPyBwb2ludERpc3RhbmNlKGNlbnRlciwgcDApIDogcG9pbnREaXN0YW5jZShwMCwgcDEpIC8gMjtcbiAgICAgIHZhciB0YW4gPSBwb2xhck9mZnNldChwMCwgYW5nbGVPdXQsIDIgKiByYWRpdXMgKiByb3VuZENvcm5lcik7XG4gICAgICBvdXRwdXRCZXppZXIuc2V0WFlBdCh0YW5bMF0sIHRhblsxXSwgJ28nLCBvdXRwdXRCZXppZXIubGVuZ3RoKCkgLSAxKTtcbiAgICAgIHRhbiA9IHBvbGFyT2Zmc2V0KHAxLCBhbmdsZUluLCAyICogcmFkaXVzICogcm91bmRDb3JuZXIpO1xuICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHAxWzBdLCBwMVsxXSwgcDFbMF0sIHAxWzFdLCB0YW5bMF0sIHRhblsxXSwgb3V0cHV0QmV6aWVyLmxlbmd0aCgpKTtcbiAgICAgIHJldHVybiBwMTtcbiAgICB9XG5cbiAgICAvLyBNaXRlclxuICAgIHZhciB0MCA9IHBvaW50RXF1YWwocDAsIHNlZzEucG9pbnRzWzJdKSA/IHNlZzEucG9pbnRzWzBdIDogc2VnMS5wb2ludHNbMl07XG4gICAgdmFyIHQxID0gcG9pbnRFcXVhbChwMSwgc2VnMi5wb2ludHNbMV0pID8gc2VnMi5wb2ludHNbM10gOiBzZWcyLnBvaW50c1sxXTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdGlvbih0MCwgcDAsIHAxLCB0MSk7XG4gICAgaWYgKGludGVyc2VjdGlvbiAmJiBwb2ludERpc3RhbmNlKGludGVyc2VjdGlvbiwgcDApIDwgbWl0ZXJMaW1pdCkge1xuICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KGludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdLCBpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXSwgaW50ZXJzZWN0aW9uWzBdLCBpbnRlcnNlY3Rpb25bMV0sIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gICAgICByZXR1cm4gaW50ZXJzZWN0aW9uO1xuICAgIH1cbiAgICByZXR1cm4gcDA7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0SW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICB2YXIgaW50ZXJzZWN0ID0gYS5pbnRlcnNlY3Rpb25zKGIpO1xuICAgIGlmIChpbnRlcnNlY3QubGVuZ3RoICYmIGZsb2F0RXF1YWwoaW50ZXJzZWN0WzBdWzBdLCAxKSkgaW50ZXJzZWN0LnNoaWZ0KCk7XG4gICAgaWYgKGludGVyc2VjdC5sZW5ndGgpIHJldHVybiBpbnRlcnNlY3RbMF07XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgZnVuY3Rpb24gcHJ1bmVTZWdtZW50SW50ZXJzZWN0aW9uKGEsIGIpIHtcbiAgICB2YXIgb3V0YSA9IGEuc2xpY2UoKTtcbiAgICB2YXIgb3V0YiA9IGIuc2xpY2UoKTtcbiAgICB2YXIgaW50ZXJzZWN0ID0gZ2V0SW50ZXJzZWN0aW9uKGFbYS5sZW5ndGggLSAxXSwgYlswXSk7XG4gICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgb3V0YVthLmxlbmd0aCAtIDFdID0gYVthLmxlbmd0aCAtIDFdLnNwbGl0KGludGVyc2VjdFswXSlbMF07XG4gICAgICBvdXRiWzBdID0gYlswXS5zcGxpdChpbnRlcnNlY3RbMV0pWzFdO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggPiAxICYmIGIubGVuZ3RoID4gMSkge1xuICAgICAgaW50ZXJzZWN0ID0gZ2V0SW50ZXJzZWN0aW9uKGFbMF0sIGJbYi5sZW5ndGggLSAxXSk7XG4gICAgICBpZiAoaW50ZXJzZWN0KSB7XG4gICAgICAgIHJldHVybiBbW2FbMF0uc3BsaXQoaW50ZXJzZWN0WzBdKVswXV0sIFtiW2IubGVuZ3RoIC0gMV0uc3BsaXQoaW50ZXJzZWN0WzFdKVsxXV1dO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gW291dGEsIG91dGJdO1xuICB9XG4gIGZ1bmN0aW9uIHBydW5lSW50ZXJzZWN0aW9ucyhzZWdtZW50cykge1xuICAgIHZhciBlO1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGUgPSBwcnVuZVNlZ21lbnRJbnRlcnNlY3Rpb24oc2VnbWVudHNbaSAtIDFdLCBzZWdtZW50c1tpXSk7XG4gICAgICBzZWdtZW50c1tpIC0gMV0gPSBlWzBdO1xuICAgICAgc2VnbWVudHNbaV0gPSBlWzFdO1xuICAgIH1cbiAgICBpZiAoc2VnbWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgZSA9IHBydW5lU2VnbWVudEludGVyc2VjdGlvbihzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgc2VnbWVudHNbMF0pO1xuICAgICAgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0gPSBlWzBdO1xuICAgICAgc2VnbWVudHNbMF0gPSBlWzFdO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudHM7XG4gIH1cbiAgZnVuY3Rpb24gb2Zmc2V0U2VnbWVudFNwbGl0KHNlZ21lbnQsIGFtb3VudCkge1xuICAgIC8qXG4gICAgICBXZSBzcGxpdCBlYWNoIGJlemllciBzZWdtZW50IGludG8gc21hbGxlciBwaWVjZXMgYmFzZWRcbiAgICAgIG9uIGluZmxlY3Rpb24gcG9pbnRzLCB0aGlzIGVuc3VyZXMgdGhlIGNvbnRyb2wgcG9pbnRcbiAgICAgIHBvbHlnb24gaXMgY29udmV4LlxuICAgICAgIChBIGN1YmljIGJlemllciBjYW4gaGF2ZSBub25lLCBvbmUsIG9yIHR3byBpbmZsZWN0aW9uIHBvaW50cylcbiAgICAqL1xuICAgIHZhciBmbGV4ID0gc2VnbWVudC5pbmZsZWN0aW9uUG9pbnRzKCk7XG4gICAgdmFyIGxlZnQ7XG4gICAgdmFyIHJpZ2h0O1xuICAgIHZhciBzcGxpdDtcbiAgICB2YXIgbWlkO1xuICAgIGlmIChmbGV4Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIFtvZmZzZXRTZWdtZW50KHNlZ21lbnQsIGFtb3VudCldO1xuICAgIH1cbiAgICBpZiAoZmxleC5sZW5ndGggPT09IDEgfHwgZmxvYXRFcXVhbChmbGV4WzFdLCAxKSkge1xuICAgICAgc3BsaXQgPSBzZWdtZW50LnNwbGl0KGZsZXhbMF0pO1xuICAgICAgbGVmdCA9IHNwbGl0WzBdO1xuICAgICAgcmlnaHQgPSBzcGxpdFsxXTtcbiAgICAgIHJldHVybiBbb2Zmc2V0U2VnbWVudChsZWZ0LCBhbW91bnQpLCBvZmZzZXRTZWdtZW50KHJpZ2h0LCBhbW91bnQpXTtcbiAgICB9XG4gICAgc3BsaXQgPSBzZWdtZW50LnNwbGl0KGZsZXhbMF0pO1xuICAgIGxlZnQgPSBzcGxpdFswXTtcbiAgICB2YXIgdCA9IChmbGV4WzFdIC0gZmxleFswXSkgLyAoMSAtIGZsZXhbMF0pO1xuICAgIHNwbGl0ID0gc3BsaXRbMV0uc3BsaXQodCk7XG4gICAgbWlkID0gc3BsaXRbMF07XG4gICAgcmlnaHQgPSBzcGxpdFsxXTtcbiAgICByZXR1cm4gW29mZnNldFNlZ21lbnQobGVmdCwgYW1vdW50KSwgb2Zmc2V0U2VnbWVudChtaWQsIGFtb3VudCksIG9mZnNldFNlZ21lbnQocmlnaHQsIGFtb3VudCldO1xuICB9XG4gIGZ1bmN0aW9uIE9mZnNldFBhdGhNb2RpZmllcigpIHt9XG4gIGV4dGVuZFByb3RvdHlwZShbU2hhcGVNb2RpZmllcl0sIE9mZnNldFBhdGhNb2RpZmllcik7XG4gIE9mZnNldFBhdGhNb2RpZmllci5wcm90b3R5cGUuaW5pdE1vZGlmaWVyUHJvcGVydGllcyA9IGZ1bmN0aW9uIChlbGVtLCBkYXRhKSB7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMucHJvY2Vzc0tleXM7XG4gICAgdGhpcy5hbW91bnQgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmEsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMubWl0ZXJMaW1pdCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubWwsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMubGluZUpvaW4gPSBkYXRhLmxqO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSB0aGlzLmFtb3VudC5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoICE9PSAwO1xuICB9O1xuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NQYXRoID0gZnVuY3Rpb24gKGlucHV0QmV6aWVyLCBhbW91bnQsIGxpbmVKb2luLCBtaXRlckxpbWl0KSB7XG4gICAgdmFyIG91dHB1dEJlemllciA9IHNoYXBlUG9vbC5uZXdFbGVtZW50KCk7XG4gICAgb3V0cHV0QmV6aWVyLmMgPSBpbnB1dEJlemllci5jO1xuICAgIHZhciBjb3VudCA9IGlucHV0QmV6aWVyLmxlbmd0aCgpO1xuICAgIGlmICghaW5wdXRCZXppZXIuYykge1xuICAgICAgY291bnQgLT0gMTtcbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGo7XG4gICAgdmFyIHNlZ21lbnQ7XG4gICAgdmFyIG11bHRpU2VnbWVudHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgY291bnQ7IGkgKz0gMSkge1xuICAgICAgc2VnbWVudCA9IFBvbHlub21pYWxCZXppZXIuc2hhcGVTZWdtZW50KGlucHV0QmV6aWVyLCBpKTtcbiAgICAgIG11bHRpU2VnbWVudHMucHVzaChvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSk7XG4gICAgfVxuICAgIGlmICghaW5wdXRCZXppZXIuYykge1xuICAgICAgZm9yIChpID0gY291bnQgLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICBzZWdtZW50ID0gUG9seW5vbWlhbEJlemllci5zaGFwZVNlZ21lbnRJbnZlcnRlZChpbnB1dEJlemllciwgaSk7XG4gICAgICAgIG11bHRpU2VnbWVudHMucHVzaChvZmZzZXRTZWdtZW50U3BsaXQoc2VnbWVudCwgYW1vdW50KSk7XG4gICAgICB9XG4gICAgfVxuICAgIG11bHRpU2VnbWVudHMgPSBwcnVuZUludGVyc2VjdGlvbnMobXVsdGlTZWdtZW50cyk7XG5cbiAgICAvLyBBZGQgYmV6aWVyIHNlZ21lbnRzIHRvIHRoZSBvdXRwdXQgYW5kIGFwcGx5IGxpbmUgam9pbnRzXG4gICAgdmFyIGxhc3RQb2ludCA9IG51bGw7XG4gICAgdmFyIGxhc3RTZWcgPSBudWxsO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtdWx0aVNlZ21lbnRzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICB2YXIgbXVsdGlTZWdtZW50ID0gbXVsdGlTZWdtZW50c1tpXTtcbiAgICAgIGlmIChsYXN0U2VnKSBsYXN0UG9pbnQgPSBqb2luTGluZXMob3V0cHV0QmV6aWVyLCBsYXN0U2VnLCBtdWx0aVNlZ21lbnRbMF0sIGxpbmVKb2luLCBtaXRlckxpbWl0KTtcbiAgICAgIGxhc3RTZWcgPSBtdWx0aVNlZ21lbnRbbXVsdGlTZWdtZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgZm9yIChqID0gMDsgaiA8IG11bHRpU2VnbWVudC5sZW5ndGg7IGogKz0gMSkge1xuICAgICAgICBzZWdtZW50ID0gbXVsdGlTZWdtZW50W2pdO1xuICAgICAgICBpZiAobGFzdFBvaW50ICYmIHBvaW50RXF1YWwoc2VnbWVudC5wb2ludHNbMF0sIGxhc3RQb2ludCkpIHtcbiAgICAgICAgICBvdXRwdXRCZXppZXIuc2V0WFlBdChzZWdtZW50LnBvaW50c1sxXVswXSwgc2VnbWVudC5wb2ludHNbMV1bMV0sICdvJywgb3V0cHV0QmV6aWVyLmxlbmd0aCgpIC0gMSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHNlZ21lbnQucG9pbnRzWzBdWzBdLCBzZWdtZW50LnBvaW50c1swXVsxXSwgc2VnbWVudC5wb2ludHNbMV1bMF0sIHNlZ21lbnQucG9pbnRzWzFdWzFdLCBzZWdtZW50LnBvaW50c1swXVswXSwgc2VnbWVudC5wb2ludHNbMF1bMV0sIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0QmV6aWVyLnNldFRyaXBsZUF0KHNlZ21lbnQucG9pbnRzWzNdWzBdLCBzZWdtZW50LnBvaW50c1szXVsxXSwgc2VnbWVudC5wb2ludHNbM11bMF0sIHNlZ21lbnQucG9pbnRzWzNdWzFdLCBzZWdtZW50LnBvaW50c1syXVswXSwgc2VnbWVudC5wb2ludHNbMl1bMV0sIG91dHB1dEJlemllci5sZW5ndGgoKSk7XG4gICAgICAgIGxhc3RQb2ludCA9IHNlZ21lbnQucG9pbnRzWzNdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobXVsdGlTZWdtZW50cy5sZW5ndGgpIGpvaW5MaW5lcyhvdXRwdXRCZXppZXIsIGxhc3RTZWcsIG11bHRpU2VnbWVudHNbMF1bMF0sIGxpbmVKb2luLCBtaXRlckxpbWl0KTtcbiAgICByZXR1cm4gb3V0cHV0QmV6aWVyO1xuICB9O1xuICBPZmZzZXRQYXRoTW9kaWZpZXIucHJvdG90eXBlLnByb2Nlc3NTaGFwZXMgPSBmdW5jdGlvbiAoX2lzRmlyc3RGcmFtZSkge1xuICAgIHZhciBzaGFwZVBhdGhzO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW47XG4gICAgdmFyIGFtb3VudCA9IHRoaXMuYW1vdW50LnY7XG4gICAgdmFyIG1pdGVyTGltaXQgPSB0aGlzLm1pdGVyTGltaXQudjtcbiAgICB2YXIgbGluZUpvaW4gPSB0aGlzLmxpbmVKb2luO1xuICAgIGlmIChhbW91bnQgIT09IDApIHtcbiAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICB2YXIgbG9jYWxTaGFwZUNvbGxlY3Rpb247XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGVEYXRhID0gdGhpcy5zaGFwZXNbaV07XG4gICAgICAgIGxvY2FsU2hhcGVDb2xsZWN0aW9uID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgICBpZiAoISghc2hhcGVEYXRhLnNoYXBlLl9tZGYgJiYgIXRoaXMuX21kZiAmJiAhX2lzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5yZWxlYXNlU2hhcGVzKCk7XG4gICAgICAgICAgc2hhcGVEYXRhLnNoYXBlLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIHNoYXBlUGF0aHMgPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuc2hhcGVzO1xuICAgICAgICAgIGpMZW4gPSBzaGFwZURhdGEuc2hhcGUucGF0aHMuX2xlbmd0aDtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBsb2NhbFNoYXBlQ29sbGVjdGlvbi5hZGRTaGFwZSh0aGlzLnByb2Nlc3NQYXRoKHNoYXBlUGF0aHNbal0sIGFtb3VudCwgbGluZUpvaW4sIG1pdGVyTGltaXQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc2hhcGVEYXRhLnNoYXBlLnBhdGhzID0gc2hhcGVEYXRhLmxvY2FsU2hhcGVDb2xsZWN0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0Rm9udFByb3BlcnRpZXMoZm9udERhdGEpIHtcbiAgICB2YXIgc3R5bGVzID0gZm9udERhdGEuZlN0eWxlID8gZm9udERhdGEuZlN0eWxlLnNwbGl0KCcgJykgOiBbXTtcbiAgICB2YXIgZldlaWdodCA9ICdub3JtYWwnO1xuICAgIHZhciBmU3R5bGUgPSAnbm9ybWFsJztcbiAgICB2YXIgbGVuID0gc3R5bGVzLmxlbmd0aDtcbiAgICB2YXIgc3R5bGVOYW1lO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHN0eWxlTmFtZSA9IHN0eWxlc1tpXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgc3dpdGNoIChzdHlsZU5hbWUpIHtcbiAgICAgICAgY2FzZSAnaXRhbGljJzpcbiAgICAgICAgICBmU3R5bGUgPSAnaXRhbGljJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYm9sZCc6XG4gICAgICAgICAgZldlaWdodCA9ICc3MDAnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdibGFjayc6XG4gICAgICAgICAgZldlaWdodCA9ICc5MDAnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtZWRpdW0nOlxuICAgICAgICAgIGZXZWlnaHQgPSAnNTAwJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAncmVndWxhcic6XG4gICAgICAgIGNhc2UgJ25vcm1hbCc6XG4gICAgICAgICAgZldlaWdodCA9ICc0MDAnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsaWdodCc6XG4gICAgICAgIGNhc2UgJ3RoaW4nOlxuICAgICAgICAgIGZXZWlnaHQgPSAnMjAwJztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN0eWxlOiBmU3R5bGUsXG4gICAgICB3ZWlnaHQ6IGZvbnREYXRhLmZXZWlnaHQgfHwgZldlaWdodFxuICAgIH07XG4gIH1cblxuICB2YXIgRm9udE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG1heFdhaXRpbmdUaW1lID0gNTAwMDtcbiAgICB2YXIgZW1wdHlDaGFyID0ge1xuICAgICAgdzogMCxcbiAgICAgIHNpemU6IDAsXG4gICAgICBzaGFwZXM6IFtdLFxuICAgICAgZGF0YToge1xuICAgICAgICBzaGFwZXM6IFtdXG4gICAgICB9XG4gICAgfTtcbiAgICB2YXIgY29tYmluZWRDaGFyYWN0ZXJzID0gW107XG4gICAgLy8gSGluZGkgY2hhcmFjdGVyc1xuICAgIGNvbWJpbmVkQ2hhcmFjdGVycyA9IGNvbWJpbmVkQ2hhcmFjdGVycy5jb25jYXQoWzIzMDQsIDIzMDUsIDIzMDYsIDIzMDcsIDIzNjIsIDIzNjMsIDIzNjQsIDIzNjQsIDIzNjYsIDIzNjcsIDIzNjgsIDIzNjksIDIzNzAsIDIzNzEsIDIzNzIsIDIzNzMsIDIzNzQsIDIzNzUsIDIzNzYsIDIzNzcsIDIzNzgsIDIzNzksIDIzODAsIDIzODEsIDIzODIsIDIzODMsIDIzODcsIDIzODgsIDIzODksIDIzOTAsIDIzOTEsIDI0MDIsIDI0MDNdKTtcbiAgICB2YXIgQkxBQ0tfRkxBR19DT0RFX1BPSU5UID0gMTI3OTg4O1xuICAgIHZhciBDQU5DRUxfVEFHX0NPREVfUE9JTlQgPSA5MTc2MzE7XG4gICAgdmFyIEFfVEFHX0NPREVfUE9JTlQgPSA5MTc2MDE7XG4gICAgdmFyIFpfVEFHX0NPREVfUE9JTlQgPSA5MTc2MjY7XG4gICAgdmFyIFZBUklBVElPTl9TRUxFQ1RPUl8xNl9DT0RFX1BPSU5UID0gNjUwMzk7XG4gICAgdmFyIFpFUk9fV0lEVEhfSk9JTkVSX0NPREVfUE9JTlQgPSA4MjA1O1xuICAgIHZhciBSRUdJT05BTF9DSEFSQUNURVJfQV9DT0RFX1BPSU5UID0gMTI3NDYyO1xuICAgIHZhciBSRUdJT05BTF9DSEFSQUNURVJfWl9DT0RFX1BPSU5UID0gMTI3NDg3O1xuICAgIHZhciBzdXJyb2dhdGVNb2RpZmllcnMgPSBbJ2Q4M2NkZmZiJywgJ2Q4M2NkZmZjJywgJ2Q4M2NkZmZkJywgJ2Q4M2NkZmZlJywgJ2Q4M2NkZmZmJ107XG4gICAgZnVuY3Rpb24gdHJpbUZvbnRPcHRpb25zKGZvbnQpIHtcbiAgICAgIHZhciBmYW1pbHlBcnJheSA9IGZvbnQuc3BsaXQoJywnKTtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IGZhbWlseUFycmF5Lmxlbmd0aDtcbiAgICAgIHZhciBlbmFibGVkRmFtaWxpZXMgPSBbXTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoZmFtaWx5QXJyYXlbaV0gIT09ICdzYW5zLXNlcmlmJyAmJiBmYW1pbHlBcnJheVtpXSAhPT0gJ21vbm9zcGFjZScpIHtcbiAgICAgICAgICBlbmFibGVkRmFtaWxpZXMucHVzaChmYW1pbHlBcnJheVtpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmFibGVkRmFtaWxpZXMuam9pbignLCcpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRVcE5vZGUoZm9udCwgZmFtaWx5KSB7XG4gICAgICB2YXIgcGFyZW50Tm9kZSA9IGNyZWF0ZVRhZygnc3BhbicpO1xuICAgICAgLy8gTm9kZSBpcyBpbnZpc2libGUgdG8gc2NyZWVuIHJlYWRlcnMuXG4gICAgICBwYXJlbnROb2RlLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udEZhbWlseSA9IGZhbWlseTtcbiAgICAgIHZhciBub2RlID0gY3JlYXRlVGFnKCdzcGFuJyk7XG4gICAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgdmFyeSBzaWduaWZpY2FudGx5IGFtb25nIGRpZmZlcmVudCBmb250c1xuICAgICAgbm9kZS5pbm5lclRleHQgPSAnZ2lJdFQxV1F5QCEtLyMnO1xuICAgICAgLy8gVmlzaWJsZSAtIHNvIHdlIGNhbiBtZWFzdXJlIGl0IC0gYnV0IG5vdCBvbiB0aGUgc2NyZWVuXG4gICAgICBwYXJlbnROb2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUubGVmdCA9ICctMTAwMDBweCc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLnRvcCA9ICctMTAwMDBweCc7XG4gICAgICAvLyBMYXJnZSBmb250IHNpemUgbWFrZXMgZXZlbiBzdWJ0bGUgY2hhbmdlcyBvYnZpb3VzXG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRTaXplID0gJzMwMHB4JztcbiAgICAgIC8vIFJlc2V0IGFueSBmb250IHByb3BlcnRpZXNcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFZhcmlhbnQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUuZm9udFN0eWxlID0gJ25vcm1hbCc7XG4gICAgICBwYXJlbnROb2RlLnN0eWxlLmZvbnRXZWlnaHQgPSAnbm9ybWFsJztcbiAgICAgIHBhcmVudE5vZGUuc3R5bGUubGV0dGVyU3BhY2luZyA9ICcwJztcbiAgICAgIHBhcmVudE5vZGUuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHBhcmVudE5vZGUpO1xuXG4gICAgICAvLyBSZW1lbWJlciB3aWR0aCB3aXRoIG5vIGFwcGxpZWQgd2ViIGZvbnRcbiAgICAgIHZhciB3aWR0aCA9IG5vZGUub2Zmc2V0V2lkdGg7XG4gICAgICBub2RlLnN0eWxlLmZvbnRGYW1pbHkgPSB0cmltRm9udE9wdGlvbnMoZm9udCkgKyAnLCAnICsgZmFtaWx5O1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgdzogd2lkdGgsXG4gICAgICAgIHBhcmVudDogcGFyZW50Tm9kZVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tMb2FkZWRGb250cygpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZm9udHMubGVuZ3RoO1xuICAgICAgdmFyIG5vZGU7XG4gICAgICB2YXIgdztcbiAgICAgIHZhciBsb2FkZWRDb3VudCA9IGxlbjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAodGhpcy5mb250c1tpXS5sb2FkZWQpIHtcbiAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZm9udHNbaV0uZk9yaWdpbiA9PT0gJ24nIHx8IHRoaXMuZm9udHNbaV0ub3JpZ2luID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5mb250c1tpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vZGUgPSB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLm5vZGU7XG4gICAgICAgICAgdyA9IHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UudztcbiAgICAgICAgICBpZiAobm9kZS5vZmZzZXRXaWR0aCAhPT0gdykge1xuICAgICAgICAgICAgbG9hZGVkQ291bnQgLT0gMTtcbiAgICAgICAgICAgIHRoaXMuZm9udHNbaV0ubG9hZGVkID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IHRoaXMuZm9udHNbaV0uc2Fuc0Nhc2Uubm9kZTtcbiAgICAgICAgICAgIHcgPSB0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnc7XG4gICAgICAgICAgICBpZiAobm9kZS5vZmZzZXRXaWR0aCAhPT0gdykge1xuICAgICAgICAgICAgICBsb2FkZWRDb3VudCAtPSAxO1xuICAgICAgICAgICAgICB0aGlzLmZvbnRzW2ldLmxvYWRlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmxvYWRlZCkge1xuICAgICAgICAgICAgdGhpcy5mb250c1tpXS5zYW5zQ2FzZS5wYXJlbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLmZvbnRzW2ldLnNhbnNDYXNlLnBhcmVudCk7XG4gICAgICAgICAgICB0aGlzLmZvbnRzW2ldLm1vbm9DYXNlLnBhcmVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRoaXMuZm9udHNbaV0ubW9ub0Nhc2UucGFyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChsb2FkZWRDb3VudCAhPT0gMCAmJiBEYXRlLm5vdygpIC0gdGhpcy5pbml0VGltZSA8IG1heFdhaXRpbmdUaW1lKSB7XG4gICAgICAgIHNldFRpbWVvdXQodGhpcy5jaGVja0xvYWRlZEZvbnRzQmluZGVkLCAyMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuc2V0SXNMb2FkZWRCaW5kZWQsIDEwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlSGVscGVyKGZvbnREYXRhLCBkZWYpIHtcbiAgICAgIHZhciBlbmdpbmUgPSBkb2N1bWVudC5ib2R5ICYmIGRlZiA/ICdzdmcnIDogJ2NhbnZhcyc7XG4gICAgICB2YXIgaGVscGVyO1xuICAgICAgdmFyIGZvbnRQcm9wcyA9IGdldEZvbnRQcm9wZXJ0aWVzKGZvbnREYXRhKTtcbiAgICAgIGlmIChlbmdpbmUgPT09ICdzdmcnKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gY3JlYXRlTlMoJ3RleHQnKTtcbiAgICAgICAgdEhlbHBlci5zdHlsZS5mb250U2l6ZSA9ICcxMDBweCc7XG4gICAgICAgIC8vIHRIZWxwZXIuc3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdmb250LWZhbWlseScsIGZvbnREYXRhLmZGYW1pbHkpO1xuICAgICAgICB0SGVscGVyLnNldEF0dHJpYnV0ZSgnZm9udC1zdHlsZScsIGZvbnRQcm9wcy5zdHlsZSk7XG4gICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIGZvbnRQcm9wcy53ZWlnaHQpO1xuICAgICAgICB0SGVscGVyLnRleHRDb250ZW50ID0gJzEnO1xuICAgICAgICBpZiAoZm9udERhdGEuZkNsYXNzKSB7XG4gICAgICAgICAgdEhlbHBlci5zdHlsZS5mb250RmFtaWx5ID0gJ2luaGVyaXQnO1xuICAgICAgICAgIHRIZWxwZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsIGZvbnREYXRhLmZDbGFzcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdEhlbHBlci5zdHlsZS5mb250RmFtaWx5ID0gZm9udERhdGEuZkZhbWlseTtcbiAgICAgICAgfVxuICAgICAgICBkZWYuYXBwZW5kQ2hpbGQodEhlbHBlcik7XG4gICAgICAgIGhlbHBlciA9IHRIZWxwZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdENhbnZhc0hlbHBlciA9IG5ldyBPZmZzY3JlZW5DYW52YXMoNTAwLCA1MDApLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRDYW52YXNIZWxwZXIuZm9udCA9IGZvbnRQcm9wcy5zdHlsZSArICcgJyArIGZvbnRQcm9wcy53ZWlnaHQgKyAnIDEwMHB4ICcgKyBmb250RGF0YS5mRmFtaWx5O1xuICAgICAgICBoZWxwZXIgPSB0Q2FudmFzSGVscGVyO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbWVhc3VyZSh0ZXh0KSB7XG4gICAgICAgIGlmIChlbmdpbmUgPT09ICdzdmcnKSB7XG4gICAgICAgICAgaGVscGVyLnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgICAgICByZXR1cm4gaGVscGVyLmdldENvbXB1dGVkVGV4dExlbmd0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZWxwZXIubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVxuICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gYWRkRm9udHMoZm9udERhdGEsIGRlZnMpIHtcbiAgICAgIGlmICghZm9udERhdGEpIHtcbiAgICAgICAgdGhpcy5pc0xvYWRlZCA9IHRydWU7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNoYXJzKSB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5KSB7XG4gICAgICAgIHRoaXMuaXNMb2FkZWQgPSB0cnVlO1xuICAgICAgICBmb250RGF0YS5saXN0LmZvckVhY2goZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICBkYXRhLmhlbHBlciA9IGNyZWF0ZUhlbHBlcihkYXRhKTtcbiAgICAgICAgICBkYXRhLmNhY2hlID0ge307XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmZvbnRzID0gZm9udERhdGEubGlzdDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdmFyIGZvbnRBcnIgPSBmb250RGF0YS5saXN0O1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gZm9udEFyci5sZW5ndGg7XG4gICAgICB2YXIgX3BlbmRpbmdGb250cyA9IGxlbjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB2YXIgc2hvdWxkTG9hZEZvbnQgPSB0cnVlO1xuICAgICAgICB2YXIgbG9hZGVkU2VsZWN0b3I7XG4gICAgICAgIHZhciBqO1xuICAgICAgICBmb250QXJyW2ldLmxvYWRlZCA9IGZhbHNlO1xuICAgICAgICBmb250QXJyW2ldLm1vbm9DYXNlID0gc2V0VXBOb2RlKGZvbnRBcnJbaV0uZkZhbWlseSwgJ21vbm9zcGFjZScpO1xuICAgICAgICBmb250QXJyW2ldLnNhbnNDYXNlID0gc2V0VXBOb2RlKGZvbnRBcnJbaV0uZkZhbWlseSwgJ3NhbnMtc2VyaWYnKTtcbiAgICAgICAgaWYgKCFmb250QXJyW2ldLmZQYXRoKSB7XG4gICAgICAgICAgZm9udEFycltpXS5sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgIF9wZW5kaW5nRm9udHMgLT0gMTtcbiAgICAgICAgfSBlbHNlIGlmIChmb250QXJyW2ldLmZPcmlnaW4gPT09ICdwJyB8fCBmb250QXJyW2ldLm9yaWdpbiA9PT0gMykge1xuICAgICAgICAgIGxvYWRlZFNlbGVjdG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnc3R5bGVbZi1mb3JpZ2luPVwicFwiXVtmLWZhbWlseT1cIicgKyBmb250QXJyW2ldLmZGYW1pbHkgKyAnXCJdLCBzdHlsZVtmLW9yaWdpbj1cIjNcIl1bZi1mYW1pbHk9XCInICsgZm9udEFycltpXS5mRmFtaWx5ICsgJ1wiXScpO1xuICAgICAgICAgIGlmIChsb2FkZWRTZWxlY3Rvci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBzaG91bGRMb2FkRm9udCA9IGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2hvdWxkTG9hZEZvbnQpIHtcbiAgICAgICAgICAgIHZhciBzID0gY3JlYXRlVGFnKCdzdHlsZScpO1xuICAgICAgICAgICAgcy5zZXRBdHRyaWJ1dGUoJ2YtZm9yaWdpbicsIGZvbnRBcnJbaV0uZk9yaWdpbik7XG4gICAgICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XG4gICAgICAgICAgICBzLnNldEF0dHJpYnV0ZSgnZi1mYW1pbHknLCBmb250QXJyW2ldLmZGYW1pbHkpO1xuICAgICAgICAgICAgcy50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgICAgIHMuaW5uZXJUZXh0ID0gJ0Bmb250LWZhY2Uge2ZvbnQtZmFtaWx5OiAnICsgZm9udEFycltpXS5mRmFtaWx5ICsgXCI7IGZvbnQtc3R5bGU6IG5vcm1hbDsgc3JjOiB1cmwoJ1wiICsgZm9udEFycltpXS5mUGF0aCArIFwiJyk7fVwiO1xuICAgICAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZm9udEFycltpXS5mT3JpZ2luID09PSAnZycgfHwgZm9udEFycltpXS5vcmlnaW4gPT09IDEpIHtcbiAgICAgICAgICBsb2FkZWRTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmtbZi1mb3JpZ2luPVwiZ1wiXSwgbGlua1tmLW9yaWdpbj1cIjFcIl0nKTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbG9hZGVkU2VsZWN0b3IubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChsb2FkZWRTZWxlY3RvcltqXS5ocmVmLmluZGV4T2YoZm9udEFycltpXS5mUGF0aCkgIT09IC0xKSB7XG4gICAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgbCA9IGNyZWF0ZVRhZygnbGluaycpO1xuICAgICAgICAgICAgbC5zZXRBdHRyaWJ1dGUoJ2YtZm9yaWdpbicsIGZvbnRBcnJbaV0uZk9yaWdpbik7XG4gICAgICAgICAgICBsLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XG4gICAgICAgICAgICBsLnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICAgICAgbC5yZWwgPSAnc3R5bGVzaGVldCc7XG4gICAgICAgICAgICBsLmhyZWYgPSBmb250QXJyW2ldLmZQYXRoO1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChsKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZm9udEFycltpXS5mT3JpZ2luID09PSAndCcgfHwgZm9udEFycltpXS5vcmlnaW4gPT09IDIpIHtcbiAgICAgICAgICBsb2FkZWRTZWxlY3RvciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdFtmLWZvcmlnaW49XCJ0XCJdLCBzY3JpcHRbZi1vcmlnaW49XCIyXCJdJyk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGxvYWRlZFNlbGVjdG9yLmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICBpZiAoZm9udEFycltpXS5mUGF0aCA9PT0gbG9hZGVkU2VsZWN0b3Jbal0uc3JjKSB7XG4gICAgICAgICAgICAgIC8vIEZvbnQgaXMgYWxyZWFkeSBsb2FkZWRcbiAgICAgICAgICAgICAgc2hvdWxkTG9hZEZvbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNob3VsZExvYWRGb250KSB7XG4gICAgICAgICAgICB2YXIgc2MgPSBjcmVhdGVUYWcoJ2xpbmsnKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1mb3JpZ2luJywgZm9udEFycltpXS5mT3JpZ2luKTtcbiAgICAgICAgICAgIHNjLnNldEF0dHJpYnV0ZSgnZi1vcmlnaW4nLCBmb250QXJyW2ldLm9yaWdpbik7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ3JlbCcsICdzdHlsZXNoZWV0Jyk7XG4gICAgICAgICAgICBzYy5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBmb250QXJyW2ldLmZQYXRoKTtcbiAgICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoc2MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb250QXJyW2ldLmhlbHBlciA9IGNyZWF0ZUhlbHBlcihmb250QXJyW2ldLCBkZWZzKTtcbiAgICAgICAgZm9udEFycltpXS5jYWNoZSA9IHt9O1xuICAgICAgICB0aGlzLmZvbnRzLnB1c2goZm9udEFycltpXSk7XG4gICAgICB9XG4gICAgICBpZiAoX3BlbmRpbmdGb250cyA9PT0gMCkge1xuICAgICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE9uIHNvbWUgY2FzZXMgZXZlbiBpZiB0aGUgZm9udCBpcyBsb2FkZWQsIGl0IHdvbid0IGxvYWQgY29ycmVjdGx5IHdoZW4gbWVhc3VyaW5nIHRleHQgb24gY2FudmFzLlxuICAgICAgICAvLyBBZGRpbmcgdGhpcyB0aW1lb3V0IHNlZW1zIHRvIGZpeCBpdFxuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuY2hlY2tMb2FkZWRGb250cy5iaW5kKHRoaXMpLCAxMDApO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhZGRDaGFycyhjaGFycykge1xuICAgICAgaWYgKCFjaGFycykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY2hhcnMpIHtcbiAgICAgICAgdGhpcy5jaGFycyA9IFtdO1xuICAgICAgfVxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgakxlbiA9IHRoaXMuY2hhcnMubGVuZ3RoO1xuICAgICAgdmFyIGZvdW5kO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGogPSAwO1xuICAgICAgICBmb3VuZCA9IGZhbHNlO1xuICAgICAgICB3aGlsZSAoaiA8IGpMZW4pIHtcbiAgICAgICAgICBpZiAodGhpcy5jaGFyc1tqXS5zdHlsZSA9PT0gY2hhcnNbaV0uc3R5bGUgJiYgdGhpcy5jaGFyc1tqXS5mRmFtaWx5ID09PSBjaGFyc1tpXS5mRmFtaWx5ICYmIHRoaXMuY2hhcnNbal0uY2ggPT09IGNoYXJzW2ldLmNoKSB7XG4gICAgICAgICAgICBmb3VuZCA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZvdW5kKSB7XG4gICAgICAgICAgdGhpcy5jaGFycy5wdXNoKGNoYXJzW2ldKTtcbiAgICAgICAgICBqTGVuICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q2hhckRhdGEoX2NoYXIsIHN0eWxlLCBmb250KSB7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gdGhpcy5jaGFycy5sZW5ndGg7XG4gICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICBpZiAodGhpcy5jaGFyc1tpXS5jaCA9PT0gX2NoYXIgJiYgdGhpcy5jaGFyc1tpXS5zdHlsZSA9PT0gc3R5bGUgJiYgdGhpcy5jaGFyc1tpXS5mRmFtaWx5ID09PSBmb250KSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuY2hhcnNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKCh0eXBlb2YgX2NoYXIgPT09ICdzdHJpbmcnICYmIF9jaGFyLmNoYXJDb2RlQXQoMCkgIT09IDEzIHx8ICFfY2hhcikgJiYgY29uc29sZSAmJiBjb25zb2xlLndhcm4gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAmJiAhdGhpcy5fd2FybmVkKSB7XG4gICAgICAgIHRoaXMuX3dhcm5lZCA9IHRydWU7XG4gICAgICAgIGNvbnNvbGUud2FybignTWlzc2luZyBjaGFyYWN0ZXIgZnJvbSBleHBvcnRlZCBjaGFyYWN0ZXJzIGxpc3Q6ICcsIF9jaGFyLCBzdHlsZSwgZm9udCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgICAgfVxuICAgICAgcmV0dXJuIGVtcHR5Q2hhcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gbWVhc3VyZVRleHQoX2NoYXIyLCBmb250TmFtZSwgc2l6ZSkge1xuICAgICAgdmFyIGZvbnREYXRhID0gdGhpcy5nZXRGb250QnlOYW1lKGZvbnROYW1lKTtcbiAgICAgIC8vIFVzaW5nIHRoZSBjaGFyIGluc3RlYWQgb2YgY2hhci5jaGFyQ29kZUF0KDApXG4gICAgICAvLyB0byBhdm9pZCBjb2xsaXNpb25zIGJldHdlZW4gZXF1YWwgY2hhcnNcbiAgICAgIHZhciBpbmRleCA9IF9jaGFyMjtcbiAgICAgIGlmICghZm9udERhdGEuY2FjaGVbaW5kZXhdKSB7XG4gICAgICAgIHZhciB0SGVscGVyID0gZm9udERhdGEuaGVscGVyO1xuICAgICAgICBpZiAoX2NoYXIyID09PSAnICcpIHtcbiAgICAgICAgICB2YXIgZG91YmxlU2l6ZSA9IHRIZWxwZXIubWVhc3VyZVRleHQoJ3wnICsgX2NoYXIyICsgJ3wnKTtcbiAgICAgICAgICB2YXIgc2luZ2xlU2l6ZSA9IHRIZWxwZXIubWVhc3VyZVRleHQoJ3x8Jyk7XG4gICAgICAgICAgZm9udERhdGEuY2FjaGVbaW5kZXhdID0gKGRvdWJsZVNpemUgLSBzaW5nbGVTaXplKSAvIDEwMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmb250RGF0YS5jYWNoZVtpbmRleF0gPSB0SGVscGVyLm1lYXN1cmVUZXh0KF9jaGFyMikgLyAxMDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmb250RGF0YS5jYWNoZVtpbmRleF0gKiBzaXplO1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRGb250QnlOYW1lKG5hbWUpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmZvbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICh0aGlzLmZvbnRzW2ldLmZOYW1lID09PSBuYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZm9udHNbaV07XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZm9udHNbMF07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldENvZGVQb2ludChzdHJpbmcpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSAwO1xuICAgICAgdmFyIGZpcnN0ID0gc3RyaW5nLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoZmlyc3QgPj0gMHhEODAwICYmIGZpcnN0IDw9IDB4REJGRikge1xuICAgICAgICB2YXIgc2Vjb25kID0gc3RyaW5nLmNoYXJDb2RlQXQoMSk7XG4gICAgICAgIGlmIChzZWNvbmQgPj0gMHhEQzAwICYmIHNlY29uZCA8PSAweERGRkYpIHtcbiAgICAgICAgICBjb2RlUG9pbnQgPSAoZmlyc3QgLSAweEQ4MDApICogMHg0MDAgKyBzZWNvbmQgLSAweERDMDAgKyAweDEwMDAwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgIH1cblxuICAgIC8vIFNraW4gdG9uZSBtb2RpZmllcnNcbiAgICBmdW5jdGlvbiBpc01vZGlmaWVyKGZpcnN0Q2hhckNvZGUsIHNlY29uZENoYXJDb2RlKSB7XG4gICAgICB2YXIgc3VtID0gZmlyc3RDaGFyQ29kZS50b1N0cmluZygxNikgKyBzZWNvbmRDaGFyQ29kZS50b1N0cmluZygxNik7XG4gICAgICByZXR1cm4gc3Vycm9nYXRlTW9kaWZpZXJzLmluZGV4T2Yoc3VtKSAhPT0gLTE7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGlzWmVyb1dpZHRoSm9pbmVyKGNoYXJDb2RlKSB7XG4gICAgICByZXR1cm4gY2hhckNvZGUgPT09IFpFUk9fV0lEVEhfSk9JTkVSX0NPREVfUE9JTlQ7XG4gICAgfVxuXG4gICAgLy8gVGhpcyBjb2RlcG9pbnQgbWF5IGNoYW5nZSB0aGUgYXBwZWFyYW5jZSBvZiB0aGUgcHJlY2VkaW5nIGNoYXJhY3Rlci5cbiAgICAvLyBJZiB0aGF0IGlzIGEgc3ltYm9sLCBkaW5nYmF0IG9yIGVtb2ppLCBVK0ZFMEYgZm9yY2VzIGl0IHRvIGJlIHJlbmRlcmVkXG4gICAgLy8gYXMgYSBjb2xvcmZ1bCBpbWFnZSBhcyBjb21wYXJlZCB0byBhIG1vbm9jaHJvbWUgdGV4dCB2YXJpYW50LlxuICAgIGZ1bmN0aW9uIGlzVmFyaWF0aW9uU2VsZWN0b3IoY2hhckNvZGUpIHtcbiAgICAgIHJldHVybiBjaGFyQ29kZSA9PT0gVkFSSUFUSU9OX1NFTEVDVE9SXzE2X0NPREVfUE9JTlQ7XG4gICAgfVxuXG4gICAgLy8gVGhlIHJlZ2lvbmFsIGluZGljYXRvciBzeW1ib2xzIGFyZSBhIHNldCBvZiAyNiBhbHBoYWJldGljIFVuaWNvZGVcbiAgICAvLy8gY2hhcmFjdGVycyAoQeKAk1opIGludGVuZGVkIHRvIGJlIHVzZWQgdG8gZW5jb2RlIElTTyAzMTY2LTEgYWxwaGEtMlxuICAgIC8vIHR3by1sZXR0ZXIgY291bnRyeSBjb2RlcyBpbiBhIHdheSB0aGF0IGFsbG93cyBvcHRpb25hbCBzcGVjaWFsIHRyZWF0bWVudC5cbiAgICBmdW5jdGlvbiBpc1JlZ2lvbmFsQ29kZShzdHJpbmcpIHtcbiAgICAgIHZhciBjb2RlUG9pbnQgPSBnZXRDb2RlUG9pbnQoc3RyaW5nKTtcbiAgICAgIGlmIChjb2RlUG9pbnQgPj0gUkVHSU9OQUxfQ0hBUkFDVEVSX0FfQ09ERV9QT0lOVCAmJiBjb2RlUG9pbnQgPD0gUkVHSU9OQUxfQ0hBUkFDVEVSX1pfQ09ERV9QT0lOVCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBTb21lIEVtb2ppIGltcGxlbWVudGF0aW9ucyByZXByZXNlbnQgY29tYmluYXRpb25zIG9mXG4gICAgLy8gdHdvIOKAnHJlZ2lvbmFsIGluZGljYXRvcuKAnSBsZXR0ZXJzIGFzIGEgc2luZ2xlIGZsYWcgc3ltYm9sLlxuICAgIGZ1bmN0aW9uIGlzRmxhZ0Vtb2ppKHN0cmluZykge1xuICAgICAgcmV0dXJuIGlzUmVnaW9uYWxDb2RlKHN0cmluZy5zdWJzdHIoMCwgMikpICYmIGlzUmVnaW9uYWxDb2RlKHN0cmluZy5zdWJzdHIoMiwgMikpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpc0NvbWJpbmVkQ2hhcmFjdGVyKF9jaGFyMykge1xuICAgICAgcmV0dXJuIGNvbWJpbmVkQ2hhcmFjdGVycy5pbmRleE9mKF9jaGFyMykgIT09IC0xO1xuICAgIH1cblxuICAgIC8vIFJlZ2lvbmFsIGZsYWdzIHN0YXJ0IHdpdGggYSBCTEFDS19GTEFHX0NPREVfUE9JTlRcbiAgICAvLyBmb2xvd2VkIGJ5IDUgY2hhcnMgaW4gdGhlIFRBRyByYW5nZVxuICAgIC8vIGFuZCBlbmQgd2l0aCBhIENBTkNFTF9UQUdfQ09ERV9QT0lOVFxuICAgIGZ1bmN0aW9uIGlzUmVnaW9uYWxGbGFnKHRleHQsIGluZGV4KSB7XG4gICAgICB2YXIgY29kZVBvaW50ID0gZ2V0Q29kZVBvaW50KHRleHQuc3Vic3RyKGluZGV4LCAyKSk7XG4gICAgICBpZiAoY29kZVBvaW50ICE9PSBCTEFDS19GTEFHX0NPREVfUE9JTlQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgIGluZGV4ICs9IDI7XG4gICAgICB3aGlsZSAoY291bnQgPCA1KSB7XG4gICAgICAgIGNvZGVQb2ludCA9IGdldENvZGVQb2ludCh0ZXh0LnN1YnN0cihpbmRleCwgMikpO1xuICAgICAgICBpZiAoY29kZVBvaW50IDwgQV9UQUdfQ09ERV9QT0lOVCB8fCBjb2RlUG9pbnQgPiBaX1RBR19DT0RFX1BPSU5UKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIGluZGV4ICs9IDI7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ2V0Q29kZVBvaW50KHRleHQuc3Vic3RyKGluZGV4LCAyKSkgPT09IENBTkNFTF9UQUdfQ09ERV9QT0lOVDtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2V0SXNMb2FkZWQoKSB7XG4gICAgICB0aGlzLmlzTG9hZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIEZvbnQgPSBmdW5jdGlvbiBGb250KCkge1xuICAgICAgdGhpcy5mb250cyA9IFtdO1xuICAgICAgdGhpcy5jaGFycyA9IG51bGw7XG4gICAgICB0aGlzLnR5cGVraXRMb2FkZWQgPSAwO1xuICAgICAgdGhpcy5pc0xvYWRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fd2FybmVkID0gZmFsc2U7XG4gICAgICB0aGlzLmluaXRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICAgIHRoaXMuc2V0SXNMb2FkZWRCaW5kZWQgPSB0aGlzLnNldElzTG9hZGVkLmJpbmQodGhpcyk7XG4gICAgICB0aGlzLmNoZWNrTG9hZGVkRm9udHNCaW5kZWQgPSB0aGlzLmNoZWNrTG9hZGVkRm9udHMuYmluZCh0aGlzKTtcbiAgICB9O1xuICAgIEZvbnQuaXNNb2RpZmllciA9IGlzTW9kaWZpZXI7XG4gICAgRm9udC5pc1plcm9XaWR0aEpvaW5lciA9IGlzWmVyb1dpZHRoSm9pbmVyO1xuICAgIEZvbnQuaXNGbGFnRW1vamkgPSBpc0ZsYWdFbW9qaTtcbiAgICBGb250LmlzUmVnaW9uYWxDb2RlID0gaXNSZWdpb25hbENvZGU7XG4gICAgRm9udC5pc0NvbWJpbmVkQ2hhcmFjdGVyID0gaXNDb21iaW5lZENoYXJhY3RlcjtcbiAgICBGb250LmlzUmVnaW9uYWxGbGFnID0gaXNSZWdpb25hbEZsYWc7XG4gICAgRm9udC5pc1ZhcmlhdGlvblNlbGVjdG9yID0gaXNWYXJpYXRpb25TZWxlY3RvcjtcbiAgICBGb250LkJMQUNLX0ZMQUdfQ09ERV9QT0lOVCA9IEJMQUNLX0ZMQUdfQ09ERV9QT0lOVDtcbiAgICB2YXIgZm9udFByb3RvdHlwZSA9IHtcbiAgICAgIGFkZENoYXJzOiBhZGRDaGFycyxcbiAgICAgIGFkZEZvbnRzOiBhZGRGb250cyxcbiAgICAgIGdldENoYXJEYXRhOiBnZXRDaGFyRGF0YSxcbiAgICAgIGdldEZvbnRCeU5hbWU6IGdldEZvbnRCeU5hbWUsXG4gICAgICBtZWFzdXJlVGV4dDogbWVhc3VyZVRleHQsXG4gICAgICBjaGVja0xvYWRlZEZvbnRzOiBjaGVja0xvYWRlZEZvbnRzLFxuICAgICAgc2V0SXNMb2FkZWQ6IHNldElzTG9hZGVkXG4gICAgfTtcbiAgICBGb250LnByb3RvdHlwZSA9IGZvbnRQcm90b3R5cGU7XG4gICAgcmV0dXJuIEZvbnQ7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTbG90TWFuYWdlcihhbmltYXRpb25EYXRhKSB7XG4gICAgdGhpcy5hbmltYXRpb25EYXRhID0gYW5pbWF0aW9uRGF0YTtcbiAgfVxuICBTbG90TWFuYWdlci5wcm90b3R5cGUuZ2V0UHJvcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKHRoaXMuYW5pbWF0aW9uRGF0YS5zbG90cyAmJiB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihkYXRhLCB0aGlzLmFuaW1hdGlvbkRhdGEuc2xvdHNbZGF0YS5zaWRdLnApO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfTtcbiAgZnVuY3Rpb24gc2xvdEZhY3RvcnkoYW5pbWF0aW9uRGF0YSkge1xuICAgIHJldHVybiBuZXcgU2xvdE1hbmFnZXIoYW5pbWF0aW9uRGF0YSk7XG4gIH1cblxuICBmdW5jdGlvbiBSZW5kZXJhYmxlRWxlbWVudCgpIHt9XG4gIFJlbmRlcmFibGVFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBpbml0UmVuZGVyYWJsZTogZnVuY3Rpb24gaW5pdFJlbmRlcmFibGUoKSB7XG4gICAgICAvLyBsYXllcidzIHZpc2liaWxpdHkgcmVsYXRlZCB0byBpbnBvaW50IGFuZCBvdXRwb2ludC4gUmVuYW1lIGlzVmlzaWJsZSB0byBpc0luUmFuZ2VcbiAgICAgIHRoaXMuaXNJblJhbmdlID0gZmFsc2U7XG4gICAgICAvLyBsYXllcidzIGRpc3BsYXkgc3RhdGVcbiAgICAgIHRoaXMuaGlkZGVuID0gZmFsc2U7XG4gICAgICAvLyBJZiBsYXllcidzIHRyYW5zcGFyZW5jeSBlcXVhbHMgMCwgaXQgY2FuIGJlIGhpZGRlblxuICAgICAgdGhpcy5pc1RyYW5zcGFyZW50ID0gZmFsc2U7XG4gICAgICAvLyBsaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcbiAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMgPSBbXTtcbiAgICB9LFxuICAgIGFkZFJlbmRlcmFibGVDb21wb25lbnQ6IGZ1bmN0aW9uIGFkZFJlbmRlcmFibGVDb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgICBpZiAodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCkgPT09IC0xKSB7XG4gICAgICAgIHRoaXMucmVuZGVyYWJsZUNvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudDogZnVuY3Rpb24gcmVtb3ZlUmVuZGVyYWJsZUNvbXBvbmVudChjb21wb25lbnQpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGVDb21wb25lbnRzLmluZGV4T2YoY29tcG9uZW50KSAhPT0gLTEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5zcGxpY2UodGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5pbmRleE9mKGNvbXBvbmVudCksIDEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcHJlcGFyZVJlbmRlcmFibGVGcmFtZTogZnVuY3Rpb24gcHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pIHtcbiAgICAgIHRoaXMuY2hlY2tMYXllckxpbWl0cyhudW0pO1xuICAgIH0sXG4gICAgY2hlY2tUcmFuc3BhcmVuY3k6IGZ1bmN0aW9uIGNoZWNrVHJhbnNwYXJlbmN5KCkge1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52IDw9IDApIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVHJhbnNwYXJlbnQgJiYgdGhpcy5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCkge1xuICAgICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RyYW5zcGFyZW50KSB7XG4gICAgICAgIHRoaXMuaXNUcmFuc3BhcmVudCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBJbml0aWFsaXplcyBmcmFtZSByZWxhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICAgICAgICogY3VycmVudCBmcmFtZSBudW1iZXIgaW4gTGF5ZXIncyB0aW1lXG4gICAgICAgKlxuICAgICAgICovXG4gICAgY2hlY2tMYXllckxpbWl0czogZnVuY3Rpb24gY2hlY2tMYXllckxpbWl0cyhudW0pIHtcbiAgICAgIGlmICh0aGlzLmRhdGEuaXAgLSB0aGlzLmRhdGEuc3QgPD0gbnVtICYmIHRoaXMuZGF0YS5vcCAtIHRoaXMuZGF0YS5zdCA+IG51bSkge1xuICAgICAgICBpZiAodGhpcy5pc0luUmFuZ2UgIT09IHRydWUpIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XG4gICAgICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgICAgICB0aGlzLmlzSW5SYW5nZSA9IHRydWU7XG4gICAgICAgICAgdGhpcy5zaG93KCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc0luUmFuZ2UgIT09IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5pc0luUmFuZ2UgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJSZW5kZXJhYmxlOiBmdW5jdGlvbiByZW5kZXJSZW5kZXJhYmxlKCkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50cy5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJhYmxlQ29tcG9uZW50c1tpXS5yZW5kZXJGcmFtZSh0aGlzLl9pc0ZpcnN0RnJhbWUpO1xuICAgICAgfVxuICAgICAgLyogdGhpcy5tYXNrTWFuYWdlci5yZW5kZXJGcmFtZSh0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdCk7XG4gICAgICAgICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIucmVuZGVyRnJhbWUodGhpcy5faXNGaXJzdEZyYW1lKTsgKi9cbiAgICB9LFxuICAgIHNvdXJjZVJlY3RBdFRpbWU6IGZ1bmN0aW9uIHNvdXJjZVJlY3RBdFRpbWUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0b3A6IDAsXG4gICAgICAgIGxlZnQ6IDAsXG4gICAgICAgIHdpZHRoOiAxMDAsXG4gICAgICAgIGhlaWdodDogMTAwXG4gICAgICB9O1xuICAgIH0sXG4gICAgZ2V0TGF5ZXJTaXplOiBmdW5jdGlvbiBnZXRMYXllclNpemUoKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLnR5ID09PSA1KSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgdzogdGhpcy5kYXRhLnRleHREYXRhLndpZHRoLFxuICAgICAgICAgIGg6IHRoaXMuZGF0YS50ZXh0RGF0YS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHc6IHRoaXMuZGF0YS53aWR0aCxcbiAgICAgICAgaDogdGhpcy5kYXRhLmhlaWdodFxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEJsZW5kTW9kZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYmxlbmRNb2RlRW51bXMgPSB7XG4gICAgICAwOiAnc291cmNlLW92ZXInLFxuICAgICAgMTogJ211bHRpcGx5JyxcbiAgICAgIDI6ICdzY3JlZW4nLFxuICAgICAgMzogJ292ZXJsYXknLFxuICAgICAgNDogJ2RhcmtlbicsXG4gICAgICA1OiAnbGlnaHRlbicsXG4gICAgICA2OiAnY29sb3ItZG9kZ2UnLFxuICAgICAgNzogJ2NvbG9yLWJ1cm4nLFxuICAgICAgODogJ2hhcmQtbGlnaHQnLFxuICAgICAgOTogJ3NvZnQtbGlnaHQnLFxuICAgICAgMTA6ICdkaWZmZXJlbmNlJyxcbiAgICAgIDExOiAnZXhjbHVzaW9uJyxcbiAgICAgIDEyOiAnaHVlJyxcbiAgICAgIDEzOiAnc2F0dXJhdGlvbicsXG4gICAgICAxNDogJ2NvbG9yJyxcbiAgICAgIDE1OiAnbHVtaW5vc2l0eSdcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAobW9kZSkge1xuICAgICAgcmV0dXJuIGJsZW5kTW9kZUVudW1zW21vZGVdIHx8ICcnO1xuICAgIH07XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTbGlkZXJFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG4gIGZ1bmN0aW9uIEFuZ2xlRWZmZWN0KGRhdGEsIGVsZW0sIGNvbnRhaW5lcikge1xuICAgIHRoaXMucCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudiwgMCwgMCwgY29udGFpbmVyKTtcbiAgfVxuICBmdW5jdGlvbiBDb2xvckVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDEsIDAsIGNvbnRhaW5lcik7XG4gIH1cbiAgZnVuY3Rpb24gUG9pbnRFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAxLCAwLCBjb250YWluZXIpO1xuICB9XG4gIGZ1bmN0aW9uIExheWVySW5kZXhFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG4gIGZ1bmN0aW9uIE1hc2tJbmRleEVmZmVjdChkYXRhLCBlbGVtLCBjb250YWluZXIpIHtcbiAgICB0aGlzLnAgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnYsIDAsIDAsIGNvbnRhaW5lcik7XG4gIH1cbiAgZnVuY3Rpb24gQ2hlY2tib3hFZmZlY3QoZGF0YSwgZWxlbSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS52LCAwLCAwLCBjb250YWluZXIpO1xuICB9XG4gIGZ1bmN0aW9uIE5vVmFsdWVFZmZlY3QoKSB7XG4gICAgdGhpcy5wID0ge307XG4gIH1cblxuICBmdW5jdGlvbiBFZmZlY3RzTWFuYWdlcihkYXRhLCBlbGVtZW50KSB7XG4gICAgdmFyIGVmZmVjdHMgPSBkYXRhLmVmIHx8IFtdO1xuICAgIHRoaXMuZWZmZWN0RWxlbWVudHMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdEl0ZW07XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlZmZlY3RJdGVtID0gbmV3IEdyb3VwRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQpO1xuICAgICAgdGhpcy5lZmZlY3RFbGVtZW50cy5wdXNoKGVmZmVjdEl0ZW0pO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBHcm91cEVmZmVjdChkYXRhLCBlbGVtZW50KSB7XG4gICAgdGhpcy5pbml0KGRhdGEsIGVsZW1lbnQpO1xuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgR3JvdXBFZmZlY3QpO1xuICBHcm91cEVmZmVjdC5wcm90b3R5cGUuZ2V0VmFsdWUgPSBHcm91cEVmZmVjdC5wcm90b3R5cGUuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICBHcm91cEVmZmVjdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50KSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW1lbnQpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmRhdGEuZWYubGVuZ3RoO1xuICAgIHZhciBlZmY7XG4gICAgdmFyIGVmZmVjdHMgPSB0aGlzLmRhdGEuZWY7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBlZmYgPSBudWxsO1xuICAgICAgc3dpdGNoIChlZmZlY3RzW2ldLnR5KSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICBlZmYgPSBuZXcgU2xpZGVyRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZWZmID0gbmV3IEFuZ2xlRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZWZmID0gbmV3IENvbG9yRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgZWZmID0gbmV3IFBvaW50RWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBlZmYgPSBuZXcgQ2hlY2tib3hFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTA6XG4gICAgICAgICAgZWZmID0gbmV3IExheWVySW5kZXhFZmZlY3QoZWZmZWN0c1tpXSwgZWxlbWVudCwgdGhpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMTE6XG4gICAgICAgICAgZWZmID0gbmV3IE1hc2tJbmRleEVmZmVjdChlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGVmZiA9IG5ldyBFZmZlY3RzTWFuYWdlcihlZmZlY3RzW2ldLCBlbGVtZW50LCB0aGlzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gY2FzZSA2OlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGVmZiA9IG5ldyBOb1ZhbHVlRWZmZWN0KGVmZmVjdHNbaV0sIGVsZW1lbnQsIHRoaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGVmZikge1xuICAgICAgICB0aGlzLmVmZmVjdEVsZW1lbnRzLnB1c2goZWZmKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gQmFzZUVsZW1lbnQoKSB7fVxuICBCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgY2hlY2tNYXNrczogZnVuY3Rpb24gY2hlY2tNYXNrcygpIHtcbiAgICAgIGlmICghdGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nICYmIHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXNbaV0uY2wgIT09IGZhbHNlKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgaW5pdEV4cHJlc3Npb25zOiBmdW5jdGlvbiBpbml0RXhwcmVzc2lvbnMoKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvbnNJbnRlcmZhY2VzID0gZ2V0RXhwcmVzc2lvbkludGVyZmFjZXMoKTtcbiAgICAgIGlmICghZXhwcmVzc2lvbnNJbnRlcmZhY2VzKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2xheWVyJyk7XG4gICAgICB2YXIgRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ2VmZmVjdHMnKTtcbiAgICAgIHZhciBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ3NoYXBlJyk7XG4gICAgICB2YXIgVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UgPSBleHByZXNzaW9uc0ludGVyZmFjZXMoJ3RleHQnKTtcbiAgICAgIHZhciBDb21wRXhwcmVzc2lvbkludGVyZmFjZSA9IGV4cHJlc3Npb25zSW50ZXJmYWNlcygnY29tcCcpO1xuICAgICAgdGhpcy5sYXllckludGVyZmFjZSA9IExheWVyRXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcbiAgICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzayAmJiB0aGlzLm1hc2tNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UucmVnaXN0ZXJNYXNrSW50ZXJmYWNlKHRoaXMubWFza01hbmFnZXIpO1xuICAgICAgfVxuICAgICAgdmFyIGVmZmVjdHNJbnRlcmZhY2UgPSBFZmZlY3RzRXhwcmVzc2lvbkludGVyZmFjZS5jcmVhdGVFZmZlY3RzSW50ZXJmYWNlKHRoaXMsIHRoaXMubGF5ZXJJbnRlcmZhY2UpO1xuICAgICAgdGhpcy5sYXllckludGVyZmFjZS5yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UoZWZmZWN0c0ludGVyZmFjZSk7XG4gICAgICBpZiAodGhpcy5kYXRhLnR5ID09PSAwIHx8IHRoaXMuZGF0YS54dCkge1xuICAgICAgICB0aGlzLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kYXRhLnR5ID09PSA0KSB7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2Uuc2hhcGVJbnRlcmZhY2UgPSBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UodGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5sYXllckludGVyZmFjZSk7XG4gICAgICAgIHRoaXMubGF5ZXJJbnRlcmZhY2UuY29udGVudCA9IHRoaXMubGF5ZXJJbnRlcmZhY2Uuc2hhcGVJbnRlcmZhY2U7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50eSA9PT0gNSkge1xuICAgICAgICB0aGlzLmxheWVySW50ZXJmYWNlLnRleHRJbnRlcmZhY2UgPSBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSh0aGlzKTtcbiAgICAgICAgdGhpcy5sYXllckludGVyZmFjZS50ZXh0ID0gdGhpcy5sYXllckludGVyZmFjZS50ZXh0SW50ZXJmYWNlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiBzZXRCbGVuZE1vZGUoKSB7XG4gICAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSBnZXRCbGVuZE1vZGUodGhpcy5kYXRhLmJtKTtcbiAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgIGVsZW0uc3R5bGVbJ21peC1ibGVuZC1tb2RlJ10gPSBibGVuZE1vZGVWYWx1ZTtcbiAgICB9LFxuICAgIGluaXRCYXNlRGF0YTogZnVuY3Rpb24gaW5pdEJhc2VEYXRhKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YSA9IGdsb2JhbERhdGE7XG4gICAgICB0aGlzLmNvbXAgPSBjb21wO1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMubGF5ZXJJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuXG4gICAgICAvLyBTdHJldGNoIGZhY3RvciBmb3Igb2xkIGFuaW1hdGlvbnMgbWlzc2luZyB0aGlzIHByb3BlcnR5LlxuICAgICAgaWYgKCF0aGlzLmRhdGEuc3IpIHtcbiAgICAgICAgdGhpcy5kYXRhLnNyID0gMTtcbiAgICAgIH1cbiAgICAgIC8vIGVmZmVjdHMgbWFuYWdlclxuICAgICAgdGhpcy5lZmZlY3RzTWFuYWdlciA9IG5ldyBFZmZlY3RzTWFuYWdlcih0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICAgIH0sXG4gICAgZ2V0VHlwZTogZnVuY3Rpb24gZ2V0VHlwZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnR5cGU7XG4gICAgfSxcbiAgICBzb3VyY2VSZWN0QXRUaW1lOiBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge31cbiAgfTtcblxuICAvKipcbiAgICogQGZpbGVcbiAgICogSGFuZGxlcyBlbGVtZW50J3MgbGF5ZXIgZnJhbWUgdXBkYXRlLlxuICAgKiBDaGVja3MgbGF5ZXIgaW4gcG9pbnQgYW5kIG91dCBwb2ludFxuICAgKlxuICAgKi9cblxuICBmdW5jdGlvbiBGcmFtZUVsZW1lbnQoKSB7fVxuICBGcmFtZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBJbml0aWFsaXplcyBmcmFtZSByZWxhdGVkIHByb3BlcnRpZXMuXG4gICAgICAgKlxuICAgICAgICovXG4gICAgaW5pdEZyYW1lOiBmdW5jdGlvbiBpbml0RnJhbWUoKSB7XG4gICAgICAvLyBzZXQgdG8gdHJ1ZSB3aGVuIGlucG9pbnQgaXMgcmVuZGVyZWRcbiAgICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IGZhbHNlO1xuICAgICAgLy8gbGlzdCBvZiBhbmltYXRlZCBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzID0gW107XG4gICAgICAvLyBJZiBsYXllciBoYXMgYmVlbiBtb2RpZmllZCBpbiBjdXJyZW50IHRpY2sgdGhpcyB3aWxsIGJlIHRydWVcbiAgICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICAgKiBAZnVuY3Rpb25cbiAgICAgICAqIENhbGN1bGF0ZXMgYWxsIGR5bmFtaWMgdmFsdWVzXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG51bVxuICAgICAgICogY3VycmVudCBmcmFtZSBudW1iZXIgaW4gTGF5ZXIncyB0aW1lXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGlzVmlzaWJsZVxuICAgICAgICogaWYgbGF5ZXJzIGlzIGN1cnJlbnRseSBpbiByYW5nZVxuICAgICAgICpcbiAgICAgICAqL1xuICAgIHByZXBhcmVQcm9wZXJ0aWVzOiBmdW5jdGlvbiBwcmVwYXJlUHJvcGVydGllcyhudW0sIGlzVmlzaWJsZSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdGhpcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGlzVmlzaWJsZSB8fCB0aGlzLl9pc1BhcmVudCAmJiB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzW2ldLnByb3BUeXBlID09PSAndHJhbnNmb3JtJykge1xuICAgICAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcbiAgICAgICAgICBpZiAodGhpcy5keW5hbWljUHJvcGVydGllc1tpXS5fbWRmKSB7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLl9tZGYgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgYWRkRHluYW1pY1Byb3BlcnR5OiBmdW5jdGlvbiBhZGREeW5hbWljUHJvcGVydHkocHJvcCkge1xuICAgICAgaWYgKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMuaW5kZXhPZihwcm9wKSA9PT0gLTEpIHtcbiAgICAgICAgdGhpcy5keW5hbWljUHJvcGVydGllcy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBGb290YWdlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5hc3NldERhdGEgPSBnbG9iYWxEYXRhLmdldEFzc2V0RGF0YShkYXRhLnJlZklkKTtcbiAgICB0aGlzLmZvb3RhZ2VEYXRhID0gZ2xvYmFsRGF0YS5pbWFnZUxvYWRlci5nZXRBc3NldCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cbiAgRm9vdGFnZUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xuICBleHRlbmRQcm90b3R5cGUoW1JlbmRlcmFibGVFbGVtZW50LCBCYXNlRWxlbWVudCwgRnJhbWVFbGVtZW50XSwgRm9vdGFnZUVsZW1lbnQpO1xuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHt9O1xuICBGb290YWdlRWxlbWVudC5wcm90b3R5cGUuaW5pdEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBleHByZXNzaW9uc0ludGVyZmFjZXMgPSBnZXRFeHByZXNzaW9uSW50ZXJmYWNlcygpO1xuICAgIGlmICghZXhwcmVzc2lvbnNJbnRlcmZhY2VzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBGb290YWdlSW50ZXJmYWNlID0gZXhwcmVzc2lvbnNJbnRlcmZhY2VzKCdmb290YWdlJyk7XG4gICAgdGhpcy5sYXllckludGVyZmFjZSA9IEZvb3RhZ2VJbnRlcmZhY2UodGhpcyk7XG4gIH07XG4gIEZvb3RhZ2VFbGVtZW50LnByb3RvdHlwZS5nZXRGb290YWdlRGF0YSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5mb290YWdlRGF0YTtcbiAgfTtcblxuICBmdW5jdGlvbiBBdWRpb0VsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEoZGF0YS5yZWZJZCk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5faXNQbGF5aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fY2FuUGxheSA9IGZhbHNlO1xuICAgIHZhciBhc3NldFBhdGggPSB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdGhpcy5hdWRpbyA9IHRoaXMuZ2xvYmFsRGF0YS5hdWRpb0NvbnRyb2xsZXIuY3JlYXRlQXVkaW8oYXNzZXRQYXRoKTtcbiAgICB0aGlzLl9jdXJyZW50VGltZSA9IDA7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlci5hZGRBdWRpbyh0aGlzKTtcbiAgICB0aGlzLl92b2x1bWVNdWx0aXBsaWVyID0gMTtcbiAgICB0aGlzLl92b2x1bWUgPSAxO1xuICAgIHRoaXMuX3ByZXZpb3VzVm9sdW1lID0gbnVsbDtcbiAgICB0aGlzLnRtID0gZGF0YS50bSA/IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudG0sIDAsIGdsb2JhbERhdGEuZnJhbWVSYXRlLCB0aGlzKSA6IHtcbiAgICAgIF9wbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gICAgdGhpcy5sdiA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEuYXUgJiYgZGF0YS5hdS5sdiA/IGRhdGEuYXUubHYgOiB7XG4gICAgICBrOiBbMTAwXVxuICAgIH0sIDEsIDAuMDEsIHRoaXMpO1xuICB9XG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0sIHRydWUpO1xuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0cnVlKTtcbiAgICBpZiAoIXRoaXMudG0uX3BsYWNlaG9sZGVyKSB7XG4gICAgICB2YXIgdGltZVJlbWFwcGVkID0gdGhpcy50bS52O1xuICAgICAgdGhpcy5fY3VycmVudFRpbWUgPSB0aW1lUmVtYXBwZWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2N1cnJlbnRUaW1lID0gbnVtIC8gdGhpcy5kYXRhLnNyO1xuICAgIH1cbiAgICB0aGlzLl92b2x1bWUgPSB0aGlzLmx2LnZbMF07XG4gICAgdmFyIHRvdGFsVm9sdW1lID0gdGhpcy5fdm9sdW1lICogdGhpcy5fdm9sdW1lTXVsdGlwbGllcjtcbiAgICBpZiAodGhpcy5fcHJldmlvdXNWb2x1bWUgIT09IHRvdGFsVm9sdW1lKSB7XG4gICAgICB0aGlzLl9wcmV2aW91c1ZvbHVtZSA9IHRvdGFsVm9sdW1lO1xuICAgICAgdGhpcy5hdWRpby52b2x1bWUodG90YWxWb2x1bWUpO1xuICAgIH1cbiAgfTtcbiAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgQmFzZUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIEF1ZGlvRWxlbWVudCk7XG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuaXNJblJhbmdlICYmIHRoaXMuX2NhblBsYXkpIHtcbiAgICAgIGlmICghdGhpcy5faXNQbGF5aW5nKSB7XG4gICAgICAgIHRoaXMuYXVkaW8ucGxheSgpO1xuICAgICAgICB0aGlzLmF1ZGlvLnNlZWsodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmdsb2JhbERhdGEuZnJhbWVSYXRlKTtcbiAgICAgICAgdGhpcy5faXNQbGF5aW5nID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuYXVkaW8ucGxheWluZygpIHx8IE1hdGguYWJzKHRoaXMuX2N1cnJlbnRUaW1lIC8gdGhpcy5nbG9iYWxEYXRhLmZyYW1lUmF0ZSAtIHRoaXMuYXVkaW8uc2VlaygpKSA+IDAuMSkge1xuICAgICAgICB0aGlzLmF1ZGlvLnNlZWsodGhpcy5fY3VycmVudFRpbWUgLyB0aGlzLmdsb2JhbERhdGEuZnJhbWVSYXRlKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB0aGlzLmF1ZGlvLnBsYXkoKVxuICB9O1xuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hdWRpby5wYXVzZSgpO1xuICAgIHRoaXMuX2lzUGxheWluZyA9IGZhbHNlO1xuICB9O1xuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuYXVkaW8ucGF1c2UoKTtcbiAgICB0aGlzLl9pc1BsYXlpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9jYW5QbGF5ID0gZmFsc2U7XG4gIH07XG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX2NhblBsYXkgPSB0cnVlO1xuICB9O1xuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLnNldFJhdGUgPSBmdW5jdGlvbiAocmF0ZVZhbHVlKSB7XG4gICAgdGhpcy5hdWRpby5yYXRlKHJhdGVWYWx1ZSk7XG4gIH07XG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUudm9sdW1lID0gZnVuY3Rpb24gKHZvbHVtZVZhbHVlKSB7XG4gICAgdGhpcy5fdm9sdW1lTXVsdGlwbGllciA9IHZvbHVtZVZhbHVlO1xuICAgIHRoaXMuX3ByZXZpb3VzVm9sdW1lID0gdm9sdW1lVmFsdWUgKiB0aGlzLl92b2x1bWU7XG4gICAgdGhpcy5hdWRpby52b2x1bWUodGhpcy5fcHJldmlvdXNWb2x1bWUpO1xuICB9O1xuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmdldEJhc2VFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBBdWRpb0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcbiAgQXVkaW9FbGVtZW50LnByb3RvdHlwZS5zb3VyY2VSZWN0QXRUaW1lID0gZnVuY3Rpb24gKCkge307XG4gIEF1ZGlvRWxlbWVudC5wcm90b3R5cGUuaW5pdEV4cHJlc3Npb25zID0gZnVuY3Rpb24gKCkge307XG5cbiAgZnVuY3Rpb24gQmFzZVJlbmRlcmVyKCkge31cbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jaGVja0xheWVycyA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIHZhciBkYXRhO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSB0cnVlO1xuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAoIXRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgZGF0YSA9IHRoaXMubGF5ZXJzW2ldO1xuICAgICAgICBpZiAoZGF0YS5pcCAtIGRhdGEuc3QgPD0gbnVtIC0gdGhpcy5sYXllcnNbaV0uc3QgJiYgZGF0YS5vcCAtIGRhdGEuc3QgPiBudW0gLSB0aGlzLmxheWVyc1tpXS5zdCkge1xuICAgICAgICAgIHRoaXMuYnVpbGRJdGVtKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gdGhpcy5lbGVtZW50c1tpXSA/IHRoaXMuY29tcGxldGVMYXllcnMgOiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BlbmRpbmdFbGVtZW50cygpO1xuICB9O1xuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUl0ZW0gPSBmdW5jdGlvbiAobGF5ZXIpIHtcbiAgICBzd2l0Y2ggKGxheWVyLnR5KSB7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUltYWdlKGxheWVyKTtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlQ29tcChsYXllcik7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNvbGlkKGxheWVyKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlTnVsbChsYXllcik7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVNoYXBlKGxheWVyKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVGV4dChsYXllcik7XG4gICAgICBjYXNlIDY6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUF1ZGlvKGxheWVyKTtcbiAgICAgIGNhc2UgMTM6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZUNhbWVyYShsYXllcik7XG4gICAgICBjYXNlIDE1OlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGb290YWdlKGxheWVyKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZU51bGwobGF5ZXIpO1xuICAgIH1cbiAgfTtcbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDYW1lcmEgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdZb3VcXCdyZSB1c2luZyBhIDNkIGNhbWVyYS4gVHJ5IHRoZSBodG1sIHJlbmRlcmVyLicpO1xuICB9O1xuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUF1ZGlvID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IEF1ZGlvRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUZvb3RhZ2UgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgRm9vdGFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEFsbEl0ZW1zID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmJ1aWxkSXRlbShpKTtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BlbmRpbmdFbGVtZW50cygpO1xuICB9O1xuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLmluY2x1ZGVMYXllcnMgPSBmdW5jdGlvbiAobmV3TGF5ZXJzKSB7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBuZXdMYXllcnMubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaiA9IDA7XG4gICAgICB3aGlsZSAoaiA8IGpMZW4pIHtcbiAgICAgICAgaWYgKHRoaXMubGF5ZXJzW2pdLmlkID09PSBuZXdMYXllcnNbaV0uaWQpIHtcbiAgICAgICAgICB0aGlzLmxheWVyc1tqXSA9IG5ld0xheWVyc1tpXTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBqICs9IDE7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBCYXNlUmVuZGVyZXIucHJvdG90eXBlLnNldFByb2plY3RJbnRlcmZhY2UgPSBmdW5jdGlvbiAocEludGVyZmFjZSkge1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlID0gcEludGVyZmFjZTtcbiAgfTtcbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5pbml0SXRlbXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkKSB7XG4gICAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcbiAgICB9XG4gIH07XG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nID0gZnVuY3Rpb24gKGVsZW1lbnQsIHBhcmVudE5hbWUsIGhpZXJhcmNoeSkge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgdmFyIGxheWVycyA9IHRoaXMubGF5ZXJzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gbGF5ZXJzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKGxheWVyc1tpXS5pbmQgPT0gcGFyZW50TmFtZSkge1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgICAgICBpZiAoIWVsZW1lbnRzW2ldIHx8IGVsZW1lbnRzW2ldID09PSB0cnVlKSB7XG4gICAgICAgICAgdGhpcy5idWlsZEl0ZW0oaSk7XG4gICAgICAgICAgdGhpcy5hZGRQZW5kaW5nRWxlbWVudChlbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBoaWVyYXJjaHkucHVzaChlbGVtZW50c1tpXSk7XG4gICAgICAgICAgZWxlbWVudHNbaV0uc2V0QXNQYXJlbnQoKTtcbiAgICAgICAgICBpZiAobGF5ZXJzW2ldLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmJ1aWxkRWxlbWVudFBhcmVudGluZyhlbGVtZW50LCBsYXllcnNbaV0ucGFyZW50LCBoaWVyYXJjaHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBlbGVtZW50LnNldEhpZXJhcmNoeShoaWVyYXJjaHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfTtcbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5hZGRQZW5kaW5nRWxlbWVudCA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgfTtcbiAgQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5zZWFyY2hFeHRyYUNvbXBvc2l0aW9ucyA9IGZ1bmN0aW9uIChhc3NldHMpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gYXNzZXRzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChhc3NldHNbaV0ueHQpIHtcbiAgICAgICAgdmFyIGNvbXAgPSB0aGlzLmNyZWF0ZUNvbXAoYXNzZXRzW2ldKTtcbiAgICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5SWQgPSBmdW5jdGlvbiAoaW5kKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uZGF0YS5pbmQgPT09IGluZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lbGVtZW50c1tpXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuZ2V0RWxlbWVudEJ5UGF0aCA9IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIHBhdGhWYWx1ZSA9IHBhdGguc2hpZnQoKTtcbiAgICB2YXIgZWxlbWVudDtcbiAgICBpZiAodHlwZW9mIHBhdGhWYWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW3BhdGhWYWx1ZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZWxlbWVudHMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldLmRhdGEubm0gPT09IHBhdGhWYWx1ZSkge1xuICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50LmdldEVsZW1lbnRCeVBhdGgocGF0aCk7XG4gIH07XG4gIEJhc2VSZW5kZXJlci5wcm90b3R5cGUuc2V0dXBHbG9iYWxEYXRhID0gZnVuY3Rpb24gKGFuaW1EYXRhLCBmb250c0NvbnRhaW5lcikge1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlciA9IG5ldyBGb250TWFuYWdlcigpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5zbG90TWFuYWdlciA9IHNsb3RGYWN0b3J5KGFuaW1EYXRhKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuYWRkQ2hhcnMoYW5pbURhdGEuY2hhcnMpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5hZGRGb250cyhhbmltRGF0YS5mb250cywgZm9udHNDb250YWluZXIpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldERhdGEgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uZ2V0QXNzZXREYXRhLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZ2V0QXNzZXRzUGF0aCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5nZXRBc3NldHNQYXRoLmJpbmQodGhpcy5hbmltYXRpb25JdGVtKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuaW1hZ2VMb2FkZXIgPSB0aGlzLmFuaW1hdGlvbkl0ZW0uaW1hZ2VQcmVsb2FkZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmF1ZGlvQ29udHJvbGxlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS5hdWRpb0NvbnRyb2xsZXI7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmZyYW1lSWQgPSAwO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgPSBhbmltRGF0YS5mcjtcbiAgICB0aGlzLmdsb2JhbERhdGEubm0gPSBhbmltRGF0YS5ubTtcbiAgICB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUgPSB7XG4gICAgICB3OiBhbmltRGF0YS53LFxuICAgICAgaDogYW5pbURhdGEuaFxuICAgIH07XG4gIH07XG5cbiAgdmFyIGVmZmVjdFR5cGVzID0ge1xuICAgIFRSQU5TRk9STV9FRkZFQ1Q6ICd0cmFuc2Zvcm1FRmZlY3QnXG4gIH07XG5cbiAgZnVuY3Rpb24gVHJhbnNmb3JtRWxlbWVudCgpIHt9XG4gIFRyYW5zZm9ybUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIGluaXRUcmFuc2Zvcm06IGZ1bmN0aW9uIGluaXRUcmFuc2Zvcm0oKSB7XG4gICAgICB2YXIgbWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybSA9IHtcbiAgICAgICAgbVByb3A6IHRoaXMuZGF0YS5rcyA/IFRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeS5nZXRUcmFuc2Zvcm1Qcm9wZXJ0eSh0aGlzLCB0aGlzLmRhdGEua3MsIHRoaXMpIDoge1xuICAgICAgICAgIG86IDBcbiAgICAgICAgfSxcbiAgICAgICAgX21hdE1kZjogZmFsc2UsXG4gICAgICAgIF9sb2NhbE1hdE1kZjogZmFsc2UsXG4gICAgICAgIF9vcE1kZjogZmFsc2UsXG4gICAgICAgIG1hdDogbWF0LFxuICAgICAgICBsb2NhbE1hdDogbWF0LFxuICAgICAgICBsb2NhbE9wYWNpdHk6IDFcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRhLmFvKSB7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AuYXV0b09yaWVudGVkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETzogY2hlY2sgVFlQRSAxMTogR3VpZGVkIGVsZW1lbnRzXG4gICAgICBpZiAodGhpcy5kYXRhLnR5ICE9PSAxMSkge1xuICAgICAgICAvLyB0aGlzLmNyZWF0ZUVsZW1lbnRzKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJUcmFuc2Zvcm06IGZ1bmN0aW9uIHJlbmRlclRyYW5zZm9ybSgpIHtcbiAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lO1xuICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgICB2YXIgbWF0O1xuICAgICAgICB2YXIgZmluYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoO1xuICAgICAgICAvLyBDaGVja2luZyBpZiBhbnkgb2YgdGhlIHRyYW5zZm9ybWF0aW9uIG1hdHJpY2VzIGluIHRoZSBoaWVyYXJjaHkgY2hhaW4gaGFzIGNoYW5nZWQuXG4gICAgICAgIGlmICghdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmKSB7XG4gICAgICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZiA9IHRydWU7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgICAgbWF0ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC52LnByb3BzO1xuICAgICAgICAgIGZpbmFsTWF0LmNsb25lRnJvbVByb3BzKG1hdCk7XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBmaW5hbE1hdC5tdWx0aXBseSh0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC52KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5sb2NhbFRyYW5zZm9ybXMgfHwgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0uX2xvY2FsTWF0TWRmID0gdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmKSB7XG4gICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxPcGFjaXR5ID0gdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5vLnY7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJMb2NhbFRyYW5zZm9ybTogZnVuY3Rpb24gcmVuZGVyTG9jYWxUcmFuc2Zvcm0oKSB7XG4gICAgICBpZiAodGhpcy5sb2NhbFRyYW5zZm9ybXMpIHtcbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5sb2NhbFRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgICB0aGlzLmZpbmFsVHJhbnNmb3JtLl9sb2NhbE1hdE1kZiA9IHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZjtcbiAgICAgICAgaWYgKCF0aGlzLmZpbmFsVHJhbnNmb3JtLl9sb2NhbE1hdE1kZiB8fCAhdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLl9tZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLl9vcE1kZiAmJiAhdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE9wYWNpdHkgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLm8udjtcbiAgICAgICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fbG9jYWxNYXRNZGYpIHtcbiAgICAgICAgICB2YXIgbG9jYWxNYXQgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsTWF0O1xuICAgICAgICAgIHRoaXMubG9jYWxUcmFuc2Zvcm1zWzBdLm1hdHJpeC5jbG9uZShsb2NhbE1hdCk7XG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICB2YXIgbG1hdCA9IHRoaXMubG9jYWxUcmFuc2Zvcm1zW2ldLm1hdHJpeDtcbiAgICAgICAgICAgIGxvY2FsTWF0Lm11bHRpcGx5KGxtYXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBsb2NhbE1hdC5tdWx0aXBseSh0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX29wTWRmKSB7XG4gICAgICAgICAgdmFyIGxvY2FsT3AgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGxvY2FsT3AgKj0gdGhpcy5sb2NhbFRyYW5zZm9ybXNbaV0ub3BhY2l0eSAqIDAuMDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxPcGFjaXR5ID0gbG9jYWxPcDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2VhcmNoRWZmZWN0VHJhbnNmb3JtczogZnVuY3Rpb24gc2VhcmNoRWZmZWN0VHJhbnNmb3JtcygpIHtcbiAgICAgIGlmICh0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlcikge1xuICAgICAgICB2YXIgdHJhbnNmb3JtRWZmZWN0cyA9IHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyLmdldEVmZmVjdHMoZWZmZWN0VHlwZXMuVFJBTlNGT1JNX0VGRkVDVCk7XG4gICAgICAgIGlmICh0cmFuc2Zvcm1FZmZlY3RzLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMubG9jYWxUcmFuc2Zvcm1zID0gW107XG4gICAgICAgICAgdGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybUVmZmVjdHMubGVuZ3RoO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgdGhpcy5sb2NhbFRyYW5zZm9ybXMucHVzaCh0cmFuc2Zvcm1FZmZlY3RzW2ldKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGdsb2JhbFRvTG9jYWw6IGZ1bmN0aW9uIGdsb2JhbFRvTG9jYWwocHQpIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW107XG4gICAgICB0cmFuc2Zvcm1zLnB1c2godGhpcy5maW5hbFRyYW5zZm9ybSk7XG4gICAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgICB2YXIgY29tcCA9IHRoaXMuY29tcDtcbiAgICAgIHdoaWxlIChmbGFnKSB7XG4gICAgICAgIGlmIChjb21wLmZpbmFsVHJhbnNmb3JtKSB7XG4gICAgICAgICAgaWYgKGNvbXAuZGF0YS5oYXNNYXNrKSB7XG4gICAgICAgICAgICB0cmFuc2Zvcm1zLnNwbGljZSgwLCAwLCBjb21wLmZpbmFsVHJhbnNmb3JtKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tcCA9IGNvbXAuY29tcDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBmbGFnID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgdmFyIHB0TmV3O1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHB0TmV3ID0gdHJhbnNmb3Jtc1tpXS5tYXQuYXBwbHlUb1BvaW50QXJyYXkoMCwgMCwgMCk7XG4gICAgICAgIC8vIHB0TmV3ID0gdHJhbnNmb3Jtc1tpXS5tYXQuYXBwbHlUb1BvaW50QXJyYXkocHRbMF0scHRbMV0scHRbMl0pO1xuICAgICAgICBwdCA9IFtwdFswXSAtIHB0TmV3WzBdLCBwdFsxXSAtIHB0TmV3WzFdLCAwXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwdDtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuXG4gIGZ1bmN0aW9uIE1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQsIGdsb2JhbERhdGEpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5nbG9iYWxEYXRhID0gZ2xvYmFsRGF0YTtcbiAgICB0aGlzLnN0b3JlZERhdGEgPSBbXTtcbiAgICB0aGlzLm1hc2tzUHJvcGVydGllcyA9IHRoaXMuZGF0YS5tYXNrc1Byb3BlcnRpZXMgfHwgW107XG4gICAgdGhpcy5tYXNrRWxlbWVudCA9IG51bGw7XG4gICAgdmFyIGRlZnMgPSB0aGlzLmdsb2JhbERhdGEuZGVmcztcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMgPyB0aGlzLm1hc2tzUHJvcGVydGllcy5sZW5ndGggOiAwO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KGxlbik7XG4gICAgdGhpcy5zb2xpZFBhdGggPSAnJztcbiAgICB2YXIgcGF0aDtcbiAgICB2YXIgcHJvcGVydGllcyA9IHRoaXMubWFza3NQcm9wZXJ0aWVzO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGN1cnJlbnRNYXNrcyA9IFtdO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBsYXllcklkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIHJlY3Q7XG4gICAgdmFyIGV4cGFuc29yO1xuICAgIHZhciBmZU1vcnBoO1xuICAgIHZhciB4O1xuICAgIHZhciBtYXNrVHlwZSA9ICdjbGlwUGF0aCc7XG4gICAgdmFyIG1hc2tSZWYgPSAnY2xpcC1wYXRoJztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICdhJyAmJiBwcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJyB8fCBwcm9wZXJ0aWVzW2ldLmludiB8fCBwcm9wZXJ0aWVzW2ldLm8uayAhPT0gMTAwIHx8IHByb3BlcnRpZXNbaV0uby54KSB7XG4gICAgICAgIG1hc2tUeXBlID0gJ21hc2snO1xuICAgICAgICBtYXNrUmVmID0gJ21hc2snO1xuICAgICAgfVxuICAgICAgaWYgKChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyB8fCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdpJykgJiYgY291bnQgPT09IDApIHtcbiAgICAgICAgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJyNmZmZmZmYnKTtcbiAgICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5lbGVtZW50LmNvbXAuZGF0YS53IHx8IDApO1xuICAgICAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5lbGVtZW50LmNvbXAuZGF0YS5oIHx8IDApO1xuICAgICAgICBjdXJyZW50TWFza3MucHVzaChyZWN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlY3QgPSBudWxsO1xuICAgICAgfVxuICAgICAgcGF0aCA9IGNyZWF0ZU5TKCdwYXRoJyk7XG4gICAgICBpZiAocHJvcGVydGllc1tpXS5tb2RlID09PSAnbicpIHtcbiAgICAgICAgLy8gVE9ETyBtb3ZlIHRoaXMgdG8gYSBmYWN0b3J5IG9yIHRvIGEgY29uc3RydWN0b3JcbiAgICAgICAgdGhpcy52aWV3RGF0YVtpXSA9IHtcbiAgICAgICAgICBvcDogUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcy5lbGVtZW50LCBwcm9wZXJ0aWVzW2ldLm8sIDAsIDAuMDEsIHRoaXMuZWxlbWVudCksXG4gICAgICAgICAgcHJvcDogU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXSwgMyksXG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICBsYXN0UGF0aDogJydcbiAgICAgICAgfTtcbiAgICAgICAgZGVmcy5hcHBlbmRDaGlsZChwYXRoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgcHJvcGVydGllc1tpXS5tb2RlID09PSAncycgPyAnIzAwMDAwMCcgOiAnI2ZmZmZmZicpO1xuICAgICAgICBwYXRoLnNldEF0dHJpYnV0ZSgnY2xpcC1ydWxlJywgJ25vbnplcm8nKTtcbiAgICAgICAgdmFyIGZpbHRlcklEO1xuICAgICAgICBpZiAocHJvcGVydGllc1tpXS54LmsgIT09IDApIHtcbiAgICAgICAgICBtYXNrVHlwZSA9ICdtYXNrJztcbiAgICAgICAgICBtYXNrUmVmID0gJ21hc2snO1xuICAgICAgICAgIHggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0ueCwgMCwgbnVsbCwgdGhpcy5lbGVtZW50KTtcbiAgICAgICAgICBmaWx0ZXJJRCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgICAgIGV4cGFuc29yID0gY3JlYXRlTlMoJ2ZpbHRlcicpO1xuICAgICAgICAgIGV4cGFuc29yLnNldEF0dHJpYnV0ZSgnaWQnLCBmaWx0ZXJJRCk7XG4gICAgICAgICAgZmVNb3JwaCA9IGNyZWF0ZU5TKCdmZU1vcnBob2xvZ3knKTtcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgnb3BlcmF0b3InLCAnZXJvZGUnKTtcbiAgICAgICAgICBmZU1vcnBoLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlR3JhcGhpYycpO1xuICAgICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdyYWRpdXMnLCAnMCcpO1xuICAgICAgICAgIGV4cGFuc29yLmFwcGVuZENoaWxkKGZlTW9ycGgpO1xuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQoZXhwYW5zb3IpO1xuICAgICAgICAgIHBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCBwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdzJyA/ICcjMDAwMDAwJyA6ICcjZmZmZmZmJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZmVNb3JwaCA9IG51bGw7XG4gICAgICAgICAgeCA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPIG1vdmUgdGhpcyB0byBhIGZhY3Rvcnkgb3IgdG8gYSBjb25zdHJ1Y3RvclxuICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICB4OiB4LFxuICAgICAgICAgIGV4cGFuOiBmZU1vcnBoLFxuICAgICAgICAgIGxhc3RQYXRoOiAnJyxcbiAgICAgICAgICBsYXN0T3BlcmF0b3I6ICcnLFxuICAgICAgICAgIGZpbHRlcklkOiBmaWx0ZXJJRCxcbiAgICAgICAgICBsYXN0UmFkaXVzOiAwXG4gICAgICAgIH07XG4gICAgICAgIGlmIChwcm9wZXJ0aWVzW2ldLm1vZGUgPT09ICdpJykge1xuICAgICAgICAgIGpMZW4gPSBjdXJyZW50TWFza3MubGVuZ3RoO1xuICAgICAgICAgIHZhciBnID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBnLmFwcGVuZENoaWxkKGN1cnJlbnRNYXNrc1tqXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBtYXNrID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XG4gICAgICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbGF5ZXJJZCArICdfJyArIGNvdW50KTtcbiAgICAgICAgICBtYXNrLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgICAgIGRlZnMuYXBwZW5kQ2hpbGQobWFzayk7XG4gICAgICAgICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGxheWVySWQgKyAnXycgKyBjb3VudCArICcpJyk7XG4gICAgICAgICAgY3VycmVudE1hc2tzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2goZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudE1hc2tzLnB1c2gocGF0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3BlcnRpZXNbaV0uaW52ICYmICF0aGlzLnNvbGlkUGF0aCkge1xuICAgICAgICAgIHRoaXMuc29saWRQYXRoID0gdGhpcy5jcmVhdGVMYXllclNvbGlkUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gbW92ZSB0aGlzIHRvIGEgZmFjdG9yeSBvciB0byBhIGNvbnN0cnVjdG9yXG4gICAgICAgIHRoaXMudmlld0RhdGFbaV0gPSB7XG4gICAgICAgICAgZWxlbTogcGF0aCxcbiAgICAgICAgICBsYXN0UGF0aDogJycsXG4gICAgICAgICAgb3A6IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMuZWxlbWVudCwgcHJvcGVydGllc1tpXS5vLCAwLCAwLjAxLCB0aGlzLmVsZW1lbnQpLFxuICAgICAgICAgIHByb3A6IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsIHByb3BlcnRpZXNbaV0sIDMpLFxuICAgICAgICAgIGludlJlY3Q6IHJlY3RcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLnZpZXdEYXRhW2ldLnByb3Auaykge1xuICAgICAgICAgIHRoaXMuZHJhd1BhdGgocHJvcGVydGllc1tpXSwgdGhpcy52aWV3RGF0YVtpXS5wcm9wLnYsIHRoaXMudmlld0RhdGFbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubWFza0VsZW1lbnQgPSBjcmVhdGVOUyhtYXNrVHlwZSk7XG4gICAgbGVuID0gY3VycmVudE1hc2tzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMubWFza0VsZW1lbnQuYXBwZW5kQ2hpbGQoY3VycmVudE1hc2tzW2ldKTtcbiAgICB9XG4gICAgaWYgKGNvdW50ID4gMCkge1xuICAgICAgdGhpcy5tYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgbGF5ZXJJZCk7XG4gICAgICB0aGlzLmVsZW1lbnQubWFza2VkRWxlbWVudC5zZXRBdHRyaWJ1dGUobWFza1JlZiwgJ3VybCgnICsgZ2V0TG9jYXRpb25IcmVmKCkgKyAnIycgKyBsYXllcklkICsgJyknKTtcbiAgICAgIGRlZnMuYXBwZW5kQ2hpbGQodGhpcy5tYXNrRWxlbWVudCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnZpZXdEYXRhLmxlbmd0aCkge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgcmV0dXJuIHRoaXMudmlld0RhdGFbcG9zXS5wcm9wO1xuICB9O1xuICBNYXNrRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIGZpbmFsTWF0ID0gdGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5tYXNrc1Byb3BlcnRpZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMudmlld0RhdGFbaV0ucHJvcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLmRyYXdQYXRoKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLCB0aGlzLnZpZXdEYXRhW2ldLnByb3AudiwgdGhpcy52aWV3RGF0YVtpXSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5vcC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLnZpZXdEYXRhW2ldLmVsZW0uc2V0QXR0cmlidXRlKCdmaWxsLW9wYWNpdHknLCB0aGlzLnZpZXdEYXRhW2ldLm9wLnYpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLm1vZGUgIT09ICduJykge1xuICAgICAgICBpZiAodGhpcy52aWV3RGF0YVtpXS5pbnZSZWN0ICYmICh0aGlzLmVsZW1lbnQuZmluYWxUcmFuc2Zvcm0ubVByb3AuX21kZiB8fCBpc0ZpcnN0RnJhbWUpKSB7XG4gICAgICAgICAgdGhpcy52aWV3RGF0YVtpXS5pbnZSZWN0LnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgZmluYWxNYXQuZ2V0SW52ZXJzZU1hdHJpeCgpLnRvMmRDU1MoKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RvcmVkRGF0YVtpXS54ICYmICh0aGlzLnN0b3JlZERhdGFbaV0ueC5fbWRmIHx8IGlzRmlyc3RGcmFtZSkpIHtcbiAgICAgICAgICB2YXIgZmVNb3JwaCA9IHRoaXMuc3RvcmVkRGF0YVtpXS5leHBhbjtcbiAgICAgICAgICBpZiAodGhpcy5zdG9yZWREYXRhW2ldLngudiA8IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yICE9PSAnZXJvZGUnKSB7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5sYXN0T3BlcmF0b3IgPSAnZXJvZGUnO1xuICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgdGhpcy5zdG9yZWREYXRhW2ldLmZpbHRlcklkICsgJyknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZlTW9ycGguc2V0QXR0cmlidXRlKCdyYWRpdXMnLCAtdGhpcy5zdG9yZWREYXRhW2ldLngudik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yICE9PSAnZGlsYXRlJykge1xuICAgICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0ubGFzdE9wZXJhdG9yID0gJ2RpbGF0ZSc7XG4gICAgICAgICAgICAgIHRoaXMuc3RvcmVkRGF0YVtpXS5lbGVtLnNldEF0dHJpYnV0ZSgnZmlsdGVyJywgbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnN0b3JlZERhdGFbaV0uZWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuc3RvcmVkRGF0YVtpXS54LnYgKiAyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrZWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXNrRWxlbWVudDtcbiAgfTtcbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUxheWVyU29saWRQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBwYXRoID0gJ00wLDAgJztcbiAgICBwYXRoICs9ICcgaCcgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICBwYXRoICs9ICcgdicgKyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICBwYXRoICs9ICcgaC0nICsgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XG4gICAgcGF0aCArPSAnIHYtJyArIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oICsgJyAnO1xuICAgIHJldHVybiBwYXRoO1xuICB9O1xuICBNYXNrRWxlbWVudC5wcm90b3R5cGUuZHJhd1BhdGggPSBmdW5jdGlvbiAocGF0aERhdGEsIHBhdGhOb2Rlcywgdmlld0RhdGEpIHtcbiAgICB2YXIgcGF0aFN0cmluZyA9ICcgTScgKyBwYXRoTm9kZXMudlswXVswXSArICcsJyArIHBhdGhOb2Rlcy52WzBdWzFdO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAvLyBwYXRoU3RyaW5nICs9IFwiIENcIitwYXRoTm9kZXMub1tpLTFdWzBdKycsJytwYXRoTm9kZXMub1tpLTFdWzFdICsgXCIgXCIrcGF0aE5vZGVzLmlbaV1bMF0rJywnK3BhdGhOb2Rlcy5pW2ldWzFdICsgXCIgXCIrcGF0aE5vZGVzLnZbaV1bMF0rJywnK3BhdGhOb2Rlcy52W2ldWzFdO1xuICAgICAgcGF0aFN0cmluZyArPSAnIEMnICsgcGF0aE5vZGVzLm9baSAtIDFdWzBdICsgJywnICsgcGF0aE5vZGVzLm9baSAtIDFdWzFdICsgJyAnICsgcGF0aE5vZGVzLmlbaV1bMF0gKyAnLCcgKyBwYXRoTm9kZXMuaVtpXVsxXSArICcgJyArIHBhdGhOb2Rlcy52W2ldWzBdICsgJywnICsgcGF0aE5vZGVzLnZbaV1bMV07XG4gICAgfVxuICAgIC8vIHBhdGhTdHJpbmcgKz0gXCIgQ1wiK3BhdGhOb2Rlcy5vW2ktMV1bMF0rJywnK3BhdGhOb2Rlcy5vW2ktMV1bMV0gKyBcIiBcIitwYXRoTm9kZXMuaVswXVswXSsnLCcrcGF0aE5vZGVzLmlbMF1bMV0gKyBcIiBcIitwYXRoTm9kZXMudlswXVswXSsnLCcrcGF0aE5vZGVzLnZbMF1bMV07XG4gICAgaWYgKHBhdGhOb2Rlcy5jICYmIGxlbiA+IDEpIHtcbiAgICAgIHBhdGhTdHJpbmcgKz0gJyBDJyArIHBhdGhOb2Rlcy5vW2kgLSAxXVswXSArICcsJyArIHBhdGhOb2Rlcy5vW2kgLSAxXVsxXSArICcgJyArIHBhdGhOb2Rlcy5pWzBdWzBdICsgJywnICsgcGF0aE5vZGVzLmlbMF1bMV0gKyAnICcgKyBwYXRoTm9kZXMudlswXVswXSArICcsJyArIHBhdGhOb2Rlcy52WzBdWzFdO1xuICAgIH1cbiAgICAvLyBwYXRoTm9kZXMuX19yZW5kZXJlZFN0cmluZyA9IHBhdGhTdHJpbmc7XG5cbiAgICBpZiAodmlld0RhdGEubGFzdFBhdGggIT09IHBhdGhTdHJpbmcpIHtcbiAgICAgIHZhciBwYXRoU2hhcGVWYWx1ZSA9ICcnO1xuICAgICAgaWYgKHZpZXdEYXRhLmVsZW0pIHtcbiAgICAgICAgaWYgKHBhdGhOb2Rlcy5jKSB7XG4gICAgICAgICAgcGF0aFNoYXBlVmFsdWUgPSBwYXRoRGF0YS5pbnYgPyB0aGlzLnNvbGlkUGF0aCArIHBhdGhTdHJpbmcgOiBwYXRoU3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHZpZXdEYXRhLmVsZW0uc2V0QXR0cmlidXRlKCdkJywgcGF0aFNoYXBlVmFsdWUpO1xuICAgICAgfVxuICAgICAgdmlld0RhdGEubGFzdFBhdGggPSBwYXRoU3RyaW5nO1xuICAgIH1cbiAgfTtcbiAgTWFza0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmdsb2JhbERhdGEgPSBudWxsO1xuICAgIHRoaXMubWFza0VsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IG51bGw7XG4gICAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSBudWxsO1xuICB9O1xuXG4gIHZhciBmaWx0ZXJzRmFjdG9yeSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgb2IgPSB7fTtcbiAgICBvYi5jcmVhdGVGaWx0ZXIgPSBjcmVhdGVGaWx0ZXI7XG4gICAgb2IuY3JlYXRlQWxwaGFUb0x1bWluYW5jZUZpbHRlciA9IGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXI7XG4gICAgZnVuY3Rpb24gY3JlYXRlRmlsdGVyKGZpbElkLCBza2lwQ29vcmRpbmF0ZXMpIHtcbiAgICAgIHZhciBmaWwgPSBjcmVhdGVOUygnZmlsdGVyJyk7XG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdpZCcsIGZpbElkKTtcbiAgICAgIGlmIChza2lwQ29vcmRpbmF0ZXMgIT09IHRydWUpIHtcbiAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnZmlsdGVyVW5pdHMnLCAnb2JqZWN0Qm91bmRpbmdCb3gnKTtcbiAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgneCcsICcwJScpO1xuICAgICAgICBmaWwuc2V0QXR0cmlidXRlKCd5JywgJzAlJyk7XG4gICAgICAgIGZpbC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEwMCUnKTtcbiAgICAgICAgZmlsLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgJzEwMCUnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmaWw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSB7XG4gICAgICB2YXIgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcwIDAgMCAxIDAgIDAgMCAwIDEgMCAgMCAwIDAgMSAwICAwIDAgMCAxIDEnKTtcbiAgICAgIHJldHVybiBmZUNvbG9yTWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgZmVhdHVyZVN1cHBvcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge1xuICAgICAgbWFza1R5cGU6IHRydWUsXG4gICAgICBzdmdMdW1hSGlkZGVuOiB0cnVlLFxuICAgICAgb2Zmc2NyZWVuQ2FudmFzOiB0eXBlb2YgT2Zmc2NyZWVuQ2FudmFzICE9PSAndW5kZWZpbmVkJ1xuICAgIH07XG4gICAgaWYgKC9NU0lFIDEwL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvTVNJRSA5L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fCAvcnY6MTEuMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHwgL0VkZ2VcXC9cXGQuL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgb2IubWFza1R5cGUgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKC9maXJlZm94L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgb2Iuc3ZnTHVtYUhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgcmVnaXN0ZXJlZEVmZmVjdHMkMSA9IHt9O1xuICB2YXIgaWRQcmVmaXggPSAnZmlsdGVyX3Jlc3VsdF8nO1xuICBmdW5jdGlvbiBTVkdFZmZlY3RzKGVsZW0pIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgc291cmNlID0gJ1NvdXJjZUdyYXBoaWMnO1xuICAgIHZhciBsZW4gPSBlbGVtLmRhdGEuZWYgPyBlbGVtLmRhdGEuZWYubGVuZ3RoIDogMDtcbiAgICB2YXIgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICB2YXIgZmlsID0gZmlsdGVyc0ZhY3RvcnkuY3JlYXRlRmlsdGVyKGZpbElkLCB0cnVlKTtcbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIHZhciBmaWx0ZXJNYW5hZ2VyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcbiAgICAgIGlmIChyZWdpc3RlcmVkRWZmZWN0cyQxW3R5cGVdKSB7XG4gICAgICAgIHZhciBFZmZlY3QgPSByZWdpc3RlcmVkRWZmZWN0cyQxW3R5cGVdLmVmZmVjdDtcbiAgICAgICAgZmlsdGVyTWFuYWdlciA9IG5ldyBFZmZlY3QoZmlsLCBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldLCBlbGVtLCBpZFByZWZpeCArIGNvdW50LCBzb3VyY2UpO1xuICAgICAgICBzb3VyY2UgPSBpZFByZWZpeCArIGNvdW50O1xuICAgICAgICBpZiAocmVnaXN0ZXJlZEVmZmVjdHMkMVt0eXBlXS5jb3VudHNBc0VmZmVjdCkge1xuICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlck1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY291bnQpIHtcbiAgICAgIGVsZW0uZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XG4gICAgICBlbGVtLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgIH1cbiAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZWxlbS5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBTVkdFZmZlY3RzLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChfaXNGaXJzdEZyYW1lKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICB0aGlzLmZpbHRlcnNbaV0ucmVuZGVyRnJhbWUoX2lzRmlyc3RGcmFtZSk7XG4gICAgfVxuICB9O1xuICBTVkdFZmZlY3RzLnByb3RvdHlwZS5nZXRFZmZlY3RzID0gZnVuY3Rpb24gKHR5cGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcbiAgICB2YXIgZWZmZWN0cyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyc1tpXS50eXBlID09PSB0eXBlKSB7XG4gICAgICAgIGVmZmVjdHMucHVzaCh0aGlzLmZpbHRlcnNbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWZmZWN0cztcbiAgfTtcbiAgZnVuY3Rpb24gcmVnaXN0ZXJFZmZlY3QkMShpZCwgZWZmZWN0LCBjb3VudHNBc0VmZmVjdCkge1xuICAgIHJlZ2lzdGVyZWRFZmZlY3RzJDFbaWRdID0ge1xuICAgICAgZWZmZWN0OiBlZmZlY3QsXG4gICAgICBjb3VudHNBc0VmZmVjdDogY291bnRzQXNFZmZlY3RcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gU1ZHQmFzZUVsZW1lbnQoKSB7fVxuICBTVkdCYXNlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdFJlbmRlcmVyRWxlbWVudDogZnVuY3Rpb24gaW5pdFJlbmRlcmVyRWxlbWVudCgpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIHRoaXMubWF0dGVFbGVtZW50ID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICB0aGlzLm1hc2tlZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgbGF5ZXJFbGVtZW50UGFyZW50ID0gbnVsbDtcbiAgICAgIC8vIElmIHRoaXMgbGF5ZXIgYWN0cyBhcyBhIG1hc2sgZm9yIHRoZSBmb2xsb3dpbmcgbGF5ZXJcbiAgICAgIGlmICh0aGlzLmRhdGEudGQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZU1hc2tzID0ge307XG4gICAgICAgIHZhciBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgIGdnLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmxheWVySWQpO1xuICAgICAgICBnZy5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IGdnO1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChnZyk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS50dCkge1xuICAgICAgICB0aGlzLm1hdHRlRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmxheWVyRWxlbWVudCk7XG4gICAgICAgIGxheWVyRWxlbWVudFBhcmVudCA9IHRoaXMubWF0dGVFbGVtZW50O1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy5tYXR0ZUVsZW1lbnQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50ID0gdGhpcy5sYXllckVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmxuKSB7XG4gICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmRhdGEubG4pO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5jbCkge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5kYXRhLmNsKTtcbiAgICAgIH1cbiAgICAgIC8vIENsaXBwaW5nIGNvbXBvc2l0aW9ucyB0byBoaWRlIGNvbnRlbnQgdGhhdCBleGNlZWRzIGJvdW5kYXJpZXMuIElmIGNvbGxhcHNlZCB0cmFuc2Zvcm1hdGlvbnMgaXMgb24sIGNvbXBvbmVudCBzaG91bGQgbm90IGJlIGNsaXBwZWRcbiAgICAgIGlmICh0aGlzLmRhdGEudHkgPT09IDAgJiYgIXRoaXMuZGF0YS5oZCkge1xuICAgICAgICB2YXIgY3AgPSBjcmVhdGVOUygnY2xpcFBhdGgnKTtcbiAgICAgICAgdmFyIHB0ID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgICAgcHQuc2V0QXR0cmlidXRlKCdkJywgJ00wLDAgTCcgKyB0aGlzLmRhdGEudyArICcsMCBMJyArIHRoaXMuZGF0YS53ICsgJywnICsgdGhpcy5kYXRhLmggKyAnIEwwLCcgKyB0aGlzLmRhdGEuaCArICd6Jyk7XG4gICAgICAgIHZhciBjbGlwSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgY3Auc2V0QXR0cmlidXRlKCdpZCcsIGNsaXBJZCk7XG4gICAgICAgIGNwLmFwcGVuZENoaWxkKHB0KTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoY3ApO1xuICAgICAgICBpZiAodGhpcy5jaGVja01hc2tzKCkpIHtcbiAgICAgICAgICB2YXIgY3BHcm91cCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgY3BHcm91cC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgY2xpcElkICsgJyknKTtcbiAgICAgICAgICBjcEdyb3VwLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcbiAgICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IGNwR3JvdXA7XG4gICAgICAgICAgaWYgKGxheWVyRWxlbWVudFBhcmVudCkge1xuICAgICAgICAgICAgbGF5ZXJFbGVtZW50UGFyZW50LmFwcGVuZENoaWxkKHRoaXMudHJhbnNmb3JtZWRFbGVtZW50KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5iYXNlRWxlbWVudCA9IHRoaXMudHJhbnNmb3JtZWRFbGVtZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgY2xpcElkICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5ibSAhPT0gMCkge1xuICAgICAgICB0aGlzLnNldEJsZW5kTW9kZSgpO1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyRWxlbWVudDogZnVuY3Rpb24gcmVuZGVyRWxlbWVudCgpIHtcbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9sb2NhbE1hdE1kZikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHRoaXMuZmluYWxUcmFuc2Zvcm0ubG9jYWxNYXQudG8yZENTUygpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZpbmFsVHJhbnNmb3JtLl9vcE1kZikge1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBkZXN0cm95QmFzZUVsZW1lbnQ6IGZ1bmN0aW9uIGRlc3Ryb3lCYXNlRWxlbWVudCgpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMubWF0dGVFbGVtZW50ID0gbnVsbDtcbiAgICAgIHRoaXMubWFza01hbmFnZXIuZGVzdHJveSgpO1xuICAgIH0sXG4gICAgZ2V0QmFzZUVsZW1lbnQ6IGZ1bmN0aW9uIGdldEJhc2VFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5oZCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJhc2VFbGVtZW50O1xuICAgIH0sXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XG4gICAgICB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlciA9IG5ldyBTVkdFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy5zZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCk7XG4gICAgfSxcbiAgICBnZXRNYXR0ZTogZnVuY3Rpb24gZ2V0TWF0dGUobWF0dGVUeXBlKSB7XG4gICAgICAvLyBUaGlzIHNob3VsZCBub3QgYmUgYSBjb21tb24gY2FzZS4gQnV0IGZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB3ZSdsbCBjcmVhdGUgdGhlIG1hdHRlIG9iamVjdC5cbiAgICAgIC8vIEl0IHNvbHZlcyBhbmltYXRpb25zIHRoYXQgaGF2ZSB0d28gY29uc2VjdXRpdmUgbGF5ZXJzIG1hcmtlZCBhcyBtYXR0ZSBtYXNrcy5cbiAgICAgIC8vIFdoaWNoIGlzIGFuIHVuZGVmaW5lZCBiZWhhdmlvciBpbiBBRS5cbiAgICAgIGlmICghdGhpcy5tYXR0ZU1hc2tzKSB7XG4gICAgICAgIHRoaXMubWF0dGVNYXNrcyA9IHt9O1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLm1hdHRlTWFza3NbbWF0dGVUeXBlXSkge1xuICAgICAgICB2YXIgaWQgPSB0aGlzLmxheWVySWQgKyAnXycgKyBtYXR0ZVR5cGU7XG4gICAgICAgIHZhciBmaWxJZDtcbiAgICAgICAgdmFyIGZpbDtcbiAgICAgICAgdmFyIHVzZUVsZW1lbnQ7XG4gICAgICAgIHZhciBnZztcbiAgICAgICAgaWYgKG1hdHRlVHlwZSA9PT0gMSB8fCBtYXR0ZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICB2YXIgbWFza2VyID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCBtYXR0ZVR5cGUgPT09IDMgPyAnbHVtaW5hbmNlJyA6ICdhbHBoYScpO1xuICAgICAgICAgIHVzZUVsZW1lbnQgPSBjcmVhdGVOUygndXNlJyk7XG4gICAgICAgICAgdXNlRWxlbWVudC5zZXRBdHRyaWJ1dGVOUygnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsICdocmVmJywgJyMnICsgdGhpcy5sYXllcklkKTtcbiAgICAgICAgICBtYXNrZXIuYXBwZW5kQ2hpbGQodXNlRWxlbWVudCk7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFza2VyKTtcbiAgICAgICAgICBpZiAoIWZlYXR1cmVTdXBwb3J0Lm1hc2tUeXBlICYmIG1hdHRlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgbWFza2VyLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2x1bWluYW5jZScpO1xuICAgICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICAgIGZpbCA9IGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUZpbHRlcihmaWxJZCk7XG4gICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChmaWwpO1xuICAgICAgICAgICAgZmlsLmFwcGVuZENoaWxkKGZpbHRlcnNGYWN0b3J5LmNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIoKSk7XG4gICAgICAgICAgICBnZyA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICBnZy5hcHBlbmRDaGlsZCh1c2VFbGVtZW50KTtcbiAgICAgICAgICAgIG1hc2tlci5hcHBlbmRDaGlsZChnZyk7XG4gICAgICAgICAgICBnZy5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChtYXR0ZVR5cGUgPT09IDIpIHtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwID0gY3JlYXRlTlMoJ21hc2snKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgICAgICBtYXNrR3JvdXAuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgICAgICB2YXIgbWFza0dyb3VwZXIgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgIG1hc2tHcm91cC5hcHBlbmRDaGlsZChtYXNrR3JvdXBlcik7XG4gICAgICAgICAgZmlsSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICAgICAgICBmaWwgPSBmaWx0ZXJzRmFjdG9yeS5jcmVhdGVGaWx0ZXIoZmlsSWQpO1xuICAgICAgICAgIC8vLyAvXG4gICAgICAgICAgdmFyIGZlQ1RyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICAgICAgICBmZUNUci5zZXRBdHRyaWJ1dGUoJ2luJywgJ1NvdXJjZUdyYXBoaWMnKTtcbiAgICAgICAgICBmaWwuYXBwZW5kQ2hpbGQoZmVDVHIpO1xuICAgICAgICAgIHZhciBmZUZ1bmMgPSBjcmVhdGVOUygnZmVGdW5jQScpO1xuICAgICAgICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICAgICAgICBmZUZ1bmMuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsICcxLjAgMC4wJyk7XG4gICAgICAgICAgZmVDVHIuYXBwZW5kQ2hpbGQoZmVGdW5jKTtcbiAgICAgICAgICAvLy8gL1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGZpbCk7XG4gICAgICAgICAgdmFyIGFscGhhUmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgICAgICAgYWxwaGFSZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmNvbXAuZGF0YS53KTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmNvbXAuZGF0YS5oKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd4JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCd5JywgJzAnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdmaWxsJywgJyNmZmZmZmYnKTtcbiAgICAgICAgICBhbHBoYVJlY3Quc2V0QXR0cmlidXRlKCdvcGFjaXR5JywgJzAnKTtcbiAgICAgICAgICBtYXNrR3JvdXBlci5zZXRBdHRyaWJ1dGUoJ2ZpbHRlcicsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgZmlsSWQgKyAnKScpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKGFscGhhUmVjdCk7XG4gICAgICAgICAgdXNlRWxlbWVudCA9IGNyZWF0ZU5TKCd1c2UnKTtcbiAgICAgICAgICB1c2VFbGVtZW50LnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCAnIycgKyB0aGlzLmxheWVySWQpO1xuICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKHVzZUVsZW1lbnQpO1xuICAgICAgICAgIGlmICghZmVhdHVyZVN1cHBvcnQubWFza1R5cGUpIHtcbiAgICAgICAgICAgIG1hc2tHcm91cC5zZXRBdHRyaWJ1dGUoJ21hc2stdHlwZScsICdsdW1pbmFuY2UnKTtcbiAgICAgICAgICAgIGZpbC5hcHBlbmRDaGlsZChmaWx0ZXJzRmFjdG9yeS5jcmVhdGVBbHBoYVRvTHVtaW5hbmNlRmlsdGVyKCkpO1xuICAgICAgICAgICAgZ2cgPSBjcmVhdGVOUygnZycpO1xuICAgICAgICAgICAgbWFza0dyb3VwZXIuYXBwZW5kQ2hpbGQoYWxwaGFSZWN0KTtcbiAgICAgICAgICAgIGdnLmFwcGVuZENoaWxkKHRoaXMubGF5ZXJFbGVtZW50KTtcbiAgICAgICAgICAgIG1hc2tHcm91cGVyLmFwcGVuZENoaWxkKGdnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQobWFza0dyb3VwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1hdHRlTWFza3NbbWF0dGVUeXBlXSA9IGlkO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWF0dGVNYXNrc1ttYXR0ZVR5cGVdO1xuICAgIH0sXG4gICAgc2V0TWF0dGU6IGZ1bmN0aW9uIHNldE1hdHRlKGlkKSB7XG4gICAgICBpZiAoIXRoaXMubWF0dGVFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF0dGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnbWFzaycsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgaWQgKyAnKScpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQGZpbGVcbiAgICogSGFuZGxlcyBBRSdzIGxheWVyIHBhcmVudGluZyBwcm9wZXJ0eS5cbiAgICpcbiAgICovXG5cbiAgZnVuY3Rpb24gSGllcmFyY2h5RWxlbWVudCgpIHt9XG4gIEhpZXJhcmNoeUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIC8qKlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBJbml0aWFsaXplcyBoaWVyYXJjaHkgcHJvcGVydGllc1xuICAgICAgICpcbiAgICAgICAqL1xuICAgIGluaXRIaWVyYXJjaHk6IGZ1bmN0aW9uIGluaXRIaWVyYXJjaHkoKSB7XG4gICAgICAvLyBlbGVtZW50J3MgcGFyZW50IGxpc3RcbiAgICAgIHRoaXMuaGllcmFyY2h5ID0gW107XG4gICAgICAvLyBpZiBlbGVtZW50IGlzIHBhcmVudCBvZiBhbm90aGVyIGxheWVyIF9pc1BhcmVudCB3aWxsIGJlIHRydWVcbiAgICAgIHRoaXMuX2lzUGFyZW50ID0gZmFsc2U7XG4gICAgICB0aGlzLmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogU2V0cyBsYXllcidzIGhpZXJhcmNoeS5cbiAgICAgICAqIEBwYXJhbSB7YXJyYXl9IGhpZXJhcmNoXG4gICAgICAgKiBsYXllcidzIHBhcmVudCBsaXN0XG4gICAgICAgKlxuICAgICAgICovXG4gICAgc2V0SGllcmFyY2h5OiBmdW5jdGlvbiBzZXRIaWVyYXJjaHkoaGllcmFyY2h5KSB7XG4gICAgICB0aGlzLmhpZXJhcmNoeSA9IGhpZXJhcmNoeTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAgICogQGZ1bmN0aW9uXG4gICAgICAgKiBTZXRzIGxheWVyIGFzIHBhcmVudC5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICBzZXRBc1BhcmVudDogZnVuY3Rpb24gc2V0QXNQYXJlbnQoKSB7XG4gICAgICB0aGlzLl9pc1BhcmVudCA9IHRydWU7XG4gICAgfSxcbiAgICAvKipcbiAgICAgICAqIEBmdW5jdGlvblxuICAgICAgICogU2VhcmNoZXMgbGF5ZXIncyBwYXJlbnRpbmcgY2hhaW5cbiAgICAgICAqXG4gICAgICAgKi9cbiAgICBjaGVja1BhcmVudGluZzogZnVuY3Rpb24gY2hlY2tQYXJlbnRpbmcoKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLnBhcmVudCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuY29tcC5idWlsZEVsZW1lbnRQYXJlbnRpbmcodGhpcywgdGhpcy5kYXRhLnBhcmVudCwgW10pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBSZW5kZXJhYmxlRE9NRWxlbWVudCgpIHt9XG4gIChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIF9wcm90b3R5cGUgPSB7XG4gICAgICBpbml0RWxlbWVudDogZnVuY3Rpb24gaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgICAgICB0aGlzLmluaXRGcmFtZSgpO1xuICAgICAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICAgICAgdGhpcy5pbml0VHJhbnNmb3JtKGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgICAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICAgICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgICAgICB0aGlzLmluaXRSZW5kZXJlckVsZW1lbnQoKTtcbiAgICAgICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgICAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgICAgIHRoaXMuY3JlYXRlQ29udGVudCgpO1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0sXG4gICAgICBoaWRlOiBmdW5jdGlvbiBoaWRlKCkge1xuICAgICAgICAvLyBjb25zb2xlLmxvZygnSElERScsIHRoaXMpO1xuICAgICAgICBpZiAoIXRoaXMuaGlkZGVuICYmICghdGhpcy5pc0luUmFuZ2UgfHwgdGhpcy5pc1RyYW5zcGFyZW50KSkge1xuICAgICAgICAgIHZhciBlbGVtID0gdGhpcy5iYXNlRWxlbWVudCB8fCB0aGlzLmxheWVyRWxlbWVudDtcbiAgICAgICAgICBlbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgc2hvdzogZnVuY3Rpb24gc2hvdygpIHtcbiAgICAgICAgLy8gY29uc29sZS5sb2coJ1NIT1cnLCB0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuZGF0YS5oZCkge1xuICAgICAgICAgICAgdmFyIGVsZW0gPSB0aGlzLmJhc2VFbGVtZW50IHx8IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICAgICAgZWxlbS5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uIHJlbmRlckZyYW1lKCkge1xuICAgICAgICAvLyBJZiBpdCBpcyBleHBvcnRlZCBhcyBoaWRkZW4gKGRhdGEuaGQgPT09IHRydWUpIG5vIG5lZWQgdG8gcmVuZGVyXG4gICAgICAgIC8vIElmIGl0IGlzIG5vdCB2aXNpYmxlIG5vIG5lZWQgdG8gcmVuZGVyXG4gICAgICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XG4gICAgICAgIHRoaXMucmVuZGVyTG9jYWxUcmFuc2Zvcm0oKTtcbiAgICAgICAgdGhpcy5yZW5kZXJFbGVtZW50KCk7XG4gICAgICAgIHRoaXMucmVuZGVySW5uZXJDb250ZW50KCk7XG4gICAgICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHJlbmRlcklubmVyQ29udGVudDogZnVuY3Rpb24gcmVuZGVySW5uZXJDb250ZW50KCkge30sXG4gICAgICBwcmVwYXJlRnJhbWU6IGZ1bmN0aW9uIHByZXBhcmVGcmFtZShudW0pIHtcbiAgICAgICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xuICAgICAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICAgICAgICB0aGlzLmNoZWNrVHJhbnNwYXJlbmN5KCk7XG4gICAgICB9LFxuICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5pbm5lckVsZW0gPSBudWxsO1xuICAgICAgICB0aGlzLmRlc3Ryb3lCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuICAgIH07XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtSZW5kZXJhYmxlRWxlbWVudCwgY3JlYXRlUHJveHlGdW5jdGlvbihfcHJvdG90eXBlKV0sIFJlbmRlcmFibGVET01FbGVtZW50KTtcbiAgfSkoKTtcblxuICBmdW5jdGlvbiBJSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIGlmICh0aGlzLmFzc2V0RGF0YSAmJiB0aGlzLmFzc2V0RGF0YS5zaWQpIHtcbiAgICAgIHRoaXMuYXNzZXREYXRhID0gZ2xvYmFsRGF0YS5zbG90TWFuYWdlci5nZXRQcm9wKHRoaXMuYXNzZXREYXRhKTtcbiAgICB9XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLnNvdXJjZVJlY3QgPSB7XG4gICAgICB0b3A6IDAsXG4gICAgICBsZWZ0OiAwLFxuICAgICAgd2lkdGg6IHRoaXMuYXNzZXREYXRhLncsXG4gICAgICBoZWlnaHQ6IHRoaXMuYXNzZXREYXRhLmhcbiAgICB9O1xuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUltYWdlRWxlbWVudCk7XG4gIElJbWFnZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcbiAgICB0aGlzLmlubmVyRWxlbSA9IGNyZWF0ZU5TKCdpbWFnZScpO1xuICAgIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53ICsgJ3B4Jyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmFzc2V0RGF0YS5oICsgJ3B4Jyk7XG4gICAgdGhpcy5pbm5lckVsZW0uc2V0QXR0cmlidXRlKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgdGhpcy5hc3NldERhdGEucHIgfHwgdGhpcy5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIHRoaXMuaW5uZXJFbGVtLnNldEF0dHJpYnV0ZU5TKCdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJywgJ2hyZWYnLCBhc3NldFBhdGgpO1xuICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuaW5uZXJFbGVtKTtcbiAgfTtcbiAgSUltYWdlRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zb3VyY2VSZWN0O1xuICB9O1xuXG4gIGZ1bmN0aW9uIFByb2Nlc3NlZEVsZW1lbnQoZWxlbWVudCwgcG9zaXRpb24pIHtcbiAgICB0aGlzLmVsZW0gPSBlbGVtZW50O1xuICAgIHRoaXMucG9zID0gcG9zaXRpb247XG4gIH1cblxuICBmdW5jdGlvbiBJU2hhcGVFbGVtZW50KCkge31cbiAgSVNoYXBlRWxlbWVudC5wcm90b3R5cGUgPSB7XG4gICAgYWRkU2hhcGVUb01vZGlmaWVyczogZnVuY3Rpb24gYWRkU2hhcGVUb01vZGlmaWVycyhkYXRhKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLmFkZFNoYXBlKGRhdGEpO1xuICAgICAgfVxuICAgIH0sXG4gICAgaXNTaGFwZUluQW5pbWF0ZWRNb2RpZmllcnM6IGZ1bmN0aW9uIGlzU2hhcGVJbkFuaW1hdGVkTW9kaWZpZXJzKGRhdGEpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlTW9kaWZpZXJzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgIGlmICh0aGlzLnNoYXBlTW9kaWZpZXJzW2ldLmlzQW5pbWF0ZWRXaXRoU2hhcGUoZGF0YSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG4gICAgcmVuZGVyTW9kaWZpZXJzOiBmdW5jdGlvbiByZW5kZXJNb2RpZmllcnMoKSB7XG4gICAgICBpZiAoIXRoaXMuc2hhcGVNb2RpZmllcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuc2hhcGVzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB0aGlzLnNoYXBlc1tpXS5zaC5yZXNldCgpO1xuICAgICAgfVxuICAgICAgbGVuID0gdGhpcy5zaGFwZU1vZGlmaWVycy5sZW5ndGg7XG4gICAgICB2YXIgc2hvdWxkQnJlYWtQcm9jZXNzO1xuICAgICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgc2hvdWxkQnJlYWtQcm9jZXNzID0gdGhpcy5zaGFwZU1vZGlmaWVyc1tpXS5wcm9jZXNzU2hhcGVzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgICAgIC8vIHdvcmthcm91bmQgdG8gZml4IGNhc2VzIHdoZXJlIGEgcmVwZWF0ZXIgcmVzZXRzIHRoZSBzaGFwZSBzbyB0aGUgZm9sbG93aW5nIHByb2Nlc3NlcyBnZXQgY2FsbGVkIHR3aWNlXG4gICAgICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24gZm9yIHRoaXNcbiAgICAgICAgaWYgKHNob3VsZEJyZWFrUHJvY2Vzcykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBzZWFyY2hQcm9jZXNzZWRFbGVtZW50OiBmdW5jdGlvbiBzZWFyY2hQcm9jZXNzZWRFbGVtZW50KGVsZW0pIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucHJvY2Vzc2VkRWxlbWVudHM7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmVsZW0gPT09IGVsZW0pIHtcbiAgICAgICAgICByZXR1cm4gZWxlbWVudHNbaV0ucG9zO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgYWRkUHJvY2Vzc2VkRWxlbWVudDogZnVuY3Rpb24gYWRkUHJvY2Vzc2VkRWxlbWVudChlbGVtLCBwb3MpIHtcbiAgICAgIHZhciBlbGVtZW50cyA9IHRoaXMucHJvY2Vzc2VkRWxlbWVudHM7XG4gICAgICB2YXIgaSA9IGVsZW1lbnRzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpKSB7XG4gICAgICAgIGkgLT0gMTtcbiAgICAgICAgaWYgKGVsZW1lbnRzW2ldLmVsZW0gPT09IGVsZW0pIHtcbiAgICAgICAgICBlbGVtZW50c1tpXS5wb3MgPSBwb3M7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBlbGVtZW50cy5wdXNoKG5ldyBQcm9jZXNzZWRFbGVtZW50KGVsZW0sIHBvcykpO1xuICAgIH0sXG4gICAgcHJlcGFyZUZyYW1lOiBmdW5jdGlvbiBwcmVwYXJlRnJhbWUobnVtKSB7XG4gICAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcbiAgICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBsaW5lQ2FwRW51bSA9IHtcbiAgICAxOiAnYnV0dCcsXG4gICAgMjogJ3JvdW5kJyxcbiAgICAzOiAnc3F1YXJlJ1xuICB9O1xuICB2YXIgbGluZUpvaW5FbnVtID0ge1xuICAgIDE6ICdtaXRlcicsXG4gICAgMjogJ3JvdW5kJyxcbiAgICAzOiAnYmV2ZWwnXG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHU2hhcGVEYXRhKHRyYW5zZm9ybWVycywgbGV2ZWwsIHNoYXBlKSB7XG4gICAgdGhpcy5jYWNoZXMgPSBbXTtcbiAgICB0aGlzLnN0eWxlcyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtZXJzID0gdHJhbnNmb3JtZXJzO1xuICAgIHRoaXMubFN0ciA9ICcnO1xuICAgIHRoaXMuc2ggPSBzaGFwZTtcbiAgICB0aGlzLmx2bCA9IGxldmVsO1xuICAgIC8vIFRPRE8gZmluZCBpZiB0aGVyZSBhcmUgc29tZSBjYXNlcyB3aGVyZSBfaXNBbmltYXRlZCBjYW4gYmUgZmFsc2UuXG4gICAgLy8gRm9yIG5vdywgc2luY2Ugc2hhcGVzIGFkZCB1cCB3aXRoIG90aGVyIHNoYXBlcy4gVGhleSBoYXZlIHRvIGJlIGNhbGN1bGF0ZWQgZXZlcnkgdGltZS5cbiAgICAvLyBPbmUgd2F5IG9mIGZpbmRpbmcgb3V0IGlzIGNoZWNraW5nIGlmIGFsbCBzdHlsZXMgYXNzb2NpYXRlZCB0byB0aGlzIHNoYXBlIGRlcGVuZCBvbmx5IG9mIHRoaXMgc2hhcGVcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISFzaGFwZS5rO1xuICAgIC8vIFRPRE86IGNvbW1lbnRpbmcgdGhpcyBmb3Igbm93IHNpbmNlIGFsbCBzaGFwZXMgYXJlIGFuaW1hdGVkXG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0cmFuc2Zvcm1lcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgfVxuICBTVkdTaGFwZURhdGEucHJvdG90eXBlLnNldEFzQW5pbWF0ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9IHRydWU7XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHU3R5bGVEYXRhKGRhdGEsIGxldmVsKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLnR5cGUgPSBkYXRhLnR5O1xuICAgIHRoaXMuZCA9ICcnO1xuICAgIHRoaXMubHZsID0gbGV2ZWw7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5jbG9zZWQgPSBkYXRhLmhkID09PSB0cnVlO1xuICAgIHRoaXMucEVsZW0gPSBjcmVhdGVOUygncGF0aCcpO1xuICAgIHRoaXMubXNFbGVtID0gbnVsbDtcbiAgfVxuICBTVkdTdHlsZURhdGEucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZCA9ICcnO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICB9O1xuXG4gIGZ1bmN0aW9uIERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLCByZW5kZXJlciwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICB0aGlzLmZyYW1lSWQgPSAtMTtcbiAgICB0aGlzLmRhdGFQcm9wcyA9IGNyZWF0ZVNpemVkQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgIHRoaXMucmVuZGVyZXIgPSByZW5kZXJlcjtcbiAgICB0aGlzLmsgPSBmYWxzZTtcbiAgICB0aGlzLmRhc2hTdHIgPSAnJztcbiAgICB0aGlzLmRhc2hBcnJheSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBkYXRhLmxlbmd0aCA/IGRhdGEubGVuZ3RoIC0gMSA6IDApO1xuICAgIHRoaXMuZGFzaG9mZnNldCA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCAxKTtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoY29udGFpbmVyKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gZGF0YS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcHJvcDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhW2ldLnYsIDAsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5rID0gcHJvcC5rIHx8IHRoaXMuaztcbiAgICAgIHRoaXMuZGF0YVByb3BzW2ldID0ge1xuICAgICAgICBuOiBkYXRhW2ldLm4sXG4gICAgICAgIHA6IHByb3BcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghdGhpcy5rKSB7XG4gICAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICAgIH1cbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gdGhpcy5rO1xuICB9XG4gIERhc2hQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0VmFsdWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAodGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVJZCA9PT0gdGhpcy5mcmFtZUlkICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmZyYW1lSWQgPSB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gICAgdGhpcy5fbWRmID0gdGhpcy5fbWRmIHx8IGZvcmNlUmVuZGVyO1xuICAgIGlmICh0aGlzLl9tZGYpIHtcbiAgICAgIHZhciBpID0gMDtcbiAgICAgIHZhciBsZW4gPSB0aGlzLmRhdGFQcm9wcy5sZW5ndGg7XG4gICAgICBpZiAodGhpcy5yZW5kZXJlciA9PT0gJ3N2ZycpIHtcbiAgICAgICAgdGhpcy5kYXNoU3RyID0gJyc7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVByb3BzW2ldLm4gIT09ICdvJykge1xuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcmVyID09PSAnc3ZnJykge1xuICAgICAgICAgICAgdGhpcy5kYXNoU3RyICs9ICcgJyArIHRoaXMuZGF0YVByb3BzW2ldLnAudjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5kYXNoQXJyYXlbaV0gPSB0aGlzLmRhdGFQcm9wc1tpXS5wLnY7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZGFzaG9mZnNldFswXSA9IHRoaXMuZGF0YVByb3BzW2ldLnAudjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBEYXNoUHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIFNWR1N0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMudyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEudywgMCwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5kID0gbmV3IERhc2hQcm9wZXJ0eShlbGVtLCBkYXRhLmQgfHwge30sICdzdmcnLCB0aGlzKTtcbiAgICB0aGlzLmMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmMsIDEsIDI1NSwgdGhpcyk7XG4gICAgdGhpcy5zdHlsZSA9IHN0eWxlT2I7XG4gICAgdGhpcy5faXNBbmltYXRlZCA9ICEhdGhpcy5faXNBbmltYXRlZDtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR1N0cm9rZVN0eWxlRGF0YSk7XG5cbiAgZnVuY3Rpb24gU1ZHRmlsbFN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuYyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYywgMSwgMjU1LCB0aGlzKTtcbiAgICB0aGlzLnN0eWxlID0gc3R5bGVPYjtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR0ZpbGxTdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIFNWR05vU3R5bGVEYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgdGhpcy5nZXRWYWx1ZSA9IHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHTm9TdHlsZURhdGEpO1xuXG4gIGZ1bmN0aW9uIEdyYWRpZW50UHJvcGVydHkoZWxlbSwgZGF0YSwgY29udGFpbmVyKSB7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmMgPSBjcmVhdGVUeXBlZEFycmF5KCd1aW50OGMnLCBkYXRhLnAgKiA0KTtcbiAgICB2YXIgY0xlbmd0aCA9IGRhdGEuay5rWzBdLnMgPyBkYXRhLmsua1swXS5zLmxlbmd0aCAtIGRhdGEucCAqIDQgOiBkYXRhLmsuay5sZW5ndGggLSBkYXRhLnAgKiA0O1xuICAgIHRoaXMubyA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBjTGVuZ3RoKTtcbiAgICB0aGlzLl9jbWRmID0gZmFsc2U7XG4gICAgdGhpcy5fb21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX2NvbGxhcHNhYmxlID0gdGhpcy5jaGVja0NvbGxhcHNhYmxlKCk7XG4gICAgdGhpcy5faGFzT3BhY2l0eSA9IGNMZW5ndGg7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGNvbnRhaW5lcik7XG4gICAgdGhpcy5wcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5rLCAxLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmsgPSB0aGlzLnByb3AuaztcbiAgICB0aGlzLmdldFZhbHVlKHRydWUpO1xuICB9XG4gIEdyYWRpZW50UHJvcGVydHkucHJvdG90eXBlLmNvbXBhcmVQb2ludHMgPSBmdW5jdGlvbiAodmFsdWVzLCBwb2ludHMpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMuby5sZW5ndGggLyAyO1xuICAgIHZhciBkaWZmO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBkaWZmID0gTWF0aC5hYnModmFsdWVzW2kgKiA0XSAtIHZhbHVlc1twb2ludHMgKiA0ICsgaSAqIDJdKTtcbiAgICAgIGlmIChkaWZmID4gMC4wMSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpICs9IDE7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuICBHcmFkaWVudFByb3BlcnR5LnByb3RvdHlwZS5jaGVja0NvbGxhcHNhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLm8ubGVuZ3RoIC8gMiAhPT0gdGhpcy5jLmxlbmd0aCAvIDQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGF0YS5rLmtbMF0ucykge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5rLmsubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbXBhcmVQb2ludHModGhpcy5kYXRhLmsua1tpXS5zLCB0aGlzLmRhdGEucCkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIXRoaXMuY29tcGFyZVBvaW50cyh0aGlzLmRhdGEuay5rLCB0aGlzLmRhdGEucCkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG4gIEdyYWRpZW50UHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgdGhpcy5wcm9wLmdldFZhbHVlKCk7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgdGhpcy5fY21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX29tZGYgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5wcm9wLl9tZGYgfHwgZm9yY2VSZW5kZXIpIHtcbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHRoaXMuZGF0YS5wICogNDtcbiAgICAgIHZhciBtdWx0O1xuICAgICAgdmFyIHZhbDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBtdWx0ID0gaSAlIDQgPT09IDAgPyAxMDAgOiAyNTU7XG4gICAgICAgIHZhbCA9IE1hdGgucm91bmQodGhpcy5wcm9wLnZbaV0gKiBtdWx0KTtcbiAgICAgICAgaWYgKHRoaXMuY1tpXSAhPT0gdmFsKSB7XG4gICAgICAgICAgdGhpcy5jW2ldID0gdmFsO1xuICAgICAgICAgIHRoaXMuX2NtZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm8ubGVuZ3RoKSB7XG4gICAgICAgIGxlbiA9IHRoaXMucHJvcC52Lmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gdGhpcy5kYXRhLnAgKiA0OyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBtdWx0ID0gaSAlIDIgPT09IDAgPyAxMDAgOiAxO1xuICAgICAgICAgIHZhbCA9IGkgJSAyID09PSAwID8gTWF0aC5yb3VuZCh0aGlzLnByb3AudltpXSAqIDEwMCkgOiB0aGlzLnByb3AudltpXTtcbiAgICAgICAgICBpZiAodGhpcy5vW2kgLSB0aGlzLmRhdGEucCAqIDRdICE9PSB2YWwpIHtcbiAgICAgICAgICAgIHRoaXMub1tpIC0gdGhpcy5kYXRhLnAgKiA0XSA9IHZhbDtcbiAgICAgICAgICAgIHRoaXMuX29tZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9tZGYgPSAhZm9yY2VSZW5kZXI7XG4gICAgfVxuICB9O1xuICBleHRlbmRQcm90b3R5cGUoW0R5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIEdyYWRpZW50UHJvcGVydHkpO1xuXG4gIGZ1bmN0aW9uIFNWR0dyYWRpZW50RmlsbFN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLmluaXRHcmFkaWVudERhdGEoZWxlbSwgZGF0YSwgc3R5bGVPYik7XG4gIH1cbiAgU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhLnByb3RvdHlwZS5pbml0R3JhZGllbnREYXRhID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHN0eWxlT2IpIHtcbiAgICB0aGlzLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEucywgMSwgbnVsbCwgdGhpcyk7XG4gICAgdGhpcy5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5lLCAxLCBudWxsLCB0aGlzKTtcbiAgICB0aGlzLmggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmggfHwge1xuICAgICAgazogMFxuICAgIH0sIDAsIDAuMDEsIHRoaXMpO1xuICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSB8fCB7XG4gICAgICBrOiAwXG4gICAgfSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICB0aGlzLmcgPSBuZXcgR3JhZGllbnRQcm9wZXJ0eShlbGVtLCBkYXRhLmcsIHRoaXMpO1xuICAgIHRoaXMuc3R5bGUgPSBzdHlsZU9iO1xuICAgIHRoaXMuc3RvcHMgPSBbXTtcbiAgICB0aGlzLnNldEdyYWRpZW50RGF0YShzdHlsZU9iLnBFbGVtLCBkYXRhKTtcbiAgICB0aGlzLnNldEdyYWRpZW50T3BhY2l0eShkYXRhLCBzdHlsZU9iKTtcbiAgICB0aGlzLl9pc0FuaW1hdGVkID0gISF0aGlzLl9pc0FuaW1hdGVkO1xuICB9O1xuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50RGF0YSA9IGZ1bmN0aW9uIChwYXRoRWxlbWVudCwgZGF0YSkge1xuICAgIHZhciBncmFkaWVudElkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgdmFyIGdmaWxsID0gY3JlYXRlTlMoZGF0YS50ID09PSAxID8gJ2xpbmVhckdyYWRpZW50JyA6ICdyYWRpYWxHcmFkaWVudCcpO1xuICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgnaWQnLCBncmFkaWVudElkKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ3NwcmVhZE1ldGhvZCcsICdwYWQnKTtcbiAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2dyYWRpZW50VW5pdHMnLCAndXNlclNwYWNlT25Vc2UnKTtcbiAgICB2YXIgc3RvcHMgPSBbXTtcbiAgICB2YXIgc3RvcDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICBqTGVuID0gZGF0YS5nLnAgKiA0O1xuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDQpIHtcbiAgICAgIHN0b3AgPSBjcmVhdGVOUygnc3RvcCcpO1xuICAgICAgZ2ZpbGwuYXBwZW5kQ2hpbGQoc3RvcCk7XG4gICAgICBzdG9wcy5wdXNoKHN0b3ApO1xuICAgIH1cbiAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsJyA6ICdzdHJva2UnLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGdyYWRpZW50SWQgKyAnKScpO1xuICAgIHRoaXMuZ2YgPSBnZmlsbDtcbiAgICB0aGlzLmNzdCA9IHN0b3BzO1xuICB9O1xuICBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEucHJvdG90eXBlLnNldEdyYWRpZW50T3BhY2l0eSA9IGZ1bmN0aW9uIChkYXRhLCBzdHlsZU9iKSB7XG4gICAgaWYgKHRoaXMuZy5faGFzT3BhY2l0eSAmJiAhdGhpcy5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgdmFyIHN0b3A7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuO1xuICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xuICAgICAgdmFyIG1hc2tFbGVtZW50ID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgIG1hc2suYXBwZW5kQ2hpbGQobWFza0VsZW1lbnQpO1xuICAgICAgdmFyIG9wYWNpdHlJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgbWFzay5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICAgIHZhciBvcEZpbGwgPSBjcmVhdGVOUyhkYXRhLnQgPT09IDEgPyAnbGluZWFyR3JhZGllbnQnIDogJ3JhZGlhbEdyYWRpZW50Jyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdpZCcsIG9wYWNpdHlJZCk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdzcHJlYWRNZXRob2QnLCAncGFkJyk7XG4gICAgICBvcEZpbGwuc2V0QXR0cmlidXRlKCdncmFkaWVudFVuaXRzJywgJ3VzZXJTcGFjZU9uVXNlJyk7XG4gICAgICBqTGVuID0gZGF0YS5nLmsua1swXS5zID8gZGF0YS5nLmsua1swXS5zLmxlbmd0aCA6IGRhdGEuZy5rLmsubGVuZ3RoO1xuICAgICAgdmFyIHN0b3BzID0gdGhpcy5zdG9wcztcbiAgICAgIGZvciAoaiA9IGRhdGEuZy5wICogNDsgaiA8IGpMZW47IGogKz0gMikge1xuICAgICAgICBzdG9wID0gY3JlYXRlTlMoJ3N0b3AnKTtcbiAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3AtY29sb3InLCAncmdiKDI1NSwyNTUsMjU1KScpO1xuICAgICAgICBvcEZpbGwuYXBwZW5kQ2hpbGQoc3RvcCk7XG4gICAgICAgIHN0b3BzLnB1c2goc3RvcCk7XG4gICAgICB9XG4gICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoZGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsJyA6ICdzdHJva2UnLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIG9wYWNpdHlJZCArICcpJyk7XG4gICAgICBpZiAoZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bZGF0YS5sYyB8fCAyXSk7XG4gICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtW2RhdGEubGogfHwgMl0pO1xuICAgICAgICBpZiAoZGF0YS5saiA9PT0gMSkge1xuICAgICAgICAgIG1hc2tFbGVtZW50LnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCBkYXRhLm1sKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5vZiA9IG9wRmlsbDtcbiAgICAgIHRoaXMubXMgPSBtYXNrO1xuICAgICAgdGhpcy5vc3QgPSBzdG9wcztcbiAgICAgIHRoaXMubWFza0lkID0gbWFza0lkO1xuICAgICAgc3R5bGVPYi5tc0VsZW0gPSBtYXNrRWxlbWVudDtcbiAgICB9XG4gIH07XG4gIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgU1ZHR3JhZGllbnRGaWxsU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YShlbGVtLCBkYXRhLCBzdHlsZU9iKSB7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICAgIHRoaXMuZ2V0VmFsdWUgPSB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcztcbiAgICB0aGlzLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xuICAgIHRoaXMuZCA9IG5ldyBEYXNoUHJvcGVydHkoZWxlbSwgZGF0YS5kIHx8IHt9LCAnc3ZnJywgdGhpcyk7XG4gICAgdGhpcy5pbml0R3JhZGllbnREYXRhKGVsZW0sIGRhdGEsIHN0eWxlT2IpO1xuICAgIHRoaXMuX2lzQW5pbWF0ZWQgPSAhIXRoaXMuX2lzQW5pbWF0ZWQ7XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEsIER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lcl0sIFNWR0dyYWRpZW50U3Ryb2tlU3R5bGVEYXRhKTtcblxuICBmdW5jdGlvbiBTaGFwZUdyb3VwRGF0YSgpIHtcbiAgICB0aGlzLml0ID0gW107XG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICB0aGlzLmdyID0gY3JlYXRlTlMoJ2cnKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIFNWR1RyYW5zZm9ybURhdGEobVByb3BzLCBvcCwgY29udGFpbmVyKSB7XG4gICAgdGhpcy50cmFuc2Zvcm0gPSB7XG4gICAgICBtUHJvcHM6IG1Qcm9wcyxcbiAgICAgIG9wOiBvcCxcbiAgICAgIGNvbnRhaW5lcjogY29udGFpbmVyXG4gICAgfTtcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgdGhpcy5faXNBbmltYXRlZCA9IHRoaXMudHJhbnNmb3JtLm1Qcm9wcy5keW5hbWljUHJvcGVydGllcy5sZW5ndGggfHwgdGhpcy50cmFuc2Zvcm0ub3AuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aDtcbiAgfVxuXG4gIHZhciBidWlsZFNoYXBlU3RyaW5nID0gZnVuY3Rpb24gYnVpbGRTaGFwZVN0cmluZyhwYXRoTm9kZXMsIGxlbmd0aCwgY2xvc2VkLCBtYXQpIHtcbiAgICBpZiAobGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHZhciBfbyA9IHBhdGhOb2Rlcy5vO1xuICAgIHZhciBfaSA9IHBhdGhOb2Rlcy5pO1xuICAgIHZhciBfdiA9IHBhdGhOb2Rlcy52O1xuICAgIHZhciBpO1xuICAgIHZhciBzaGFwZVN0cmluZyA9ICcgTScgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbMF1bMF0sIF92WzBdWzFdKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIHNoYXBlU3RyaW5nICs9ICcgQycgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX29baSAtIDFdWzBdLCBfb1tpIC0gMV1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pW2ldWzBdLCBfaVtpXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbaV1bMF0sIF92W2ldWzFdKTtcbiAgICB9XG4gICAgaWYgKGNsb3NlZCAmJiBsZW5ndGgpIHtcbiAgICAgIHNoYXBlU3RyaW5nICs9ICcgQycgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX29baSAtIDFdWzBdLCBfb1tpIC0gMV1bMV0pICsgJyAnICsgbWF0LmFwcGx5VG9Qb2ludFN0cmluZ2lmaWVkKF9pWzBdWzBdLCBfaVswXVsxXSkgKyAnICcgKyBtYXQuYXBwbHlUb1BvaW50U3RyaW5naWZpZWQoX3ZbMF1bMF0sIF92WzBdWzFdKTtcbiAgICAgIHNoYXBlU3RyaW5nICs9ICd6JztcbiAgICB9XG4gICAgcmV0dXJuIHNoYXBlU3RyaW5nO1xuICB9O1xuXG4gIHZhciBTVkdFbGVtZW50c1JlbmRlcmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBfaWRlbnRpdHlNYXRyaXggPSBuZXcgTWF0cml4KCk7XG4gICAgdmFyIF9tYXRyaXhIZWxwZXIgPSBuZXcgTWF0cml4KCk7XG4gICAgdmFyIG9iID0ge1xuICAgICAgY3JlYXRlUmVuZGVyRnVuY3Rpb246IGNyZWF0ZVJlbmRlckZ1bmN0aW9uXG4gICAgfTtcbiAgICBmdW5jdGlvbiBjcmVhdGVSZW5kZXJGdW5jdGlvbihkYXRhKSB7XG4gICAgICBzd2l0Y2ggKGRhdGEudHkpIHtcbiAgICAgICAgY2FzZSAnZmwnOlxuICAgICAgICAgIHJldHVybiByZW5kZXJGaWxsO1xuICAgICAgICBjYXNlICdnZic6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50O1xuICAgICAgICBjYXNlICdncyc6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckdyYWRpZW50U3Ryb2tlO1xuICAgICAgICBjYXNlICdzdCc6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlclN0cm9rZTtcbiAgICAgICAgY2FzZSAnc2gnOlxuICAgICAgICBjYXNlICdlbCc6XG4gICAgICAgIGNhc2UgJ3JjJzpcbiAgICAgICAgY2FzZSAnc3InOlxuICAgICAgICAgIHJldHVybiByZW5kZXJQYXRoO1xuICAgICAgICBjYXNlICd0cic6XG4gICAgICAgICAgcmV0dXJuIHJlbmRlckNvbnRlbnRUcmFuc2Zvcm07XG4gICAgICAgIGNhc2UgJ25vJzpcbiAgICAgICAgICByZXR1cm4gcmVuZGVyTm9vcDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gcmVuZGVyQ29udGVudFRyYW5zZm9ybShzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIGlmIChpc0ZpcnN0RnJhbWUgfHwgaXRlbURhdGEudHJhbnNmb3JtLm9wLl9tZGYpIHtcbiAgICAgICAgaXRlbURhdGEudHJhbnNmb3JtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCBpdGVtRGF0YS50cmFuc2Zvcm0ub3Audik7XG4gICAgICB9XG4gICAgICBpZiAoaXNGaXJzdEZyYW1lIHx8IGl0ZW1EYXRhLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xuICAgICAgICBpdGVtRGF0YS50cmFuc2Zvcm0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgaXRlbURhdGEudHJhbnNmb3JtLm1Qcm9wcy52LnRvMmRDU1MoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlck5vb3AoKSB7fVxuICAgIGZ1bmN0aW9uIHJlbmRlclBhdGgoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgajtcbiAgICAgIHZhciBqTGVuO1xuICAgICAgdmFyIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgIHZhciByZWRyYXc7XG4gICAgICB2YXIgcGF0aE5vZGVzO1xuICAgICAgdmFyIGw7XG4gICAgICB2YXIgbExlbiA9IGl0ZW1EYXRhLnN0eWxlcy5sZW5ndGg7XG4gICAgICB2YXIgbHZsID0gaXRlbURhdGEubHZsO1xuICAgICAgdmFyIHBhdGhzO1xuICAgICAgdmFyIG1hdDtcbiAgICAgIHZhciBpdGVyYXRpb25zO1xuICAgICAgdmFyIGs7XG4gICAgICBmb3IgKGwgPSAwOyBsIDwgbExlbjsgbCArPSAxKSB7XG4gICAgICAgIHJlZHJhdyA9IGl0ZW1EYXRhLnNoLl9tZGYgfHwgaXNGaXJzdEZyYW1lO1xuICAgICAgICBpZiAoaXRlbURhdGEuc3R5bGVzW2xdLmx2bCA8IGx2bCkge1xuICAgICAgICAgIG1hdCA9IF9tYXRyaXhIZWxwZXIucmVzZXQoKTtcbiAgICAgICAgICBpdGVyYXRpb25zID0gbHZsIC0gaXRlbURhdGEuc3R5bGVzW2xdLmx2bDtcbiAgICAgICAgICBrID0gaXRlbURhdGEudHJhbnNmb3JtZXJzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgd2hpbGUgKCFyZWRyYXcgJiYgaXRlcmF0aW9ucyA+IDApIHtcbiAgICAgICAgICAgIHJlZHJhdyA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVyc1trXS5tUHJvcHMuX21kZiB8fCByZWRyYXc7XG4gICAgICAgICAgICBpdGVyYXRpb25zIC09IDE7XG4gICAgICAgICAgICBrIC09IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZWRyYXcpIHtcbiAgICAgICAgICAgIGl0ZXJhdGlvbnMgPSBsdmwgLSBpdGVtRGF0YS5zdHlsZXNbbF0ubHZsO1xuICAgICAgICAgICAgayA9IGl0ZW1EYXRhLnRyYW5zZm9ybWVycy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgd2hpbGUgKGl0ZXJhdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgIG1hdC5tdWx0aXBseShpdGVtRGF0YS50cmFuc2Zvcm1lcnNba10ubVByb3BzLnYpO1xuICAgICAgICAgICAgICBpdGVyYXRpb25zIC09IDE7XG4gICAgICAgICAgICAgIGsgLT0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWF0ID0gX2lkZW50aXR5TWF0cml4O1xuICAgICAgICB9XG4gICAgICAgIHBhdGhzID0gaXRlbURhdGEuc2gucGF0aHM7XG4gICAgICAgIGpMZW4gPSBwYXRocy5fbGVuZ3RoO1xuICAgICAgICBpZiAocmVkcmF3KSB7XG4gICAgICAgICAgcGF0aFN0cmluZ1RyYW5zZm9ybWVkID0gJyc7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xuICAgICAgICAgICAgaWYgKHBhdGhOb2RlcyAmJiBwYXRoTm9kZXMuX2xlbmd0aCkge1xuICAgICAgICAgICAgICBwYXRoU3RyaW5nVHJhbnNmb3JtZWQgKz0gYnVpbGRTaGFwZVN0cmluZyhwYXRoTm9kZXMsIHBhdGhOb2Rlcy5fbGVuZ3RoLCBwYXRoTm9kZXMuYywgbWF0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXRlbURhdGEuY2FjaGVzW2xdID0gcGF0aFN0cmluZ1RyYW5zZm9ybWVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHBhdGhTdHJpbmdUcmFuc2Zvcm1lZCA9IGl0ZW1EYXRhLmNhY2hlc1tsXTtcbiAgICAgICAgfVxuICAgICAgICBpdGVtRGF0YS5zdHlsZXNbbF0uZCArPSBzdHlsZURhdGEuaGQgPT09IHRydWUgPyAnJyA6IHBhdGhTdHJpbmdUcmFuc2Zvcm1lZDtcbiAgICAgICAgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGYgPSByZWRyYXcgfHwgaXRlbURhdGEuc3R5bGVzW2xdLl9tZGY7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckZpbGwoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdmaWxsJywgJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtRGF0YS5vLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlckdyYWRpZW50U3Ryb2tlKHN0eWxlRGF0YSwgaXRlbURhdGEsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgcmVuZGVyR3JhZGllbnQoc3R5bGVEYXRhLCBpdGVtRGF0YSwgaXNGaXJzdEZyYW1lKTtcbiAgICAgIHJlbmRlclN0cm9rZShzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW5kZXJHcmFkaWVudChzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBnZmlsbCA9IGl0ZW1EYXRhLmdmO1xuICAgICAgdmFyIGhhc09wYWNpdHkgPSBpdGVtRGF0YS5nLl9oYXNPcGFjaXR5O1xuICAgICAgdmFyIHB0MSA9IGl0ZW1EYXRhLnMudjtcbiAgICAgIHZhciBwdDIgPSBpdGVtRGF0YS5lLnY7XG4gICAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB2YXIgYXR0ciA9IHN0eWxlRGF0YS50eSA9PT0gJ2dmJyA/ICdmaWxsLW9wYWNpdHknIDogJ3N0cm9rZS1vcGFjaXR5JztcbiAgICAgICAgaXRlbURhdGEuc3R5bGUucEVsZW0uc2V0QXR0cmlidXRlKGF0dHIsIGl0ZW1EYXRhLm8udik7XG4gICAgICB9XG4gICAgICBpZiAoaXRlbURhdGEucy5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICB2YXIgYXR0cjEgPSBzdHlsZURhdGEudCA9PT0gMSA/ICd4MScgOiAnY3gnO1xuICAgICAgICB2YXIgYXR0cjIgPSBhdHRyMSA9PT0gJ3gxJyA/ICd5MScgOiAnY3knO1xuICAgICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoYXR0cjEsIHB0MVswXSk7XG4gICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZShhdHRyMiwgcHQxWzFdKTtcbiAgICAgICAgaWYgKGhhc09wYWNpdHkgJiYgIWl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKGF0dHIxLCBwdDFbMF0pO1xuICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZShhdHRyMiwgcHQxWzFdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIHN0b3BzO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHN0b3A7XG4gICAgICBpZiAoaXRlbURhdGEuZy5fY21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3RvcHMgPSBpdGVtRGF0YS5jc3Q7XG4gICAgICAgIHZhciBjVmFsdWVzID0gaXRlbURhdGEuZy5jO1xuICAgICAgICBsZW4gPSBzdG9wcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHN0b3AgPSBzdG9wc1tpXTtcbiAgICAgICAgICBzdG9wLnNldEF0dHJpYnV0ZSgnb2Zmc2V0JywgY1ZhbHVlc1tpICogNF0gKyAnJScpO1xuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlKCdzdG9wLWNvbG9yJywgJ3JnYignICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJyknKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGhhc09wYWNpdHkgJiYgKGl0ZW1EYXRhLmcuX29tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICB2YXIgb1ZhbHVlcyA9IGl0ZW1EYXRhLmcubztcbiAgICAgICAgaWYgKGl0ZW1EYXRhLmcuX2NvbGxhcHNhYmxlKSB7XG4gICAgICAgICAgc3RvcHMgPSBpdGVtRGF0YS5jc3Q7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc3RvcHMgPSBpdGVtRGF0YS5vc3Q7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gc3RvcHMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBzdG9wID0gc3RvcHNbaV07XG4gICAgICAgICAgaWYgKCFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ29mZnNldCcsIG9WYWx1ZXNbaSAqIDJdICsgJyUnKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGUoJ3N0b3Atb3BhY2l0eScsIG9WYWx1ZXNbaSAqIDIgKyAxXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdHlsZURhdGEudCA9PT0gMSkge1xuICAgICAgICBpZiAoaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneDInLCBwdDJbMF0pO1xuICAgICAgICAgIGdmaWxsLnNldEF0dHJpYnV0ZSgneTInLCBwdDJbMV0pO1xuICAgICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCd4MicsIHB0MlswXSk7XG4gICAgICAgICAgICBpdGVtRGF0YS5vZi5zZXRBdHRyaWJ1dGUoJ3kyJywgcHQyWzFdKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYWQ7XG4gICAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXRlbURhdGEuZS5fbWRmIHx8IGlzRmlyc3RGcmFtZSkge1xuICAgICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdyJywgcmFkKTtcbiAgICAgICAgICBpZiAoaGFzT3BhY2l0eSAmJiAhaXRlbURhdGEuZy5fY29sbGFwc2FibGUpIHtcbiAgICAgICAgICAgIGl0ZW1EYXRhLm9mLnNldEF0dHJpYnV0ZSgncicsIHJhZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtRGF0YS5zLl9tZGYgfHwgaXRlbURhdGEuZS5fbWRmIHx8IGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgICAgaWYgKCFyYWQpIHtcbiAgICAgICAgICAgIHJhZCA9IE1hdGguc3FydChNYXRoLnBvdyhwdDFbMF0gLSBwdDJbMF0sIDIpICsgTWF0aC5wb3cocHQxWzFdIC0gcHQyWzFdLCAyKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBhbmcgPSBNYXRoLmF0YW4yKHB0MlsxXSAtIHB0MVsxXSwgcHQyWzBdIC0gcHQxWzBdKTtcbiAgICAgICAgICB2YXIgcGVyY2VudCA9IGl0ZW1EYXRhLmgudjtcbiAgICAgICAgICBpZiAocGVyY2VudCA+PSAxKSB7XG4gICAgICAgICAgICBwZXJjZW50ID0gMC45OTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHBlcmNlbnQgPD0gLTEpIHtcbiAgICAgICAgICAgIHBlcmNlbnQgPSAtMC45OTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFyIGRpc3QgPSByYWQgKiBwZXJjZW50O1xuICAgICAgICAgIHZhciB4ID0gTWF0aC5jb3MoYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMF07XG4gICAgICAgICAgdmFyIHkgPSBNYXRoLnNpbihhbmcgKyBpdGVtRGF0YS5hLnYpICogZGlzdCArIHB0MVsxXTtcbiAgICAgICAgICBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z4JywgeCk7XG4gICAgICAgICAgZ2ZpbGwuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xuICAgICAgICAgIGlmIChoYXNPcGFjaXR5ICYmICFpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeCcsIHgpO1xuICAgICAgICAgICAgaXRlbURhdGEub2Yuc2V0QXR0cmlidXRlKCdmeScsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBnZmlsbC5zZXRBdHRyaWJ1dGUoJ2Z5JywnMjAwJyk7XG4gICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlbmRlclN0cm9rZShzdHlsZURhdGEsIGl0ZW1EYXRhLCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcbiAgICAgIHZhciBkID0gaXRlbURhdGEuZDtcbiAgICAgIGlmIChkICYmIChkLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSAmJiBkLmRhc2hTdHIpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWRhc2hhcnJheScsIGQuZGFzaFN0cik7XG4gICAgICAgIHN0eWxlRWxlbS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgZC5kYXNob2Zmc2V0WzBdKTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtRGF0YS5jICYmIChpdGVtRGF0YS5jLl9tZGYgfHwgaXNGaXJzdEZyYW1lKSkge1xuICAgICAgICBzdHlsZUVsZW0ucEVsZW0uc2V0QXR0cmlidXRlKCdzdHJva2UnLCAncmdiKCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlswXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsxXSkgKyAnLCcgKyBibUZsb29yKGl0ZW1EYXRhLmMudlsyXSkgKyAnKScpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW9wYWNpdHknLCBpdGVtRGF0YS5vLnYpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1EYXRhLncuX21kZiB8fCBpc0ZpcnN0RnJhbWUpIHtcbiAgICAgICAgc3R5bGVFbGVtLnBFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgaXRlbURhdGEudy52KTtcbiAgICAgICAgaWYgKHN0eWxlRWxlbS5tc0VsZW0pIHtcbiAgICAgICAgICBzdHlsZUVsZW0ubXNFbGVtLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgaXRlbURhdGEudy52KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICBmdW5jdGlvbiBTVkdTaGFwZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIC8vIExpc3Qgb2YgZHJhd2FibGUgZWxlbWVudHNcbiAgICB0aGlzLnNoYXBlcyA9IFtdO1xuICAgIC8vIEZ1bGwgc2hhcGUgZGF0YVxuICAgIHRoaXMuc2hhcGVzRGF0YSA9IGRhdGEuc2hhcGVzO1xuICAgIC8vIExpc3Qgb2Ygc3R5bGVzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuICAgIHRoaXMuc3R5bGVzTGlzdCA9IFtdO1xuICAgIC8vIExpc3Qgb2YgbW9kaWZpZXJzIHRoYXQgd2lsbCBiZSBhcHBsaWVkIHRvIHNoYXBlc1xuICAgIHRoaXMuc2hhcGVNb2RpZmllcnMgPSBbXTtcbiAgICAvLyBMaXN0IG9mIGl0ZW1zIGluIHNoYXBlIHRyZWVcbiAgICB0aGlzLml0ZW1zRGF0YSA9IFtdO1xuICAgIC8vIExpc3Qgb2YgaXRlbXMgaW4gcHJldmlvdXMgc2hhcGUgdHJlZVxuICAgIHRoaXMucHJvY2Vzc2VkRWxlbWVudHMgPSBbXTtcbiAgICAvLyBMaXN0IG9mIGFuaW1hdGVkIGNvbXBvbmVudHNcbiAgICB0aGlzLmFuaW1hdGVkQ29udGVudHMgPSBbXTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIC8vIE1vdmluZyBhbnkgcHJvcGVydHkgdGhhdCBkb2Vzbid0IGdldCB0b28gbXVjaCBhY2Nlc3MgYWZ0ZXIgaW5pdGlhbGl6YXRpb24gYmVjYXVzZSBvZiB2OCB3YXkgb2YgaGFuZGxpbmcgbW9yZSB0aGFuIDEwIHByb3BlcnRpZXMuXG4gICAgLy8gTGlzdCBvZiBlbGVtZW50cyB0aGF0IGhhdmUgYmVlbiBjcmVhdGVkXG4gICAgdGhpcy5wcmV2Vmlld0RhdGEgPSBbXTtcbiAgICAvLyBNb3ZpbmcgYW55IHByb3BlcnR5IHRoYXQgZG9lc24ndCBnZXQgdG9vIG11Y2ggYWNjZXNzIGFmdGVyIGluaXRpYWxpemF0aW9uIGJlY2F1c2Ugb2Ygdjggd2F5IG9mIGhhbmRsaW5nIG1vcmUgdGhhbiAxMCBwcm9wZXJ0aWVzLlxuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIFNWR0Jhc2VFbGVtZW50LCBJU2hhcGVFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgU1ZHU2hhcGVFbGVtZW50KTtcbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5pbml0U2Vjb25kYXJ5RWxlbWVudCA9IGZ1bmN0aW9uICgpIHt9O1xuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmlkZW50aXR5TWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHt9O1xuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMubGF5ZXJFbGVtZW50LCAwLCBbXSwgdHJ1ZSk7XG4gICAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcbiAgfTtcblxuICAvKlxuICBUaGlzIG1ldGhvZCBzZWFyY2hlcyBmb3IgbXVsdGlwbGUgc2hhcGVzIHRoYXQgYWZmZWN0IGEgc2luZ2xlIGVsZW1lbnQgYW5kIG9uZSBvZiB0aGVtIGlzIGFuaW1hdGVkXG4gICovXG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuZmlsdGVyVW5pcXVlU2hhcGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnNoYXBlcy5sZW5ndGg7XG4gICAgdmFyIHNoYXBlO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIHRlbXBTaGFwZXMgPSBbXTtcbiAgICB2YXIgYXJlQW5pbWF0ZWQgPSBmYWxzZTtcbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBzdHlsZSA9IHRoaXMuc3R5bGVzTGlzdFtqXTtcbiAgICAgIGFyZUFuaW1hdGVkID0gZmFsc2U7XG4gICAgICB0ZW1wU2hhcGVzLmxlbmd0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgc2hhcGUgPSB0aGlzLnNoYXBlc1tpXTtcbiAgICAgICAgaWYgKHNoYXBlLnN0eWxlcy5pbmRleE9mKHN0eWxlKSAhPT0gLTEpIHtcbiAgICAgICAgICB0ZW1wU2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgICAgIGFyZUFuaW1hdGVkID0gc2hhcGUuX2lzQW5pbWF0ZWQgfHwgYXJlQW5pbWF0ZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0ZW1wU2hhcGVzLmxlbmd0aCA+IDEgJiYgYXJlQW5pbWF0ZWQpIHtcbiAgICAgICAgdGhpcy5zZXRTaGFwZXNBc0FuaW1hdGVkKHRlbXBTaGFwZXMpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZXRTaGFwZXNBc0FuaW1hdGVkID0gZnVuY3Rpb24gKHNoYXBlcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzaGFwZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc2hhcGVzW2ldLnNldEFzQW5pbWF0ZWQoKTtcbiAgICB9XG4gIH07XG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlU3R5bGVFbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEsIGxldmVsKSB7XG4gICAgLy8gVE9ETzogcHJldmVudCBkcmF3aW5nIG9mIGhpZGRlbiBzdHlsZXNcbiAgICB2YXIgZWxlbWVudERhdGE7XG4gICAgdmFyIHN0eWxlT2IgPSBuZXcgU1ZHU3R5bGVEYXRhKGRhdGEsIGxldmVsKTtcbiAgICB2YXIgcGF0aEVsZW1lbnQgPSBzdHlsZU9iLnBFbGVtO1xuICAgIGlmIChkYXRhLnR5ID09PSAnc3QnKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdTdHJva2VTdHlsZURhdGEodGhpcywgZGF0YSwgc3R5bGVPYik7XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnZmwnKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdGaWxsU3R5bGVEYXRhKHRoaXMsIGRhdGEsIHN0eWxlT2IpO1xuICAgIH0gZWxzZSBpZiAoZGF0YS50eSA9PT0gJ2dmJyB8fCBkYXRhLnR5ID09PSAnZ3MnKSB7XG4gICAgICB2YXIgR3JhZGllbnRDb25zdHJ1Y3RvciA9IGRhdGEudHkgPT09ICdnZicgPyBTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEgOiBTVkdHcmFkaWVudFN0cm9rZVN0eWxlRGF0YTtcbiAgICAgIGVsZW1lbnREYXRhID0gbmV3IEdyYWRpZW50Q29uc3RydWN0b3IodGhpcywgZGF0YSwgc3R5bGVPYik7XG4gICAgICB0aGlzLmdsb2JhbERhdGEuZGVmcy5hcHBlbmRDaGlsZChlbGVtZW50RGF0YS5nZik7XG4gICAgICBpZiAoZWxlbWVudERhdGEubWFza0lkKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKGVsZW1lbnREYXRhLm1zKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmRlZnMuYXBwZW5kQ2hpbGQoZWxlbWVudERhdGEub2YpO1xuICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGVsZW1lbnREYXRhLm1hc2tJZCArICcpJyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhLnR5ID09PSAnbm8nKSB7XG4gICAgICBlbGVtZW50RGF0YSA9IG5ldyBTVkdOb1N0eWxlRGF0YSh0aGlzLCBkYXRhLCBzdHlsZU9iKTtcbiAgICB9XG4gICAgaWYgKGRhdGEudHkgPT09ICdzdCcgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsIGxpbmVDYXBFbnVtW2RhdGEubGMgfHwgMl0pO1xuICAgICAgcGF0aEVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCBsaW5lSm9pbkVudW1bZGF0YS5saiB8fCAyXSk7XG4gICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZpbGwtb3BhY2l0eScsICcwJyk7XG4gICAgICBpZiAoZGF0YS5saiA9PT0gMSkge1xuICAgICAgICBwYXRoRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgZGF0YS5tbCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChkYXRhLnIgPT09IDIpIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbC1ydWxlJywgJ2V2ZW5vZGQnKTtcbiAgICB9XG4gICAgaWYgKGRhdGEubG4pIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCBkYXRhLmxuKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2wpIHtcbiAgICAgIHBhdGhFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBkYXRhLmNsKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYm0pIHtcbiAgICAgIHBhdGhFbGVtZW50LnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xuICAgIH1cbiAgICB0aGlzLnN0eWxlc0xpc3QucHVzaChzdHlsZU9iKTtcbiAgICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNoYXBlR3JvdXBEYXRhKCk7XG4gICAgaWYgKGRhdGEubG4pIHtcbiAgICAgIGVsZW1lbnREYXRhLmdyLnNldEF0dHJpYnV0ZSgnaWQnLCBkYXRhLmxuKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuY2wpIHtcbiAgICAgIGVsZW1lbnREYXRhLmdyLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBkYXRhLmNsKTtcbiAgICB9XG4gICAgaWYgKGRhdGEuYm0pIHtcbiAgICAgIGVsZW1lbnREYXRhLmdyLnN0eWxlWydtaXgtYmxlbmQtbW9kZSddID0gZ2V0QmxlbmRNb2RlKGRhdGEuYm0pO1xuICAgIH1cbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlVHJhbnNmb3JtRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBjb250YWluZXIpIHtcbiAgICB2YXIgdHJhbnNmb3JtUHJvcGVydHkgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkodGhpcywgZGF0YSwgdGhpcyk7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IFNWR1RyYW5zZm9ybURhdGEodHJhbnNmb3JtUHJvcGVydHksIHRyYW5zZm9ybVByb3BlcnR5Lm8sIGNvbnRhaW5lcik7XG4gICAgdGhpcy5hZGRUb0FuaW1hdGVkQ29udGVudHMoZGF0YSwgZWxlbWVudERhdGEpO1xuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTaGFwZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgb3duVHJhbnNmb3JtZXJzLCBsZXZlbCkge1xuICAgIHZhciB0eSA9IDQ7XG4gICAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcbiAgICAgIHR5ID0gNTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcbiAgICAgIHR5ID0gNjtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcbiAgICAgIHR5ID0gNztcbiAgICB9XG4gICAgdmFyIHNoYXBlUHJvcGVydHkgPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3AodGhpcywgZGF0YSwgdHksIHRoaXMpO1xuICAgIHZhciBlbGVtZW50RGF0YSA9IG5ldyBTVkdTaGFwZURhdGEob3duVHJhbnNmb3JtZXJzLCBsZXZlbCwgc2hhcGVQcm9wZXJ0eSk7XG4gICAgdGhpcy5zaGFwZXMucHVzaChlbGVtZW50RGF0YSk7XG4gICAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXJzKGVsZW1lbnREYXRhKTtcbiAgICB0aGlzLmFkZFRvQW5pbWF0ZWRDb250ZW50cyhkYXRhLCBlbGVtZW50RGF0YSk7XG4gICAgcmV0dXJuIGVsZW1lbnREYXRhO1xuICB9O1xuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFkZFRvQW5pbWF0ZWRDb250ZW50cyA9IGZ1bmN0aW9uIChkYXRhLCBlbGVtZW50KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLmFuaW1hdGVkQ29udGVudHMubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRlZENvbnRlbnRzW2ldLmVsZW1lbnQgPT09IGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICB0aGlzLmFuaW1hdGVkQ29udGVudHMucHVzaCh7XG4gICAgICBmbjogU1ZHRWxlbWVudHNSZW5kZXJlci5jcmVhdGVSZW5kZXJGdW5jdGlvbihkYXRhKSxcbiAgICAgIGVsZW1lbnQ6IGVsZW1lbnQsXG4gICAgICBkYXRhOiBkYXRhXG4gICAgfSk7XG4gIH07XG4gIFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudFN0eWxlcyA9IGZ1bmN0aW9uIChlbGVtZW50RGF0YSkge1xuICAgIHZhciBhcnIgPSBlbGVtZW50RGF0YS5zdHlsZXM7XG4gICAgdmFyIGo7XG4gICAgdmFyIGpMZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgIGlmIChhcnIuaW5kZXhPZih0aGlzLnN0eWxlc0xpc3Rbal0pID09PSAtMSAmJiAhdGhpcy5zdHlsZXNMaXN0W2pdLmNsb3NlZCkge1xuICAgICAgICBhcnIucHVzaCh0aGlzLnN0eWxlc0xpc3Rbal0pO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZWxvYWRTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcbiAgICB9XG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRoaXMubGF5ZXJFbGVtZW50LCAwLCBbXSwgdHJ1ZSk7XG4gICAgdGhpcy5maWx0ZXJVbmlxdWVTaGFwZXMoKTtcbiAgICBsZW4gPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgfTtcbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5zZWFyY2hTaGFwZXMgPSBmdW5jdGlvbiAoYXJyLCBpdGVtc0RhdGEsIHByZXZWaWV3RGF0YSwgY29udGFpbmVyLCBsZXZlbCwgdHJhbnNmb3JtZXJzLCByZW5kZXIpIHtcbiAgICB2YXIgb3duVHJhbnNmb3JtZXJzID0gW10uY29uY2F0KHRyYW5zZm9ybWVycyk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGFyci5sZW5ndGggLSAxO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBvd25TdHlsZXMgPSBbXTtcbiAgICB2YXIgb3duTW9kaWZpZXJzID0gW107XG4gICAgdmFyIGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgdmFyIG1vZGlmaWVyO1xuICAgIHZhciBwcm9jZXNzZWRQb3M7XG4gICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgcHJvY2Vzc2VkUG9zID0gdGhpcy5zZWFyY2hQcm9jZXNzZWRFbGVtZW50KGFycltpXSk7XG4gICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICBhcnJbaV0uX3JlbmRlciA9IHJlbmRlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZW1zRGF0YVtpXSA9IHByZXZWaWV3RGF0YVtwcm9jZXNzZWRQb3MgLSAxXTtcbiAgICAgIH1cbiAgICAgIGlmIChhcnJbaV0udHkgPT09ICdmbCcgfHwgYXJyW2ldLnR5ID09PSAnc3QnIHx8IGFycltpXS50eSA9PT0gJ2dmJyB8fCBhcnJbaV0udHkgPT09ICdncycgfHwgYXJyW2ldLnR5ID09PSAnbm8nKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTdHlsZUVsZW1lbnQoYXJyW2ldLCBsZXZlbCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldLnN0eWxlLmNsb3NlZCA9IGFycltpXS5oZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXJyW2ldLl9yZW5kZXIpIHtcbiAgICAgICAgICBpZiAoaXRlbXNEYXRhW2ldLnN0eWxlLnBFbGVtLnBhcmVudE5vZGUgIT09IGNvbnRhaW5lcikge1xuICAgICAgICAgICAgY29udGFpbmVyLmFwcGVuZENoaWxkKGl0ZW1zRGF0YVtpXS5zdHlsZS5wRWxlbSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG93blN0eWxlcy5wdXNoKGl0ZW1zRGF0YVtpXS5zdHlsZSk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlR3JvdXBFbGVtZW50KGFycltpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgakxlbiA9IGl0ZW1zRGF0YVtpXS5pdC5sZW5ndGg7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YVtqXSA9IGl0ZW1zRGF0YVtpXS5pdFtqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZWFyY2hTaGFwZXMoYXJyW2ldLml0LCBpdGVtc0RhdGFbaV0uaXQsIGl0ZW1zRGF0YVtpXS5wcmV2Vmlld0RhdGEsIGl0ZW1zRGF0YVtpXS5nciwgbGV2ZWwgKyAxLCBvd25UcmFuc2Zvcm1lcnMsIHJlbmRlcik7XG4gICAgICAgIGlmIChhcnJbaV0uX3JlbmRlcikge1xuICAgICAgICAgIGlmIChpdGVtc0RhdGFbaV0uZ3IucGFyZW50Tm9kZSAhPT0gY29udGFpbmVyKSB7XG4gICAgICAgICAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoaXRlbXNEYXRhW2ldLmdyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAndHInKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50KGFycltpXSwgY29udGFpbmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50VHJhbnNmb3JtID0gaXRlbXNEYXRhW2ldLnRyYW5zZm9ybTtcbiAgICAgICAgb3duVHJhbnNmb3JtZXJzLnB1c2goY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3NoJyB8fCBhcnJbaV0udHkgPT09ICdyYycgfHwgYXJyW2ldLnR5ID09PSAnZWwnIHx8IGFycltpXS50eSA9PT0gJ3NyJykge1xuICAgICAgICBpZiAoIXByb2Nlc3NlZFBvcykge1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IHRoaXMuY3JlYXRlU2hhcGVFbGVtZW50KGFycltpXSwgb3duVHJhbnNmb3JtZXJzLCBsZXZlbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRFbGVtZW50U3R5bGVzKGl0ZW1zRGF0YVtpXSk7XG4gICAgICB9IGVsc2UgaWYgKGFycltpXS50eSA9PT0gJ3RtJyB8fCBhcnJbaV0udHkgPT09ICdyZCcgfHwgYXJyW2ldLnR5ID09PSAnbXMnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG93bk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAncnAnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyLCBpLCBpdGVtc0RhdGEpO1xuICAgICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgcmVuZGVyID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XG4gICAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuICAgIGxlbiA9IG93blN0eWxlcy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBvd25TdHlsZXNbaV0uY2xvc2VkID0gdHJ1ZTtcbiAgICB9XG4gICAgbGVuID0gb3duTW9kaWZpZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG93bk1vZGlmaWVyc1tpXS5jbG9zZWQgPSB0cnVlO1xuICAgIH1cbiAgfTtcbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5zdHlsZXNMaXN0Lmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5yZXNldCgpO1xuICAgIH1cbiAgICB0aGlzLnJlbmRlclNoYXBlKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5zdHlsZXNMaXN0W2ldLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIGlmICh0aGlzLnN0eWxlc0xpc3RbaV0ubXNFbGVtKSB7XG4gICAgICAgICAgdGhpcy5zdHlsZXNMaXN0W2ldLm1zRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCk7XG4gICAgICAgICAgLy8gQWRkaW5nIE0wIDAgZml4ZXMgc2FtZSBtYXNrIGJ1ZyBvbiBhbGwgYnJvd3NlcnNcbiAgICAgICAgICB0aGlzLnN0eWxlc0xpc3RbaV0uZCA9ICdNMCAwJyArIHRoaXMuc3R5bGVzTGlzdFtpXS5kO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS5wRWxlbS5zZXRBdHRyaWJ1dGUoJ2QnLCB0aGlzLnN0eWxlc0xpc3RbaV0uZCB8fCAnTTAgMCcpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU1ZHU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTaGFwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5hbmltYXRlZENvbnRlbnRzLmxlbmd0aDtcbiAgICB2YXIgYW5pbWF0ZWRDb250ZW50O1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgYW5pbWF0ZWRDb250ZW50ID0gdGhpcy5hbmltYXRlZENvbnRlbnRzW2ldO1xuICAgICAgaWYgKCh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQuX2lzQW5pbWF0ZWQpICYmIGFuaW1hdGVkQ29udGVudC5kYXRhICE9PSB0cnVlKSB7XG4gICAgICAgIGFuaW1hdGVkQ29udGVudC5mbihhbmltYXRlZENvbnRlbnQuZGF0YSwgYW5pbWF0ZWRDb250ZW50LmVsZW1lbnQsIHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5kZXN0cm95QmFzZUVsZW1lbnQoKTtcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBudWxsO1xuICAgIHRoaXMuaXRlbXNEYXRhID0gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBMZXR0ZXJQcm9wcyhvLCBzdywgc2MsIGZjLCBtLCBwKSB7XG4gICAgdGhpcy5vID0gbztcbiAgICB0aGlzLnN3ID0gc3c7XG4gICAgdGhpcy5zYyA9IHNjO1xuICAgIHRoaXMuZmMgPSBmYztcbiAgICB0aGlzLm0gPSBtO1xuICAgIHRoaXMucCA9IHA7XG4gICAgdGhpcy5fbWRmID0ge1xuICAgICAgbzogdHJ1ZSxcbiAgICAgIHN3OiAhIXN3LFxuICAgICAgc2M6ICEhc2MsXG4gICAgICBmYzogISFmYyxcbiAgICAgIG06IHRydWUsXG4gICAgICBwOiB0cnVlXG4gICAgfTtcbiAgfVxuICBMZXR0ZXJQcm9wcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG8sIHN3LCBzYywgZmMsIG0sIHApIHtcbiAgICB0aGlzLl9tZGYubyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5zdyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5zYyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5mYyA9IGZhbHNlO1xuICAgIHRoaXMuX21kZi5tID0gZmFsc2U7XG4gICAgdGhpcy5fbWRmLnAgPSBmYWxzZTtcbiAgICB2YXIgdXBkYXRlZCA9IGZhbHNlO1xuICAgIGlmICh0aGlzLm8gIT09IG8pIHtcbiAgICAgIHRoaXMubyA9IG87XG4gICAgICB0aGlzLl9tZGYubyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuc3cgIT09IHN3KSB7XG4gICAgICB0aGlzLnN3ID0gc3c7XG4gICAgICB0aGlzLl9tZGYuc3cgPSB0cnVlO1xuICAgICAgdXBkYXRlZCA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLnNjICE9PSBzYykge1xuICAgICAgdGhpcy5zYyA9IHNjO1xuICAgICAgdGhpcy5fbWRmLnNjID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5mYyAhPT0gZmMpIHtcbiAgICAgIHRoaXMuZmMgPSBmYztcbiAgICAgIHRoaXMuX21kZi5mYyA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMubSAhPT0gbSkge1xuICAgICAgdGhpcy5tID0gbTtcbiAgICAgIHRoaXMuX21kZi5tID0gdHJ1ZTtcbiAgICAgIHVwZGF0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAocC5sZW5ndGggJiYgKHRoaXMucFswXSAhPT0gcFswXSB8fCB0aGlzLnBbMV0gIT09IHBbMV0gfHwgdGhpcy5wWzRdICE9PSBwWzRdIHx8IHRoaXMucFs1XSAhPT0gcFs1XSB8fCB0aGlzLnBbMTJdICE9PSBwWzEyXSB8fCB0aGlzLnBbMTNdICE9PSBwWzEzXSkpIHtcbiAgICAgIHRoaXMucCA9IHA7XG4gICAgICB0aGlzLl9tZGYucCA9IHRydWU7XG4gICAgICB1cGRhdGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHVwZGF0ZWQ7XG4gIH07XG5cbiAgZnVuY3Rpb24gVGV4dFByb3BlcnR5KGVsZW0sIGRhdGEpIHtcbiAgICB0aGlzLl9mcmFtZUlkID0gaW5pdGlhbERlZmF1bHRGcmFtZTtcbiAgICB0aGlzLnB2ID0gJyc7XG4gICAgdGhpcy52ID0gJyc7XG4gICAgdGhpcy5rZiA9IGZhbHNlO1xuICAgIHRoaXMuX2lzRmlyc3RGcmFtZSA9IHRydWU7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgaWYgKGRhdGEuZCAmJiBkYXRhLmQuc2lkKSB7XG4gICAgICBkYXRhLmQgPSBlbGVtLmdsb2JhbERhdGEuc2xvdE1hbmFnZXIuZ2V0UHJvcChkYXRhLmQpO1xuICAgIH1cbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5jb21wID0gdGhpcy5lbGVtLmNvbXA7XG4gICAgdGhpcy5rZXlzSW5kZXggPSAwO1xuICAgIHRoaXMuY2FuUmVzaXplID0gZmFsc2U7XG4gICAgdGhpcy5taW5pbXVtRm9udFNpemUgPSAxO1xuICAgIHRoaXMuZWZmZWN0c1NlcXVlbmNlID0gW107XG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IHtcbiAgICAgIGFzY2VudDogMCxcbiAgICAgIGJveFdpZHRoOiB0aGlzLmRlZmF1bHRCb3hXaWR0aCxcbiAgICAgIGY6ICcnLFxuICAgICAgZlN0eWxlOiAnJyxcbiAgICAgIGZXZWlnaHQ6ICcnLFxuICAgICAgZmM6ICcnLFxuICAgICAgajogJycsXG4gICAgICBqdXN0aWZ5T2Zmc2V0OiAnJyxcbiAgICAgIGw6IFtdLFxuICAgICAgbGg6IDAsXG4gICAgICBsaW5lV2lkdGhzOiBbXSxcbiAgICAgIGxzOiAnJyxcbiAgICAgIG9mOiAnJyxcbiAgICAgIHM6ICcnLFxuICAgICAgc2M6ICcnLFxuICAgICAgc3c6IDAsXG4gICAgICB0OiAwLFxuICAgICAgdHI6IDAsXG4gICAgICBzejogMCxcbiAgICAgIHBzOiBudWxsLFxuICAgICAgZmlsbENvbG9yQW5pbTogZmFsc2UsXG4gICAgICBzdHJva2VDb2xvckFuaW06IGZhbHNlLFxuICAgICAgc3Ryb2tlV2lkdGhBbmltOiBmYWxzZSxcbiAgICAgIHlPZmZzZXQ6IDAsXG4gICAgICBmaW5hbFNpemU6IDAsXG4gICAgICBmaW5hbFRleHQ6IFtdLFxuICAgICAgZmluYWxMaW5lSGVpZ2h0OiAwLFxuICAgICAgX19jb21wbGV0ZTogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMuY29weURhdGEodGhpcy5jdXJyZW50RGF0YSwgdGhpcy5kYXRhLmQua1swXS5zKTtcbiAgICBpZiAoIXRoaXMuc2VhcmNoUHJvcGVydHkoKSkge1xuICAgICAgdGhpcy5jb21wbGV0ZVRleHREYXRhKHRoaXMuY3VycmVudERhdGEpO1xuICAgIH1cbiAgfVxuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmRlZmF1bHRCb3hXaWR0aCA9IFswLCAwXTtcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5jb3B5RGF0YSA9IGZ1bmN0aW9uIChvYmosIGRhdGEpIHtcbiAgICBmb3IgKHZhciBzIGluIGRhdGEpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZGF0YSwgcykpIHtcbiAgICAgICAgb2JqW3NdID0gZGF0YVtzXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZXRDdXJyZW50RGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCFkYXRhLl9fY29tcGxldGUpIHtcbiAgICAgIHRoaXMuY29tcGxldGVUZXh0RGF0YShkYXRhKTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RGF0YSA9IGRhdGE7XG4gICAgdGhpcy5jdXJyZW50RGF0YS5ib3hXaWR0aCA9IHRoaXMuY3VycmVudERhdGEuYm94V2lkdGggfHwgdGhpcy5kZWZhdWx0Qm94V2lkdGg7XG4gICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgfTtcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5zZWFyY2hLZXlmcmFtZXMoKTtcbiAgfTtcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hLZXlmcmFtZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5rZiA9IHRoaXMuZGF0YS5kLmsubGVuZ3RoID4gMTtcbiAgICBpZiAodGhpcy5rZikge1xuICAgICAgdGhpcy5hZGRFZmZlY3QodGhpcy5nZXRLZXlmcmFtZVZhbHVlLmJpbmQodGhpcykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5rZjtcbiAgfTtcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5hZGRFZmZlY3QgPSBmdW5jdGlvbiAoZWZmZWN0RnVuY3Rpb24pIHtcbiAgICB0aGlzLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKGVmZmVjdEZ1bmN0aW9uKTtcbiAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICB9O1xuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKF9maW5hbFZhbHVlKSB7XG4gICAgaWYgKCh0aGlzLmVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkID09PSB0aGlzLmZyYW1lSWQgfHwgIXRoaXMuZWZmZWN0c1NlcXVlbmNlLmxlbmd0aCkgJiYgIV9maW5hbFZhbHVlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY3VycmVudERhdGEudCA9IHRoaXMuZGF0YS5kLmtbdGhpcy5rZXlzSW5kZXhdLnMudDtcbiAgICB2YXIgY3VycmVudFZhbHVlID0gdGhpcy5jdXJyZW50RGF0YTtcbiAgICB2YXIgY3VycmVudEluZGV4ID0gdGhpcy5rZXlzSW5kZXg7XG4gICAgaWYgKHRoaXMubG9jaykge1xuICAgICAgdGhpcy5zZXRDdXJyZW50RGF0YSh0aGlzLmN1cnJlbnREYXRhKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5sb2NrID0gdHJ1ZTtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lZmZlY3RzU2VxdWVuY2UubGVuZ3RoO1xuICAgIHZhciBmaW5hbFZhbHVlID0gX2ZpbmFsVmFsdWUgfHwgdGhpcy5kYXRhLmQua1t0aGlzLmtleXNJbmRleF0ucztcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIC8vIENoZWNraW5nIGlmIGluZGV4IGNoYW5nZWQgdG8gcHJldmVudCBjcmVhdGluZyBhIG5ldyBvYmplY3QgZXZlcnkgdGltZSB0aGUgZXhwcmVzc2lvbiB1cGRhdGVzLlxuICAgICAgaWYgKGN1cnJlbnRJbmRleCAhPT0gdGhpcy5rZXlzSW5kZXgpIHtcbiAgICAgICAgZmluYWxWYWx1ZSA9IHRoaXMuZWZmZWN0c1NlcXVlbmNlW2ldKGZpbmFsVmFsdWUsIGZpbmFsVmFsdWUudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaW5hbFZhbHVlID0gdGhpcy5lZmZlY3RzU2VxdWVuY2VbaV0odGhpcy5jdXJyZW50RGF0YSwgZmluYWxWYWx1ZS50KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRWYWx1ZSAhPT0gZmluYWxWYWx1ZSkge1xuICAgICAgdGhpcy5zZXRDdXJyZW50RGF0YShmaW5hbFZhbHVlKTtcbiAgICB9XG4gICAgdGhpcy52ID0gdGhpcy5jdXJyZW50RGF0YTtcbiAgICB0aGlzLnB2ID0gdGhpcy52O1xuICAgIHRoaXMubG9jayA9IGZhbHNlO1xuICAgIHRoaXMuZnJhbWVJZCA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQ7XG4gIH07XG4gIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuZ2V0S2V5ZnJhbWVWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGV4dEtleXMgPSB0aGlzLmRhdGEuZC5rO1xuICAgIHZhciBmcmFtZU51bSA9IHRoaXMuZWxlbS5jb21wLnJlbmRlcmVkRnJhbWU7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0S2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGkgPD0gbGVuIC0gMSkge1xuICAgICAgaWYgKGkgPT09IGxlbiAtIDEgfHwgdGV4dEtleXNbaSArIDFdLnQgPiBmcmFtZU51bSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgaWYgKHRoaXMua2V5c0luZGV4ICE9PSBpKSB7XG4gICAgICB0aGlzLmtleXNJbmRleCA9IGk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRhdGEuZC5rW3RoaXMua2V5c0luZGV4XS5zO1xuICB9O1xuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmJ1aWxkRmluYWxUZXh0ID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgICB2YXIgY2hhcmFjdGVyc0FycmF5ID0gW107XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0Lmxlbmd0aDtcbiAgICB2YXIgY2hhckNvZGU7XG4gICAgdmFyIHNlY29uZENoYXJDb2RlO1xuICAgIHZhciBzaG91bGRDb21iaW5lID0gZmFsc2U7XG4gICAgdmFyIHNob3VsZENvbWJpbmVOZXh0ID0gZmFsc2U7XG4gICAgdmFyIGN1cnJlbnRDaGFycyA9ICcnO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBzaG91bGRDb21iaW5lID0gc2hvdWxkQ29tYmluZU5leHQ7XG4gICAgICBzaG91bGRDb21iaW5lTmV4dCA9IGZhbHNlO1xuICAgICAgY2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSk7XG4gICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LmNoYXJBdChpKTtcbiAgICAgIGlmIChGb250TWFuYWdlci5pc0NvbWJpbmVkQ2hhcmFjdGVyKGNoYXJDb2RlKSkge1xuICAgICAgICBzaG91bGRDb21iaW5lID0gdHJ1ZTtcbiAgICAgICAgLy8gSXQncyBhIHBvdGVudGlhbCBzdXJyb2dhdGUgcGFpciAodGhpcyBpcyB0aGUgSGlnaCBzdXJyb2dhdGUpXG4gICAgICB9IGVsc2UgaWYgKGNoYXJDb2RlID49IDB4RDgwMCAmJiBjaGFyQ29kZSA8PSAweERCRkYpIHtcbiAgICAgICAgaWYgKEZvbnRNYW5hZ2VyLmlzUmVnaW9uYWxGbGFnKHRleHQsIGkpKSB7XG4gICAgICAgICAgY3VycmVudENoYXJzID0gdGV4dC5zdWJzdHIoaSwgMTQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNlY29uZENoYXJDb2RlID0gdGV4dC5jaGFyQ29kZUF0KGkgKyAxKTtcbiAgICAgICAgICAvLyBJdCdzIGEgc3Vycm9nYXRlIHBhaXIgKHRoaXMgaXMgdGhlIExvdyBzdXJyb2dhdGUpXG4gICAgICAgICAgaWYgKHNlY29uZENoYXJDb2RlID49IDB4REMwMCAmJiBzZWNvbmRDaGFyQ29kZSA8PSAweERGRkYpIHtcbiAgICAgICAgICAgIGlmIChGb250TWFuYWdlci5pc01vZGlmaWVyKGNoYXJDb2RlLCBzZWNvbmRDaGFyQ29kZSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudENoYXJzID0gdGV4dC5zdWJzdHIoaSwgMik7XG4gICAgICAgICAgICAgIHNob3VsZENvbWJpbmUgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChGb250TWFuYWdlci5pc0ZsYWdFbW9qaSh0ZXh0LnN1YnN0cihpLCA0KSkpIHtcbiAgICAgICAgICAgICAgY3VycmVudENoYXJzID0gdGV4dC5zdWJzdHIoaSwgNCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdXJyZW50Q2hhcnMgPSB0ZXh0LnN1YnN0cihpLCAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPiAweERCRkYpIHtcbiAgICAgICAgc2Vjb25kQ2hhckNvZGUgPSB0ZXh0LmNoYXJDb2RlQXQoaSArIDEpO1xuICAgICAgICBpZiAoRm9udE1hbmFnZXIuaXNWYXJpYXRpb25TZWxlY3RvcihjaGFyQ29kZSkpIHtcbiAgICAgICAgICBzaG91bGRDb21iaW5lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChGb250TWFuYWdlci5pc1plcm9XaWR0aEpvaW5lcihjaGFyQ29kZSkpIHtcbiAgICAgICAgc2hvdWxkQ29tYmluZSA9IHRydWU7XG4gICAgICAgIHNob3VsZENvbWJpbmVOZXh0ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzaG91bGRDb21iaW5lKSB7XG4gICAgICAgIGNoYXJhY3RlcnNBcnJheVtjaGFyYWN0ZXJzQXJyYXkubGVuZ3RoIC0gMV0gKz0gY3VycmVudENoYXJzO1xuICAgICAgICBzaG91bGRDb21iaW5lID0gZmFsc2U7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjaGFyYWN0ZXJzQXJyYXkucHVzaChjdXJyZW50Q2hhcnMpO1xuICAgICAgfVxuICAgICAgaSArPSBjdXJyZW50Q2hhcnMubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gY2hhcmFjdGVyc0FycmF5O1xuICB9O1xuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmNvbXBsZXRlVGV4dERhdGEgPSBmdW5jdGlvbiAoZG9jdW1lbnREYXRhKSB7XG4gICAgZG9jdW1lbnREYXRhLl9fY29tcGxldGUgPSB0cnVlO1xuICAgIHZhciBmb250TWFuYWdlciA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyO1xuICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgIHZhciBsZXR0ZXJzID0gW107XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbmV3TGluZUZsYWc7XG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgdmFsO1xuICAgIHZhciBhbmNob3JHcm91cGluZyA9IGRhdGEubS5nO1xuICAgIHZhciBjdXJyZW50U2l6ZSA9IDA7XG4gICAgdmFyIGN1cnJlbnRQb3MgPSAwO1xuICAgIHZhciBjdXJyZW50TGluZSA9IDA7XG4gICAgdmFyIGxpbmVXaWR0aHMgPSBbXTtcbiAgICB2YXIgbGluZVdpZHRoID0gMDtcbiAgICB2YXIgbWF4TGluZVdpZHRoID0gMDtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgZm9udERhdGEgPSBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcbiAgICB2YXIgY2hhckRhdGE7XG4gICAgdmFyIGNMZW5ndGggPSAwO1xuICAgIHZhciBmb250UHJvcHMgPSBnZXRGb250UHJvcGVydGllcyhmb250RGF0YSk7XG4gICAgZG9jdW1lbnREYXRhLmZXZWlnaHQgPSBmb250UHJvcHMud2VpZ2h0O1xuICAgIGRvY3VtZW50RGF0YS5mU3R5bGUgPSBmb250UHJvcHMuc3R5bGU7XG4gICAgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSA9IGRvY3VtZW50RGF0YS5zO1xuICAgIGRvY3VtZW50RGF0YS5maW5hbFRleHQgPSB0aGlzLmJ1aWxkRmluYWxUZXh0KGRvY3VtZW50RGF0YS50KTtcbiAgICBsZW4gPSBkb2N1bWVudERhdGEuZmluYWxUZXh0Lmxlbmd0aDtcbiAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmxoO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAvIDEwMDAgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgIHZhciBjaGFyQ29kZTtcbiAgICBpZiAoZG9jdW1lbnREYXRhLnN6KSB7XG4gICAgICB2YXIgZmxhZyA9IHRydWU7XG4gICAgICB2YXIgYm94V2lkdGggPSBkb2N1bWVudERhdGEuc3pbMF07XG4gICAgICB2YXIgYm94SGVpZ2h0ID0gZG9jdW1lbnREYXRhLnN6WzFdO1xuICAgICAgdmFyIGN1cnJlbnRIZWlnaHQ7XG4gICAgICB2YXIgZmluYWxUZXh0O1xuICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgZmluYWxUZXh0ID0gdGhpcy5idWlsZEZpbmFsVGV4dChkb2N1bWVudERhdGEudCk7XG4gICAgICAgIGN1cnJlbnRIZWlnaHQgPSAwO1xuICAgICAgICBsaW5lV2lkdGggPSAwO1xuICAgICAgICBsZW4gPSBmaW5hbFRleHQubGVuZ3RoO1xuICAgICAgICB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAvIDEwMDAgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgICAgICB2YXIgbGFzdFNwYWNlSW5kZXggPSAtMTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgY2hhckNvZGUgPSBmaW5hbFRleHRbaV0uY2hhckNvZGVBdCgwKTtcbiAgICAgICAgICBuZXdMaW5lRmxhZyA9IGZhbHNlO1xuICAgICAgICAgIGlmIChmaW5hbFRleHRbaV0gPT09ICcgJykge1xuICAgICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSBpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY2hhckNvZGUgPT09IDEzIHx8IGNoYXJDb2RlID09PSAzKSB7XG4gICAgICAgICAgICBsaW5lV2lkdGggPSAwO1xuICAgICAgICAgICAgbmV3TGluZUZsYWcgPSB0cnVlO1xuICAgICAgICAgICAgY3VycmVudEhlaWdodCArPSBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0IHx8IGRvY3VtZW50RGF0YS5maW5hbFNpemUgKiAxLjI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChmb250TWFuYWdlci5jaGFycykge1xuICAgICAgICAgICAgY2hhckRhdGEgPSBmb250TWFuYWdlci5nZXRDaGFyRGF0YShmaW5hbFRleHRbaV0sIGZvbnREYXRhLmZTdHlsZSwgZm9udERhdGEuZkZhbWlseSk7XG4gICAgICAgICAgICBjTGVuZ3RoID0gbmV3TGluZUZsYWcgPyAwIDogY2hhckRhdGEudyAqIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHRDYW52YXNIZWxwZXIuZm9udCA9IGRvY3VtZW50RGF0YS5zICsgJ3B4ICcrIGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgICAgICBjTGVuZ3RoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQoZmluYWxUZXh0W2ldLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChsaW5lV2lkdGggKyBjTGVuZ3RoID4gYm94V2lkdGggJiYgZmluYWxUZXh0W2ldICE9PSAnICcpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3BhY2VJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgbGVuICs9IDE7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpID0gbGFzdFNwYWNlSW5kZXg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGRvY3VtZW50RGF0YS5maW5hbExpbmVIZWlnaHQgfHwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMjtcbiAgICAgICAgICAgIGZpbmFsVGV4dC5zcGxpY2UoaSwgbGFzdFNwYWNlSW5kZXggPT09IGkgPyAxIDogMCwgJ1xccicpO1xuICAgICAgICAgICAgLy8gZmluYWxUZXh0ID0gZmluYWxUZXh0LnN1YnN0cigwLGkpICsgXCJcXHJcIiArIGZpbmFsVGV4dC5zdWJzdHIoaSA9PT0gbGFzdFNwYWNlSW5kZXggPyBpICsgMSA6IGkpO1xuICAgICAgICAgICAgbGFzdFNwYWNlSW5kZXggPSAtMTtcbiAgICAgICAgICAgIGxpbmVXaWR0aCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpbmVXaWR0aCArPSBjTGVuZ3RoO1xuICAgICAgICAgICAgbGluZVdpZHRoICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjdXJyZW50SGVpZ2h0ICs9IGZvbnREYXRhLmFzY2VudCAqIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxMDA7XG4gICAgICAgIGlmICh0aGlzLmNhblJlc2l6ZSAmJiBkb2N1bWVudERhdGEuZmluYWxTaXplID4gdGhpcy5taW5pbXVtRm9udFNpemUgJiYgYm94SGVpZ2h0IDwgY3VycmVudEhlaWdodCkge1xuICAgICAgICAgIGRvY3VtZW50RGF0YS5maW5hbFNpemUgLT0gMTtcbiAgICAgICAgICBkb2N1bWVudERhdGEuZmluYWxMaW5lSGVpZ2h0ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIGRvY3VtZW50RGF0YS5saCAvIGRvY3VtZW50RGF0YS5zO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRvY3VtZW50RGF0YS5maW5hbFRleHQgPSBmaW5hbFRleHQ7XG4gICAgICAgICAgbGVuID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dC5sZW5ndGg7XG4gICAgICAgICAgZmxhZyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxpbmVXaWR0aCA9IC10cmFja2luZ09mZnNldDtcbiAgICBjTGVuZ3RoID0gMDtcbiAgICB2YXIgdW5jb2xsYXBzZWRTcGFjZXMgPSAwO1xuICAgIHZhciBjdXJyZW50Q2hhcjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG5ld0xpbmVGbGFnID0gZmFsc2U7XG4gICAgICBjdXJyZW50Q2hhciA9IGRvY3VtZW50RGF0YS5maW5hbFRleHRbaV07XG4gICAgICBjaGFyQ29kZSA9IGN1cnJlbnRDaGFyLmNoYXJDb2RlQXQoMCk7XG4gICAgICBpZiAoY2hhckNvZGUgPT09IDEzIHx8IGNoYXJDb2RlID09PSAzKSB7XG4gICAgICAgIHVuY29sbGFwc2VkU3BhY2VzID0gMDtcbiAgICAgICAgbGluZVdpZHRocy5wdXNoKGxpbmVXaWR0aCk7XG4gICAgICAgIG1heExpbmVXaWR0aCA9IGxpbmVXaWR0aCA+IG1heExpbmVXaWR0aCA/IGxpbmVXaWR0aCA6IG1heExpbmVXaWR0aDtcbiAgICAgICAgbGluZVdpZHRoID0gLTIgKiB0cmFja2luZ09mZnNldDtcbiAgICAgICAgdmFsID0gJyc7XG4gICAgICAgIG5ld0xpbmVGbGFnID0gdHJ1ZTtcbiAgICAgICAgY3VycmVudExpbmUgKz0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbCA9IGN1cnJlbnRDaGFyO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGNoYXJEYXRhID0gZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoY3VycmVudENoYXIsIGZvbnREYXRhLmZTdHlsZSwgZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XG4gICAgICAgIGNMZW5ndGggPSBuZXdMaW5lRmxhZyA/IDAgOiBjaGFyRGF0YS53ICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHZhciBjaGFyV2lkdGggPSBmb250TWFuYWdlci5tZWFzdXJlVGV4dCh2YWwsIGRvY3VtZW50RGF0YS5mLCBkb2N1bWVudERhdGEuZmluYWxTaXplKTtcbiAgICAgICAgLy8gdENhbnZhc0hlbHBlci5mb250ID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCAnKyBmb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5O1xuICAgICAgICBjTGVuZ3RoID0gZm9udE1hbmFnZXIubWVhc3VyZVRleHQodmFsLCBkb2N1bWVudERhdGEuZiwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICBpZiAoY3VycmVudENoYXIgPT09ICcgJykge1xuICAgICAgICB1bmNvbGxhcHNlZFNwYWNlcyArPSBjTGVuZ3RoICsgdHJhY2tpbmdPZmZzZXQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaW5lV2lkdGggKz0gY0xlbmd0aCArIHRyYWNraW5nT2Zmc2V0ICsgdW5jb2xsYXBzZWRTcGFjZXM7XG4gICAgICAgIHVuY29sbGFwc2VkU3BhY2VzID0gMDtcbiAgICAgIH1cbiAgICAgIGxldHRlcnMucHVzaCh7XG4gICAgICAgIGw6IGNMZW5ndGgsXG4gICAgICAgIGFuOiBjTGVuZ3RoLFxuICAgICAgICBhZGQ6IGN1cnJlbnRTaXplLFxuICAgICAgICBuOiBuZXdMaW5lRmxhZyxcbiAgICAgICAgYW5JbmRleGVzOiBbXSxcbiAgICAgICAgdmFsOiB2YWwsXG4gICAgICAgIGxpbmU6IGN1cnJlbnRMaW5lLFxuICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQ6IDBcbiAgICAgIH0pO1xuICAgICAgaWYgKGFuY2hvckdyb3VwaW5nID09IDIpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgY3VycmVudFNpemUgKz0gY0xlbmd0aDtcbiAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgdmFsID09PSAnICcgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgIGlmICh2YWwgPT09ICcnIHx8IHZhbCA9PT0gJyAnKSB7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZSAtPSBjTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGluZGV4ICs9IDE7XG4gICAgICAgICAgY3VycmVudFNpemUgPSAwO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKGFuY2hvckdyb3VwaW5nID09IDMpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgY3VycmVudFNpemUgKz0gY0xlbmd0aDtcbiAgICAgICAgaWYgKHZhbCA9PT0gJycgfHwgaSA9PT0gbGVuIC0gMSkge1xuICAgICAgICAgIGlmICh2YWwgPT09ICcnKSB7XG4gICAgICAgICAgICBjdXJyZW50U2l6ZSAtPSBjTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoY3VycmVudFBvcyA8PSBpKSB7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmFuID0gY3VycmVudFNpemU7XG4gICAgICAgICAgICBsZXR0ZXJzW2N1cnJlbnRQb3NdLmluZCA9IGluZGV4O1xuICAgICAgICAgICAgbGV0dGVyc1tjdXJyZW50UG9zXS5leHRyYSA9IGNMZW5ndGg7XG4gICAgICAgICAgICBjdXJyZW50UG9zICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRTaXplID0gMDtcbiAgICAgICAgICBpbmRleCArPSAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXR0ZXJzW2luZGV4XS5pbmQgPSBpbmRleDtcbiAgICAgICAgbGV0dGVyc1tpbmRleF0uZXh0cmEgPSAwO1xuICAgICAgICBpbmRleCArPSAxO1xuICAgICAgfVxuICAgIH1cbiAgICBkb2N1bWVudERhdGEubCA9IGxldHRlcnM7XG4gICAgbWF4TGluZVdpZHRoID0gbGluZVdpZHRoID4gbWF4TGluZVdpZHRoID8gbGluZVdpZHRoIDogbWF4TGluZVdpZHRoO1xuICAgIGxpbmVXaWR0aHMucHVzaChsaW5lV2lkdGgpO1xuICAgIGlmIChkb2N1bWVudERhdGEuc3opIHtcbiAgICAgIGRvY3VtZW50RGF0YS5ib3hXaWR0aCA9IGRvY3VtZW50RGF0YS5zelswXTtcbiAgICAgIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgZG9jdW1lbnREYXRhLmJveFdpZHRoID0gbWF4TGluZVdpZHRoO1xuICAgICAgc3dpdGNoIChkb2N1bWVudERhdGEuaikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgPSAtZG9jdW1lbnREYXRhLmJveFdpZHRoO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgPSAtZG9jdW1lbnREYXRhLmJveFdpZHRoIC8gMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBkb2N1bWVudERhdGEuanVzdGlmeU9mZnNldCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzID0gbGluZVdpZHRocztcbiAgICB2YXIgYW5pbWF0b3JzID0gZGF0YS5hO1xuICAgIHZhciBhbmltYXRvckRhdGE7XG4gICAgdmFyIGxldHRlckRhdGE7XG4gICAgakxlbiA9IGFuaW1hdG9ycy5sZW5ndGg7XG4gICAgdmFyIGJhc2VkO1xuICAgIHZhciBpbmQ7XG4gICAgdmFyIGluZGV4ZXMgPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICBhbmltYXRvckRhdGEgPSBhbmltYXRvcnNbal07XG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLmEuc2MpIHtcbiAgICAgICAgZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLmEuc3cpIHtcbiAgICAgICAgZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5pbWF0b3JEYXRhLmEuZmMgfHwgYW5pbWF0b3JEYXRhLmEuZmggfHwgYW5pbWF0b3JEYXRhLmEuZnMgfHwgYW5pbWF0b3JEYXRhLmEuZmIpIHtcbiAgICAgICAgZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gPSB0cnVlO1xuICAgICAgfVxuICAgICAgaW5kID0gMDtcbiAgICAgIGJhc2VkID0gYW5pbWF0b3JEYXRhLnMuYjtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBsZXR0ZXJEYXRhID0gbGV0dGVyc1tpXTtcbiAgICAgICAgbGV0dGVyRGF0YS5hbkluZGV4ZXNbal0gPSBpbmQ7XG4gICAgICAgIGlmIChiYXNlZCA9PSAxICYmIGxldHRlckRhdGEudmFsICE9PSAnJyB8fCBiYXNlZCA9PSAyICYmIGxldHRlckRhdGEudmFsICE9PSAnJyAmJiBsZXR0ZXJEYXRhLnZhbCAhPT0gJyAnIHx8IGJhc2VkID09IDMgJiYgKGxldHRlckRhdGEubiB8fCBsZXR0ZXJEYXRhLnZhbCA9PSAnICcgfHwgaSA9PSBsZW4gLSAxKSB8fCBiYXNlZCA9PSA0ICYmIChsZXR0ZXJEYXRhLm4gfHwgaSA9PSBsZW4gLSAxKSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgICAgaWYgKGFuaW1hdG9yRGF0YS5zLnJuID09PSAxKSB7XG4gICAgICAgICAgICBpbmRleGVzLnB1c2goaW5kKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaW5kICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGRhdGEuYVtqXS5zLnRvdGFsQ2hhcnMgPSBpbmQ7XG4gICAgICB2YXIgY3VycmVudEluZCA9IC0xO1xuICAgICAgdmFyIG5ld0luZDtcbiAgICAgIGlmIChhbmltYXRvckRhdGEucy5ybiA9PT0gMSkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBsZXR0ZXJEYXRhID0gbGV0dGVyc1tpXTtcbiAgICAgICAgICBpZiAoY3VycmVudEluZCAhPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgICAgIGN1cnJlbnRJbmQgPSBsZXR0ZXJEYXRhLmFuSW5kZXhlc1tqXTtcbiAgICAgICAgICAgIG5ld0luZCA9IGluZGV4ZXMuc3BsaWNlKE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGluZGV4ZXMubGVuZ3RoKSwgMSlbMF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldHRlckRhdGEuYW5JbmRleGVzW2pdID0gbmV3SW5kO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGRvY3VtZW50RGF0YS55T2Zmc2V0ID0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodCB8fCBkb2N1bWVudERhdGEuZmluYWxTaXplICogMS4yO1xuICAgIGRvY3VtZW50RGF0YS5scyA9IGRvY3VtZW50RGF0YS5scyB8fCAwO1xuICAgIGRvY3VtZW50RGF0YS5hc2NlbnQgPSBmb250RGF0YS5hc2NlbnQgKiBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwO1xuICB9O1xuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50RGF0YSA9IGZ1bmN0aW9uIChuZXdEYXRhLCBpbmRleCkge1xuICAgIGluZGV4ID0gaW5kZXggPT09IHVuZGVmaW5lZCA/IHRoaXMua2V5c0luZGV4IDogaW5kZXg7XG4gICAgdmFyIGREYXRhID0gdGhpcy5jb3B5RGF0YSh7fSwgdGhpcy5kYXRhLmQua1tpbmRleF0ucyk7XG4gICAgZERhdGEgPSB0aGlzLmNvcHlEYXRhKGREYXRhLCBuZXdEYXRhKTtcbiAgICB0aGlzLmRhdGEuZC5rW2luZGV4XS5zID0gZERhdGE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZShpbmRleCk7XG4gICAgdGhpcy5zZXRDdXJyZW50RGF0YShkRGF0YSk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcbiAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5yZWNhbGN1bGF0ZSA9IGZ1bmN0aW9uIChpbmRleCkge1xuICAgIHZhciBkRGF0YSA9IHRoaXMuZGF0YS5kLmtbaW5kZXhdLnM7XG4gICAgZERhdGEuX19jb21wbGV0ZSA9IGZhbHNlO1xuICAgIHRoaXMua2V5c0luZGV4ID0gMDtcbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSB0cnVlO1xuICAgIHRoaXMuZ2V0VmFsdWUoZERhdGEpO1xuICB9O1xuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmNhblJlc2l6ZUZvbnQgPSBmdW5jdGlvbiAoX2NhblJlc2l6ZSkge1xuICAgIHRoaXMuY2FuUmVzaXplID0gX2NhblJlc2l6ZTtcbiAgICB0aGlzLnJlY2FsY3VsYXRlKHRoaXMua2V5c0luZGV4KTtcbiAgICB0aGlzLmVsZW0uYWRkRHluYW1pY1Byb3BlcnR5KHRoaXMpO1xuICB9O1xuICBUZXh0UHJvcGVydHkucHJvdG90eXBlLnNldE1pbmltdW1Gb250U2l6ZSA9IGZ1bmN0aW9uIChfZm9udFZhbHVlKSB7XG4gICAgdGhpcy5taW5pbXVtRm9udFNpemUgPSBNYXRoLmZsb29yKF9mb250VmFsdWUpIHx8IDE7XG4gICAgdGhpcy5yZWNhbGN1bGF0ZSh0aGlzLmtleXNJbmRleCk7XG4gICAgdGhpcy5lbGVtLmFkZER5bmFtaWNQcm9wZXJ0eSh0aGlzKTtcbiAgfTtcblxuICB2YXIgVGV4dFNlbGVjdG9yUHJvcCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgbWF4ID0gTWF0aC5tYXg7XG4gICAgdmFyIG1pbiA9IE1hdGgubWluO1xuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgZnVuY3Rpb24gVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkoZWxlbSwgZGF0YSkge1xuICAgICAgdGhpcy5fY3VycmVudFRleHRMZW5ndGggPSAtMTtcbiAgICAgIHRoaXMuayA9IGZhbHNlO1xuICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgICB0aGlzLmNvbXAgPSBlbGVtLmNvbXA7XG4gICAgICB0aGlzLmZpbmFsUyA9IDA7XG4gICAgICB0aGlzLmZpbmFsRSA9IDA7XG4gICAgICB0aGlzLmluaXREeW5hbWljUHJvcGVydHlDb250YWluZXIoZWxlbSk7XG4gICAgICB0aGlzLnMgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnMgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIGlmICgnZScgaW4gZGF0YSkge1xuICAgICAgICB0aGlzLmUgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLmUsIDAsIDAsIHRoaXMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lID0ge1xuICAgICAgICAgIHY6IDEwMFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgdGhpcy5vID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS5vIHx8IHtcbiAgICAgICAgazogMFxuICAgICAgfSwgMCwgMCwgdGhpcyk7XG4gICAgICB0aGlzLnhlID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AoZWxlbSwgZGF0YS54ZSB8fCB7XG4gICAgICAgIGs6IDBcbiAgICAgIH0sIDAsIDAsIHRoaXMpO1xuICAgICAgdGhpcy5uZSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEubmUgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuc20gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcChlbGVtLCBkYXRhLnNtIHx8IHtcbiAgICAgICAgazogMTAwXG4gICAgICB9LCAwLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMuYSA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKGVsZW0sIGRhdGEuYSwgMCwgMC4wMSwgdGhpcyk7XG4gICAgICBpZiAoIXRoaXMuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkucHJvdG90eXBlID0ge1xuICAgICAgZ2V0TXVsdDogZnVuY3Rpb24gZ2V0TXVsdChpbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRUZXh0TGVuZ3RoICE9PSB0aGlzLmVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmwubGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5nZXRWYWx1ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHZhciB4MSA9IDA7XG4gICAgICAgIHZhciB5MSA9IDA7XG4gICAgICAgIHZhciB4MiA9IDE7XG4gICAgICAgIHZhciB5MiA9IDE7XG4gICAgICAgIGlmICh0aGlzLm5lLnYgPiAwKSB7XG4gICAgICAgICAgeDEgPSB0aGlzLm5lLnYgLyAxMDAuMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5MSA9IC10aGlzLm5lLnYgLyAxMDAuMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy54ZS52ID4gMCkge1xuICAgICAgICAgIHgyID0gMS4wIC0gdGhpcy54ZS52IC8gMTAwLjA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgeTIgPSAxLjAgKyB0aGlzLnhlLnYgLyAxMDAuMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZWFzZXIgPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZyh4MSwgeTEsIHgyLCB5MikuZ2V0O1xuICAgICAgICB2YXIgbXVsdCA9IDA7XG4gICAgICAgIHZhciBzID0gdGhpcy5maW5hbFM7XG4gICAgICAgIHZhciBlID0gdGhpcy5maW5hbEU7XG4gICAgICAgIHZhciB0eXBlID0gdGhpcy5kYXRhLnNoO1xuICAgICAgICBpZiAodHlwZSA9PT0gMikge1xuICAgICAgICAgIGlmIChlID09PSBzKSB7XG4gICAgICAgICAgICBtdWx0ID0gaW5kID49IGUgPyAxIDogMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDMpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgbXVsdCA9IGluZCA+PSBlID8gMCA6IDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG11bHQgPSAxIC0gbWF4KDAsIG1pbigwLjUgLyAoZSAtIHMpICsgKGluZCAtIHMpIC8gKGUgLSBzKSwgMSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBtdWx0ID0gZWFzZXIobXVsdCk7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICAgIGlmIChlID09PSBzKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IG1heCgwLCBtaW4oMC41IC8gKGUgLSBzKSArIChpbmQgLSBzKSAvIChlIC0gcyksIDEpKTtcbiAgICAgICAgICAgIGlmIChtdWx0IDwgMC41KSB7XG4gICAgICAgICAgICAgIG11bHQgKj0gMjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG11bHQgPSAxIC0gMiAqIChtdWx0IC0gMC41KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDUpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgbXVsdCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciB0b3QgPSBlIC0gcztcbiAgICAgICAgICAgIC8qIGluZCArPSAwLjU7XG4gICAgICAgICAgICAgICAgICAgICAgbXVsdCA9IC00Lyh0b3QqdG90KSooaW5kKmluZCkrKDQvdG90KSppbmQ7ICovXG4gICAgICAgICAgICBpbmQgPSBtaW4obWF4KDAsIGluZCArIDAuNSAtIHMpLCBlIC0gcyk7XG4gICAgICAgICAgICB2YXIgeCA9IC10b3QgLyAyICsgaW5kO1xuICAgICAgICAgICAgdmFyIGEgPSB0b3QgLyAyO1xuICAgICAgICAgICAgbXVsdCA9IE1hdGguc3FydCgxIC0geCAqIHggLyAoYSAqIGEpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09IDYpIHtcbiAgICAgICAgICBpZiAoZSA9PT0gcykge1xuICAgICAgICAgICAgbXVsdCA9IDA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGluZCA9IG1pbihtYXgoMCwgaW5kICsgMC41IC0gcyksIGUgLSBzKTtcbiAgICAgICAgICAgIG11bHQgPSAoMSArIE1hdGguY29zKE1hdGguUEkgKyBNYXRoLlBJICogMiAqIGluZCAvIChlIC0gcykpKSAvIDI7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB9XG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbmQgPj0gZmxvb3IocykpIHtcbiAgICAgICAgICAgIGlmIChpbmQgLSBzIDwgMCkge1xuICAgICAgICAgICAgICBtdWx0ID0gbWF4KDAsIG1pbihtaW4oZSwgMSkgLSAocyAtIGluZCksIDEpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG11bHQgPSBtYXgoMCwgbWluKGUgLSBpbmQsIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbXVsdCA9IGVhc2VyKG11bHQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNtb290aG5lc3MgaW1wbGVtZW50YXRpb24uXG4gICAgICAgIC8vIFRoZSBzbW9vdGhuZXNzIHJlcHJlc2VudHMgYSByZWR1Y2VkIHJhbmdlIG9mIHRoZSBvcmlnaW5hbCBbMDsgMV0gcmFuZ2UuXG4gICAgICAgIC8vIGlmIHNtb290aG5lc3MgaXMgMjUlLCB0aGUgbmV3IHJhbmdlIHdpbGwgYmUgWzAuMzc1OyAwLjYyNV1cbiAgICAgICAgLy8gU3RlcHMgYXJlOlxuICAgICAgICAvLyAtIGZpbmQgdGhlIGxvd2VyIHZhbHVlIG9mIHRoZSBuZXcgcmFuZ2UgKHRocmVzaG9sZClcbiAgICAgICAgLy8gLSBpZiBtdWx0aXBsaWVyIGlzIHNtYWxsZXIgdGhhbiB0aGF0IHZhbHVlLCBmbG9vciBpdCB0byAwXG4gICAgICAgIC8vIC0gaWYgaXQgaXMgbGFyZ2VyLFxuICAgICAgICAvLyAgICAgLSBzdWJ0cmFjdCB0aGUgdGhyZXNob2xkXG4gICAgICAgIC8vICAgICAtIGRpdmlkZSBpdCBieSB0aGUgc21vb3RobmVzcyAodGhpcyB3aWxsIHJldHVybiB0aGUgcmFuZ2UgdG8gWzA7IDFdKVxuICAgICAgICAvLyBOb3RlOiBJZiBpdCBkb2Vzbid0IHdvcmsgb24gc29tZSBzY2VuYXJpb3MsIGNvbnNpZGVyIGFwcGx5aW5nIGl0IGJlZm9yZSB0aGUgZWFzZXIuXG4gICAgICAgIGlmICh0aGlzLnNtLnYgIT09IDEwMCkge1xuICAgICAgICAgIHZhciBzbW9vdGhuZXNzID0gdGhpcy5zbS52ICogMC4wMTtcbiAgICAgICAgICBpZiAoc21vb3RobmVzcyA9PT0gMCkge1xuICAgICAgICAgICAgc21vb3RobmVzcyA9IDAuMDAwMDAwMDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciB0aHJlc2hvbGQgPSAwLjUgLSBzbW9vdGhuZXNzICogMC41O1xuICAgICAgICAgIGlmIChtdWx0IDwgdGhyZXNob2xkKSB7XG4gICAgICAgICAgICBtdWx0ID0gMDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXVsdCA9IChtdWx0IC0gdGhyZXNob2xkKSAvIHNtb290aG5lc3M7XG4gICAgICAgICAgICBpZiAobXVsdCA+IDEpIHtcbiAgICAgICAgICAgICAgbXVsdCA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtdWx0ICogdGhpcy5hLnY7XG4gICAgICB9LFxuICAgICAgZ2V0VmFsdWU6IGZ1bmN0aW9uIGdldFZhbHVlKG5ld0NoYXJzRmxhZykge1xuICAgICAgICB0aGlzLml0ZXJhdGVEeW5hbWljUHJvcGVydGllcygpO1xuICAgICAgICB0aGlzLl9tZGYgPSBuZXdDaGFyc0ZsYWcgfHwgdGhpcy5fbWRmO1xuICAgICAgICB0aGlzLl9jdXJyZW50VGV4dExlbmd0aCA9IHRoaXMuZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubC5sZW5ndGggfHwgMDtcbiAgICAgICAgaWYgKG5ld0NoYXJzRmxhZyAmJiB0aGlzLmRhdGEuciA9PT0gMikge1xuICAgICAgICAgIHRoaXMuZS52ID0gdGhpcy5fY3VycmVudFRleHRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRpdmlzb3IgPSB0aGlzLmRhdGEuciA9PT0gMiA/IDEgOiAxMDAgLyB0aGlzLmRhdGEudG90YWxDaGFycztcbiAgICAgICAgdmFyIG8gPSB0aGlzLm8udiAvIGRpdmlzb3I7XG4gICAgICAgIHZhciBzID0gdGhpcy5zLnYgLyBkaXZpc29yICsgbztcbiAgICAgICAgdmFyIGUgPSB0aGlzLmUudiAvIGRpdmlzb3IgKyBvO1xuICAgICAgICBpZiAocyA+IGUpIHtcbiAgICAgICAgICB2YXIgX3MgPSBzO1xuICAgICAgICAgIHMgPSBlO1xuICAgICAgICAgIGUgPSBfcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmFsUyA9IHM7XG4gICAgICAgIHRoaXMuZmluYWxFID0gZTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGV4dGVuZFByb3RvdHlwZShbRHluYW1pY1Byb3BlcnR5Q29udGFpbmVyXSwgVGV4dFNlbGVjdG9yUHJvcEZhY3RvcnkpO1xuICAgIGZ1bmN0aW9uIGdldFRleHRTZWxlY3RvclByb3AoZWxlbSwgZGF0YSwgYXJyKSB7XG4gICAgICByZXR1cm4gbmV3IFRleHRTZWxlY3RvclByb3BGYWN0b3J5KGVsZW0sIGRhdGEsIGFycik7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBnZXRUZXh0U2VsZWN0b3JQcm9wOiBnZXRUZXh0U2VsZWN0b3JQcm9wXG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIFRleHRBbmltYXRvckRhdGFQcm9wZXJ0eShlbGVtLCBhbmltYXRvclByb3BzLCBjb250YWluZXIpIHtcbiAgICB2YXIgZGVmYXVsdERhdGEgPSB7XG4gICAgICBwcm9wVHlwZTogZmFsc2VcbiAgICB9O1xuICAgIHZhciBnZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XG4gICAgdmFyIHRleHRBbmltYXRvckFuaW1hdGFibGVzID0gYW5pbWF0b3JQcm9wcy5hO1xuICAgIHRoaXMuYSA9IHtcbiAgICAgIHI6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnIsIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgcng6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ4ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5yeCwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICByeTogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMucnkgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnJ5LCAwLCBkZWdUb1JhZHMsIGNvbnRhaW5lcikgOiBkZWZhdWx0RGF0YSxcbiAgICAgIHNrOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zayA/IGdldFByb3AoZWxlbSwgdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2ssIDAsIGRlZ1RvUmFkcywgY29udGFpbmVyKSA6IGRlZmF1bHREYXRhLFxuICAgICAgc2E6IHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNhID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zYSwgMCwgZGVnVG9SYWRzLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5zLCAxLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBhOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5hID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5hLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBvOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5vID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5vLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBwOiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5wID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy5wLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzdzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc3cgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnN3LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBzYzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuc2MgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLnNjLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmYzogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmMgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZjLCAxLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmaDogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmggPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZoLCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmczogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZnMgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZzLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICBmYjogdGV4dEFuaW1hdG9yQW5pbWF0YWJsZXMuZmIgPyBnZXRQcm9wKGVsZW0sIHRleHRBbmltYXRvckFuaW1hdGFibGVzLmZiLCAwLCAwLjAxLCBjb250YWluZXIpIDogZGVmYXVsdERhdGEsXG4gICAgICB0OiB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy50ID8gZ2V0UHJvcChlbGVtLCB0ZXh0QW5pbWF0b3JBbmltYXRhYmxlcy50LCAwLCAwLCBjb250YWluZXIpIDogZGVmYXVsdERhdGFcbiAgICB9O1xuICAgIHRoaXMucyA9IFRleHRTZWxlY3RvclByb3AuZ2V0VGV4dFNlbGVjdG9yUHJvcChlbGVtLCBhbmltYXRvclByb3BzLnMsIGNvbnRhaW5lcik7XG4gICAgdGhpcy5zLnQgPSBhbmltYXRvclByb3BzLnMudDtcbiAgfVxuXG4gIGZ1bmN0aW9uIFRleHRBbmltYXRvclByb3BlcnR5KHRleHREYXRhLCByZW5kZXJUeXBlLCBlbGVtKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gZmFsc2U7XG4gICAgdGhpcy5fZnJhbWVJZCA9IC0xO1xuICAgIHRoaXMuX3RleHREYXRhID0gdGV4dERhdGE7XG4gICAgdGhpcy5fcmVuZGVyVHlwZSA9IHJlbmRlclR5cGU7XG4gICAgdGhpcy5fZWxlbSA9IGVsZW07XG4gICAgdGhpcy5fYW5pbWF0b3JzRGF0YSA9IGNyZWF0ZVNpemVkQXJyYXkodGhpcy5fdGV4dERhdGEuYS5sZW5ndGgpO1xuICAgIHRoaXMuX3BhdGhEYXRhID0ge307XG4gICAgdGhpcy5fbW9yZU9wdGlvbnMgPSB7XG4gICAgICBhbGlnbm1lbnQ6IHt9XG4gICAgfTtcbiAgICB0aGlzLnJlbmRlcmVkTGV0dGVycyA9IFtdO1xuICAgIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnID0gZmFsc2U7XG4gICAgdGhpcy5pbml0RHluYW1pY1Byb3BlcnR5Q29udGFpbmVyKGVsZW0pO1xuICB9XG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLl90ZXh0RGF0YS5hLmxlbmd0aDtcbiAgICB2YXIgYW5pbWF0b3JQcm9wcztcbiAgICB2YXIgZ2V0UHJvcCA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgYW5pbWF0b3JQcm9wcyA9IHRoaXMuX3RleHREYXRhLmFbaV07XG4gICAgICB0aGlzLl9hbmltYXRvcnNEYXRhW2ldID0gbmV3IFRleHRBbmltYXRvckRhdGFQcm9wZXJ0eSh0aGlzLl9lbGVtLCBhbmltYXRvclByb3BzLCB0aGlzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3RleHREYXRhLnAgJiYgJ20nIGluIHRoaXMuX3RleHREYXRhLnApIHtcbiAgICAgIHRoaXMuX3BhdGhEYXRhID0ge1xuICAgICAgICBhOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuYSwgMCwgMCwgdGhpcyksXG4gICAgICAgIGY6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5mLCAwLCAwLCB0aGlzKSxcbiAgICAgICAgbDogZ2V0UHJvcCh0aGlzLl9lbGVtLCB0aGlzLl90ZXh0RGF0YS5wLmwsIDAsIDAsIHRoaXMpLFxuICAgICAgICByOiBnZXRQcm9wKHRoaXMuX2VsZW0sIHRoaXMuX3RleHREYXRhLnAuciwgMCwgMCwgdGhpcyksXG4gICAgICAgIHA6IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEucC5wLCAwLCAwLCB0aGlzKSxcbiAgICAgICAgbTogdGhpcy5fZWxlbS5tYXNrTWFuYWdlci5nZXRNYXNrUHJvcGVydHkodGhpcy5fdGV4dERhdGEucC5tKVxuICAgICAgfTtcbiAgICAgIHRoaXMuX2hhc01hc2tlZFBhdGggPSB0cnVlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9oYXNNYXNrZWRQYXRoID0gZmFsc2U7XG4gICAgfVxuICAgIHRoaXMuX21vcmVPcHRpb25zLmFsaWdubWVudCA9IGdldFByb3AodGhpcy5fZWxlbSwgdGhpcy5fdGV4dERhdGEubS5hLCAxLCAwLCB0aGlzKTtcbiAgfTtcbiAgVGV4dEFuaW1hdG9yUHJvcGVydHkucHJvdG90eXBlLmdldE1lYXN1cmVzID0gZnVuY3Rpb24gKGRvY3VtZW50RGF0YSwgbGV0dGVyc0NoYW5nZWRGbGFnKSB7XG4gICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSBsZXR0ZXJzQ2hhbmdlZEZsYWc7XG4gICAgaWYgKCF0aGlzLl9tZGYgJiYgIXRoaXMuX2lzRmlyc3RGcmFtZSAmJiAhbGV0dGVyc0NoYW5nZWRGbGFnICYmICghdGhpcy5faGFzTWFza2VkUGF0aCB8fCAhdGhpcy5fcGF0aERhdGEubS5fbWRmKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICB2YXIgYWxpZ25tZW50ID0gdGhpcy5fbW9yZU9wdGlvbnMuYWxpZ25tZW50LnY7XG4gICAgdmFyIGFuaW1hdG9ycyA9IHRoaXMuX2FuaW1hdG9yc0RhdGE7XG4gICAgdmFyIHRleHREYXRhID0gdGhpcy5fdGV4dERhdGE7XG4gICAgdmFyIG1hdHJpeEhlbHBlciA9IHRoaXMubUhlbHBlcjtcbiAgICB2YXIgcmVuZGVyVHlwZSA9IHRoaXMuX3JlbmRlclR5cGU7XG4gICAgdmFyIHJlbmRlcmVkTGV0dGVyc0NvdW50ID0gdGhpcy5yZW5kZXJlZExldHRlcnMubGVuZ3RoO1xuICAgIHZhciB4UG9zO1xuICAgIHZhciB5UG9zO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW47XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubDtcbiAgICB2YXIgcGF0aEluZm87XG4gICAgdmFyIGN1cnJlbnRMZW5ndGg7XG4gICAgdmFyIGN1cnJlbnRQb2ludDtcbiAgICB2YXIgc2VnbWVudExlbmd0aDtcbiAgICB2YXIgZmxhZztcbiAgICB2YXIgcG9pbnRJbmQ7XG4gICAgdmFyIHNlZ21lbnRJbmQ7XG4gICAgdmFyIHByZXZQb2ludDtcbiAgICB2YXIgcG9pbnRzO1xuICAgIHZhciBzZWdtZW50cztcbiAgICB2YXIgcGFydGlhbExlbmd0aDtcbiAgICB2YXIgdG90YWxMZW5ndGg7XG4gICAgdmFyIHBlcmM7XG4gICAgdmFyIHRhbkFuZ2xlO1xuICAgIHZhciBtYXNrO1xuICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICBtYXNrID0gdGhpcy5fcGF0aERhdGEubTtcbiAgICAgIGlmICghdGhpcy5fcGF0aERhdGEubiB8fCB0aGlzLl9wYXRoRGF0YS5fbWRmKSB7XG4gICAgICAgIHZhciBwYXRocyA9IG1hc2sudjtcbiAgICAgICAgaWYgKHRoaXMuX3BhdGhEYXRhLnIudikge1xuICAgICAgICAgIHBhdGhzID0gcGF0aHMucmV2ZXJzZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE86IHJlbGVhc2UgYmV6aWVyIGRhdGEgY2FjaGVkIGZyb20gcHJldmlvdXMgcGF0aEluZm86IHRoaXMuX3BhdGhEYXRhLnBpXG4gICAgICAgIHBhdGhJbmZvID0ge1xuICAgICAgICAgIHRMZW5ndGg6IDAsXG4gICAgICAgICAgc2VnbWVudHM6IFtdXG4gICAgICAgIH07XG4gICAgICAgIGxlbiA9IHBhdGhzLl9sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYmV6aWVyRGF0YTtcbiAgICAgICAgdG90YWxMZW5ndGggPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBiZXppZXJEYXRhID0gYmV6LmJ1aWxkQmV6aWVyRGF0YShwYXRocy52W2ldLCBwYXRocy52W2kgKyAxXSwgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sIFtwYXRocy5pW2kgKyAxXVswXSAtIHBhdGhzLnZbaSArIDFdWzBdLCBwYXRocy5pW2kgKyAxXVsxXSAtIHBhdGhzLnZbaSArIDFdWzFdXSk7XG4gICAgICAgICAgcGF0aEluZm8udExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgICAgcGF0aEluZm8uc2VnbWVudHMucHVzaChiZXppZXJEYXRhKTtcbiAgICAgICAgICB0b3RhbExlbmd0aCArPSBiZXppZXJEYXRhLnNlZ21lbnRMZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgaSA9IGxlbjtcbiAgICAgICAgaWYgKG1hc2sudi5jKSB7XG4gICAgICAgICAgYmV6aWVyRGF0YSA9IGJlei5idWlsZEJlemllckRhdGEocGF0aHMudltpXSwgcGF0aHMudlswXSwgW3BhdGhzLm9baV1bMF0gLSBwYXRocy52W2ldWzBdLCBwYXRocy5vW2ldWzFdIC0gcGF0aHMudltpXVsxXV0sIFtwYXRocy5pWzBdWzBdIC0gcGF0aHMudlswXVswXSwgcGF0aHMuaVswXVsxXSAtIHBhdGhzLnZbMF1bMV1dKTtcbiAgICAgICAgICBwYXRoSW5mby50TGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcbiAgICAgICAgICBwYXRoSW5mby5zZWdtZW50cy5wdXNoKGJlemllckRhdGEpO1xuICAgICAgICAgIHRvdGFsTGVuZ3RoICs9IGJlemllckRhdGEuc2VnbWVudExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXRoRGF0YS5waSA9IHBhdGhJbmZvO1xuICAgICAgfVxuICAgICAgcGF0aEluZm8gPSB0aGlzLl9wYXRoRGF0YS5waTtcbiAgICAgIGN1cnJlbnRMZW5ndGggPSB0aGlzLl9wYXRoRGF0YS5mLnY7XG4gICAgICBzZWdtZW50SW5kID0gMDtcbiAgICAgIHBvaW50SW5kID0gMTtcbiAgICAgIHNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgZmxhZyA9IHRydWU7XG4gICAgICBzZWdtZW50cyA9IHBhdGhJbmZvLnNlZ21lbnRzO1xuICAgICAgaWYgKGN1cnJlbnRMZW5ndGggPCAwICYmIG1hc2sudi5jKSB7XG4gICAgICAgIGlmIChwYXRoSW5mby50TGVuZ3RoIDwgTWF0aC5hYnMoY3VycmVudExlbmd0aCkpIHtcbiAgICAgICAgICBjdXJyZW50TGVuZ3RoID0gLU1hdGguYWJzKGN1cnJlbnRMZW5ndGgpICUgcGF0aEluZm8udExlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBzZWdtZW50SW5kID0gc2VnbWVudHMubGVuZ3RoIC0gMTtcbiAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICBwb2ludEluZCA9IHBvaW50cy5sZW5ndGggLSAxO1xuICAgICAgICB3aGlsZSAoY3VycmVudExlbmd0aCA8IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHBvaW50c1twb2ludEluZF0ucGFydGlhbExlbmd0aDtcbiAgICAgICAgICBwb2ludEluZCAtPSAxO1xuICAgICAgICAgIGlmIChwb2ludEluZCA8IDApIHtcbiAgICAgICAgICAgIHNlZ21lbnRJbmQgLT0gMTtcbiAgICAgICAgICAgIHBvaW50cyA9IHNlZ21lbnRzW3NlZ21lbnRJbmRdLnBvaW50cztcbiAgICAgICAgICAgIHBvaW50SW5kID0gcG9pbnRzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwb2ludHMgPSBzZWdtZW50c1tzZWdtZW50SW5kXS5wb2ludHM7XG4gICAgICBwcmV2UG9pbnQgPSBwb2ludHNbcG9pbnRJbmQgLSAxXTtcbiAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XG4gICAgICBwYXJ0aWFsTGVuZ3RoID0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgfVxuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHhQb3MgPSAwO1xuICAgIHlQb3MgPSAwO1xuICAgIHZhciB5T2ZmID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAqIDEuMiAqIDAuNzE0O1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciBhbmltYXRvclByb3BzO1xuICAgIHZhciBhbmltYXRvclNlbGVjdG9yO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBsZXR0ZXJWYWx1ZTtcbiAgICBqTGVuID0gYW5pbWF0b3JzLmxlbmd0aDtcbiAgICB2YXIgbXVsdDtcbiAgICB2YXIgaW5kID0gLTE7XG4gICAgdmFyIG9mZmY7XG4gICAgdmFyIHhQYXRoUG9zO1xuICAgIHZhciB5UGF0aFBvcztcbiAgICB2YXIgaW5pdFBhdGhQb3MgPSBjdXJyZW50TGVuZ3RoO1xuICAgIHZhciBpbml0U2VnbWVudEluZCA9IHNlZ21lbnRJbmQ7XG4gICAgdmFyIGluaXRQb2ludEluZCA9IHBvaW50SW5kO1xuICAgIHZhciBjdXJyZW50TGluZSA9IC0xO1xuICAgIHZhciBlbGVtT3BhY2l0eTtcbiAgICB2YXIgc2M7XG4gICAgdmFyIHN3O1xuICAgIHZhciBmYztcbiAgICB2YXIgaztcbiAgICB2YXIgbGV0dGVyU3c7XG4gICAgdmFyIGxldHRlclNjO1xuICAgIHZhciBsZXR0ZXJGYztcbiAgICB2YXIgbGV0dGVyTSA9ICcnO1xuICAgIHZhciBsZXR0ZXJQID0gdGhpcy5kZWZhdWx0UHJvcHNBcnJheTtcbiAgICB2YXIgbGV0dGVyTztcblxuICAgIC8vXG4gICAgaWYgKGRvY3VtZW50RGF0YS5qID09PSAyIHx8IGRvY3VtZW50RGF0YS5qID09PSAxKSB7XG4gICAgICB2YXIgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgIHZhciBhbmltYXRvckZpcnN0Q2hhck9mZnNldCA9IDA7XG4gICAgICB2YXIganVzdGlmeU9mZnNldE11bHQgPSBkb2N1bWVudERhdGEuaiA9PT0gMiA/IC0wLjUgOiAtMTtcbiAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgdmFyIGlzTmV3TGluZSA9IHRydWU7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xuICAgICAgICAgIGlmIChhbmltYXRvckp1c3RpZnlPZmZzZXQpIHtcbiAgICAgICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvckZpcnN0Q2hhck9mZnNldDtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGkpIHtcbiAgICAgICAgICAgIGxldHRlcnNbbGFzdEluZGV4XS5hbmltYXRvckp1c3RpZnlPZmZzZXQgPSBhbmltYXRvckp1c3RpZnlPZmZzZXQ7XG4gICAgICAgICAgICBsYXN0SW5kZXggKz0gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ID0gMDtcbiAgICAgICAgICBpc05ld0xpbmUgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLnQucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKGlzTmV3TGluZSAmJiBkb2N1bWVudERhdGEuaiA9PT0gMikge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMudC52ICoganVzdGlmeU9mZnNldE11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9ySnVzdGlmeU9mZnNldCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHRbMF0gKiBqdXN0aWZ5T2Zmc2V0TXVsdDtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBhbmltYXRvckp1c3RpZnlPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0ICoganVzdGlmeU9mZnNldE11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaXNOZXdMaW5lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChhbmltYXRvckp1c3RpZnlPZmZzZXQpIHtcbiAgICAgICAgYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICs9IGFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKGxhc3RJbmRleCA8IGkpIHtcbiAgICAgICAgbGV0dGVyc1tsYXN0SW5kZXhdLmFuaW1hdG9ySnVzdGlmeU9mZnNldCA9IGFuaW1hdG9ySnVzdGlmeU9mZnNldDtcbiAgICAgICAgbGFzdEluZGV4ICs9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIC8vXG5cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIG1hdHJpeEhlbHBlci5yZXNldCgpO1xuICAgICAgZWxlbU9wYWNpdHkgPSAxO1xuICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xuICAgICAgICB4UG9zID0gMDtcbiAgICAgICAgeVBvcyArPSBkb2N1bWVudERhdGEueU9mZnNldDtcbiAgICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcbiAgICAgICAgY3VycmVudExlbmd0aCA9IGluaXRQYXRoUG9zO1xuICAgICAgICBmaXJzdExpbmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICBzZWdtZW50SW5kID0gaW5pdFNlZ21lbnRJbmQ7XG4gICAgICAgICAgcG9pbnRJbmQgPSBpbml0UG9pbnRJbmQ7XG4gICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50c1twb2ludEluZCAtIDFdO1xuICAgICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XG4gICAgICAgICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgIHNlZ21lbnRMZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGxldHRlck0gPSAnJztcbiAgICAgICAgbGV0dGVyRmMgPSAnJztcbiAgICAgICAgbGV0dGVyU3cgPSAnJztcbiAgICAgICAgbGV0dGVyTyA9ICcnO1xuICAgICAgICBsZXR0ZXJQID0gdGhpcy5kZWZhdWx0UHJvcHNBcnJheTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLl9oYXNNYXNrZWRQYXRoKSB7XG4gICAgICAgICAgaWYgKGN1cnJlbnRMaW5lICE9PSBsZXR0ZXJzW2ldLmxpbmUpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoZG9jdW1lbnREYXRhLmopIHtcbiAgICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gdG90YWxMZW5ndGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSAodG90YWxMZW5ndGggLSBkb2N1bWVudERhdGEubGluZVdpZHRoc1tsZXR0ZXJzW2ldLmxpbmVdKSAvIDI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGluZSA9IGxldHRlcnNbaV0ubGluZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGluZCAhPT0gbGV0dGVyc1tpXS5pbmQpIHtcbiAgICAgICAgICAgIGlmIChsZXR0ZXJzW2luZF0pIHtcbiAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2luZF0uZXh0cmE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IGxldHRlcnNbaV0uYW4gLyAyO1xuICAgICAgICAgICAgaW5kID0gbGV0dGVyc1tpXS5pbmQ7XG4gICAgICAgICAgfVxuICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1O1xuICAgICAgICAgIHZhciBhbmltYXRvck9mZnNldCA9IDA7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMucC52WzBdICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuYS5wcm9wVHlwZSkge1xuICAgICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICAgIG11bHQgPSBhbmltYXRvclNlbGVjdG9yLmdldE11bHQobGV0dGVyc1tpXS5hbkluZGV4ZXNbal0sIHRleHREYXRhLmFbal0ucy50b3RhbENoYXJzKTtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0b3JPZmZzZXQgKz0gYW5pbWF0b3JQcm9wcy5hLnZbMF0gKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGFuaW1hdG9yT2Zmc2V0ICs9IGFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmbGFnID0gdHJ1ZTtcbiAgICAgICAgICAvLyBGb3JjZSBhbGlnbm1lbnQgb25seSB3b3JrcyB3aXRoIGEgc2luZ2xlIGxpbmUgZm9yIG5vd1xuICAgICAgICAgIGlmICh0aGlzLl9wYXRoRGF0YS5hLnYpIHtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggPSBsZXR0ZXJzWzBdLmFuICogMC41ICsgKHRvdGFsTGVuZ3RoIC0gdGhpcy5fcGF0aERhdGEuZi52IC0gbGV0dGVyc1swXS5hbiAqIDAuNSAtIGxldHRlcnNbbGV0dGVycy5sZW5ndGggLSAxXS5hbiAqIDAuNSkgKiBpbmQgLyAobGVuIC0gMSk7XG4gICAgICAgICAgICBjdXJyZW50TGVuZ3RoICs9IHRoaXMuX3BhdGhEYXRhLmYudjtcbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKGZsYWcpIHtcbiAgICAgICAgICAgIGlmIChzZWdtZW50TGVuZ3RoICsgcGFydGlhbExlbmd0aCA+PSBjdXJyZW50TGVuZ3RoICsgYW5pbWF0b3JPZmZzZXQgfHwgIXBvaW50cykge1xuICAgICAgICAgICAgICBwZXJjID0gKGN1cnJlbnRMZW5ndGggKyBhbmltYXRvck9mZnNldCAtIHNlZ21lbnRMZW5ndGgpIC8gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICAgIHhQYXRoUG9zID0gcHJldlBvaW50LnBvaW50WzBdICsgKGN1cnJlbnRQb2ludC5wb2ludFswXSAtIHByZXZQb2ludC5wb2ludFswXSkgKiBwZXJjO1xuICAgICAgICAgICAgICB5UGF0aFBvcyA9IHByZXZQb2ludC5wb2ludFsxXSArIChjdXJyZW50UG9pbnQucG9pbnRbMV0gLSBwcmV2UG9pbnQucG9pbnRbMV0pICogcGVyYztcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgtYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1LCAtKGFsaWdubWVudFsxXSAqIHlPZmYpICogMC4wMSk7XG4gICAgICAgICAgICAgIGZsYWcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocG9pbnRzKSB7XG4gICAgICAgICAgICAgIHNlZ21lbnRMZW5ndGggKz0gY3VycmVudFBvaW50LnBhcnRpYWxMZW5ndGg7XG4gICAgICAgICAgICAgIHBvaW50SW5kICs9IDE7XG4gICAgICAgICAgICAgIGlmIChwb2ludEluZCA+PSBwb2ludHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmQgKz0gMTtcbiAgICAgICAgICAgICAgICBpZiAoIXNlZ21lbnRzW3NlZ21lbnRJbmRdKSB7XG4gICAgICAgICAgICAgICAgICBpZiAobWFzay52LmMpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRJbmQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBzZWdtZW50SW5kID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgc2VnbWVudExlbmd0aCAtPSBjdXJyZW50UG9pbnQucGFydGlhbExlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcG9pbnRzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcG9pbnRzID0gc2VnbWVudHNbc2VnbWVudEluZF0ucG9pbnRzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAocG9pbnRzKSB7XG4gICAgICAgICAgICAgICAgcHJldlBvaW50ID0gY3VycmVudFBvaW50O1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQb2ludCA9IHBvaW50c1twb2ludEluZF07XG4gICAgICAgICAgICAgICAgcGFydGlhbExlbmd0aCA9IGN1cnJlbnRQb2ludC5wYXJ0aWFsTGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIG9mZmYgPSBsZXR0ZXJzW2ldLmFuIC8gMiAtIGxldHRlcnNbaV0uYWRkO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLW9mZmYsIDAsIDApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZmYgPSBsZXR0ZXJzW2ldLmFuIC8gMiAtIGxldHRlcnNbaV0uYWRkO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLW9mZmYsIDAsIDApO1xuXG4gICAgICAgICAgLy8gR3JvdXBpbmcgYWxpZ25tZW50XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgtYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1LCAtYWxpZ25tZW50WzFdICogeU9mZiAqIDAuMDEsIDApO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMudC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuICAgICAgICAgICAgLy8gVGhpcyBjb25kaXRpb24gaXMgdG8gcHJldmVudCBhcHBseWluZyB0cmFja2luZyB0byBmaXJzdCBjaGFyYWN0ZXIgaW4gZWFjaCBsaW5lLiBNaWdodCBiZSBiZXR0ZXIgdG8gdXNlIGEgYm9vbGVhbiBcImlzTmV3TGluZVwiXG4gICAgICAgICAgICBpZiAoeFBvcyAhPT0gMCB8fCBkb2N1bWVudERhdGEuaiAhPT0gMCkge1xuICAgICAgICAgICAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBhbmltYXRvclByb3BzLnQudiAqIG11bHRbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHhQb3MgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0WzBdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhQb3MgKz0gYW5pbWF0b3JQcm9wcy50LnYgKiBtdWx0O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgc3cgPSBkb2N1bWVudERhdGEuc3cgfHwgMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZUNvbG9yQW5pbSkge1xuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuc2MpIHtcbiAgICAgICAgICAgIHNjID0gW2RvY3VtZW50RGF0YS5zY1swXSwgZG9jdW1lbnREYXRhLnNjWzFdLCBkb2N1bWVudERhdGEuc2NbMl1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzYyA9IFswLCAwLCAwXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgICAgIGZjID0gW2RvY3VtZW50RGF0YS5mY1swXSwgZG9jdW1lbnREYXRhLmZjWzFdLCBkb2N1bWVudERhdGEuZmNbMl1dO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBhbmltYXRvclByb3BzID0gYW5pbWF0b3JzW2pdLmE7XG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuYS5wcm9wVHlwZSkge1xuICAgICAgICAgICAgYW5pbWF0b3JTZWxlY3RvciA9IGFuaW1hdG9yc1tqXS5zO1xuICAgICAgICAgICAgbXVsdCA9IGFuaW1hdG9yU2VsZWN0b3IuZ2V0TXVsdChsZXR0ZXJzW2ldLmFuSW5kZXhlc1tqXSwgdGV4dERhdGEuYVtqXS5zLnRvdGFsQ2hhcnMpO1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdFswXSwgLWFuaW1hdG9yUHJvcHMuYS52WzFdICogbXVsdFsxXSwgYW5pbWF0b3JQcm9wcy5hLnZbMl0gKiBtdWx0WzJdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoLWFuaW1hdG9yUHJvcHMuYS52WzBdICogbXVsdCwgLWFuaW1hdG9yUHJvcHMuYS52WzFdICogbXVsdCwgYW5pbWF0b3JQcm9wcy5hLnZbMl0gKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5zLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMF0gLSAxKSAqIG11bHRbMF0sIDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMV0gLSAxKSAqIG11bHRbMV0sIDEpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnNjYWxlKDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMF0gLSAxKSAqIG11bHQsIDEgKyAoYW5pbWF0b3JQcm9wcy5zLnZbMV0gLSAxKSAqIG11bHQsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgYW5pbWF0b3JQcm9wcyA9IGFuaW1hdG9yc1tqXS5hO1xuICAgICAgICAgIGFuaW1hdG9yU2VsZWN0b3IgPSBhbmltYXRvcnNbal0ucztcbiAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuc2sucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIuc2tld0Zyb21BeGlzKC1hbmltYXRvclByb3BzLnNrLnYgKiBtdWx0WzBdLCBhbmltYXRvclByb3BzLnNhLnYgKiBtdWx0WzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5za2V3RnJvbUF4aXMoLWFuaW1hdG9yUHJvcHMuc2sudiAqIG11bHQsIGFuaW1hdG9yUHJvcHMuc2EudiAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5yLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVooLWFuaW1hdG9yUHJvcHMuci52ICogbXVsdFsyXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWigtYW5pbWF0b3JQcm9wcy5yLnYgKiBtdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMucnkucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlWShhbmltYXRvclByb3BzLnJ5LnYgKiBtdWx0WzFdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVZKGFuaW1hdG9yUHJvcHMucnkudiAqIG11bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5yeC5wcm9wVHlwZSkge1xuICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci5yb3RhdGVYKGFuaW1hdG9yUHJvcHMucngudiAqIG11bHRbMF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnJvdGF0ZVgoYW5pbWF0b3JQcm9wcy5yeC52ICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLm8ucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICBlbGVtT3BhY2l0eSArPSAoYW5pbWF0b3JQcm9wcy5vLnYgKiBtdWx0WzBdIC0gZWxlbU9wYWNpdHkpICogbXVsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGVsZW1PcGFjaXR5ICs9IChhbmltYXRvclByb3BzLm8udiAqIG11bHQgLSBlbGVtT3BhY2l0eSkgKiBtdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZG9jdW1lbnREYXRhLnN0cm9rZVdpZHRoQW5pbSAmJiBhbmltYXRvclByb3BzLnN3LnByb3BUeXBlKSB7XG4gICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgc3cgKz0gYW5pbWF0b3JQcm9wcy5zdy52ICogbXVsdFswXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHN3ICs9IGFuaW1hdG9yUHJvcHMuc3cudiAqIG11bHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlQ29sb3JBbmltICYmIGFuaW1hdG9yUHJvcHMuc2MucHJvcFR5cGUpIHtcbiAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCAzOyBrICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgc2Nba10gKz0gKGFuaW1hdG9yUHJvcHMuc2MudltrXSAtIHNjW2tdKSAqIG11bHRbMF07XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2Nba10gKz0gKGFuaW1hdG9yUHJvcHMuc2MudltrXSAtIHNjW2tdKSAqIG11bHQ7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5maWxsQ29sb3JBbmltICYmIGRvY3VtZW50RGF0YS5mYykge1xuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmMucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IDM7IGsgKz0gMSkge1xuICAgICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgZmNba10gKz0gKGFuaW1hdG9yUHJvcHMuZmMudltrXSAtIGZjW2tdKSAqIG11bHRbMF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGZjW2tdICs9IChhbmltYXRvclByb3BzLmZjLnZba10gLSBmY1trXSkgKiBtdWx0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFuaW1hdG9yUHJvcHMuZmgucHJvcFR5cGUpIHtcbiAgICAgICAgICAgICAgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdFswXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMgPSBhZGRIdWVUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5maC52ICogbXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZzLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZjID0gYWRkU2F0dXJhdGlvblRvUkdCKGZjLCBhbmltYXRvclByb3BzLmZzLnYgKiBtdWx0WzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZFNhdHVyYXRpb25Ub1JHQihmYywgYW5pbWF0b3JQcm9wcy5mcy52ICogbXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhbmltYXRvclByb3BzLmZiLnByb3BUeXBlKSB7XG4gICAgICAgICAgICAgIGlmIChtdWx0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGZjID0gYWRkQnJpZ2h0bmVzc1RvUkdCKGZjLCBhbmltYXRvclByb3BzLmZiLnYgKiBtdWx0WzBdKTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYyA9IGFkZEJyaWdodG5lc3NUb1JHQihmYywgYW5pbWF0b3JQcm9wcy5mYi52ICogbXVsdCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIGFuaW1hdG9yUHJvcHMgPSBhbmltYXRvcnNbal0uYTtcbiAgICAgICAgICBpZiAoYW5pbWF0b3JQcm9wcy5wLnByb3BUeXBlKSB7XG4gICAgICAgICAgICBhbmltYXRvclNlbGVjdG9yID0gYW5pbWF0b3JzW2pdLnM7XG4gICAgICAgICAgICBtdWx0ID0gYW5pbWF0b3JTZWxlY3Rvci5nZXRNdWx0KGxldHRlcnNbaV0uYW5JbmRleGVzW2pdLCB0ZXh0RGF0YS5hW2pdLnMudG90YWxDaGFycyk7XG4gICAgICAgICAgICBpZiAodGhpcy5faGFzTWFza2VkUGF0aCkge1xuICAgICAgICAgICAgICBpZiAobXVsdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIGFuaW1hdG9yUHJvcHMucC52WzFdICogbXVsdFswXSwgLWFuaW1hdG9yUHJvcHMucC52WzJdICogbXVsdFsxXSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHQsIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHQpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG11bHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoYW5pbWF0b3JQcm9wcy5wLnZbMF0gKiBtdWx0WzBdLCBhbmltYXRvclByb3BzLnAudlsxXSAqIG11bHRbMV0sIC1hbmltYXRvclByb3BzLnAudlsyXSAqIG11bHRbMl0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShhbmltYXRvclByb3BzLnAudlswXSAqIG11bHQsIGFuaW1hdG9yUHJvcHMucC52WzFdICogbXVsdCwgLWFuaW1hdG9yUHJvcHMucC52WzJdICogbXVsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChkb2N1bWVudERhdGEuc3Ryb2tlV2lkdGhBbmltKSB7XG4gICAgICAgICAgbGV0dGVyU3cgPSBzdyA8IDAgPyAwIDogc3c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRvY3VtZW50RGF0YS5zdHJva2VDb2xvckFuaW0pIHtcbiAgICAgICAgICBsZXR0ZXJTYyA9ICdyZ2IoJyArIE1hdGgucm91bmQoc2NbMF0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChzY1sxXSAqIDI1NSkgKyAnLCcgKyBNYXRoLnJvdW5kKHNjWzJdICogMjU1KSArICcpJztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZG9jdW1lbnREYXRhLmZpbGxDb2xvckFuaW0gJiYgZG9jdW1lbnREYXRhLmZjKSB7XG4gICAgICAgICAgbGV0dGVyRmMgPSAncmdiKCcgKyBNYXRoLnJvdW5kKGZjWzBdICogMjU1KSArICcsJyArIE1hdGgucm91bmQoZmNbMV0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChmY1syXSAqIDI1NSkgKyAnKSc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2hhc01hc2tlZFBhdGgpIHtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKDAsIC1kb2N1bWVudERhdGEubHMpO1xuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgYWxpZ25tZW50WzFdICogeU9mZiAqIDAuMDEgKyB5UG9zLCAwKTtcbiAgICAgICAgICBpZiAodGhpcy5fcGF0aERhdGEucC52KSB7XG4gICAgICAgICAgICB0YW5BbmdsZSA9IChjdXJyZW50UG9pbnQucG9pbnRbMV0gLSBwcmV2UG9pbnQucG9pbnRbMV0pIC8gKGN1cnJlbnRQb2ludC5wb2ludFswXSAtIHByZXZQb2ludC5wb2ludFswXSk7XG4gICAgICAgICAgICB2YXIgcm90ID0gTWF0aC5hdGFuKHRhbkFuZ2xlKSAqIDE4MCAvIE1hdGguUEk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFBvaW50LnBvaW50WzBdIDwgcHJldlBvaW50LnBvaW50WzBdKSB7XG4gICAgICAgICAgICAgIHJvdCArPSAxODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBtYXRyaXhIZWxwZXIucm90YXRlKC1yb3QgKiBNYXRoLlBJIC8gMTgwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSh4UGF0aFBvcywgeVBhdGhQb3MsIDApO1xuICAgICAgICAgIGN1cnJlbnRMZW5ndGggLT0gYWxpZ25tZW50WzBdICogbGV0dGVyc1tpXS5hbiAqIDAuMDA1O1xuICAgICAgICAgIGlmIChsZXR0ZXJzW2kgKyAxXSAmJiBpbmQgIT09IGxldHRlcnNbaSArIDFdLmluZCkge1xuICAgICAgICAgICAgY3VycmVudExlbmd0aCArPSBsZXR0ZXJzW2ldLmFuIC8gMjtcbiAgICAgICAgICAgIGN1cnJlbnRMZW5ndGggKz0gZG9jdW1lbnREYXRhLnRyICogMC4wMDEgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKHhQb3MsIHlQb3MsIDApO1xuICAgICAgICAgIGlmIChkb2N1bWVudERhdGEucHMpIHtcbiAgICAgICAgICAgIC8vIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLGRvY3VtZW50RGF0YS5wc1sxXSwwKTtcbiAgICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLCBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LCAwKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChkb2N1bWVudERhdGEuaikge1xuICAgICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGxldHRlcnNbaV0uYW5pbWF0b3JKdXN0aWZ5T2Zmc2V0ICsgZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGV0dGVyc1tpXS5saW5lXSksIDAsIDApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShsZXR0ZXJzW2ldLmFuaW1hdG9ySnVzdGlmeU9mZnNldCArIGRvY3VtZW50RGF0YS5qdXN0aWZ5T2Zmc2V0ICsgKGRvY3VtZW50RGF0YS5ib3hXaWR0aCAtIGRvY3VtZW50RGF0YS5saW5lV2lkdGhzW2xldHRlcnNbaV0ubGluZV0pIC8gMiwgMCwgMCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoMCwgLWRvY3VtZW50RGF0YS5scyk7XG4gICAgICAgICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZShvZmZmLCAwLCAwKTtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIudHJhbnNsYXRlKGFsaWdubWVudFswXSAqIGxldHRlcnNbaV0uYW4gKiAwLjAwNSwgYWxpZ25tZW50WzFdICogeU9mZiAqIDAuMDEsIDApO1xuICAgICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sICsgZG9jdW1lbnREYXRhLnRyICogMC4wMDEgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW5kZXJUeXBlID09PSAnaHRtbCcpIHtcbiAgICAgICAgICBsZXR0ZXJNID0gbWF0cml4SGVscGVyLnRvQ1NTKCk7XG4gICAgICAgIH0gZWxzZSBpZiAocmVuZGVyVHlwZSA9PT0gJ3N2ZycpIHtcbiAgICAgICAgICBsZXR0ZXJNID0gbWF0cml4SGVscGVyLnRvMmRDU1MoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZXR0ZXJQID0gW21hdHJpeEhlbHBlci5wcm9wc1swXSwgbWF0cml4SGVscGVyLnByb3BzWzFdLCBtYXRyaXhIZWxwZXIucHJvcHNbMl0sIG1hdHJpeEhlbHBlci5wcm9wc1szXSwgbWF0cml4SGVscGVyLnByb3BzWzRdLCBtYXRyaXhIZWxwZXIucHJvcHNbNV0sIG1hdHJpeEhlbHBlci5wcm9wc1s2XSwgbWF0cml4SGVscGVyLnByb3BzWzddLCBtYXRyaXhIZWxwZXIucHJvcHNbOF0sIG1hdHJpeEhlbHBlci5wcm9wc1s5XSwgbWF0cml4SGVscGVyLnByb3BzWzEwXSwgbWF0cml4SGVscGVyLnByb3BzWzExXSwgbWF0cml4SGVscGVyLnByb3BzWzEyXSwgbWF0cml4SGVscGVyLnByb3BzWzEzXSwgbWF0cml4SGVscGVyLnByb3BzWzE0XSwgbWF0cml4SGVscGVyLnByb3BzWzE1XV07XG4gICAgICAgIH1cbiAgICAgICAgbGV0dGVyTyA9IGVsZW1PcGFjaXR5O1xuICAgICAgfVxuICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyc0NvdW50IDw9IGkpIHtcbiAgICAgICAgbGV0dGVyVmFsdWUgPSBuZXcgTGV0dGVyUHJvcHMobGV0dGVyTywgbGV0dGVyU3csIGxldHRlclNjLCBsZXR0ZXJGYywgbGV0dGVyTSwgbGV0dGVyUCk7XG4gICAgICAgIHRoaXMucmVuZGVyZWRMZXR0ZXJzLnB1c2gobGV0dGVyVmFsdWUpO1xuICAgICAgICByZW5kZXJlZExldHRlcnNDb3VudCArPSAxO1xuICAgICAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXR0ZXJWYWx1ZSA9IHRoaXMucmVuZGVyZWRMZXR0ZXJzW2ldO1xuICAgICAgICB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyA9IGxldHRlclZhbHVlLnVwZGF0ZShsZXR0ZXJPLCBsZXR0ZXJTdywgbGV0dGVyU2MsIGxldHRlckZjLCBsZXR0ZXJNLCBsZXR0ZXJQKSB8fCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZztcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fZWxlbS5nbG9iYWxEYXRhLmZyYW1lSWQgPT09IHRoaXMuX2ZyYW1lSWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fZnJhbWVJZCA9IHRoaXMuX2VsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuICAgIHRoaXMuaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzKCk7XG4gIH07XG4gIFRleHRBbmltYXRvclByb3BlcnR5LnByb3RvdHlwZS5tSGVscGVyID0gbmV3IE1hdHJpeCgpO1xuICBUZXh0QW5pbWF0b3JQcm9wZXJ0eS5wcm90b3R5cGUuZGVmYXVsdFByb3BzQXJyYXkgPSBbXTtcbiAgZXh0ZW5kUHJvdG90eXBlKFtEeW5hbWljUHJvcGVydHlDb250YWluZXJdLCBUZXh0QW5pbWF0b3JQcm9wZXJ0eSk7XG5cbiAgZnVuY3Rpb24gSVRleHRFbGVtZW50KCkge31cbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgPSB0cnVlO1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy50ZXh0UHJvcGVydHkgPSBuZXcgVGV4dFByb3BlcnR5KHRoaXMsIGRhdGEudCwgdGhpcy5keW5hbWljUHJvcGVydGllcyk7XG4gICAgdGhpcy50ZXh0QW5pbWF0b3IgPSBuZXcgVGV4dEFuaW1hdG9yUHJvcGVydHkoZGF0YS50LCB0aGlzLnJlbmRlclR5cGUsIHRoaXMpO1xuICAgIHRoaXMuaW5pdFRyYW5zZm9ybShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRIaWVyYXJjaHkoKTtcbiAgICB0aGlzLmluaXRSZW5kZXJhYmxlKCk7XG4gICAgdGhpcy5pbml0UmVuZGVyZXJFbGVtZW50KCk7XG4gICAgdGhpcy5jcmVhdGVDb250YWluZXJFbGVtZW50cygpO1xuICAgIHRoaXMuY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHMoKTtcbiAgICB0aGlzLmNyZWF0ZUNvbnRlbnQoKTtcbiAgICB0aGlzLmhpZGUoKTtcbiAgICB0aGlzLnRleHRBbmltYXRvci5zZWFyY2hQcm9wZXJ0aWVzKHRoaXMuZHluYW1pY1Byb3BlcnRpZXMpO1xuICB9O1xuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLl9tZGYgPSBmYWxzZTtcbiAgICB0aGlzLnByZXBhcmVSZW5kZXJhYmxlRnJhbWUobnVtKTtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdGhpcy5pc0luUmFuZ2UpO1xuICB9O1xuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVBhdGhTaGFwZSA9IGZ1bmN0aW9uIChtYXRyaXhIZWxwZXIsIHNoYXBlcykge1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuID0gc2hhcGVzLmxlbmd0aDtcbiAgICB2YXIgcGF0aE5vZGVzO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgIGlmIChzaGFwZXNbal0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgcGF0aE5vZGVzID0gc2hhcGVzW2pdLmtzLms7XG4gICAgICAgIHNoYXBlU3RyICs9IGJ1aWxkU2hhcGVTdHJpbmcocGF0aE5vZGVzLCBwYXRoTm9kZXMuaS5sZW5ndGgsIHRydWUsIG1hdHJpeEhlbHBlcik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzaGFwZVN0cjtcbiAgfTtcbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS51cGRhdGVEb2N1bWVudERhdGEgPSBmdW5jdGlvbiAobmV3RGF0YSwgaW5kZXgpIHtcbiAgICB0aGlzLnRleHRQcm9wZXJ0eS51cGRhdGVEb2N1bWVudERhdGEobmV3RGF0YSwgaW5kZXgpO1xuICB9O1xuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmNhblJlc2l6ZUZvbnQgPSBmdW5jdGlvbiAoX2NhblJlc2l6ZSkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LmNhblJlc2l6ZUZvbnQoX2NhblJlc2l6ZSk7XG4gIH07XG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuc2V0TWluaW11bUZvbnRTaXplID0gZnVuY3Rpb24gKF9mb250U2l6ZSkge1xuICAgIHRoaXMudGV4dFByb3BlcnR5LnNldE1pbmltdW1Gb250U2l6ZShfZm9udFNpemUpO1xuICB9O1xuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmFwcGx5VGV4dFByb3BlcnRpZXNUb01hdHJpeCA9IGZ1bmN0aW9uIChkb2N1bWVudERhdGEsIG1hdHJpeEhlbHBlciwgbGluZU51bWJlciwgeFBvcywgeVBvcykge1xuICAgIGlmIChkb2N1bWVudERhdGEucHMpIHtcbiAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLnBzWzBdLCBkb2N1bWVudERhdGEucHNbMV0gKyBkb2N1bWVudERhdGEuYXNjZW50LCAwKTtcbiAgICB9XG4gICAgbWF0cml4SGVscGVyLnRyYW5zbGF0ZSgwLCAtZG9jdW1lbnREYXRhLmxzLCAwKTtcbiAgICBzd2l0Y2ggKGRvY3VtZW50RGF0YS5qKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGluZU51bWJlcl0pLCAwLCAwKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoZG9jdW1lbnREYXRhLmp1c3RpZnlPZmZzZXQgKyAoZG9jdW1lbnREYXRhLmJveFdpZHRoIC0gZG9jdW1lbnREYXRhLmxpbmVXaWR0aHNbbGluZU51bWJlcl0pIC8gMiwgMCwgMCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIG1hdHJpeEhlbHBlci50cmFuc2xhdGUoeFBvcywgeVBvcywgMCk7XG4gIH07XG4gIElUZXh0RWxlbWVudC5wcm90b3R5cGUuYnVpbGRDb2xvciA9IGZ1bmN0aW9uIChjb2xvckRhdGEpIHtcbiAgICByZXR1cm4gJ3JnYignICsgTWF0aC5yb3VuZChjb2xvckRhdGFbMF0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChjb2xvckRhdGFbMV0gKiAyNTUpICsgJywnICsgTWF0aC5yb3VuZChjb2xvckRhdGFbMl0gKiAyNTUpICsgJyknO1xuICB9O1xuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmVtcHR5UHJvcCA9IG5ldyBMZXR0ZXJQcm9wcygpO1xuICBJVGV4dEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7fTtcbiAgSVRleHRFbGVtZW50LnByb3RvdHlwZS52YWxpZGF0ZVRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMudGV4dFByb3BlcnR5Ll9tZGYgfHwgdGhpcy50ZXh0UHJvcGVydHkuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgdGhpcy5idWlsZE5ld1RleHQoKTtcbiAgICAgIHRoaXMudGV4dFByb3BlcnR5Ll9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIHRoaXMudGV4dFByb3BlcnR5Ll9tZGYgPSBmYWxzZTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGVtcHR5U2hhcGVEYXRhID0ge1xuICAgIHNoYXBlczogW11cbiAgfTtcbiAgZnVuY3Rpb24gU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMudGV4dFNwYW5zID0gW107XG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ3N2Zyc7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBTVkdCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRE9NRWxlbWVudCwgSVRleHRFbGVtZW50XSwgU1ZHVGV4dExvdHRpZUVsZW1lbnQpO1xuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5kYXRhLnNpbmdsZVNoYXBlICYmICF0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuY2hhcnMpIHtcbiAgICAgIHRoaXMudGV4dENvbnRhaW5lciA9IGNyZWF0ZU5TKCd0ZXh0Jyk7XG4gICAgfVxuICB9O1xuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuYnVpbGRUZXh0Q29udGVudHMgPSBmdW5jdGlvbiAodGV4dEFycmF5KSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0ZXh0QXJyYXkubGVuZ3RoO1xuICAgIHZhciB0ZXh0Q29udGVudHMgPSBbXTtcbiAgICB2YXIgY3VycmVudFRleHRDb250ZW50ID0gJyc7XG4gICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgIGlmICh0ZXh0QXJyYXlbaV0gPT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMTMpIHx8IHRleHRBcnJheVtpXSA9PT0gU3RyaW5nLmZyb21DaGFyQ29kZSgzKSkge1xuICAgICAgICB0ZXh0Q29udGVudHMucHVzaChjdXJyZW50VGV4dENvbnRlbnQpO1xuICAgICAgICBjdXJyZW50VGV4dENvbnRlbnQgPSAnJztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGN1cnJlbnRUZXh0Q29udGVudCArPSB0ZXh0QXJyYXlbaV07XG4gICAgICB9XG4gICAgICBpICs9IDE7XG4gICAgfVxuICAgIHRleHRDb250ZW50cy5wdXNoKGN1cnJlbnRUZXh0Q29udGVudCk7XG4gICAgcmV0dXJuIHRleHRDb250ZW50cztcbiAgfTtcbiAgU1ZHVGV4dExvdHRpZUVsZW1lbnQucHJvdG90eXBlLmJ1aWxkU2hhcGVEYXRhID0gZnVuY3Rpb24gKGRhdGEsIHNjYWxlKSB7XG4gICAgLy8gZGF0YSBzaG91bGQgcHJvYmFibHkgYmUgY2xvbmVkIHRvIGFwcGx5IHNjYWxlIHNlcGFyYXRlbHkgdG8gZWFjaCBpbnN0YW5jZSBvZiBhIHRleHQgb24gZGlmZmVyZW50IGxheWVyc1xuICAgIC8vIGJ1dCBzaW5jZSB0ZXh0IGludGVybmFsIGNvbnRlbnQgZ2V0cyBvbmx5IHJlbmRlcmVkIG9uY2UgYW5kIHRoZW4gaXQncyBuZXZlciByZXJlbmRlcmVkLFxuICAgIC8vIGl0J3MgcHJvYmFibHkgc2FmZSBub3QgdG8gY2xvbmUgZGF0YSBhbmQgcmV1c2UgYWx3YXlzIHRoZSBzYW1lIGluc3RhbmNlIGV2ZW4gaWYgdGhlIG9iamVjdCBpcyBtdXRhdGVkLlxuICAgIC8vIEF2b2lkaW5nIGNsb25pbmcgaXMgcHJlZmVycmVkIHNpbmNlIGNsb25pbmcgZWFjaCBjaGFyYWN0ZXIgc2hhcGUgZGF0YSBpcyBleHBlbnNpdmVcbiAgICBpZiAoZGF0YS5zaGFwZXMgJiYgZGF0YS5zaGFwZXMubGVuZ3RoKSB7XG4gICAgICB2YXIgc2hhcGUgPSBkYXRhLnNoYXBlc1swXTtcbiAgICAgIGlmIChzaGFwZS5pdCkge1xuICAgICAgICB2YXIgc2hhcGVJdGVtID0gc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChzaGFwZUl0ZW0ucykge1xuICAgICAgICAgIHNoYXBlSXRlbS5zLmtbMF0gPSBzY2FsZTtcbiAgICAgICAgICBzaGFwZUl0ZW0ucy5rWzFdID0gc2NhbGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH07XG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5idWlsZE5ld1RleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hZGREeW5hbWljUHJvcGVydHkodGhpcyk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YSA/IGRvY3VtZW50RGF0YS5sLmxlbmd0aCA6IDApO1xuICAgIGlmIChkb2N1bWVudERhdGEuZmMpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmaWxsJywgJ3JnYmEoMCwwLDAsMCknKTtcbiAgICB9XG4gICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdzdHJva2UnLCB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLnNjKSk7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIGRvY3VtZW50RGF0YS5zdyk7XG4gICAgfVxuICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9udC1zaXplJywgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSk7XG4gICAgdmFyIGZvbnREYXRhID0gdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpO1xuICAgIGlmIChmb250RGF0YS5mQ2xhc3MpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBmb250RGF0YS5mQ2xhc3MpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtZmFtaWx5JywgZm9udERhdGEuZkZhbWlseSk7XG4gICAgICB2YXIgZldlaWdodCA9IGRvY3VtZW50RGF0YS5mV2VpZ2h0O1xuICAgICAgdmFyIGZTdHlsZSA9IGRvY3VtZW50RGF0YS5mU3R5bGU7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2ZvbnQtc3R5bGUnLCBmU3R5bGUpO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdmb250LXdlaWdodCcsIGZXZWlnaHQpO1xuICAgIH1cbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCBkb2N1bWVudERhdGEudCk7XG4gICAgdmFyIGxldHRlcnMgPSBkb2N1bWVudERhdGEubCB8fCBbXTtcbiAgICB2YXIgdXNlc0dseXBocyA9ICEhdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzO1xuICAgIGxlbiA9IGxldHRlcnMubGVuZ3RoO1xuICAgIHZhciB0U3BhbjtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHZhciBzaGFwZVN0ciA9ICcnO1xuICAgIHZhciBzaW5nbGVTaGFwZSA9IHRoaXMuZGF0YS5zaW5nbGVTaGFwZTtcbiAgICB2YXIgeFBvcyA9IDA7XG4gICAgdmFyIHlQb3MgPSAwO1xuICAgIHZhciBmaXJzdExpbmUgPSB0cnVlO1xuICAgIHZhciB0cmFja2luZ09mZnNldCA9IGRvY3VtZW50RGF0YS50ciAqIDAuMDAxICogZG9jdW1lbnREYXRhLmZpbmFsU2l6ZTtcbiAgICBpZiAoc2luZ2xlU2hhcGUgJiYgIXVzZXNHbHlwaHMgJiYgIWRvY3VtZW50RGF0YS5zeikge1xuICAgICAgdmFyIHRFbGVtZW50ID0gdGhpcy50ZXh0Q29udGFpbmVyO1xuICAgICAgdmFyIGp1c3RpZnkgPSAnc3RhcnQnO1xuICAgICAgc3dpdGNoIChkb2N1bWVudERhdGEuaikge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAganVzdGlmeSA9ICdlbmQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAganVzdGlmeSA9ICdtaWRkbGUnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGp1c3RpZnkgPSAnc3RhcnQnO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgdEVsZW1lbnQuc2V0QXR0cmlidXRlKCd0ZXh0LWFuY2hvcicsIGp1c3RpZnkpO1xuICAgICAgdEVsZW1lbnQuc2V0QXR0cmlidXRlKCdsZXR0ZXItc3BhY2luZycsIHRyYWNraW5nT2Zmc2V0KTtcbiAgICAgIHZhciB0ZXh0Q29udGVudCA9IHRoaXMuYnVpbGRUZXh0Q29udGVudHMoZG9jdW1lbnREYXRhLmZpbmFsVGV4dCk7XG4gICAgICBsZW4gPSB0ZXh0Q29udGVudC5sZW5ndGg7XG4gICAgICB5UG9zID0gZG9jdW1lbnREYXRhLnBzID8gZG9jdW1lbnREYXRhLnBzWzFdICsgZG9jdW1lbnREYXRhLmFzY2VudCA6IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdFNwYW4gPSB0aGlzLnRleHRTcGFuc1tpXS5zcGFuIHx8IGNyZWF0ZU5TKCd0c3BhbicpO1xuICAgICAgICB0U3Bhbi50ZXh0Q29udGVudCA9IHRleHRDb250ZW50W2ldO1xuICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd5JywgeVBvcyk7XG4gICAgICAgIHRTcGFuLnN0eWxlLmRpc3BsYXkgPSAnaW5oZXJpdCc7XG4gICAgICAgIHRFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgaWYgKCF0aGlzLnRleHRTcGFuc1tpXSkge1xuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldID0ge1xuICAgICAgICAgICAgc3BhbjogbnVsbCxcbiAgICAgICAgICAgIGdseXBoOiBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRleHRTcGFuc1tpXS5zcGFuID0gdFNwYW47XG4gICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLmZpbmFsTGluZUhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRFbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGNhY2hlZFNwYW5zTGVuZ3RoID0gdGhpcy50ZXh0U3BhbnMubGVuZ3RoO1xuICAgICAgdmFyIGNoYXJEYXRhO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0U3BhbnNbaV0pIHtcbiAgICAgICAgICB0aGlzLnRleHRTcGFuc1tpXSA9IHtcbiAgICAgICAgICAgIHNwYW46IG51bGwsXG4gICAgICAgICAgICBjaGlsZFNwYW46IG51bGwsXG4gICAgICAgICAgICBnbHlwaDogbnVsbFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF1c2VzR2x5cGhzIHx8ICFzaW5nbGVTaGFwZSB8fCBpID09PSAwKSB7XG4gICAgICAgICAgdFNwYW4gPSBjYWNoZWRTcGFuc0xlbmd0aCA+IGkgPyB0aGlzLnRleHRTcGFuc1tpXS5zcGFuIDogY3JlYXRlTlModXNlc0dseXBocyA/ICdnJyA6ICd0ZXh0Jyk7XG4gICAgICAgICAgaWYgKGNhY2hlZFNwYW5zTGVuZ3RoIDw9IGkpIHtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAnYnV0dCcpO1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKTtcbiAgICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLW1pdGVybGltaXQnLCAnNCcpO1xuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uc3BhbiA9IHRTcGFuO1xuICAgICAgICAgICAgaWYgKHVzZXNHbHlwaHMpIHtcbiAgICAgICAgICAgICAgdmFyIGNoaWxkU3BhbiA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgICAgICAgIHRTcGFuLmFwcGVuZENoaWxkKGNoaWxkU3Bhbik7XG4gICAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmNoaWxkU3BhbiA9IGNoaWxkU3BhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLnNwYW4gPSB0U3BhbjtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdFNwYW4uc3R5bGUuZGlzcGxheSA9ICdpbmhlcml0JztcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcbiAgICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XG4gICAgICAgICAgaWYgKGxldHRlcnNbaV0ubikge1xuICAgICAgICAgICAgeFBvcyA9IC10cmFja2luZ09mZnNldDtcbiAgICAgICAgICAgIHlQb3MgKz0gZG9jdW1lbnREYXRhLnlPZmZzZXQ7XG4gICAgICAgICAgICB5UG9zICs9IGZpcnN0TGluZSA/IDEgOiAwO1xuICAgICAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuYXBwbHlUZXh0UHJvcGVydGllc1RvTWF0cml4KGRvY3VtZW50RGF0YSwgbWF0cml4SGVscGVyLCBsZXR0ZXJzW2ldLmxpbmUsIHhQb3MsIHlQb3MpO1xuICAgICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sIHx8IDA7XG4gICAgICAgICAgLy8geFBvcyArPSBsZXR0ZXJzW2ldLnZhbCA9PT0gJyAnID8gMCA6IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgICAgIHhQb3MgKz0gdHJhY2tpbmdPZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVzZXNHbHlwaHMpIHtcbiAgICAgICAgICBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgICAgICB2YXIgZ2x5cGhFbGVtZW50O1xuICAgICAgICAgIC8vIHQgPT09IDEgbWVhbnMgdGhlIGNoYXJhY3RlciBoYXMgYmVlbiByZXBsYWNlZCB3aXRoIGFuIGFuaW1hdGVkIHNoYXBlZFxuICAgICAgICAgIGlmIChjaGFyRGF0YS50ID09PSAxKSB7XG4gICAgICAgICAgICBnbHlwaEVsZW1lbnQgPSBuZXcgU1ZHQ29tcEVsZW1lbnQoY2hhckRhdGEuZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBlbXB0eVNoYXBlRGF0YTtcbiAgICAgICAgICAgIGlmIChjaGFyRGF0YS5kYXRhICYmIGNoYXJEYXRhLmRhdGEuc2hhcGVzKSB7XG4gICAgICAgICAgICAgIGRhdGEgPSB0aGlzLmJ1aWxkU2hhcGVEYXRhKGNoYXJEYXRhLmRhdGEsIGRvY3VtZW50RGF0YS5maW5hbFNpemUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZ2x5cGhFbGVtZW50ID0gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy50ZXh0U3BhbnNbaV0uZ2x5cGgpIHtcbiAgICAgICAgICAgIHZhciBnbHlwaCA9IHRoaXMudGV4dFNwYW5zW2ldLmdseXBoO1xuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuLnJlbW92ZUNoaWxkKGdseXBoLmxheWVyRWxlbWVudCk7XG4gICAgICAgICAgICBnbHlwaC5kZXN0cm95KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMudGV4dFNwYW5zW2ldLmdseXBoID0gZ2x5cGhFbGVtZW50O1xuICAgICAgICAgIGdseXBoRWxlbWVudC5fZGVidWcgPSB0cnVlO1xuICAgICAgICAgIGdseXBoRWxlbWVudC5wcmVwYXJlRnJhbWUoMCk7XG4gICAgICAgICAgZ2x5cGhFbGVtZW50LnJlbmRlckZyYW1lKCk7XG4gICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuLmFwcGVuZENoaWxkKGdseXBoRWxlbWVudC5sYXllckVsZW1lbnQpO1xuICAgICAgICAgIC8vIHdoZW4gdXNpbmcgYW5pbWF0ZWQgc2hhcGVzLCB0aGUgbGF5ZXIgd2lsbCBiZSBzY2FsZWQgaW5zdGVhZCBvZiByZXBsYWNpbmcgdGhlIGludGVybmFsIHNjYWxlXG4gICAgICAgICAgLy8gdGhpcyBtaWdodCBoYXZlIGlzc3VlcyB3aXRoIHN0cm9rZXMgYW5kIG1pZ2h0IG5lZWQgYSBkaWZmZXJlbnQgc29sdXRpb25cbiAgICAgICAgICBpZiAoY2hhckRhdGEudCA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy50ZXh0U3BhbnNbaV0uY2hpbGRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgJ3NjYWxlKCcgKyBkb2N1bWVudERhdGEuZmluYWxTaXplIC8gMTAwICsgJywnICsgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCArICcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzaW5nbGVTaGFwZSkge1xuICAgICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCd0cmFuc2Zvcm0nLCAndHJhbnNsYXRlKCcgKyBtYXRyaXhIZWxwZXIucHJvcHNbMTJdICsgJywnICsgbWF0cml4SGVscGVyLnByb3BzWzEzXSArICcpJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRTcGFuLnRleHRDb250ZW50ID0gbGV0dGVyc1tpXS52YWw7XG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICd4bWw6c3BhY2UnLCAncHJlc2VydmUnKTtcbiAgICAgICAgfVxuICAgICAgICAvL1xuICAgICAgfVxuICAgICAgaWYgKHNpbmdsZVNoYXBlICYmIHRTcGFuKSB7XG4gICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnZCcsIHNoYXBlU3RyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKGkgPCB0aGlzLnRleHRTcGFucy5sZW5ndGgpIHtcbiAgICAgIHRoaXMudGV4dFNwYW5zW2ldLnNwYW4uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgdGhpcy5fc2l6ZUNoYW5nZWQgPSB0cnVlO1xuICB9O1xuICBTVkdUZXh0TG90dGllRWxlbWVudC5wcm90b3R5cGUuc291cmNlUmVjdEF0VGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnByZXBhcmVGcmFtZSh0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMuZGF0YS5zdCk7XG4gICAgdGhpcy5yZW5kZXJJbm5lckNvbnRlbnQoKTtcbiAgICBpZiAodGhpcy5fc2l6ZUNoYW5nZWQpIHtcbiAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gZmFsc2U7XG4gICAgICB2YXIgdGV4dEJveCA9IHRoaXMubGF5ZXJFbGVtZW50LmdldEJCb3goKTtcbiAgICAgIHRoaXMuYmJveCA9IHtcbiAgICAgICAgdG9wOiB0ZXh0Qm94LnksXG4gICAgICAgIGxlZnQ6IHRleHRCb3gueCxcbiAgICAgICAgd2lkdGg6IHRleHRCb3gud2lkdGgsXG4gICAgICAgIGhlaWdodDogdGV4dEJveC5oZWlnaHRcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmJib3g7XG4gIH07XG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5nZXRWYWx1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy50ZXh0U3BhbnMubGVuZ3RoO1xuICAgIHZhciBnbHlwaEVsZW1lbnQ7XG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWU7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcbiAgICAgIGlmIChnbHlwaEVsZW1lbnQpIHtcbiAgICAgICAgZ2x5cGhFbGVtZW50LnByZXBhcmVGcmFtZSh0aGlzLmNvbXAucmVuZGVyZWRGcmFtZSAtIHRoaXMuZGF0YS5zdCk7XG4gICAgICAgIGlmIChnbHlwaEVsZW1lbnQuX21kZikge1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIFNWR1RleHRMb3R0aWVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy52YWxpZGF0ZVRleHQoKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5zaW5nbGVTaGFwZSB8fCB0aGlzLl9tZGYpIHtcbiAgICAgIHRoaXMudGV4dEFuaW1hdG9yLmdldE1lYXN1cmVzKHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLCB0aGlzLmxldHRlcnNDaGFuZ2VkRmxhZyk7XG4gICAgICBpZiAodGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgfHwgdGhpcy50ZXh0QW5pbWF0b3IubGV0dGVyc0NoYW5nZWRGbGFnKSB7XG4gICAgICAgIHRoaXMuX3NpemVDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW47XG4gICAgICAgIHZhciByZW5kZXJlZExldHRlcnMgPSB0aGlzLnRleHRBbmltYXRvci5yZW5kZXJlZExldHRlcnM7XG4gICAgICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICAgICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgICAgIHZhciByZW5kZXJlZExldHRlcjtcbiAgICAgICAgdmFyIHRleHRTcGFuO1xuICAgICAgICB2YXIgZ2x5cGhFbGVtZW50O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBpZiAoIWxldHRlcnNbaV0ubikge1xuICAgICAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldLnNwYW47XG4gICAgICAgICAgICBnbHlwaEVsZW1lbnQgPSB0aGlzLnRleHRTcGFuc1tpXS5nbHlwaDtcbiAgICAgICAgICAgIGlmIChnbHlwaEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgZ2x5cGhFbGVtZW50LnJlbmRlckZyYW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5tKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgndHJhbnNmb3JtJywgcmVuZGVyZWRMZXR0ZXIubSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5vKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScsIHJlbmRlcmVkTGV0dGVyLm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLl9tZGYuc3cpIHtcbiAgICAgICAgICAgICAgdGV4dFNwYW4uc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCByZW5kZXJlZExldHRlci5zdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuX21kZi5zYykge1xuICAgICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsIHJlbmRlcmVkTGV0dGVyLnNjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLmZjKSB7XG4gICAgICAgICAgICAgIHRleHRTcGFuLnNldEF0dHJpYnV0ZSgnZmlsbCcsIHJlbmRlcmVkTGV0dGVyLmZjKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSVNvbGlkRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0lJbWFnZUVsZW1lbnRdLCBJU29saWRFbGVtZW50KTtcbiAgSVNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdCA9IGNyZWF0ZU5TKCdyZWN0Jyk7XG4gICAgLy8vIC9yZWN0LnN0eWxlLndpZHRoID0gdGhpcy5kYXRhLnN3O1xuICAgIC8vLyAvcmVjdC5zdHlsZS5oZWlnaHQgPSB0aGlzLmRhdGEuc2g7XG4gICAgLy8vIC9yZWN0LnN0eWxlLmZpbGwgPSB0aGlzLmRhdGEuc2M7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLnN3KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLnNoKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnZmlsbCcsIHRoaXMuZGF0YS5zYyk7XG4gICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQocmVjdCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTnVsbEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gIH1cbiAgTnVsbEVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHt9O1xuICBOdWxsRWxlbWVudC5wcm90b3R5cGUuZ2V0QmFzZUVsZW1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5zb3VyY2VSZWN0QXRUaW1lID0gZnVuY3Rpb24gKCkge307XG4gIE51bGxFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge307XG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudF0sIE51bGxFbGVtZW50KTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlckJhc2UoKSB7fVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VSZW5kZXJlcl0sIFNWR1JlbmRlcmVyQmFzZSk7XG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBOdWxsRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNoYXBlID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IFNWR1NoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHVGV4dExvdHRpZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBJSW1hZ2VFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU29saWQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmNvbmZpZ0FuaW1hdGlvbiA9IGZ1bmN0aW9uIChhbmltRGF0YSkge1xuICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyk7XG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgneG1sbnM6eGxpbmsnLCAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycpO1xuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94U2l6ZSkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsIHRoaXMucmVuZGVyQ29uZmlnLnZpZXdCb3hTaXplKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgndmlld0JveCcsICcwIDAgJyArIGFuaW1EYXRhLncgKyAnICcgKyBhbmltRGF0YS5oKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy52aWV3Qm94T25seSkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGFuaW1EYXRhLmgpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS50cmFuc2Zvcm0gPSAndHJhbnNsYXRlM2QoMCwwLDApJztcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zdHlsZS5jb250ZW50VmlzaWJpbGl0eSA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5O1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcud2lkdGgpIHtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5yZW5kZXJDb25maWcud2lkdGgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuaGVpZ2h0KSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLnJlbmRlckNvbmZpZy5oZWlnaHQpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMucmVuZGVyQ29uZmlnLmNsYXNzTmFtZSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5pZCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnJlbmRlckNvbmZpZy5pZCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5mb2N1c2FibGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnZm9jdXNhYmxlJywgdGhpcy5yZW5kZXJDb25maWcuZm9jdXNhYmxlKTtcbiAgICB9XG4gICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgncHJlc2VydmVBc3BlY3RSYXRpbycsIHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8pO1xuICAgIC8vIHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLnRyYW5zZm9ybSA9ICd0cmFuc2xhdGUzZCgwLDAsMCknO1xuICAgIC8vIHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLnRyYW5zZm9ybU9yaWdpbiA9IHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLm1velRyYW5zZm9ybU9yaWdpbiA9IHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlWyctd2Via2l0LXRyYW5zZm9ybSddID0gXCIwcHggMHB4IDBweFwiO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XG4gICAgLy8gTWFzayBhbmltYXRpb25cbiAgICB2YXIgZGVmcyA9IHRoaXMuZ2xvYmFsRGF0YS5kZWZzO1xuICAgIHRoaXMuc2V0dXBHbG9iYWxEYXRhKGFuaW1EYXRhLCBkZWZzKTtcbiAgICB0aGlzLmdsb2JhbERhdGEucHJvZ3Jlc3NpdmVMb2FkID0gdGhpcy5yZW5kZXJDb25maWcucHJvZ3Jlc3NpdmVMb2FkO1xuICAgIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xuICAgIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCdjbGlwUGF0aCcpO1xuICAgIHZhciByZWN0ID0gY3JlYXRlTlMoJ3JlY3QnKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBhbmltRGF0YS53KTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgYW5pbURhdGEuaCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3gnLCAwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZSgneScsIDApO1xuICAgIHZhciBtYXNrSWQgPSBjcmVhdGVFbGVtZW50SUQoKTtcbiAgICBtYXNrRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgbWFza0lkKTtcbiAgICBtYXNrRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2NsaXAtcGF0aCcsICd1cmwoJyArIGdldExvY2F0aW9uSHJlZigpICsgJyMnICsgbWFza0lkICsgJyknKTtcbiAgICBkZWZzLmFwcGVuZENoaWxkKG1hc2tFbGVtZW50KTtcbiAgICB0aGlzLmxheWVycyA9IGFuaW1EYXRhLmxheWVycztcbiAgICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheShhbmltRGF0YS5sYXllcnMubGVuZ3RoKTtcbiAgfTtcbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuaW5uZXJUZXh0ID0gJyc7XG4gICAgfVxuICAgIHRoaXMubGF5ZXJFbGVtZW50ID0gbnVsbDtcbiAgICB0aGlzLmdsb2JhbERhdGEuZGVmcyA9IG51bGw7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzID8gdGhpcy5sYXllcnMubGVuZ3RoIDogMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5lbGVtZW50cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBudWxsO1xuICB9O1xuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLnVwZGF0ZUNvbnRhaW5lclNpemUgPSBmdW5jdGlvbiAoKSB7fTtcbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5maW5kSW5kZXhCeUluZCA9IGZ1bmN0aW9uIChpbmQpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmxheWVyc1tpXS5pbmQgPT09IGluZCkge1xuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9O1xuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkSXRlbSA9IGZ1bmN0aW9uIChwb3MpIHtcbiAgICB2YXIgZWxlbWVudHMgPSB0aGlzLmVsZW1lbnRzO1xuICAgIGlmIChlbGVtZW50c1twb3NdIHx8IHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDk5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGVsZW1lbnRzW3Bvc10gPSB0cnVlO1xuICAgIHZhciBlbGVtZW50ID0gdGhpcy5jcmVhdGVJdGVtKHRoaXMubGF5ZXJzW3Bvc10pO1xuICAgIGVsZW1lbnRzW3Bvc10gPSBlbGVtZW50O1xuICAgIGlmIChnZXRFeHByZXNzaW9uc1BsdWdpbigpKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50eSA9PT0gMCkge1xuICAgICAgICB0aGlzLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGVsZW1lbnQpO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5pbml0RXhwcmVzc2lvbnMoKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRFbGVtZW50SW5Qb3MoZWxlbWVudCwgcG9zKTtcbiAgICBpZiAodGhpcy5sYXllcnNbcG9zXS50dCkge1xuICAgICAgdmFyIGVsZW1lbnRJbmRleCA9ICd0cCcgaW4gdGhpcy5sYXllcnNbcG9zXSA/IHRoaXMuZmluZEluZGV4QnlJbmQodGhpcy5sYXllcnNbcG9zXS50cCkgOiBwb3MgLSAxO1xuICAgICAgaWYgKGVsZW1lbnRJbmRleCA9PT0gLTEpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmVsZW1lbnRzW2VsZW1lbnRJbmRleF0gfHwgdGhpcy5lbGVtZW50c1tlbGVtZW50SW5kZXhdID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuYnVpbGRJdGVtKGVsZW1lbnRJbmRleCk7XG4gICAgICAgIHRoaXMuYWRkUGVuZGluZ0VsZW1lbnQoZWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbWF0dGVFbGVtZW50ID0gZWxlbWVudHNbZWxlbWVudEluZGV4XTtcbiAgICAgICAgdmFyIG1hdHRlTWFzayA9IG1hdHRlRWxlbWVudC5nZXRNYXR0ZSh0aGlzLmxheWVyc1twb3NdLnR0KTtcbiAgICAgICAgZWxlbWVudC5zZXRNYXR0ZShtYXR0ZU1hc2spO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuICAgICAgaWYgKGVsZW1lbnQuZGF0YS50dCkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLmVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSA9PT0gZWxlbWVudCkge1xuICAgICAgICAgICAgdmFyIGVsZW1lbnRJbmRleCA9ICd0cCcgaW4gZWxlbWVudC5kYXRhID8gdGhpcy5maW5kSW5kZXhCeUluZChlbGVtZW50LmRhdGEudHApIDogaSAtIDE7XG4gICAgICAgICAgICB2YXIgbWF0dGVFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tlbGVtZW50SW5kZXhdO1xuICAgICAgICAgICAgdmFyIG1hdHRlTWFzayA9IG1hdHRlRWxlbWVudC5nZXRNYXR0ZSh0aGlzLmxheWVyc1tpXS50dCk7XG4gICAgICAgICAgICBlbGVtZW50LnNldE1hdHRlKG1hdHRlTWFzayk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBTVkdSZW5kZXJlckJhc2UucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xuICAgIGlmICh0aGlzLnJlbmRlcmVkRnJhbWUgPT09IG51bSB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAobnVtID09PSBudWxsKSB7XG4gICAgICBudW0gPSB0aGlzLnJlbmRlcmVkRnJhbWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bTtcbiAgICB9XG4gICAgLy8gY29uc29sZS5sb2coJy0tLS0tLS0nKTtcbiAgICAvLyBjb25zb2xlLmxvZygnRlJBTUUgJyxudW0pO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5mcmFtZU51bSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmN1cnJlbnRGcmFtZSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuX21kZiA9IGZhbHNlO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgaWYgKCF0aGlzLmNvbXBsZXRlTGF5ZXJzKSB7XG4gICAgICB0aGlzLmNoZWNrTGF5ZXJzKG51bSk7XG4gICAgfVxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKG51bSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5fbWRmKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5hcHBlbmRFbGVtZW50SW5Qb3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgcG9zKSB7XG4gICAgdmFyIG5ld0VsZW1lbnQgPSBlbGVtZW50LmdldEJhc2VFbGVtZW50KCk7XG4gICAgaWYgKCFuZXdFbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbmV4dEVsZW1lbnQ7XG4gICAgd2hpbGUgKGkgPCBwb3MpIHtcbiAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2ldICYmIHRoaXMuZWxlbWVudHNbaV0gIT09IHRydWUgJiYgdGhpcy5lbGVtZW50c1tpXS5nZXRCYXNlRWxlbWVudCgpKSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tpXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICBpZiAobmV4dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShuZXdFbGVtZW50LCBuZXh0RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKG5ld0VsZW1lbnQpO1xuICAgIH1cbiAgfTtcbiAgU1ZHUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMubGF5ZXJFbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG4gIFNWR1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmxheWVyRWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcblxuICBmdW5jdGlvbiBJQ29tcEVsZW1lbnQoKSB7fVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVET01FbGVtZW50XSwgSUNvbXBFbGVtZW50KTtcbiAgSUNvbXBFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RnJhbWUoKTtcbiAgICB0aGlzLmluaXRCYXNlRGF0YShkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLmluaXRUcmFuc2Zvcm0oZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0UmVuZGVyYWJsZSgpO1xuICAgIHRoaXMuaW5pdEhpZXJhcmNoeSgpO1xuICAgIHRoaXMuaW5pdFJlbmRlcmVyRWxlbWVudCgpO1xuICAgIHRoaXMuY3JlYXRlQ29udGFpbmVyRWxlbWVudHMoKTtcbiAgICB0aGlzLmNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCk7XG4gICAgaWYgKHRoaXMuZGF0YS54dCB8fCAhZ2xvYmFsRGF0YS5wcm9ncmVzc2l2ZUxvYWQpIHtcbiAgICAgIHRoaXMuYnVpbGRBbGxJdGVtcygpO1xuICAgIH1cbiAgICB0aGlzLmhpZGUoKTtcbiAgfTtcblxuICAvKiBJQ29tcEVsZW1lbnQucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbigpe1xuICAgICAgaWYoIXRoaXMuaGlkZGVuKXtcbiAgICAgICAgICB0aGlzLmhpZGVFbGVtZW50KCk7XG4gICAgICAgICAgdmFyIGksbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgICAgICAgZm9yKCBpID0gMDsgaSA8IGxlbjsgaSs9MSApe1xuICAgICAgICAgICAgICBpZih0aGlzLmVsZW1lbnRzW2ldKXtcbiAgICAgICAgICAgICAgICAgIHRoaXMuZWxlbWVudHNbaV0uaGlkZSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9OyAqL1xuXG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gZnVuY3Rpb24gKG51bSkge1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMucHJlcGFyZVJlbmRlcmFibGVGcmFtZShudW0pO1xuICAgIHRoaXMucHJlcGFyZVByb3BlcnRpZXMobnVtLCB0aGlzLmlzSW5SYW5nZSk7XG4gICAgaWYgKCF0aGlzLmlzSW5SYW5nZSAmJiAhdGhpcy5kYXRhLnh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy50bS5fcGxhY2Vob2xkZXIpIHtcbiAgICAgIHZhciB0aW1lUmVtYXBwZWQgPSB0aGlzLnRtLnY7XG4gICAgICBpZiAodGltZVJlbWFwcGVkID09PSB0aGlzLmRhdGEub3ApIHtcbiAgICAgICAgdGltZVJlbWFwcGVkID0gdGhpcy5kYXRhLm9wIC0gMTtcbiAgICAgIH1cbiAgICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IHRpbWVSZW1hcHBlZDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gbnVtIC8gdGhpcy5kYXRhLnNyO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgaWYgKCF0aGlzLmNvbXBsZXRlTGF5ZXJzKSB7XG4gICAgICB0aGlzLmNoZWNrTGF5ZXJzKHRoaXMucmVuZGVyZWRGcmFtZSk7XG4gICAgfVxuICAgIC8vIFRoaXMgaXRlcmF0aW9uIG5lZWRzIHRvIGJlIGJhY2t3YXJkcyBiZWNhdXNlIG9mIGhvdyBleHByZXNzaW9ucyBjb25uZWN0IGJldHdlZW4gZWFjaCBvdGhlclxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucHJlcGFyZUZyYW1lKHRoaXMucmVuZGVyZWRGcmFtZSAtIHRoaXMubGF5ZXJzW2ldLnN0KTtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0uX21kZikge1xuICAgICAgICAgIHRoaXMuX21kZiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuc2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoZWxlbXMpIHtcbiAgICB0aGlzLmVsZW1lbnRzID0gZWxlbXM7XG4gIH07XG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuZ2V0RWxlbWVudHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudHM7XG4gIH07XG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIElDb21wRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmRlc3Ryb3lFbGVtZW50cygpO1xuICAgIHRoaXMuZGVzdHJveUJhc2VFbGVtZW50KCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHQ29tcEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gdHJ1ZTtcbiAgICB0aGlzLmNvbXBsZXRlTGF5ZXJzID0gZmFsc2U7XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRzID0gdGhpcy5sYXllcnMgPyBjcmVhdGVTaXplZEFycmF5KHRoaXMubGF5ZXJzLmxlbmd0aCkgOiBbXTtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICAgIHRoaXMudG0gPSBkYXRhLnRtID8gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS50bSwgMCwgZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIHRoaXMpIDoge1xuICAgICAgX3BsYWNlaG9sZGVyOiB0cnVlXG4gICAgfTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW1NWR1JlbmRlcmVyQmFzZSwgSUNvbXBFbGVtZW50LCBTVkdCYXNlRWxlbWVudF0sIFNWR0NvbXBFbGVtZW50KTtcbiAgU1ZHQ29tcEVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTVkdSZW5kZXJlcihhbmltYXRpb25JdGVtLCBjb25maWcpIHtcbiAgICB0aGlzLmFuaW1hdGlvbkl0ZW0gPSBhbmltYXRpb25JdGVtO1xuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLnJlbmRlcmVkRnJhbWUgPSAtMTtcbiAgICB0aGlzLnN2Z0VsZW1lbnQgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgdmFyIGFyaWFMYWJlbCA9ICcnO1xuICAgIGlmIChjb25maWcgJiYgY29uZmlnLnRpdGxlKSB7XG4gICAgICB2YXIgdGl0bGVFbGVtZW50ID0gY3JlYXRlTlMoJ3RpdGxlJyk7XG4gICAgICB2YXIgdGl0bGVJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdGl0bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aXRsZUlkKTtcbiAgICAgIHRpdGxlRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbmZpZy50aXRsZTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZCh0aXRsZUVsZW1lbnQpO1xuICAgICAgYXJpYUxhYmVsICs9IHRpdGxlSWQ7XG4gICAgfVxuICAgIGlmIChjb25maWcgJiYgY29uZmlnLmRlc2NyaXB0aW9uKSB7XG4gICAgICB2YXIgZGVzY0VsZW1lbnQgPSBjcmVhdGVOUygnZGVzYycpO1xuICAgICAgdmFyIGRlc2NJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgZGVzY0VsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIGRlc2NJZCk7XG4gICAgICBkZXNjRWxlbWVudC50ZXh0Q29udGVudCA9IGNvbmZpZy5kZXNjcmlwdGlvbjtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5hcHBlbmRDaGlsZChkZXNjRWxlbWVudCk7XG4gICAgICBhcmlhTGFiZWwgKz0gJyAnICsgZGVzY0lkO1xuICAgIH1cbiAgICBpZiAoYXJpYUxhYmVsKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsbGVkYnknLCBhcmlhTGFiZWwpO1xuICAgIH1cbiAgICB2YXIgZGVmcyA9IGNyZWF0ZU5TKCdkZWZzJyk7XG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKGRlZnMpO1xuICAgIHZhciBtYXNrRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgdGhpcy5zdmdFbGVtZW50LmFwcGVuZENoaWxkKG1hc2tFbGVtZW50KTtcbiAgICB0aGlzLmxheWVyRWxlbWVudCA9IG1hc2tFbGVtZW50O1xuICAgIHRoaXMucmVuZGVyQ29uZmlnID0ge1xuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBtZWV0JyxcbiAgICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIHNsaWNlJyxcbiAgICAgIGNvbnRlbnRWaXNpYmlsaXR5OiBjb25maWcgJiYgY29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5IHx8ICd2aXNpYmxlJyxcbiAgICAgIHByb2dyZXNzaXZlTG9hZDogY29uZmlnICYmIGNvbmZpZy5wcm9ncmVzc2l2ZUxvYWQgfHwgZmFsc2UsXG4gICAgICBoaWRlT25UcmFuc3BhcmVudDogIShjb25maWcgJiYgY29uZmlnLmhpZGVPblRyYW5zcGFyZW50ID09PSBmYWxzZSksXG4gICAgICB2aWV3Qm94T25seTogY29uZmlnICYmIGNvbmZpZy52aWV3Qm94T25seSB8fCBmYWxzZSxcbiAgICAgIHZpZXdCb3hTaXplOiBjb25maWcgJiYgY29uZmlnLnZpZXdCb3hTaXplIHx8IGZhbHNlLFxuICAgICAgY2xhc3NOYW1lOiBjb25maWcgJiYgY29uZmlnLmNsYXNzTmFtZSB8fCAnJyxcbiAgICAgIGlkOiBjb25maWcgJiYgY29uZmlnLmlkIHx8ICcnLFxuICAgICAgZm9jdXNhYmxlOiBjb25maWcgJiYgY29uZmlnLmZvY3VzYWJsZSxcbiAgICAgIGZpbHRlclNpemU6IHtcbiAgICAgICAgd2lkdGg6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS53aWR0aCB8fCAnMTAwJScsXG4gICAgICAgIGhlaWdodDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLmhlaWdodCB8fCAnMTAwJScsXG4gICAgICAgIHg6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS54IHx8ICcwJScsXG4gICAgICAgIHk6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS55IHx8ICcwJSdcbiAgICAgIH0sXG4gICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy53aWR0aCxcbiAgICAgIGhlaWdodDogY29uZmlnICYmIGNvbmZpZy5oZWlnaHQsXG4gICAgICBydW5FeHByZXNzaW9uczogIWNvbmZpZyB8fCBjb25maWcucnVuRXhwcmVzc2lvbnMgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucnVuRXhwcmVzc2lvbnNcbiAgICB9O1xuICAgIHRoaXMuZ2xvYmFsRGF0YSA9IHtcbiAgICAgIF9tZGY6IGZhbHNlLFxuICAgICAgZnJhbWVOdW06IC0xLFxuICAgICAgZGVmczogZGVmcyxcbiAgICAgIHJlbmRlckNvbmZpZzogdGhpcy5yZW5kZXJDb25maWdcbiAgICB9O1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5yZW5kZXJlclR5cGUgPSAnc3ZnJztcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW1NWR1JlbmRlcmVyQmFzZV0sIFNWR1JlbmRlcmVyKTtcbiAgU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZUNvbXAgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgU1ZHQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBTaGFwZVRyYW5zZm9ybU1hbmFnZXIoKSB7XG4gICAgdGhpcy5zZXF1ZW5jZXMgPSB7fTtcbiAgICB0aGlzLnNlcXVlbmNlTGlzdCA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCA9IDA7XG4gIH1cbiAgU2hhcGVUcmFuc2Zvcm1NYW5hZ2VyLnByb3RvdHlwZSA9IHtcbiAgICBhZGRUcmFuc2Zvcm1TZXF1ZW5jZTogZnVuY3Rpb24gYWRkVHJhbnNmb3JtU2VxdWVuY2UodHJhbnNmb3Jtcykge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gdHJhbnNmb3Jtcy5sZW5ndGg7XG4gICAgICB2YXIga2V5ID0gJ18nO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGtleSArPSB0cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5rZXkgKyAnXyc7XG4gICAgICB9XG4gICAgICB2YXIgc2VxdWVuY2UgPSB0aGlzLnNlcXVlbmNlc1trZXldO1xuICAgICAgaWYgKCFzZXF1ZW5jZSkge1xuICAgICAgICBzZXF1ZW5jZSA9IHtcbiAgICAgICAgICB0cmFuc2Zvcm1zOiBbXS5jb25jYXQodHJhbnNmb3JtcyksXG4gICAgICAgICAgZmluYWxUcmFuc2Zvcm06IG5ldyBNYXRyaXgoKSxcbiAgICAgICAgICBfbWRmOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNlcXVlbmNlc1trZXldID0gc2VxdWVuY2U7XG4gICAgICAgIHRoaXMuc2VxdWVuY2VMaXN0LnB1c2goc2VxdWVuY2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNlcXVlbmNlO1xuICAgIH0sXG4gICAgcHJvY2Vzc1NlcXVlbmNlOiBmdW5jdGlvbiBwcm9jZXNzU2VxdWVuY2Uoc2VxdWVuY2UsIGlzRmlyc3RGcmFtZSkge1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGxlbiA9IHNlcXVlbmNlLnRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgdmFyIF9tZGYgPSBpc0ZpcnN0RnJhbWU7XG4gICAgICB3aGlsZSAoaSA8IGxlbiAmJiAhaXNGaXJzdEZyYW1lKSB7XG4gICAgICAgIGlmIChzZXF1ZW5jZS50cmFuc2Zvcm1zW2ldLnRyYW5zZm9ybS5tUHJvcHMuX21kZikge1xuICAgICAgICAgIF9tZGYgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGkgKz0gMTtcbiAgICAgIH1cbiAgICAgIGlmIChfbWRmKSB7XG4gICAgICAgIHNlcXVlbmNlLmZpbmFsVHJhbnNmb3JtLnJlc2V0KCk7XG4gICAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgICAgc2VxdWVuY2UuZmluYWxUcmFuc2Zvcm0ubXVsdGlwbHkoc2VxdWVuY2UudHJhbnNmb3Jtc1tpXS50cmFuc2Zvcm0ubVByb3BzLnYpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzZXF1ZW5jZS5fbWRmID0gX21kZjtcbiAgICB9LFxuICAgIHByb2Nlc3NTZXF1ZW5jZXM6IGZ1bmN0aW9uIHByb2Nlc3NTZXF1ZW5jZXMoaXNGaXJzdEZyYW1lKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnNlcXVlbmNlTGlzdC5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgdGhpcy5wcm9jZXNzU2VxdWVuY2UodGhpcy5zZXF1ZW5jZUxpc3RbaV0sIGlzRmlyc3RGcmFtZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBnZXROZXdLZXk6IGZ1bmN0aW9uIGdldE5ld0tleSgpIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudCArPSAxO1xuICAgICAgcmV0dXJuICdfJyArIHRoaXMudHJhbnNmb3JtX2tleV9jb3VudDtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGx1bWFMb2FkZXIgPSBmdW5jdGlvbiBsdW1hTG9hZGVyKCkge1xuICAgIHZhciBpZCA9ICdfX2xvdHRpZV9lbGVtZW50X2x1bWFfYnVmZmVyJztcbiAgICB2YXIgbHVtYUJ1ZmZlciA9IG51bGw7XG4gICAgdmFyIGx1bWFCdWZmZXJDdHggPSBudWxsO1xuICAgIHZhciBzdmcgPSBudWxsO1xuXG4gICAgLy8gVGhpcyBhbHRlcm5hdGUgc29sdXRpb24gaGFzIGEgc2xpZ2h0IGRlbGF5IGJlZm9yZSB0aGUgZmlsdGVyIGlzIGFwcGxpZWQsIHJlc3VsdGluZyBpbiBhIGZsaWNrZXIgb24gdGhlIGZpcnN0IGZyYW1lLlxuICAgIC8vIEtlZXBpbmcgdGhpcyBoZXJlIGZvciByZWZlcmVuY2UsIGFuZCBpbiB0aGUgZnV0dXJlLCBpZiBvZmZzY3JlZW4gY2FudmFzIHN1cHBvcnRzIHVybCBmaWx0ZXJzLCB0aGlzIGNhbiBiZSB1c2VkLlxuICAgIC8vIEZvciBub3csIG5laXRoZXIgb2YgdGhlbSB3b3JrIGZvciBvZmZzY3JlZW4gY2FudmFzLCBzbyBjYW52YXMgd29ya2VycyBjYW4ndCBzdXBwb3J0IHRoZSBsdW1hIHRyYWNrIG1hdHRlIG1hc2suXG4gICAgLy8gTmFtaW5nIGl0IHNvbHV0aW9uIDIgdG8gbWFyayB0aGUgZXh0cmEgY29tbWVudCBsaW5lcy5cbiAgICAvKlxuICAgIHZhciBzdmdTdHJpbmcgPSBbXG4gICAgICAnPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+JyxcbiAgICAgICc8ZmlsdGVyIGlkPVwiJyArIGlkICsgJ1wiPicsXG4gICAgICAnPGZlQ29sb3JNYXRyaXggdHlwZT1cIm1hdHJpeFwiIGNvbG9yLWludGVycG9sYXRpb24tZmlsdGVycz1cInNSR0JcIiB2YWx1ZXM9XCInLFxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAsICcsXG4gICAgICAnMC4zLCAwLjMsIDAuMywgMCwgMCwgJyxcbiAgICAgICcwLjMsIDAuMywgMC4zLCAwLCAwLCAnLFxuICAgICAgJzAuMywgMC4zLCAwLjMsIDAsIDAnLFxuICAgICAgJ1wiLz4nLFxuICAgICAgJzwvZmlsdGVyPicsXG4gICAgICAnPC9zdmc+JyxcbiAgICBdLmpvaW4oJycpO1xuICAgIHZhciBibG9iID0gbmV3IEJsb2IoW3N2Z1N0cmluZ10sIHsgdHlwZTogJ2ltYWdlL3N2Zyt4bWwnIH0pO1xuICAgIHZhciB1cmwgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuICAgICovXG5cbiAgICBmdW5jdGlvbiBjcmVhdGVMdW1hU3ZnRmlsdGVyKCkge1xuICAgICAgdmFyIF9zdmcgPSBjcmVhdGVOUygnc3ZnJyk7XG4gICAgICB2YXIgZmlsID0gY3JlYXRlTlMoJ2ZpbHRlcicpO1xuICAgICAgdmFyIG1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgICBmaWwuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTtcbiAgICAgIG1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XG4gICAgICBtYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgICAgbWF0cml4LnNldEF0dHJpYnV0ZSgndmFsdWVzJywgJzAuMywgMC4zLCAwLjMsIDAsIDAsIDAuMywgMC4zLCAwLjMsIDAsIDAsIDAuMywgMC4zLCAwLjMsIDAsIDAsIDAuMywgMC4zLCAwLjMsIDAsIDAnKTtcbiAgICAgIGZpbC5hcHBlbmRDaGlsZChtYXRyaXgpO1xuICAgICAgX3N2Zy5hcHBlbmRDaGlsZChmaWwpO1xuICAgICAgX3N2Zy5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQgKyAnX3N2ZycpO1xuICAgICAgaWYgKGZlYXR1cmVTdXBwb3J0LnN2Z0x1bWFIaWRkZW4pIHtcbiAgICAgICAgX3N2Zy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIF9zdmc7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxvYWRMdW1hKCkge1xuICAgICAgaWYgKCFsdW1hQnVmZmVyKSB7XG4gICAgICAgIHN2ZyA9IGNyZWF0ZUx1bWFTdmdGaWx0ZXIoKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuICAgICAgICBsdW1hQnVmZmVyID0gY3JlYXRlVGFnKCdjYW52YXMnKTtcbiAgICAgICAgbHVtYUJ1ZmZlckN0eCA9IGx1bWFCdWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgLy8gbHVtYUJ1ZmZlckN0eC5maWx0ZXIgPSBgdXJsKCcke3VybH0jX19sb3R0aWVfZWxlbWVudF9sdW1hX2J1ZmZlcicpYDsgLy8gcGFydCBvZiBzb2x1dGlvbiAyXG4gICAgICAgIGx1bWFCdWZmZXJDdHguZmlsdGVyID0gJ3VybCgjJyArIGlkICsgJyknO1xuICAgICAgICBsdW1hQnVmZmVyQ3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICAgICAgbHVtYUJ1ZmZlckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0THVtYShjYW52YXMpIHtcbiAgICAgIGlmICghbHVtYUJ1ZmZlcikge1xuICAgICAgICBsb2FkTHVtYSgpO1xuICAgICAgfVxuICAgICAgbHVtYUJ1ZmZlci53aWR0aCA9IGNhbnZhcy53aWR0aDtcbiAgICAgIGx1bWFCdWZmZXIuaGVpZ2h0ID0gY2FudmFzLmhlaWdodDtcbiAgICAgIC8vIGx1bWFCdWZmZXJDdHguZmlsdGVyID0gYHVybCgnJHt1cmx9I19fbG90dGllX2VsZW1lbnRfbHVtYV9idWZmZXInKWA7IC8vIHBhcnQgb2Ygc29sdXRpb24gMlxuICAgICAgbHVtYUJ1ZmZlckN0eC5maWx0ZXIgPSAndXJsKCMnICsgaWQgKyAnKSc7XG4gICAgICByZXR1cm4gbHVtYUJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGxvYWQ6IGxvYWRMdW1hLFxuICAgICAgZ2V0OiBnZXRMdW1hXG4gICAgfTtcbiAgfTtcbiAgZnVuY3Rpb24gY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAoZmVhdHVyZVN1cHBvcnQub2Zmc2NyZWVuQ2FudmFzKSB7XG4gICAgICByZXR1cm4gbmV3IE9mZnNjcmVlbkNhbnZhcyh3aWR0aCwgaGVpZ2h0KTtcbiAgICB9XG4gICAgdmFyIGNhbnZhcyA9IGNyZWF0ZVRhZygnY2FudmFzJyk7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG4gIHZhciBhc3NldExvYWRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZEx1bWFDYW52YXM6IGx1bWFMb2FkZXIubG9hZCxcbiAgICAgIGdldEx1bWFDYW52YXM6IGx1bWFMb2FkZXIuZ2V0LFxuICAgICAgY3JlYXRlQ2FudmFzOiBjcmVhdGVDYW52YXNcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIHJlZ2lzdGVyZWRFZmZlY3RzID0ge307XG4gIGZ1bmN0aW9uIENWRWZmZWN0cyhlbGVtKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGVsZW0uZGF0YS5lZiA/IGVsZW0uZGF0YS5lZi5sZW5ndGggOiAwO1xuICAgIHRoaXMuZmlsdGVycyA9IFtdO1xuICAgIHZhciBmaWx0ZXJNYW5hZ2VyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgZmlsdGVyTWFuYWdlciA9IG51bGw7XG4gICAgICB2YXIgdHlwZSA9IGVsZW0uZGF0YS5lZltpXS50eTtcbiAgICAgIGlmIChyZWdpc3RlcmVkRWZmZWN0c1t0eXBlXSkge1xuICAgICAgICB2YXIgRWZmZWN0ID0gcmVnaXN0ZXJlZEVmZmVjdHNbdHlwZV0uZWZmZWN0O1xuICAgICAgICBmaWx0ZXJNYW5hZ2VyID0gbmV3IEVmZmVjdChlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzW2ldLCBlbGVtKTtcbiAgICAgIH1cbiAgICAgIGlmIChmaWx0ZXJNYW5hZ2VyKSB7XG4gICAgICAgIHRoaXMuZmlsdGVycy5wdXNoKGZpbHRlck1hbmFnZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5maWx0ZXJzLmxlbmd0aCkge1xuICAgICAgZWxlbS5hZGRSZW5kZXJhYmxlQ29tcG9uZW50KHRoaXMpO1xuICAgIH1cbiAgfVxuICBDVkVmZmVjdHMucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKF9pc0ZpcnN0RnJhbWUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5maWx0ZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZmlsdGVyc1tpXS5yZW5kZXJGcmFtZShfaXNGaXJzdEZyYW1lKTtcbiAgICB9XG4gIH07XG4gIENWRWZmZWN0cy5wcm90b3R5cGUuZ2V0RWZmZWN0cyA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMuZmlsdGVycy5sZW5ndGg7XG4gICAgdmFyIGVmZmVjdHMgPSBbXTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLmZpbHRlcnNbaV0udHlwZSA9PT0gdHlwZSkge1xuICAgICAgICBlZmZlY3RzLnB1c2godGhpcy5maWx0ZXJzW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVmZmVjdHM7XG4gIH07XG4gIGZ1bmN0aW9uIHJlZ2lzdGVyRWZmZWN0KGlkLCBlZmZlY3QpIHtcbiAgICByZWdpc3RlcmVkRWZmZWN0c1tpZF0gPSB7XG4gICAgICBlZmZlY3Q6IGVmZmVjdFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBDVk1hc2tFbGVtZW50KGRhdGEsIGVsZW1lbnQpIHtcbiAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgdGhpcy5tYXNrc1Byb3BlcnRpZXMgPSB0aGlzLmRhdGEubWFza3NQcm9wZXJ0aWVzIHx8IFtdO1xuICAgIHRoaXMudmlld0RhdGEgPSBjcmVhdGVTaXplZEFycmF5KHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgaGFzTWFza3MgPSBmYWxzZTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5tb2RlICE9PSAnbicpIHtcbiAgICAgICAgaGFzTWFza3MgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy52aWV3RGF0YVtpXSA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcCh0aGlzLmVsZW1lbnQsIHRoaXMubWFza3NQcm9wZXJ0aWVzW2ldLCAzKTtcbiAgICB9XG4gICAgdGhpcy5oYXNNYXNrcyA9IGhhc01hc2tzO1xuICAgIGlmIChoYXNNYXNrcykge1xuICAgICAgdGhpcy5lbGVtZW50LmFkZFJlbmRlcmFibGVDb21wb25lbnQodGhpcyk7XG4gICAgfVxuICB9XG4gIENWTWFza0VsZW1lbnQucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5oYXNNYXNrcykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdHJhbnNmb3JtID0gdGhpcy5lbGVtZW50LmZpbmFsVHJhbnNmb3JtLm1hdDtcbiAgICB2YXIgY3R4ID0gdGhpcy5lbGVtZW50LmNhbnZhc0NvbnRleHQ7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICB2YXIgcHQ7XG4gICAgdmFyIHB0cztcbiAgICB2YXIgZGF0YTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5tYXNrc1Byb3BlcnRpZXNbaV0ubW9kZSAhPT0gJ24nKSB7XG4gICAgICAgIGlmICh0aGlzLm1hc2tzUHJvcGVydGllc1tpXS5pbnYpIHtcbiAgICAgICAgICBjdHgubW92ZVRvKDAsIDApO1xuICAgICAgICAgIGN0eC5saW5lVG8odGhpcy5lbGVtZW50Lmdsb2JhbERhdGEuY29tcFNpemUudywgMCk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS53LCB0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oKTtcbiAgICAgICAgICBjdHgubGluZVRvKDAsIHRoaXMuZWxlbWVudC5nbG9iYWxEYXRhLmNvbXBTaXplLmgpO1xuICAgICAgICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YSA9IHRoaXMudmlld0RhdGFbaV0udjtcbiAgICAgICAgcHQgPSB0cmFuc2Zvcm0uYXBwbHlUb1BvaW50QXJyYXkoZGF0YS52WzBdWzBdLCBkYXRhLnZbMF1bMV0sIDApO1xuICAgICAgICBjdHgubW92ZVRvKHB0WzBdLCBwdFsxXSk7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgakxlbiA9IGRhdGEuX2xlbmd0aDtcbiAgICAgICAgZm9yIChqID0gMTsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgIHB0cyA9IHRyYW5zZm9ybS5hcHBseVRvVHJpcGxlUG9pbnRzKGRhdGEub1tqIC0gMV0sIGRhdGEuaVtqXSwgZGF0YS52W2pdKTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhwdHNbMF0sIHB0c1sxXSwgcHRzWzJdLCBwdHNbM10sIHB0c1s0XSwgcHRzWzVdKTtcbiAgICAgICAgfVxuICAgICAgICBwdHMgPSB0cmFuc2Zvcm0uYXBwbHlUb1RyaXBsZVBvaW50cyhkYXRhLm9baiAtIDFdLCBkYXRhLmlbMF0sIGRhdGEudlswXSk7XG4gICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKHB0c1swXSwgcHRzWzFdLCBwdHNbMl0sIHB0c1szXSwgcHRzWzRdLCBwdHNbNV0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVsZW1lbnQuZ2xvYmFsRGF0YS5yZW5kZXJlci5zYXZlKHRydWUpO1xuICAgIGN0eC5jbGlwKCk7XG4gIH07XG4gIENWTWFza0VsZW1lbnQucHJvdG90eXBlLmdldE1hc2tQcm9wZXJ0eSA9IE1hc2tFbGVtZW50LnByb3RvdHlwZS5nZXRNYXNrUHJvcGVydHk7XG4gIENWTWFza0VsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5lbGVtZW50ID0gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBDVkJhc2VFbGVtZW50KCkge31cbiAgdmFyIG9wZXJhdGlvbnNNYXAgPSB7XG4gICAgMTogJ3NvdXJjZS1pbicsXG4gICAgMjogJ3NvdXJjZS1vdXQnLFxuICAgIDM6ICdzb3VyY2UtaW4nLFxuICAgIDQ6ICdzb3VyY2Utb3V0J1xuICB9O1xuICBDVkJhc2VFbGVtZW50LnByb3RvdHlwZSA9IHtcbiAgICBjcmVhdGVFbGVtZW50czogZnVuY3Rpb24gY3JlYXRlRWxlbWVudHMoKSB7fSxcbiAgICBpbml0UmVuZGVyZXJFbGVtZW50OiBmdW5jdGlvbiBpbml0UmVuZGVyZXJFbGVtZW50KCkge30sXG4gICAgY3JlYXRlQ29udGFpbmVyRWxlbWVudHM6IGZ1bmN0aW9uIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzKCkge1xuICAgICAgLy8gSWYgdGhlIGxheWVyIGlzIG1hc2tlZCB3ZSB3aWxsIHVzZSB0d28gYnVmZmVycyB0byBzdG9yZSBlYWNoIGRpZmZlcmVudCBzdGF0ZXMgb2YgdGhlIGRyYXdpbmdcbiAgICAgIC8vIFRoaXMgc29sdXRpb24gaXMgbm90IGlkZWFsIGZvciBzZXZlcmFsIHJlYXNvbi4gQnV0IHVuZm9ydHVuYXRlbHksIGJlY2F1c2Ugb2YgdGhlIHJlY3Vyc2l2ZVxuICAgICAgLy8gbmF0dXJlIG9mIHRoZSByZW5kZXIgdHJlZSwgaXQncyB0aGUgb25seSBzaW1wbGUgd2F5IHRvIG1ha2Ugc3VyZSBvbmUgaW5uZXIgbWFzayBkb2Vzbid0IG92ZXJyaWRlIGFuIG91dGVyIG1hc2suXG4gICAgICAvLyBUT0RPOiB0cnkgdG8gcmVkdWNlIHRoZSBzaXplIG9mIHRoZXNlIGJ1ZmZlcnMgdG8gdGhlIHNpemUgb2YgdGhlIGNvbXBvc2l0aW9uIGNvbnRhbmluZyB0aGUgbGF5ZXJcbiAgICAgIC8vIEl0IG1pZ2h0IGJlIGNoYWxsZW5naW5nIGJlY2F1c2UgdGhlIGxheWVyIG1vc3QgbGlrZWx5IGlzIHRyYW5zZm9ybWVkIGluIHNvbWUgd2F5XG4gICAgICBpZiAodGhpcy5kYXRhLnR0ID49IDEpIHtcbiAgICAgICAgdGhpcy5idWZmZXJzID0gW107XG4gICAgICAgIHZhciBjYW52YXNDb250ZXh0ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICAgIHZhciBidWZmZXJDYW52YXMgPSBhc3NldExvYWRlci5jcmVhdGVDYW52YXMoY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGgsIGNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCk7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJ1ZmZlckNhbnZhcyk7XG4gICAgICAgIHZhciBidWZmZXJDYW52YXMyID0gYXNzZXRMb2FkZXIuY3JlYXRlQ2FudmFzKGNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoLCBjYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQpO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChidWZmZXJDYW52YXMyKTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAzICYmICFkb2N1bWVudC5faXNQcm94eSkge1xuICAgICAgICAgIGFzc2V0TG9hZGVyLmxvYWRMdW1hQ2FudmFzKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0O1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMgPSB0aGlzLmdsb2JhbERhdGEudHJhbnNmb3JtQ2FudmFzO1xuICAgICAgdGhpcy5yZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIgPSBuZXcgQ1ZFZmZlY3RzKHRoaXMpO1xuICAgICAgdGhpcy5zZWFyY2hFZmZlY3RUcmFuc2Zvcm1zKCk7XG4gICAgfSxcbiAgICBjcmVhdGVDb250ZW50OiBmdW5jdGlvbiBjcmVhdGVDb250ZW50KCkge30sXG4gICAgc2V0QmxlbmRNb2RlOiBmdW5jdGlvbiBzZXRCbGVuZE1vZGUoKSB7XG4gICAgICB2YXIgZ2xvYmFsRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YTtcbiAgICAgIGlmIChnbG9iYWxEYXRhLmJsZW5kTW9kZSAhPT0gdGhpcy5kYXRhLmJtKSB7XG4gICAgICAgIGdsb2JhbERhdGEuYmxlbmRNb2RlID0gdGhpcy5kYXRhLmJtO1xuICAgICAgICB2YXIgYmxlbmRNb2RlVmFsdWUgPSBnZXRCbGVuZE1vZGUodGhpcy5kYXRhLmJtKTtcbiAgICAgICAgZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZVZhbHVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBDVk1hc2tFbGVtZW50KHRoaXMuZGF0YSwgdGhpcyk7XG4gICAgICB0aGlzLnRyYW5zZm9ybUVmZmVjdHMgPSB0aGlzLnJlbmRlcmFibGVFZmZlY3RzTWFuYWdlci5nZXRFZmZlY3RzKGVmZmVjdFR5cGVzLlRSQU5TRk9STV9FRkZFQ1QpO1xuICAgIH0sXG4gICAgaGlkZUVsZW1lbnQ6IGZ1bmN0aW9uIGhpZGVFbGVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLmhpZGRlbiAmJiAoIXRoaXMuaXNJblJhbmdlIHx8IHRoaXMuaXNUcmFuc3BhcmVudCkpIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgIH0sXG4gICAgc2hvd0VsZW1lbnQ6IGZ1bmN0aW9uIHNob3dFbGVtZW50KCkge1xuICAgICAgaWYgKHRoaXMuaXNJblJhbmdlICYmICF0aGlzLmlzVHJhbnNwYXJlbnQpIHtcbiAgICAgICAgdGhpcy5oaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlci5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNsZWFyQ2FudmFzOiBmdW5jdGlvbiBjbGVhckNhbnZhcyhjYW52YXNDb250ZXh0KSB7XG4gICAgICBjYW52YXNDb250ZXh0LmNsZWFyUmVjdCh0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudHksIHRoaXMudHJhbnNmb3JtQ2FudmFzLncgKiB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeCwgdGhpcy50cmFuc2Zvcm1DYW52YXMuaCAqIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5KTtcbiAgICB9LFxuICAgIHByZXBhcmVMYXllcjogZnVuY3Rpb24gcHJlcGFyZUxheWVyKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS50dCA+PSAxKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSB0aGlzLmJ1ZmZlcnNbMF07XG4gICAgICAgIHZhciBidWZmZXJDdHggPSBidWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgdGhpcy5jbGVhckNhbnZhcyhidWZmZXJDdHgpO1xuICAgICAgICAvLyBvbiB0aGUgZmlyc3QgYnVmZmVyIHdlIHN0b3JlIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoZSBnbG9iYWwgZHJhd2luZ1xuICAgICAgICBidWZmZXJDdHguZHJhd0ltYWdlKHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMsIDAsIDApO1xuICAgICAgICAvLyBUaGUgbmV4dCBmb3VyIGxpbmVzIGFyZSB0byBjbGVhciB0aGUgY2FudmFzXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIHRoZXJlIGlzIGEgd2F5IHRvIGNsZWFyIHRoZSBjYW52YXMgd2l0aG91dCByZXNldHRpbmcgdGhlIHRyYW5zZm9ybVxuICAgICAgICB0aGlzLmN1cnJlbnRUcmFuc2Zvcm0gPSB0aGlzLmNhbnZhc0NvbnRleHQuZ2V0VHJhbnNmb3JtKCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICAgIHRoaXMuY2xlYXJDYW52YXModGhpcy5jYW52YXNDb250ZXh0KTtcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnNldFRyYW5zZm9ybSh0aGlzLmN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZXhpdExheWVyOiBmdW5jdGlvbiBleGl0TGF5ZXIoKSB7XG4gICAgICBpZiAodGhpcy5kYXRhLnR0ID49IDEpIHtcbiAgICAgICAgdmFyIGJ1ZmZlciA9IHRoaXMuYnVmZmVyc1sxXTtcbiAgICAgICAgLy8gT24gdGhlIHNlY29uZCBidWZmZXIgd2Ugc3RvcmUgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhlIGdsb2JhbCBkcmF3aW5nXG4gICAgICAgIC8vIHRoYXQgb25seSBjb250YWlucyB0aGUgY29udGVudCBvZiB0aGlzIGxheWVyXG4gICAgICAgIC8vIChpZiBpdCBpcyBhIGNvbXBvc2l0aW9uLCBpdCBhbHNvIGluY2x1ZGVzIHRoZSBuZXN0ZWQgbGF5ZXJzKVxuICAgICAgICB2YXIgYnVmZmVyQ3R4ID0gYnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgIHRoaXMuY2xlYXJDYW52YXMoYnVmZmVyQ3R4KTtcbiAgICAgICAgYnVmZmVyQ3R4LmRyYXdJbWFnZSh0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLCAwLCAwKTtcbiAgICAgICAgLy8gV2UgY2xlYXIgdGhlIGNhbnZhcyBhZ2FpblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgICAgICB0aGlzLmNsZWFyQ2FudmFzKHRoaXMuY2FudmFzQ29udGV4dCk7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5zZXRUcmFuc2Zvcm0odGhpcy5jdXJyZW50VHJhbnNmb3JtKTtcbiAgICAgICAgLy8gV2UgZHJhdyB0aGUgbWFza1xuICAgICAgICB2YXIgbWFzayA9IHRoaXMuY29tcC5nZXRFbGVtZW50QnlJZCgndHAnIGluIHRoaXMuZGF0YSA/IHRoaXMuZGF0YS50cCA6IHRoaXMuZGF0YS5pbmQgLSAxKTtcbiAgICAgICAgbWFzay5yZW5kZXJGcmFtZSh0cnVlKTtcbiAgICAgICAgLy8gV2UgZHJhdyB0aGUgc2Vjb25kIGJ1ZmZlciAodGhhdCBjb250YWlucyB0aGUgY29udGVudCBvZiB0aGlzIGxheWVyKVxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuXG4gICAgICAgIC8vIElmIHRoZSBtYXNrIGlzIGEgTHVtYSBtYXR0ZSwgd2UgbmVlZCB0byBkbyB0d28gZXh0cmEgcGFpbnRpbmcgb3BlcmF0aW9uc1xuICAgICAgICAvLyB0aGUgX2lzUHJveHkgY2hlY2sgaXMgdG8gYXZvaWQgZHJhd2luZyBhIGZha2UgY2FudmFzIGluIHdvcmtlcnMgdGhhdCB3aWxsIHRocm93IGFuIGVycm9yXG4gICAgICAgIGlmICh0aGlzLmRhdGEudHQgPj0gMyAmJiAhZG9jdW1lbnQuX2lzUHJveHkpIHtcbiAgICAgICAgICAvLyBXZSBjb3B5IHRoZSBwYWludGVkIG1hc2sgdG8gYSBidWZmZXIgdGhhdCBoYXMgYSBjb2xvciBtYXRyaXggZmlsdGVyIGFwcGxpZWQgdG8gaXRcbiAgICAgICAgICAvLyB0aGF0IGFwcGxpZXMgdGhlIHJnYiB2YWx1ZXMgdG8gdGhlIGFscGhhIGNoYW5uZWxcbiAgICAgICAgICB2YXIgbHVtYUJ1ZmZlciA9IGFzc2V0TG9hZGVyLmdldEx1bWFDYW52YXModGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcyk7XG4gICAgICAgICAgdmFyIGx1bWFCdWZmZXJDdHggPSBsdW1hQnVmZmVyLmdldENvbnRleHQoJzJkJyk7XG4gICAgICAgICAgbHVtYUJ1ZmZlckN0eC5kcmF3SW1hZ2UodGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcywgMCwgMCk7XG4gICAgICAgICAgdGhpcy5jbGVhckNhbnZhcyh0aGlzLmNhbnZhc0NvbnRleHQpO1xuICAgICAgICAgIC8vIHdlIHJlcGFpbnQgdGhlIGNvbnRleHQgd2l0aCB0aGUgbWFzayBhcHBsaWVkIHRvIGl0XG4gICAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmRyYXdJbWFnZShsdW1hQnVmZmVyLCAwLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gb3BlcmF0aW9uc01hcFt0aGlzLmRhdGEudHRdO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKGJ1ZmZlciwgMCwgMCk7XG4gICAgICAgIC8vIFdlIGZpbmFsbHkgZHJhdyB0aGUgZmlyc3QgYnVmZmVyICh0aGF0IGNvbnRhaW5zIHRoZSBjb250ZW50IG9mIHRoZSBnbG9iYWwgZHJhd2luZylcbiAgICAgICAgLy8gV2UgdXNlIGRlc3RpbmF0aW9uLW92ZXIgdG8gZHJhdyB0aGUgZ2xvYmFsIGRyYXdpbmcgYmVsb3cgdGhlIGN1cnJlbnQgbGF5ZXJcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdkZXN0aW5hdGlvbi1vdmVyJztcbiAgICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmRyYXdJbWFnZSh0aGlzLmJ1ZmZlcnNbMF0sIDAsIDApO1xuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuc2V0VHJhbnNmb3JtKHRoaXMuY3VycmVudFRyYW5zZm9ybSk7XG4gICAgICAgIC8vIFdlIHJlc2V0IHRoZSBnbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gdG8gc291cmNlLW92ZXIsIHRoZSBzdGFuZGFyZCB0eXBlIG9mIG9wZXJhdGlvblxuICAgICAgICB0aGlzLmNhbnZhc0NvbnRleHQuZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ3NvdXJjZS1vdmVyJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHJlbmRlckZyYW1lOiBmdW5jdGlvbiByZW5kZXJGcmFtZShmb3JjZVJlbmRlcikge1xuICAgICAgaWYgKHRoaXMuaGlkZGVuIHx8IHRoaXMuZGF0YS5oZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLnRkID09PSAxICYmICFmb3JjZVJlbmRlcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLnJlbmRlclRyYW5zZm9ybSgpO1xuICAgICAgdGhpcy5yZW5kZXJSZW5kZXJhYmxlKCk7XG4gICAgICB0aGlzLnJlbmRlckxvY2FsVHJhbnNmb3JtKCk7XG4gICAgICB0aGlzLnNldEJsZW5kTW9kZSgpO1xuICAgICAgdmFyIGZvcmNlUmVhbFN0YWNrID0gdGhpcy5kYXRhLnR5ID09PSAwO1xuICAgICAgdGhpcy5wcmVwYXJlTGF5ZXIoKTtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5zYXZlKGZvcmNlUmVhbFN0YWNrKTtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhUcmFuc2Zvcm0odGhpcy5maW5hbFRyYW5zZm9ybS5sb2NhbE1hdC5wcm9wcyk7XG4gICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4T3BhY2l0eSh0aGlzLmZpbmFsVHJhbnNmb3JtLmxvY2FsT3BhY2l0eSk7XG4gICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLnJlc3RvcmUoZm9yY2VSZWFsU3RhY2spO1xuICAgICAgdGhpcy5leGl0TGF5ZXIoKTtcbiAgICAgIGlmICh0aGlzLm1hc2tNYW5hZ2VyLmhhc01hc2tzKSB7XG4gICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5yZXN0b3JlKHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5kYXRhID0gbnVsbDtcbiAgICAgIHRoaXMuZ2xvYmFsRGF0YSA9IG51bGw7XG4gICAgICB0aGlzLm1hc2tNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB9LFxuICAgIG1IZWxwZXI6IG5ldyBNYXRyaXgoKVxuICB9O1xuICBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gQ1ZCYXNlRWxlbWVudC5wcm90b3R5cGUuaGlkZUVsZW1lbnQ7XG4gIENWQmFzZUVsZW1lbnQucHJvdG90eXBlLnNob3cgPSBDVkJhc2VFbGVtZW50LnByb3RvdHlwZS5zaG93RWxlbWVudDtcblxuICBmdW5jdGlvbiBDVlNoYXBlRGF0YShlbGVtZW50LCBkYXRhLCBzdHlsZXMsIHRyYW5zZm9ybXNNYW5hZ2VyKSB7XG4gICAgdGhpcy5zdHlsZWRTaGFwZXMgPSBbXTtcbiAgICB0aGlzLnRyID0gWzAsIDAsIDAsIDAsIDAsIDBdO1xuICAgIHZhciB0eSA9IDQ7XG4gICAgaWYgKGRhdGEudHkgPT09ICdyYycpIHtcbiAgICAgIHR5ID0gNTtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdlbCcpIHtcbiAgICAgIHR5ID0gNjtcbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdzcicpIHtcbiAgICAgIHR5ID0gNztcbiAgICB9XG4gICAgdGhpcy5zaCA9IFNoYXBlUHJvcGVydHlGYWN0b3J5LmdldFNoYXBlUHJvcChlbGVtZW50LCBkYXRhLCB0eSwgZWxlbWVudCk7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHN0eWxlcy5sZW5ndGg7XG4gICAgdmFyIHN0eWxlZFNoYXBlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCFzdHlsZXNbaV0uY2xvc2VkKSB7XG4gICAgICAgIHN0eWxlZFNoYXBlID0ge1xuICAgICAgICAgIHRyYW5zZm9ybXM6IHRyYW5zZm9ybXNNYW5hZ2VyLmFkZFRyYW5zZm9ybVNlcXVlbmNlKHN0eWxlc1tpXS50cmFuc2Zvcm1zKSxcbiAgICAgICAgICB0ck5vZGVzOiBbXVxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnN0eWxlZFNoYXBlcy5wdXNoKHN0eWxlZFNoYXBlKTtcbiAgICAgICAgc3R5bGVzW2ldLmVsZW1lbnRzLnB1c2goc3R5bGVkU2hhcGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBDVlNoYXBlRGF0YS5wcm90b3R5cGUuc2V0QXNBbmltYXRlZCA9IFNWR1NoYXBlRGF0YS5wcm90b3R5cGUuc2V0QXNBbmltYXRlZDtcblxuICBmdW5jdGlvbiBDVlNoYXBlRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5zaGFwZXMgPSBbXTtcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlcztcbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTtcbiAgICB0aGlzLml0ZW1zRGF0YSA9IFtdO1xuICAgIHRoaXMucHJldlZpZXdEYXRhID0gW107XG4gICAgdGhpcy5zaGFwZU1vZGlmaWVycyA9IFtdO1xuICAgIHRoaXMucHJvY2Vzc2VkRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyID0gbmV3IFNoYXBlVHJhbnNmb3JtTWFuYWdlcigpO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSVNoYXBlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudF0sIENWU2hhcGVFbGVtZW50KTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50ID0gUmVuZGVyYWJsZURPTUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUudHJhbnNmb3JtSGVscGVyID0ge1xuICAgIG9wYWNpdHk6IDEsXG4gICAgX29wTWRmOiBmYWxzZVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZGFzaFJlc2V0dGVyID0gW107XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0cnVlLCBbXSk7XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVTdHlsZUVsZW1lbnQgPSBmdW5jdGlvbiAoZGF0YSwgdHJhbnNmb3Jtcykge1xuICAgIHZhciBzdHlsZUVsZW0gPSB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgdHlwZTogZGF0YS50eSxcbiAgICAgIHByZVRyYW5zZm9ybXM6IHRoaXMudHJhbnNmb3Jtc01hbmFnZXIuYWRkVHJhbnNmb3JtU2VxdWVuY2UodHJhbnNmb3JtcyksXG4gICAgICB0cmFuc2Zvcm1zOiBbXSxcbiAgICAgIGVsZW1lbnRzOiBbXSxcbiAgICAgIGNsb3NlZDogZGF0YS5oZCA9PT0gdHJ1ZVxuICAgIH07XG4gICAgdmFyIGVsZW1lbnREYXRhID0ge307XG4gICAgaWYgKGRhdGEudHkgPT09ICdmbCcgfHwgZGF0YS50eSA9PT0gJ3N0Jykge1xuICAgICAgZWxlbWVudERhdGEuYyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEuYywgMSwgMjU1LCB0aGlzKTtcbiAgICAgIGlmICghZWxlbWVudERhdGEuYy5rKSB7XG4gICAgICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoZWxlbWVudERhdGEuYy52WzJdKSArICcpJztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGEudHkgPT09ICdnZicgfHwgZGF0YS50eSA9PT0gJ2dzJykge1xuICAgICAgZWxlbWVudERhdGEucyA9IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEucywgMSwgbnVsbCwgdGhpcyk7XG4gICAgICBlbGVtZW50RGF0YS5lID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5lLCAxLCBudWxsLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmggPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmggfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCAwLjAxLCB0aGlzKTtcbiAgICAgIGVsZW1lbnREYXRhLmEgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLmEgfHwge1xuICAgICAgICBrOiAwXG4gICAgICB9LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgICAgZWxlbWVudERhdGEuZyA9IG5ldyBHcmFkaWVudFByb3BlcnR5KHRoaXMsIGRhdGEuZywgdGhpcyk7XG4gICAgfVxuICAgIGVsZW1lbnREYXRhLm8gPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLm8sIDAsIDAuMDEsIHRoaXMpO1xuICAgIGlmIChkYXRhLnR5ID09PSAnc3QnIHx8IGRhdGEudHkgPT09ICdncycpIHtcbiAgICAgIHN0eWxlRWxlbS5sYyA9IGxpbmVDYXBFbnVtW2RhdGEubGMgfHwgMl07XG4gICAgICBzdHlsZUVsZW0ubGogPSBsaW5lSm9pbkVudW1bZGF0YS5saiB8fCAyXTtcbiAgICAgIGlmIChkYXRhLmxqID09IDEpIHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICAgICAgc3R5bGVFbGVtLm1sID0gZGF0YS5tbDtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnREYXRhLncgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLncsIDAsIG51bGwsIHRoaXMpO1xuICAgICAgaWYgKCFlbGVtZW50RGF0YS53LmspIHtcbiAgICAgICAgc3R5bGVFbGVtLndpID0gZWxlbWVudERhdGEudy52O1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuZCkge1xuICAgICAgICB2YXIgZCA9IG5ldyBEYXNoUHJvcGVydHkodGhpcywgZGF0YS5kLCAnY2FudmFzJywgdGhpcyk7XG4gICAgICAgIGVsZW1lbnREYXRhLmQgPSBkO1xuICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmQuaykge1xuICAgICAgICAgIHN0eWxlRWxlbS5kYSA9IGVsZW1lbnREYXRhLmQuZGFzaEFycmF5O1xuICAgICAgICAgIHN0eWxlRWxlbVtcImRvXCJdID0gZWxlbWVudERhdGEuZC5kYXNob2Zmc2V0WzBdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0eWxlRWxlbS5yID0gZGF0YS5yID09PSAyID8gJ2V2ZW5vZGQnIDogJ25vbnplcm8nO1xuICAgIH1cbiAgICB0aGlzLnN0eWxlc0xpc3QucHVzaChzdHlsZUVsZW0pO1xuICAgIGVsZW1lbnREYXRhLnN0eWxlID0gc3R5bGVFbGVtO1xuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUdyb3VwRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7XG4gICAgICBpdDogW10sXG4gICAgICBwcmV2Vmlld0RhdGE6IFtdXG4gICAgfTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVUcmFuc2Zvcm1FbGVtZW50ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZWxlbWVudERhdGEgPSB7XG4gICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgX29wTWRmOiBmYWxzZSxcbiAgICAgICAga2V5OiB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLmdldE5ld0tleSgpLFxuICAgICAgICBvcDogUHJvcGVydHlGYWN0b3J5LmdldFByb3AodGhpcywgZGF0YS5vLCAwLCAwLjAxLCB0aGlzKSxcbiAgICAgICAgbVByb3BzOiBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHkodGhpcywgZGF0YSwgdGhpcylcbiAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBlbGVtZW50RGF0YTtcbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZVNoYXBlRWxlbWVudCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgdmFyIGVsZW1lbnREYXRhID0gbmV3IENWU2hhcGVEYXRhKHRoaXMsIGRhdGEsIHRoaXMuc3R5bGVzTGlzdCwgdGhpcy50cmFuc2Zvcm1zTWFuYWdlcik7XG4gICAgdGhpcy5zaGFwZXMucHVzaChlbGVtZW50RGF0YSk7XG4gICAgdGhpcy5hZGRTaGFwZVRvTW9kaWZpZXJzKGVsZW1lbnREYXRhKTtcbiAgICByZXR1cm4gZWxlbWVudERhdGE7XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZWxvYWRTaGFwZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5pdGVtc0RhdGEubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgdGhpcy5wcmV2Vmlld0RhdGFbaV0gPSB0aGlzLml0ZW1zRGF0YVtpXTtcbiAgICB9XG4gICAgdGhpcy5zZWFyY2hTaGFwZXModGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdGhpcy5wcmV2Vmlld0RhdGEsIHRydWUsIFtdKTtcbiAgICBsZW4gPSB0aGlzLmR5bmFtaWNQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHRoaXMuZHluYW1pY1Byb3BlcnRpZXNbaV0uZ2V0VmFsdWUoKTtcbiAgICB9XG4gICAgdGhpcy5yZW5kZXJNb2RpZmllcnMoKTtcbiAgICB0aGlzLnRyYW5zZm9ybXNNYW5hZ2VyLnByb2Nlc3NTZXF1ZW5jZXModGhpcy5faXNGaXJzdEZyYW1lKTtcbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmFkZFRyYW5zZm9ybVRvU3R5bGVMaXN0ID0gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3RbaV0uY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS50cmFuc2Zvcm1zLnB1c2godHJhbnNmb3JtKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW1vdmVUcmFuc2Zvcm1Gcm9tU3R5bGVMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCF0aGlzLnN0eWxlc0xpc3RbaV0uY2xvc2VkKSB7XG4gICAgICAgIHRoaXMuc3R5bGVzTGlzdFtpXS50cmFuc2Zvcm1zLnBvcCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLmNsb3NlU3R5bGVzID0gZnVuY3Rpb24gKHN0eWxlcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBzdHlsZXMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgc3R5bGVzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2VhcmNoU2hhcGVzID0gZnVuY3Rpb24gKGFyciwgaXRlbXNEYXRhLCBwcmV2Vmlld0RhdGEsIHNob3VsZFJlbmRlciwgdHJhbnNmb3Jtcykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoIC0gMTtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgb3duU3R5bGVzID0gW107XG4gICAgdmFyIG93bk1vZGlmaWVycyA9IFtdO1xuICAgIHZhciBwcm9jZXNzZWRQb3M7XG4gICAgdmFyIG1vZGlmaWVyO1xuICAgIHZhciBjdXJyZW50VHJhbnNmb3JtO1xuICAgIHZhciBvd25UcmFuc2Zvcm1zID0gW10uY29uY2F0KHRyYW5zZm9ybXMpO1xuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIHByb2Nlc3NlZFBvcyA9IHRoaXMuc2VhcmNoUHJvY2Vzc2VkRWxlbWVudChhcnJbaV0pO1xuICAgICAgaWYgKCFwcm9jZXNzZWRQb3MpIHtcbiAgICAgICAgYXJyW2ldLl9zaG91bGRSZW5kZXIgPSBzaG91bGRSZW5kZXI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpdGVtc0RhdGFbaV0gPSBwcmV2Vmlld0RhdGFbcHJvY2Vzc2VkUG9zIC0gMV07XG4gICAgICB9XG4gICAgICBpZiAoYXJyW2ldLnR5ID09PSAnZmwnIHx8IGFycltpXS50eSA9PT0gJ3N0JyB8fCBhcnJbaV0udHkgPT09ICdnZicgfHwgYXJyW2ldLnR5ID09PSAnZ3MnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTdHlsZUVsZW1lbnQoYXJyW2ldLCBvd25UcmFuc2Zvcm1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0uc3R5bGUuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgb3duU3R5bGVzLnB1c2goaXRlbXNEYXRhW2ldLnN0eWxlKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnZ3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVHcm91cEVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBqTGVuID0gaXRlbXNEYXRhW2ldLml0Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgICAgICBpdGVtc0RhdGFbaV0ucHJldlZpZXdEYXRhW2pdID0gaXRlbXNEYXRhW2ldLml0W2pdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlYXJjaFNoYXBlcyhhcnJbaV0uaXQsIGl0ZW1zRGF0YVtpXS5pdCwgaXRlbXNEYXRhW2ldLnByZXZWaWV3RGF0YSwgc2hvdWxkUmVuZGVyLCBvd25UcmFuc2Zvcm1zKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAndHInKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgY3VycmVudFRyYW5zZm9ybSA9IHRoaXMuY3JlYXRlVHJhbnNmb3JtRWxlbWVudChhcnJbaV0pO1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IGN1cnJlbnRUcmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgICAgb3duVHJhbnNmb3Jtcy5wdXNoKGl0ZW1zRGF0YVtpXSk7XG4gICAgICAgIHRoaXMuYWRkVHJhbnNmb3JtVG9TdHlsZUxpc3QoaXRlbXNEYXRhW2ldKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAnc2gnIHx8IGFycltpXS50eSA9PT0gJ3JjJyB8fCBhcnJbaV0udHkgPT09ICdlbCcgfHwgYXJyW2ldLnR5ID09PSAnc3InKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgaXRlbXNEYXRhW2ldID0gdGhpcy5jcmVhdGVTaGFwZUVsZW1lbnQoYXJyW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhcnJbaV0udHkgPT09ICd0bScgfHwgYXJyW2ldLnR5ID09PSAncmQnIHx8IGFycltpXS50eSA9PT0gJ3BiJyB8fCBhcnJbaV0udHkgPT09ICd6eicgfHwgYXJyW2ldLnR5ID09PSAnb3AnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyW2ldKTtcbiAgICAgICAgICBpdGVtc0RhdGFbaV0gPSBtb2RpZmllcjtcbiAgICAgICAgICB0aGlzLnNoYXBlTW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1vZGlmaWVyID0gaXRlbXNEYXRhW2ldO1xuICAgICAgICAgIG1vZGlmaWVyLmNsb3NlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG93bk1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgIH0gZWxzZSBpZiAoYXJyW2ldLnR5ID09PSAncnAnKSB7XG4gICAgICAgIGlmICghcHJvY2Vzc2VkUG9zKSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBTaGFwZU1vZGlmaWVycy5nZXRNb2RpZmllcihhcnJbaV0udHkpO1xuICAgICAgICAgIGl0ZW1zRGF0YVtpXSA9IG1vZGlmaWVyO1xuICAgICAgICAgIG1vZGlmaWVyLmluaXQodGhpcywgYXJyLCBpLCBpdGVtc0RhdGEpO1xuICAgICAgICAgIHRoaXMuc2hhcGVNb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICAgICAgc2hvdWxkUmVuZGVyID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbW9kaWZpZXIgPSBpdGVtc0RhdGFbaV07XG4gICAgICAgICAgbW9kaWZpZXIuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBvd25Nb2RpZmllcnMucHVzaChtb2RpZmllcik7XG4gICAgICB9XG4gICAgICB0aGlzLmFkZFByb2Nlc3NlZEVsZW1lbnQoYXJyW2ldLCBpICsgMSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlVHJhbnNmb3JtRnJvbVN0eWxlTGlzdCgpO1xuICAgIHRoaXMuY2xvc2VTdHlsZXMob3duU3R5bGVzKTtcbiAgICBsZW4gPSBvd25Nb2RpZmllcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgb3duTW9kaWZpZXJzW2ldLmNsb3NlZCA9IHRydWU7XG4gICAgfVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLm9wYWNpdHkgPSAxO1xuICAgIHRoaXMudHJhbnNmb3JtSGVscGVyLl9vcE1kZiA9IGZhbHNlO1xuICAgIHRoaXMucmVuZGVyTW9kaWZpZXJzKCk7XG4gICAgdGhpcy50cmFuc2Zvcm1zTWFuYWdlci5wcm9jZXNzU2VxdWVuY2VzKHRoaXMuX2lzRmlyc3RGcmFtZSk7XG4gICAgdGhpcy5yZW5kZXJTaGFwZSh0aGlzLnRyYW5zZm9ybUhlbHBlciwgdGhpcy5zaGFwZXNEYXRhLCB0aGlzLml0ZW1zRGF0YSwgdHJ1ZSk7XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTaGFwZVRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwYXJlbnRUcmFuc2Zvcm0sIGdyb3VwVHJhbnNmb3JtKSB7XG4gICAgaWYgKHBhcmVudFRyYW5zZm9ybS5fb3BNZGYgfHwgZ3JvdXBUcmFuc2Zvcm0ub3AuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHkgPSBwYXJlbnRUcmFuc2Zvcm0ub3BhY2l0eTtcbiAgICAgIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHkgKj0gZ3JvdXBUcmFuc2Zvcm0ub3AudjtcbiAgICAgIGdyb3VwVHJhbnNmb3JtLl9vcE1kZiA9IHRydWU7XG4gICAgfVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZHJhd0xheWVyID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoO1xuICAgIHZhciBqO1xuICAgIHZhciBqTGVuO1xuICAgIHZhciBrO1xuICAgIHZhciBrTGVuO1xuICAgIHZhciBlbGVtcztcbiAgICB2YXIgbm9kZXM7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyO1xuICAgIHZhciBjdHggPSB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dDtcbiAgICB2YXIgdHlwZTtcbiAgICB2YXIgY3VycmVudFN0eWxlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgY3VycmVudFN0eWxlID0gdGhpcy5zdHlsZXNMaXN0W2ldO1xuICAgICAgdHlwZSA9IGN1cnJlbnRTdHlsZS50eXBlO1xuXG4gICAgICAvLyBTa2lwcGluZyBzdHlsZSB3aGVuXG4gICAgICAvLyBTdHJva2Ugd2lkdGggZXF1YWxzIDBcbiAgICAgIC8vIHN0eWxlIHNob3VsZCBub3QgYmUgcmVuZGVyZWQgKGV4dHJhIHVudXNlZCByZXBlYXRlcnMpXG4gICAgICAvLyBjdXJyZW50IG9wYWNpdHkgZXF1YWxzIDBcbiAgICAgIC8vIGdsb2JhbCBvcGFjaXR5IGVxdWFscyAwXG4gICAgICBpZiAoISgodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKSAmJiBjdXJyZW50U3R5bGUud2kgPT09IDAgfHwgIWN1cnJlbnRTdHlsZS5kYXRhLl9zaG91bGRSZW5kZXIgfHwgY3VycmVudFN0eWxlLmNvT3AgPT09IDAgfHwgdGhpcy5nbG9iYWxEYXRhLmN1cnJlbnRHbG9iYWxBbHBoYSA9PT0gMCkpIHtcbiAgICAgICAgcmVuZGVyZXIuc2F2ZSgpO1xuICAgICAgICBlbGVtcyA9IGN1cnJlbnRTdHlsZS5lbGVtZW50cztcbiAgICAgICAgaWYgKHR5cGUgPT09ICdzdCcgfHwgdHlwZSA9PT0gJ2dzJykge1xuICAgICAgICAgIHJlbmRlcmVyLmN0eFN0cm9rZVN0eWxlKHR5cGUgPT09ICdzdCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkKTtcbiAgICAgICAgICAvLyBjdHguc3Ryb2tlU3R5bGUgPSB0eXBlID09PSAnc3QnID8gY3VycmVudFN0eWxlLmNvIDogY3VycmVudFN0eWxlLmdyZDtcbiAgICAgICAgICByZW5kZXJlci5jdHhMaW5lV2lkdGgoY3VycmVudFN0eWxlLndpKTtcbiAgICAgICAgICAvLyBjdHgubGluZVdpZHRoID0gY3VycmVudFN0eWxlLndpO1xuICAgICAgICAgIHJlbmRlcmVyLmN0eExpbmVDYXAoY3VycmVudFN0eWxlLmxjKTtcbiAgICAgICAgICAvLyBjdHgubGluZUNhcCA9IGN1cnJlbnRTdHlsZS5sYztcbiAgICAgICAgICByZW5kZXJlci5jdHhMaW5lSm9pbihjdXJyZW50U3R5bGUubGopO1xuICAgICAgICAgIC8vIGN0eC5saW5lSm9pbiA9IGN1cnJlbnRTdHlsZS5sajtcbiAgICAgICAgICByZW5kZXJlci5jdHhNaXRlckxpbWl0KGN1cnJlbnRTdHlsZS5tbCB8fCAwKTtcbiAgICAgICAgICAvLyBjdHgubWl0ZXJMaW1pdCA9IGN1cnJlbnRTdHlsZS5tbCB8fCAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGxTdHlsZSh0eXBlID09PSAnZmwnID8gY3VycmVudFN0eWxlLmNvIDogY3VycmVudFN0eWxlLmdyZCk7XG4gICAgICAgICAgLy8gY3R4LmZpbGxTdHlsZSA9IHR5cGUgPT09ICdmbCcgPyBjdXJyZW50U3R5bGUuY28gOiBjdXJyZW50U3R5bGUuZ3JkO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLmN0eE9wYWNpdHkoY3VycmVudFN0eWxlLmNvT3ApO1xuICAgICAgICBpZiAodHlwZSAhPT0gJ3N0JyAmJiB0eXBlICE9PSAnZ3MnKSB7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlbmRlcmVyLmN0eFRyYW5zZm9ybShjdXJyZW50U3R5bGUucHJlVHJhbnNmb3Jtcy5maW5hbFRyYW5zZm9ybS5wcm9wcyk7XG4gICAgICAgIGpMZW4gPSBlbGVtcy5sZW5ndGg7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICBpZiAodHlwZSA9PT0gJ3N0JyB8fCB0eXBlID09PSAnZ3MnKSB7XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBpZiAoY3VycmVudFN0eWxlLmRhKSB7XG4gICAgICAgICAgICAgIGN0eC5zZXRMaW5lRGFzaChjdXJyZW50U3R5bGUuZGEpO1xuICAgICAgICAgICAgICBjdHgubGluZURhc2hPZmZzZXQgPSBjdXJyZW50U3R5bGVbXCJkb1wiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZXMgPSBlbGVtc1tqXS50ck5vZGVzO1xuICAgICAgICAgIGtMZW4gPSBub2Rlcy5sZW5ndGg7XG4gICAgICAgICAgZm9yIChrID0gMDsgayA8IGtMZW47IGsgKz0gMSkge1xuICAgICAgICAgICAgaWYgKG5vZGVzW2tdLnQgPT09ICdtJykge1xuICAgICAgICAgICAgICBjdHgubW92ZVRvKG5vZGVzW2tdLnBbMF0sIG5vZGVzW2tdLnBbMV0pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChub2Rlc1trXS50ID09PSAnYycpIHtcbiAgICAgICAgICAgICAgY3R4LmJlemllckN1cnZlVG8obm9kZXNba10ucHRzWzBdLCBub2Rlc1trXS5wdHNbMV0sIG5vZGVzW2tdLnB0c1syXSwgbm9kZXNba10ucHRzWzNdLCBub2Rlc1trXS5wdHNbNF0sIG5vZGVzW2tdLnB0c1s1XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0eXBlID09PSAnc3QnIHx8IHR5cGUgPT09ICdncycpIHtcbiAgICAgICAgICAgIC8vIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmN0eFN0cm9rZSgpO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRTdHlsZS5kYSkge1xuICAgICAgICAgICAgICBjdHguc2V0TGluZURhc2godGhpcy5kYXNoUmVzZXR0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSAhPT0gJ3N0JyAmJiB0eXBlICE9PSAnZ3MnKSB7XG4gICAgICAgICAgLy8gY3R4LmZpbGwoY3VycmVudFN0eWxlLnIpO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlci5jdHhGaWxsKGN1cnJlbnRTdHlsZS5yKTtcbiAgICAgICAgfVxuICAgICAgICByZW5kZXJlci5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyU2hhcGUgPSBmdW5jdGlvbiAocGFyZW50VHJhbnNmb3JtLCBpdGVtcywgZGF0YSwgaXNNYWluKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGl0ZW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIGdyb3VwVHJhbnNmb3JtO1xuICAgIGdyb3VwVHJhbnNmb3JtID0gcGFyZW50VHJhbnNmb3JtO1xuICAgIGZvciAoaSA9IGxlbjsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgIGlmIChpdGVtc1tpXS50eSA9PT0gJ3RyJykge1xuICAgICAgICBncm91cFRyYW5zZm9ybSA9IGRhdGFbaV0udHJhbnNmb3JtO1xuICAgICAgICB0aGlzLnJlbmRlclNoYXBlVHJhbnNmb3JtKHBhcmVudFRyYW5zZm9ybSwgZ3JvdXBUcmFuc2Zvcm0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ3NoJyB8fCBpdGVtc1tpXS50eSA9PT0gJ2VsJyB8fCBpdGVtc1tpXS50eSA9PT0gJ3JjJyB8fCBpdGVtc1tpXS50eSA9PT0gJ3NyJykge1xuICAgICAgICB0aGlzLnJlbmRlclBhdGgoaXRlbXNbaV0sIGRhdGFbaV0pO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ2ZsJykge1xuICAgICAgICB0aGlzLnJlbmRlckZpbGwoaXRlbXNbaV0sIGRhdGFbaV0sIGdyb3VwVHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdzdCcpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTdHJva2UoaXRlbXNbaV0sIGRhdGFbaV0sIGdyb3VwVHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdnZicgfHwgaXRlbXNbaV0udHkgPT09ICdncycpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJHcmFkaWVudEZpbGwoaXRlbXNbaV0sIGRhdGFbaV0sIGdyb3VwVHJhbnNmb3JtKTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNbaV0udHkgPT09ICdncicpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJTaGFwZShncm91cFRyYW5zZm9ybSwgaXRlbXNbaV0uaXQsIGRhdGFbaV0uaXQpO1xuICAgICAgfSBlbHNlIGlmIChpdGVtc1tpXS50eSA9PT0gJ3RtJykge1xuICAgICAgICAvL1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNNYWluKSB7XG4gICAgICB0aGlzLmRyYXdMYXllcigpO1xuICAgIH1cbiAgfTtcbiAgQ1ZTaGFwZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlclN0eWxlZFNoYXBlID0gZnVuY3Rpb24gKHN0eWxlZFNoYXBlLCBzaGFwZSkge1xuICAgIGlmICh0aGlzLl9pc0ZpcnN0RnJhbWUgfHwgc2hhcGUuX21kZiB8fCBzdHlsZWRTaGFwZS50cmFuc2Zvcm1zLl9tZGYpIHtcbiAgICAgIHZhciBzaGFwZU5vZGVzID0gc3R5bGVkU2hhcGUudHJOb2RlcztcbiAgICAgIHZhciBwYXRocyA9IHNoYXBlLnBhdGhzO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIGo7XG4gICAgICB2YXIgakxlbiA9IHBhdGhzLl9sZW5ndGg7XG4gICAgICBzaGFwZU5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICB2YXIgZ3JvdXBUcmFuc2Zvcm1NYXQgPSBzdHlsZWRTaGFwZS50cmFuc2Zvcm1zLmZpbmFsVHJhbnNmb3JtO1xuICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICB2YXIgcGF0aE5vZGVzID0gcGF0aHMuc2hhcGVzW2pdO1xuICAgICAgICBpZiAocGF0aE5vZGVzICYmIHBhdGhOb2Rlcy52KSB7XG4gICAgICAgICAgbGVuID0gcGF0aE5vZGVzLl9sZW5ndGg7XG4gICAgICAgICAgZm9yIChpID0gMTsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMSkge1xuICAgICAgICAgICAgICBzaGFwZU5vZGVzLnB1c2goe1xuICAgICAgICAgICAgICAgIHQ6ICdtJyxcbiAgICAgICAgICAgICAgICBwOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvUG9pbnRBcnJheShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ2MnLFxuICAgICAgICAgICAgICBwdHM6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9UcmlwbGVQb2ludHMocGF0aE5vZGVzLm9baSAtIDFdLCBwYXRoTm9kZXMuaVtpXSwgcGF0aE5vZGVzLnZbaV0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGxlbiA9PT0gMSkge1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ20nLFxuICAgICAgICAgICAgICBwOiBncm91cFRyYW5zZm9ybU1hdC5hcHBseVRvUG9pbnRBcnJheShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHBhdGhOb2Rlcy5jICYmIGxlbikge1xuICAgICAgICAgICAgc2hhcGVOb2Rlcy5wdXNoKHtcbiAgICAgICAgICAgICAgdDogJ2MnLFxuICAgICAgICAgICAgICBwdHM6IGdyb3VwVHJhbnNmb3JtTWF0LmFwcGx5VG9UcmlwbGVQb2ludHMocGF0aE5vZGVzLm9baSAtIDFdLCBwYXRoTm9kZXMuaVswXSwgcGF0aE5vZGVzLnZbMF0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNoYXBlTm9kZXMucHVzaCh7XG4gICAgICAgICAgICAgIHQ6ICd6J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdHlsZWRTaGFwZS50ck5vZGVzID0gc2hhcGVOb2RlcztcbiAgICB9XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJQYXRoID0gZnVuY3Rpb24gKHBhdGhEYXRhLCBpdGVtRGF0YSkge1xuICAgIGlmIChwYXRoRGF0YS5oZCAhPT0gdHJ1ZSAmJiBwYXRoRGF0YS5fc2hvdWxkUmVuZGVyKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBpdGVtRGF0YS5zdHlsZWRTaGFwZXMubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIHRoaXMucmVuZGVyU3R5bGVkU2hhcGUoaXRlbURhdGEuc3R5bGVkU2hhcGVzW2ldLCBpdGVtRGF0YS5zaCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVyRmlsbCA9IGZ1bmN0aW9uIChzdHlsZURhdGEsIGl0ZW1EYXRhLCBncm91cFRyYW5zZm9ybSkge1xuICAgIHZhciBzdHlsZUVsZW0gPSBpdGVtRGF0YS5zdHlsZTtcbiAgICBpZiAoaXRlbURhdGEuYy5fbWRmIHx8IHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgc3R5bGVFbGVtLmNvID0gJ3JnYignICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMF0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMV0pICsgJywnICsgYm1GbG9vcihpdGVtRGF0YS5jLnZbMl0pICsgJyknO1xuICAgIH1cbiAgICBpZiAoaXRlbURhdGEuby5fbWRmIHx8IGdyb3VwVHJhbnNmb3JtLl9vcE1kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHN0eWxlRWxlbS5jb09wID0gaXRlbURhdGEuby52ICogZ3JvdXBUcmFuc2Zvcm0ub3BhY2l0eTtcbiAgICB9XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJHcmFkaWVudEZpbGwgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgdmFyIGdyZDtcbiAgICBpZiAoIXN0eWxlRWxlbS5ncmQgfHwgaXRlbURhdGEuZy5fbWRmIHx8IGl0ZW1EYXRhLnMuX21kZiB8fCBpdGVtRGF0YS5lLl9tZGYgfHwgc3R5bGVEYXRhLnQgIT09IDEgJiYgKGl0ZW1EYXRhLmguX21kZiB8fCBpdGVtRGF0YS5hLl9tZGYpKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQ7XG4gICAgICB2YXIgcHQxID0gaXRlbURhdGEucy52O1xuICAgICAgdmFyIHB0MiA9IGl0ZW1EYXRhLmUudjtcbiAgICAgIGlmIChzdHlsZURhdGEudCA9PT0gMSkge1xuICAgICAgICBncmQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQocHQxWzBdLCBwdDFbMV0sIHB0MlswXSwgcHQyWzFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByYWQgPSBNYXRoLnNxcnQoTWF0aC5wb3cocHQxWzBdIC0gcHQyWzBdLCAyKSArIE1hdGgucG93KHB0MVsxXSAtIHB0MlsxXSwgMikpO1xuICAgICAgICB2YXIgYW5nID0gTWF0aC5hdGFuMihwdDJbMV0gLSBwdDFbMV0sIHB0MlswXSAtIHB0MVswXSk7XG4gICAgICAgIHZhciBwZXJjZW50ID0gaXRlbURhdGEuaC52O1xuICAgICAgICBpZiAocGVyY2VudCA+PSAxKSB7XG4gICAgICAgICAgcGVyY2VudCA9IDAuOTk7XG4gICAgICAgIH0gZWxzZSBpZiAocGVyY2VudCA8PSAtMSkge1xuICAgICAgICAgIHBlcmNlbnQgPSAtMC45OTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZGlzdCA9IHJhZCAqIHBlcmNlbnQ7XG4gICAgICAgIHZhciB4ID0gTWF0aC5jb3MoYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMF07XG4gICAgICAgIHZhciB5ID0gTWF0aC5zaW4oYW5nICsgaXRlbURhdGEuYS52KSAqIGRpc3QgKyBwdDFbMV07XG4gICAgICAgIGdyZCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudCh4LCB5LCAwLCBwdDFbMF0sIHB0MVsxXSwgcmFkKTtcbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IHN0eWxlRGF0YS5nLnA7XG4gICAgICB2YXIgY1ZhbHVlcyA9IGl0ZW1EYXRhLmcuYztcbiAgICAgIHZhciBvcGFjaXR5ID0gMTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBpZiAoaXRlbURhdGEuZy5faGFzT3BhY2l0eSAmJiBpdGVtRGF0YS5nLl9jb2xsYXBzYWJsZSkge1xuICAgICAgICAgIG9wYWNpdHkgPSBpdGVtRGF0YS5nLm9baSAqIDIgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBncmQuYWRkQ29sb3JTdG9wKGNWYWx1ZXNbaSAqIDRdIC8gMTAwLCAncmdiYSgnICsgY1ZhbHVlc1tpICogNCArIDFdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDJdICsgJywnICsgY1ZhbHVlc1tpICogNCArIDNdICsgJywnICsgb3BhY2l0eSArICcpJyk7XG4gICAgICB9XG4gICAgICBzdHlsZUVsZW0uZ3JkID0gZ3JkO1xuICAgIH1cbiAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XG4gIH07XG4gIENWU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJTdHJva2UgPSBmdW5jdGlvbiAoc3R5bGVEYXRhLCBpdGVtRGF0YSwgZ3JvdXBUcmFuc2Zvcm0pIHtcbiAgICB2YXIgc3R5bGVFbGVtID0gaXRlbURhdGEuc3R5bGU7XG4gICAgdmFyIGQgPSBpdGVtRGF0YS5kO1xuICAgIGlmIChkICYmIChkLl9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSkge1xuICAgICAgc3R5bGVFbGVtLmRhID0gZC5kYXNoQXJyYXk7XG4gICAgICBzdHlsZUVsZW1bXCJkb1wiXSA9IGQuZGFzaG9mZnNldFswXTtcbiAgICB9XG4gICAgaWYgKGl0ZW1EYXRhLmMuX21kZiB8fCB0aGlzLl9pc0ZpcnN0RnJhbWUpIHtcbiAgICAgIHN0eWxlRWxlbS5jbyA9ICdyZ2IoJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzBdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzFdKSArICcsJyArIGJtRmxvb3IoaXRlbURhdGEuYy52WzJdKSArICcpJztcbiAgICB9XG4gICAgaWYgKGl0ZW1EYXRhLm8uX21kZiB8fCBncm91cFRyYW5zZm9ybS5fb3BNZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0uY29PcCA9IGl0ZW1EYXRhLm8udiAqIGdyb3VwVHJhbnNmb3JtLm9wYWNpdHk7XG4gICAgfVxuICAgIGlmIChpdGVtRGF0YS53Ll9tZGYgfHwgdGhpcy5faXNGaXJzdEZyYW1lKSB7XG4gICAgICBzdHlsZUVsZW0ud2kgPSBpdGVtRGF0YS53LnY7XG4gICAgfVxuICB9O1xuICBDVlNoYXBlRWxlbWVudC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBudWxsO1xuICAgIHRoaXMuZ2xvYmFsRGF0YSA9IG51bGw7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnN0eWxlc0xpc3QubGVuZ3RoID0gMDtcbiAgICB0aGlzLml0ZW1zRGF0YS5sZW5ndGggPSAwO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWVGV4dEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMudGV4dFNwYW5zID0gW107XG4gICAgdGhpcy55T2Zmc2V0ID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvckFuaW0gPSBmYWxzZTtcbiAgICB0aGlzLnN0cm9rZUNvbG9yQW5pbSA9IGZhbHNlO1xuICAgIHRoaXMuc3Ryb2tlV2lkdGhBbmltID0gZmFsc2U7XG4gICAgdGhpcy5zdHJva2UgPSBmYWxzZTtcbiAgICB0aGlzLmZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmp1c3RpZnlPZmZzZXQgPSAwO1xuICAgIHRoaXMuY3VycmVudFJlbmRlciA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJUeXBlID0gJ2NhbnZhcyc7XG4gICAgdGhpcy52YWx1ZXMgPSB7XG4gICAgICBmaWxsOiAncmdiYSgwLDAsMCwwKScsXG4gICAgICBzdHJva2U6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgIHNXaWR0aDogMCxcbiAgICAgIGZWYWx1ZTogJydcbiAgICB9O1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgQ1ZCYXNlRWxlbWVudCwgSGllcmFyY2h5RWxlbWVudCwgRnJhbWVFbGVtZW50LCBSZW5kZXJhYmxlRWxlbWVudCwgSVRleHRFbGVtZW50XSwgQ1ZUZXh0RWxlbWVudCk7XG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnRIZWxwZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpLmdldENvbnRleHQoJzJkJyk7XG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YS5sID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG4gICAgdmFyIGhhc0ZpbGwgPSBmYWxzZTtcbiAgICBpZiAoZG9jdW1lbnREYXRhLmZjKSB7XG4gICAgICBoYXNGaWxsID0gdHJ1ZTtcbiAgICAgIHRoaXMudmFsdWVzLmZpbGwgPSB0aGlzLmJ1aWxkQ29sb3IoZG9jdW1lbnREYXRhLmZjKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy52YWx1ZXMuZmlsbCA9ICdyZ2JhKDAsMCwwLDApJztcbiAgICB9XG4gICAgdGhpcy5maWxsID0gaGFzRmlsbDtcbiAgICB2YXIgaGFzU3Ryb2tlID0gZmFsc2U7XG4gICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgaGFzU3Ryb2tlID0gdHJ1ZTtcbiAgICAgIHRoaXMudmFsdWVzLnN0cm9rZSA9IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuc2MpO1xuICAgICAgdGhpcy52YWx1ZXMuc1dpZHRoID0gZG9jdW1lbnREYXRhLnN3O1xuICAgIH1cbiAgICB2YXIgZm9udERhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZik7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgbGV0dGVycyA9IGRvY3VtZW50RGF0YS5sO1xuICAgIHZhciBtYXRyaXhIZWxwZXIgPSB0aGlzLm1IZWxwZXI7XG4gICAgdGhpcy5zdHJva2UgPSBoYXNTdHJva2U7XG4gICAgdGhpcy52YWx1ZXMuZlZhbHVlID0gZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSArICdweCAnICsgdGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmdldEZvbnRCeU5hbWUoZG9jdW1lbnREYXRhLmYpLmZGYW1pbHk7XG4gICAgbGVuID0gZG9jdW1lbnREYXRhLmZpbmFsVGV4dC5sZW5ndGg7XG4gICAgLy8gdGhpcy50SGVscGVyLmZvbnQgPSB0aGlzLnZhbHVlcy5mVmFsdWU7XG4gICAgdmFyIGNoYXJEYXRhO1xuICAgIHZhciBzaGFwZURhdGE7XG4gICAgdmFyIGs7XG4gICAgdmFyIGtMZW47XG4gICAgdmFyIHNoYXBlcztcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgcGF0aE5vZGVzO1xuICAgIHZhciBjb21tYW5kcztcbiAgICB2YXIgcGF0aEFycjtcbiAgICB2YXIgc2luZ2xlU2hhcGUgPSB0aGlzLmRhdGEuc2luZ2xlU2hhcGU7XG4gICAgdmFyIHRyYWNraW5nT2Zmc2V0ID0gZG9jdW1lbnREYXRhLnRyICogMC4wMDEgKiBkb2N1bWVudERhdGEuZmluYWxTaXplO1xuICAgIHZhciB4UG9zID0gMDtcbiAgICB2YXIgeVBvcyA9IDA7XG4gICAgdmFyIGZpcnN0TGluZSA9IHRydWU7XG4gICAgdmFyIGNudCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBjaGFyRGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRDaGFyRGF0YShkb2N1bWVudERhdGEuZmluYWxUZXh0W2ldLCBmb250RGF0YS5mU3R5bGUsIHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKS5mRmFtaWx5KTtcbiAgICAgIHNoYXBlRGF0YSA9IGNoYXJEYXRhICYmIGNoYXJEYXRhLmRhdGEgfHwge307XG4gICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcbiAgICAgIGlmIChzaW5nbGVTaGFwZSAmJiBsZXR0ZXJzW2ldLm4pIHtcbiAgICAgICAgeFBvcyA9IC10cmFja2luZ09mZnNldDtcbiAgICAgICAgeVBvcyArPSBkb2N1bWVudERhdGEueU9mZnNldDtcbiAgICAgICAgeVBvcyArPSBmaXJzdExpbmUgPyAxIDogMDtcbiAgICAgICAgZmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBzaGFwZXMgPSBzaGFwZURhdGEuc2hhcGVzID8gc2hhcGVEYXRhLnNoYXBlc1swXS5pdCA6IFtdO1xuICAgICAgakxlbiA9IHNoYXBlcy5sZW5ndGg7XG4gICAgICBtYXRyaXhIZWxwZXIuc2NhbGUoZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCk7XG4gICAgICBpZiAoc2luZ2xlU2hhcGUpIHtcbiAgICAgICAgdGhpcy5hcHBseVRleHRQcm9wZXJ0aWVzVG9NYXRyaXgoZG9jdW1lbnREYXRhLCBtYXRyaXhIZWxwZXIsIGxldHRlcnNbaV0ubGluZSwgeFBvcywgeVBvcyk7XG4gICAgICB9XG4gICAgICBjb21tYW5kcyA9IGNyZWF0ZVNpemVkQXJyYXkoakxlbiAtIDEpO1xuICAgICAgdmFyIGNvbW1hbmRzQ291bnRlciA9IDA7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgakxlbjsgaiArPSAxKSB7XG4gICAgICAgIGlmIChzaGFwZXNbal0udHkgPT09ICdzaCcpIHtcbiAgICAgICAgICBrTGVuID0gc2hhcGVzW2pdLmtzLmsuaS5sZW5ndGg7XG4gICAgICAgICAgcGF0aE5vZGVzID0gc2hhcGVzW2pdLmtzLms7XG4gICAgICAgICAgcGF0aEFyciA9IFtdO1xuICAgICAgICAgIGZvciAoayA9IDE7IGsgPCBrTGVuOyBrICs9IDEpIHtcbiAgICAgICAgICAgIGlmIChrID09PSAxKSB7XG4gICAgICAgICAgICAgIHBhdGhBcnIucHVzaChtYXRyaXhIZWxwZXIuYXBwbHlUb1gocGF0aE5vZGVzLnZbMF1bMF0sIHBhdGhOb2Rlcy52WzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9ZKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGF0aEFyci5wdXNoKG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMuaVtrXVswXSwgcGF0aE5vZGVzLmlba11bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLmlba11bMF0sIHBhdGhOb2Rlcy5pW2tdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy52W2tdWzBdLCBwYXRoTm9kZXMudltrXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMudltrXVswXSwgcGF0aE5vZGVzLnZba11bMV0sIDApKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aEFyci5wdXNoKG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMub1trIC0gMV1bMF0sIHBhdGhOb2Rlcy5vW2sgLSAxXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWChwYXRoTm9kZXMuaVswXVswXSwgcGF0aE5vZGVzLmlbMF1bMV0sIDApLCBtYXRyaXhIZWxwZXIuYXBwbHlUb1kocGF0aE5vZGVzLmlbMF1bMF0sIHBhdGhOb2Rlcy5pWzBdWzFdLCAwKSwgbWF0cml4SGVscGVyLmFwcGx5VG9YKHBhdGhOb2Rlcy52WzBdWzBdLCBwYXRoTm9kZXMudlswXVsxXSwgMCksIG1hdHJpeEhlbHBlci5hcHBseVRvWShwYXRoTm9kZXMudlswXVswXSwgcGF0aE5vZGVzLnZbMF1bMV0sIDApKTtcbiAgICAgICAgICBjb21tYW5kc1tjb21tYW5kc0NvdW50ZXJdID0gcGF0aEFycjtcbiAgICAgICAgICBjb21tYW5kc0NvdW50ZXIgKz0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNpbmdsZVNoYXBlKSB7XG4gICAgICAgIHhQb3MgKz0gbGV0dGVyc1tpXS5sO1xuICAgICAgICB4UG9zICs9IHRyYWNraW5nT2Zmc2V0O1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMudGV4dFNwYW5zW2NudF0pIHtcbiAgICAgICAgdGhpcy50ZXh0U3BhbnNbY250XS5lbGVtID0gY29tbWFuZHM7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0ge1xuICAgICAgICAgIGVsZW06IGNvbW1hbmRzXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG4gIH07XG4gIENWVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVGV4dCgpO1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmZvbnQgPSB0aGlzLnZhbHVlcy5mVmFsdWU7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyLmN0eExpbmVDYXAoJ2J1dHQnKTtcbiAgICAvLyBjdHgubGluZUNhcCA9ICdidXR0JztcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TGluZUpvaW4oJ21pdGVyJyk7XG4gICAgLy8gY3R4LmxpbmVKb2luID0gJ21pdGVyJztcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4TWl0ZXJMaW1pdCg0KTtcbiAgICAvLyBjdHgubWl0ZXJMaW1pdCA9IDQ7XG5cbiAgICBpZiAoIXRoaXMuZGF0YS5zaW5nbGVTaGFwZSkge1xuICAgICAgdGhpcy50ZXh0QW5pbWF0b3IuZ2V0TWVhc3VyZXModGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEsIHRoaXMubGV0dGVyc0NoYW5nZWRGbGFnKTtcbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbjtcbiAgICB2YXIgajtcbiAgICB2YXIgakxlbjtcbiAgICB2YXIgaztcbiAgICB2YXIga0xlbjtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXJzID0gdGhpcy50ZXh0QW5pbWF0b3IucmVuZGVyZWRMZXR0ZXJzO1xuICAgIHZhciBsZXR0ZXJzID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGEubDtcbiAgICBsZW4gPSBsZXR0ZXJzLmxlbmd0aDtcbiAgICB2YXIgcmVuZGVyZWRMZXR0ZXI7XG4gICAgdmFyIGxhc3RGaWxsID0gbnVsbDtcbiAgICB2YXIgbGFzdFN0cm9rZSA9IG51bGw7XG4gICAgdmFyIGxhc3RTdHJva2VXID0gbnVsbDtcbiAgICB2YXIgY29tbWFuZHM7XG4gICAgdmFyIHBhdGhBcnI7XG4gICAgdmFyIHJlbmRlcmVyID0gdGhpcy5nbG9iYWxEYXRhLnJlbmRlcmVyO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKCFsZXR0ZXJzW2ldLm4pIHtcbiAgICAgICAgcmVuZGVyZWRMZXR0ZXIgPSByZW5kZXJlZExldHRlcnNbaV07XG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlcikge1xuICAgICAgICAgIHJlbmRlcmVyLnNhdmUoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhUcmFuc2Zvcm0ocmVuZGVyZWRMZXR0ZXIucCk7XG4gICAgICAgICAgcmVuZGVyZXIuY3R4T3BhY2l0eShyZW5kZXJlZExldHRlci5vKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5maWxsKSB7XG4gICAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyICYmIHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICBpZiAobGFzdEZpbGwgIT09IHJlbmRlcmVkTGV0dGVyLmZjKSB7XG4gICAgICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGxTdHlsZShyZW5kZXJlZExldHRlci5mYyk7XG4gICAgICAgICAgICAgIGxhc3RGaWxsID0gcmVuZGVyZWRMZXR0ZXIuZmM7XG4gICAgICAgICAgICAgIC8vIGN0eC5maWxsU3R5bGUgPSByZW5kZXJlZExldHRlci5mYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RGaWxsICE9PSB0aGlzLnZhbHVlcy5maWxsKSB7XG4gICAgICAgICAgICBsYXN0RmlsbCA9IHRoaXMudmFsdWVzLmZpbGw7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhGaWxsU3R5bGUodGhpcy52YWx1ZXMuZmlsbCk7XG4gICAgICAgICAgICAvLyBjdHguZmlsbFN0eWxlID0gdGhpcy52YWx1ZXMuZmlsbDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29tbWFuZHMgPSB0aGlzLnRleHRTcGFuc1tpXS5lbGVtO1xuICAgICAgICAgIGpMZW4gPSBjb21tYW5kcy5sZW5ndGg7XG4gICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgZm9yIChqID0gMDsgaiA8IGpMZW47IGogKz0gMSkge1xuICAgICAgICAgICAgcGF0aEFyciA9IGNvbW1hbmRzW2pdO1xuICAgICAgICAgICAga0xlbiA9IHBhdGhBcnIubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQubW92ZVRvKHBhdGhBcnJbMF0sIHBhdGhBcnJbMV0pO1xuICAgICAgICAgICAgZm9yIChrID0gMjsgayA8IGtMZW47IGsgKz0gNikge1xuICAgICAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5iZXppZXJDdXJ2ZVRvKHBhdGhBcnJba10sIHBhdGhBcnJbayArIDFdLCBwYXRoQXJyW2sgKyAyXSwgcGF0aEFycltrICsgM10sIHBhdGhBcnJbayArIDRdLCBwYXRoQXJyW2sgKyA1XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIHJlbmRlcmVyLmN0eEZpbGwoKTtcbiAgICAgICAgICAvLyB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5maWxsKCk7XG4gICAgICAgICAgLy8vIGN0eC5maWxsVGV4dCh0aGlzLnRleHRTcGFuc1tpXS52YWwsMCwwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdHJva2UpIHtcbiAgICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIgJiYgcmVuZGVyZWRMZXR0ZXIuc3cpIHtcbiAgICAgICAgICAgIGlmIChsYXN0U3Ryb2tlVyAhPT0gcmVuZGVyZWRMZXR0ZXIuc3cpIHtcbiAgICAgICAgICAgICAgbGFzdFN0cm9rZVcgPSByZW5kZXJlZExldHRlci5zdztcbiAgICAgICAgICAgICAgcmVuZGVyZXIuY3R4TGluZVdpZHRoKHJlbmRlcmVkTGV0dGVyLnN3KTtcbiAgICAgICAgICAgICAgLy8gY3R4LmxpbmVXaWR0aCA9IHJlbmRlcmVkTGV0dGVyLnN3O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSBpZiAobGFzdFN0cm9rZVcgIT09IHRoaXMudmFsdWVzLnNXaWR0aCkge1xuICAgICAgICAgICAgbGFzdFN0cm9rZVcgPSB0aGlzLnZhbHVlcy5zV2lkdGg7XG4gICAgICAgICAgICByZW5kZXJlci5jdHhMaW5lV2lkdGgodGhpcy52YWx1ZXMuc1dpZHRoKTtcbiAgICAgICAgICAgIC8vIGN0eC5saW5lV2lkdGggPSB0aGlzLnZhbHVlcy5zV2lkdGg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZW5kZXJlZExldHRlciAmJiByZW5kZXJlZExldHRlci5zYykge1xuICAgICAgICAgICAgaWYgKGxhc3RTdHJva2UgIT09IHJlbmRlcmVkTGV0dGVyLnNjKSB7XG4gICAgICAgICAgICAgIGxhc3RTdHJva2UgPSByZW5kZXJlZExldHRlci5zYztcbiAgICAgICAgICAgICAgcmVuZGVyZXIuY3R4U3Ryb2tlU3R5bGUocmVuZGVyZWRMZXR0ZXIuc2MpO1xuICAgICAgICAgICAgICAvLyBjdHguc3Ryb2tlU3R5bGUgPSByZW5kZXJlZExldHRlci5zYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2UgaWYgKGxhc3RTdHJva2UgIT09IHRoaXMudmFsdWVzLnN0cm9rZSkge1xuICAgICAgICAgICAgbGFzdFN0cm9rZSA9IHRoaXMudmFsdWVzLnN0cm9rZTtcbiAgICAgICAgICAgIHJlbmRlcmVyLmN0eFN0cm9rZVN0eWxlKHRoaXMudmFsdWVzLnN0cm9rZSk7XG4gICAgICAgICAgICAvLyBjdHguc3Ryb2tlU3R5bGUgPSB0aGlzLnZhbHVlcy5zdHJva2U7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbW1hbmRzID0gdGhpcy50ZXh0U3BhbnNbaV0uZWxlbTtcbiAgICAgICAgICBqTGVuID0gY29tbWFuZHMubGVuZ3RoO1xuICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBqTGVuOyBqICs9IDEpIHtcbiAgICAgICAgICAgIHBhdGhBcnIgPSBjb21tYW5kc1tqXTtcbiAgICAgICAgICAgIGtMZW4gPSBwYXRoQXJyLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0Lm1vdmVUbyhwYXRoQXJyWzBdLCBwYXRoQXJyWzFdKTtcbiAgICAgICAgICAgIGZvciAoayA9IDI7IGsgPCBrTGVuOyBrICs9IDYpIHtcbiAgICAgICAgICAgICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQuYmV6aWVyQ3VydmVUbyhwYXRoQXJyW2tdLCBwYXRoQXJyW2sgKyAxXSwgcGF0aEFycltrICsgMl0sIHBhdGhBcnJbayArIDNdLCBwYXRoQXJyW2sgKyA0XSwgcGF0aEFycltrICsgNV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICByZW5kZXJlci5jdHhTdHJva2UoKTtcbiAgICAgICAgICAvLyB0aGlzLmdsb2JhbERhdGEuY2FudmFzQ29udGV4dC5zdHJva2UoKTtcbiAgICAgICAgICAvLy8gY3R4LnN0cm9rZVRleHQobGV0dGVyc1tpXS52YWwsMCwwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIpIHtcbiAgICAgICAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIucmVzdG9yZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIENWSW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuaW1nID0gZ2xvYmFsRGF0YS5pbWFnZUxvYWRlci5nZXRBc3NldCh0aGlzLmFzc2V0RGF0YSk7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBDVkJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgQ1ZJbWFnZUVsZW1lbnQpO1xuICBDVkltYWdlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQgPSBTVkdTaGFwZUVsZW1lbnQucHJvdG90eXBlLmluaXRFbGVtZW50O1xuICBDVkltYWdlRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lID0gSUltYWdlRWxlbWVudC5wcm90b3R5cGUucHJlcGFyZUZyYW1lO1xuICBDVkltYWdlRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5pbWcud2lkdGggJiYgKHRoaXMuYXNzZXREYXRhLncgIT09IHRoaXMuaW1nLndpZHRoIHx8IHRoaXMuYXNzZXREYXRhLmggIT09IHRoaXMuaW1nLmhlaWdodCkpIHtcbiAgICAgIHZhciBjYW52YXMgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgY2FudmFzLndpZHRoID0gdGhpcy5hc3NldERhdGEudztcbiAgICAgIGNhbnZhcy5oZWlnaHQgPSB0aGlzLmFzc2V0RGF0YS5oO1xuICAgICAgdmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgICAgdmFyIGltZ1cgPSB0aGlzLmltZy53aWR0aDtcbiAgICAgIHZhciBpbWdIID0gdGhpcy5pbWcuaGVpZ2h0O1xuICAgICAgdmFyIGltZ1JlbCA9IGltZ1cgLyBpbWdIO1xuICAgICAgdmFyIGNhbnZhc1JlbCA9IHRoaXMuYXNzZXREYXRhLncgLyB0aGlzLmFzc2V0RGF0YS5oO1xuICAgICAgdmFyIHdpZHRoQ3JvcDtcbiAgICAgIHZhciBoZWlnaHRDcm9wO1xuICAgICAgdmFyIHBhciA9IHRoaXMuYXNzZXREYXRhLnByIHx8IHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvO1xuICAgICAgaWYgKGltZ1JlbCA+IGNhbnZhc1JlbCAmJiBwYXIgPT09ICd4TWlkWU1pZCBzbGljZScgfHwgaW1nUmVsIDwgY2FudmFzUmVsICYmIHBhciAhPT0gJ3hNaWRZTWlkIHNsaWNlJykge1xuICAgICAgICBoZWlnaHRDcm9wID0gaW1nSDtcbiAgICAgICAgd2lkdGhDcm9wID0gaGVpZ2h0Q3JvcCAqIGNhbnZhc1JlbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdpZHRoQ3JvcCA9IGltZ1c7XG4gICAgICAgIGhlaWdodENyb3AgPSB3aWR0aENyb3AgLyBjYW52YXNSZWw7XG4gICAgICB9XG4gICAgICBjdHguZHJhd0ltYWdlKHRoaXMuaW1nLCAoaW1nVyAtIHdpZHRoQ3JvcCkgLyAyLCAoaW1nSCAtIGhlaWdodENyb3ApIC8gMiwgd2lkdGhDcm9wLCBoZWlnaHRDcm9wLCAwLCAwLCB0aGlzLmFzc2V0RGF0YS53LCB0aGlzLmFzc2V0RGF0YS5oKTtcbiAgICAgIHRoaXMuaW1nID0gY2FudmFzO1xuICAgIH1cbiAgfTtcbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZHJhd0ltYWdlKHRoaXMuaW1nLCAwLCAwKTtcbiAgfTtcbiAgQ1ZJbWFnZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5pbWcgPSBudWxsO1xuICB9O1xuXG4gIGZ1bmN0aW9uIENWU29saWRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmluaXRFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApO1xuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIENWQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZUVsZW1lbnRdLCBDVlNvbGlkRWxlbWVudCk7XG4gIENWU29saWRFbGVtZW50LnByb3RvdHlwZS5pbml0RWxlbWVudCA9IFNWR1NoYXBlRWxlbWVudC5wcm90b3R5cGUuaW5pdEVsZW1lbnQ7XG4gIENWU29saWRFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWUgPSBJSW1hZ2VFbGVtZW50LnByb3RvdHlwZS5wcmVwYXJlRnJhbWU7XG4gIENWU29saWRFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdmFyIGN0eCA9IHRoaXMuY2FudmFzQ29udGV4dDtcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4RmlsbFN0eWxlKHRoaXMuZGF0YS5zYyk7XG4gICAgLy8gY3R4LmZpbGxTdHlsZSA9IHRoaXMuZGF0YS5zYztcbiAgICB0aGlzLmdsb2JhbERhdGEucmVuZGVyZXIuY3R4RmlsbFJlY3QoMCwgMCwgdGhpcy5kYXRhLnN3LCB0aGlzLmRhdGEuc2gpO1xuICAgIC8vIGN0eC5maWxsUmVjdCgwLCAwLCB0aGlzLmRhdGEuc3csIHRoaXMuZGF0YS5zaCk7XG4gICAgLy9cbiAgfTtcblxuICBmdW5jdGlvbiBDYW52YXNSZW5kZXJlckJhc2UoKSB7fVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VSZW5kZXJlcl0sIENhbnZhc1JlbmRlcmVyQmFzZSk7XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlU2hhcGUgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHJldHVybiBuZXcgQ1ZTaGFwZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVUZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENWVGV4dEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDVkltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVNvbGlkID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENWU29saWRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlTnVsbCA9IFNWR1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVOdWxsO1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eFRyYW5zZm9ybSA9IGZ1bmN0aW9uIChwcm9wcykge1xuICAgIGlmIChwcm9wc1swXSA9PT0gMSAmJiBwcm9wc1sxXSA9PT0gMCAmJiBwcm9wc1s0XSA9PT0gMCAmJiBwcm9wc1s1XSA9PT0gMSAmJiBwcm9wc1sxMl0gPT09IDAgJiYgcHJvcHNbMTNdID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuY2FudmFzQ29udGV4dC50cmFuc2Zvcm0ocHJvcHNbMF0sIHByb3BzWzFdLCBwcm9wc1s0XSwgcHJvcHNbNV0sIHByb3BzWzEyXSwgcHJvcHNbMTNdKTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhPcGFjaXR5ID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0Lmdsb2JhbEFscGhhICo9IG9wIDwgMCA/IDAgOiBvcDtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbFN0eWxlID0gdmFsdWU7XG4gIH07XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4U3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhMaW5lV2lkdGggPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZVdpZHRoID0gdmFsdWU7XG4gIH07XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TGluZUNhcCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5saW5lQ2FwID0gdmFsdWU7XG4gIH07XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3R4TGluZUpvaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQubGluZUpvaW4gPSB2YWx1ZTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhNaXRlckxpbWl0ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0Lm1pdGVyTGltaXQgPSB2YWx1ZTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsID0gZnVuY3Rpb24gKHJ1bGUpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuZmlsbChydWxlKTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jdHhGaWxsUmVjdCA9IGZ1bmN0aW9uICh4LCB5LCB3LCBoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmZpbGxSZWN0KHgsIHksIHcsIGgpO1xuICB9O1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmN0eFN0cm9rZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVzZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5jb250ZXh0RGF0YS5yZXNldCgpO1xuICB9O1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnNhdmUoKTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGFjdGlvbkZsYWcpIHtcbiAgICBpZiAoIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzKSB7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQucmVzdG9yZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoYWN0aW9uRmxhZykge1xuICAgICAgdGhpcy5nbG9iYWxEYXRhLmJsZW5kTW9kZSA9ICdzb3VyY2Utb3Zlcic7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dERhdGEucmVzdG9yZShhY3Rpb25GbGFnKTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jb25maWdBbmltYXRpb24gPSBmdW5jdGlvbiAoYW5pbURhdGEpIHtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBjcmVhdGVUYWcoJ2NhbnZhcycpO1xuICAgICAgdmFyIGNvbnRhaW5lclN0eWxlID0gdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zdHlsZTtcbiAgICAgIGNvbnRhaW5lclN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgICAgY29udGFpbmVyU3R5bGUuaGVpZ2h0ID0gJzEwMCUnO1xuICAgICAgdmFyIG9yaWdpbiA9ICcwcHggMHB4IDBweCc7XG4gICAgICBjb250YWluZXJTdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICBjb250YWluZXJTdHlsZVsnLXdlYmtpdC10cmFuc2Zvcm0nXSA9IG9yaWdpbjtcbiAgICAgIGNvbnRhaW5lclN0eWxlLmNvbnRlbnRWaXNpYmlsaXR5ID0gdGhpcy5yZW5kZXJDb25maWcuY29udGVudFZpc2liaWxpdHk7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5hcHBlbmRDaGlsZCh0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyKTtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGFzc05hbWUpIHtcbiAgICAgICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5pZCkge1xuICAgICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0uY29udGFpbmVyLnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLnJlbmRlckNvbmZpZy5pZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dCA9IHRoaXMucmVuZGVyQ29uZmlnLmNvbnRleHQ7XG4gICAgfVxuICAgIHRoaXMuY29udGV4dERhdGEuc2V0Q29udGV4dCh0aGlzLmNhbnZhc0NvbnRleHQpO1xuICAgIHRoaXMuZGF0YSA9IGFuaW1EYXRhO1xuICAgIHRoaXMubGF5ZXJzID0gYW5pbURhdGEubGF5ZXJzO1xuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzID0ge1xuICAgICAgdzogYW5pbURhdGEudyxcbiAgICAgIGg6IGFuaW1EYXRhLmgsXG4gICAgICBzeDogMCxcbiAgICAgIHN5OiAwLFxuICAgICAgdHg6IDAsXG4gICAgICB0eTogMFxuICAgIH07XG4gICAgdGhpcy5zZXR1cEdsb2JhbERhdGEoYW5pbURhdGEsIGRvY3VtZW50LmJvZHkpO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5jYW52YXNDb250ZXh0ID0gdGhpcy5jYW52YXNDb250ZXh0O1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5yZW5kZXJlciA9IHRoaXM7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmlzRGFzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5nbG9iYWxEYXRhLnByb2dyZXNzaXZlTG9hZCA9IHRoaXMucmVuZGVyQ29uZmlnLnByb2dyZXNzaXZlTG9hZDtcbiAgICB0aGlzLmdsb2JhbERhdGEudHJhbnNmb3JtQ2FudmFzID0gdGhpcy50cmFuc2Zvcm1DYW52YXM7XG4gICAgdGhpcy5lbGVtZW50cyA9IGNyZWF0ZVNpemVkQXJyYXkoYW5pbURhdGEubGF5ZXJzLmxlbmd0aCk7XG4gICAgdGhpcy51cGRhdGVDb250YWluZXJTaXplKCk7XG4gIH07XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5yZXNldCgpO1xuICAgIHZhciBlbGVtZW50V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQ7XG4gICAgaWYgKHdpZHRoKSB7XG4gICAgICBlbGVtZW50V2lkdGggPSB3aWR0aDtcbiAgICAgIGVsZW1lbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLndpZHRoID0gZWxlbWVudFdpZHRoO1xuICAgICAgdGhpcy5jYW52YXNDb250ZXh0LmNhbnZhcy5oZWlnaHQgPSBlbGVtZW50SGVpZ2h0O1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIgJiYgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lcikge1xuICAgICAgICBlbGVtZW50V2lkdGggPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRXaWR0aDtcbiAgICAgICAgZWxlbWVudEhlaWdodCA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyLm9mZnNldEhlaWdodDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRXaWR0aCA9IHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGg7XG4gICAgICAgIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodDtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jYW52YXMud2lkdGggPSBlbGVtZW50V2lkdGggKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB0aGlzLmNhbnZhc0NvbnRleHQuY2FudmFzLmhlaWdodCA9IGVsZW1lbnRIZWlnaHQgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgfVxuICAgIHZhciBlbGVtZW50UmVsO1xuICAgIHZhciBhbmltYXRpb25SZWw7XG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8uaW5kZXhPZignbWVldCcpICE9PSAtMSB8fCB0aGlzLnJlbmRlckNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvLmluZGV4T2YoJ3NsaWNlJykgIT09IC0xKSB7XG4gICAgICB2YXIgcGFyID0gdGhpcy5yZW5kZXJDb25maWcucHJlc2VydmVBc3BlY3RSYXRpby5zcGxpdCgnICcpO1xuICAgICAgdmFyIGZpbGxUeXBlID0gcGFyWzFdIHx8ICdtZWV0JztcbiAgICAgIHZhciBwb3MgPSBwYXJbMF0gfHwgJ3hNaWRZTWlkJztcbiAgICAgIHZhciB4UG9zID0gcG9zLnN1YnN0cigwLCA0KTtcbiAgICAgIHZhciB5UG9zID0gcG9zLnN1YnN0cig0KTtcbiAgICAgIGVsZW1lbnRSZWwgPSBlbGVtZW50V2lkdGggLyBlbGVtZW50SGVpZ2h0O1xuICAgICAgYW5pbWF0aW9uUmVsID0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAvIHRoaXMudHJhbnNmb3JtQ2FudmFzLmg7XG4gICAgICBpZiAoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnIHx8IGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSBlbGVtZW50V2lkdGggLyAodGhpcy50cmFuc2Zvcm1DYW52YXMudyAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN5ID0gZWxlbWVudFdpZHRoIC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLncgLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSBlbGVtZW50SGVpZ2h0IC8gKHRoaXMudHJhbnNmb3JtQ2FudmFzLmggLyB0aGlzLnJlbmRlckNvbmZpZy5kcHIpO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRIZWlnaHQgLyAodGhpcy50cmFuc2Zvcm1DYW52YXMuaCAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XG4gICAgICB9XG4gICAgICBpZiAoeFBvcyA9PT0gJ3hNaWQnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpIC8gMiAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSBpZiAoeFBvcyA9PT0gJ3hNYXgnICYmIChhbmltYXRpb25SZWwgPCBlbGVtZW50UmVsICYmIGZpbGxUeXBlID09PSAnbWVldCcgfHwgYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ3NsaWNlJykpIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAoZWxlbWVudFdpZHRoIC0gdGhpcy50cmFuc2Zvcm1DYW52YXMudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy50cmFuc2Zvcm1DYW52YXMuaCkpICogdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMudHggPSAwO1xuICAgICAgfVxuICAgICAgaWYgKHlQb3MgPT09ICdZTWlkJyAmJiAoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnIHx8IGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gKGVsZW1lbnRIZWlnaHQgLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oICogKGVsZW1lbnRXaWR0aCAvIHRoaXMudHJhbnNmb3JtQ2FudmFzLncpKSAvIDIgKiB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB9IGVsc2UgaWYgKHlQb3MgPT09ICdZTWF4JyAmJiAoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCAmJiBmaWxsVHlwZSA9PT0gJ21lZXQnIHx8IGFuaW1hdGlvblJlbCA8IGVsZW1lbnRSZWwgJiYgZmlsbFR5cGUgPT09ICdzbGljZScpKSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gKGVsZW1lbnRIZWlnaHQgLSB0aGlzLnRyYW5zZm9ybUNhbnZhcy5oICogKGVsZW1lbnRXaWR0aCAvIHRoaXMudHJhbnNmb3JtQ2FudmFzLncpKSAqIHRoaXMucmVuZGVyQ29uZmlnLmRwcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMucmVuZGVyQ29uZmlnLnByZXNlcnZlQXNwZWN0UmF0aW8gPT09ICdub25lJykge1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3ggPSBlbGVtZW50V2lkdGggLyAodGhpcy50cmFuc2Zvcm1DYW52YXMudyAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSA9IGVsZW1lbnRIZWlnaHQgLyAodGhpcy50cmFuc2Zvcm1DYW52YXMuaCAvIHRoaXMucmVuZGVyQ29uZmlnLmRwcik7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IDA7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IDA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnN4ID0gdGhpcy5yZW5kZXJDb25maWcuZHByO1xuICAgICAgdGhpcy50cmFuc2Zvcm1DYW52YXMuc3kgPSB0aGlzLnJlbmRlckNvbmZpZy5kcHI7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eCA9IDA7XG4gICAgICB0aGlzLnRyYW5zZm9ybUNhbnZhcy50eSA9IDA7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtQ2FudmFzLnByb3BzID0gW3RoaXMudHJhbnNmb3JtQ2FudmFzLnN4LCAwLCAwLCAwLCAwLCB0aGlzLnRyYW5zZm9ybUNhbnZhcy5zeSwgMCwgMCwgMCwgMCwgMSwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudHgsIHRoaXMudHJhbnNmb3JtQ2FudmFzLnR5LCAwLCAxXTtcbiAgICAvKiB2YXIgaSwgbGVuID0gdGhpcy5lbGVtZW50cy5sZW5ndGg7XG4gICAgICBmb3IoaT0wO2k8bGVuO2krPTEpe1xuICAgICAgICAgIGlmKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXS5kYXRhLnR5ID09PSAwKXtcbiAgICAgICAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5yZXNpemUodGhpcy5nbG9iYWxEYXRhLnRyYW5zZm9ybUNhbnZhcyk7XG4gICAgICAgICAgfVxuICAgICAgfSAqL1xuICAgIHRoaXMuY3R4VHJhbnNmb3JtKHRoaXMudHJhbnNmb3JtQ2FudmFzLnByb3BzKTtcbiAgICB0aGlzLmNhbnZhc0NvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LnJlY3QoMCwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudywgdGhpcy50cmFuc2Zvcm1DYW52YXMuaCk7XG4gICAgdGhpcy5jYW52YXNDb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbGlwKCk7XG4gICAgdGhpcy5yZW5kZXJGcmFtZSh0aGlzLnJlbmRlcmVkRnJhbWUsIHRydWUpO1xuICB9O1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzICYmIHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyKSB7XG4gICAgICB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5pbm5lclRleHQgPSAnJztcbiAgICB9XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzID8gdGhpcy5sYXllcnMubGVuZ3RoIDogMDtcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5nbG9iYWxEYXRhLmNhbnZhc0NvbnRleHQgPSBudWxsO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfTtcbiAgQ2FudmFzUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChudW0sIGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKHRoaXMucmVuZGVyZWRGcmFtZSA9PT0gbnVtICYmIHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzID09PSB0cnVlICYmICFmb3JjZVJlbmRlciB8fCB0aGlzLmRlc3Ryb3llZCB8fCBudW0gPT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IG51bTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVOdW0gPSBudW0gLSB0aGlzLmFuaW1hdGlvbkl0ZW0uX2lzRmlyc3RGcmFtZTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZnJhbWVJZCArPSAxO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5fbWRmID0gIXRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzIHx8IGZvcmNlUmVuZGVyO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5wcm9qZWN0SW50ZXJmYWNlLmN1cnJlbnRGcmFtZSA9IG51bTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCctLS0tLS0tLScpO1xuICAgIC8vIGNvbnNvbGUubG9nKCdORVc6ICcsbnVtKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIGlmICghdGhpcy5jb21wbGV0ZUxheWVycykge1xuICAgICAgdGhpcy5jaGVja0xheWVycyhudW0pO1xuICAgIH1cbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuY29tcGxldGVMYXllcnMgfHwgdGhpcy5lbGVtZW50c1tpXSkge1xuICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnByZXBhcmVGcmFtZShudW0gLSB0aGlzLmxheWVyc1tpXS5zdCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0aGlzLmdsb2JhbERhdGEuX21kZikge1xuICAgICAgaWYgKHRoaXMucmVuZGVyQ29uZmlnLmNsZWFyQ2FudmFzID09PSB0cnVlKSB7XG4gICAgICAgIHRoaXMuY2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy50cmFuc2Zvcm1DYW52YXMudywgdGhpcy50cmFuc2Zvcm1DYW52YXMuaCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNhdmUoKTtcbiAgICAgIH1cbiAgICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICAgIGlmICh0aGlzLmNvbXBsZXRlTGF5ZXJzIHx8IHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgICB0aGlzLmVsZW1lbnRzW2ldLnJlbmRlckZyYW1lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcyAhPT0gdHJ1ZSkge1xuICAgICAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENhbnZhc1JlbmRlcmVyQmFzZS5wcm90b3R5cGUuYnVpbGRJdGVtID0gZnVuY3Rpb24gKHBvcykge1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbWVudHM7XG4gICAgaWYgKGVsZW1lbnRzW3Bvc10gfHwgdGhpcy5sYXllcnNbcG9zXS50eSA9PT0gOTkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGVsZW1lbnQgPSB0aGlzLmNyZWF0ZUl0ZW0odGhpcy5sYXllcnNbcG9zXSwgdGhpcywgdGhpcy5nbG9iYWxEYXRhKTtcbiAgICBlbGVtZW50c1twb3NdID0gZWxlbWVudDtcbiAgICBlbGVtZW50LmluaXRFeHByZXNzaW9ucygpO1xuICAgIC8qIGlmKHRoaXMubGF5ZXJzW3Bvc10udHkgPT09IDApe1xuICAgICAgICAgIGVsZW1lbnQucmVzaXplKHRoaXMuZ2xvYmFsRGF0YS50cmFuc2Zvcm1DYW52YXMpO1xuICAgICAgfSAqL1xuICB9O1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmNoZWNrUGVuZGluZ0VsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICAgIHdoaWxlICh0aGlzLnBlbmRpbmdFbGVtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZhciBlbGVtZW50ID0gdGhpcy5wZW5kaW5nRWxlbWVudHMucG9wKCk7XG4gICAgICBlbGVtZW50LmNoZWNrUGFyZW50aW5nKCk7XG4gICAgfVxuICB9O1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLmhpZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9O1xuICBDYW52YXNSZW5kZXJlckJhc2UucHJvdG90eXBlLnNob3cgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtLmNvbnRhaW5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgfTtcblxuICBmdW5jdGlvbiBDYW52YXNDb250ZXh0KCkge1xuICAgIHRoaXMub3BhY2l0eSA9IC0xO1xuICAgIHRoaXMudHJhbnNmb3JtID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIDE2KTtcbiAgICB0aGlzLmZpbGxTdHlsZSA9ICcnO1xuICAgIHRoaXMuc3Ryb2tlU3R5bGUgPSAnJztcbiAgICB0aGlzLmxpbmVXaWR0aCA9ICcnO1xuICAgIHRoaXMubGluZUNhcCA9ICcnO1xuICAgIHRoaXMubGluZUpvaW4gPSAnJztcbiAgICB0aGlzLm1pdGVyTGltaXQgPSAnJztcbiAgICB0aGlzLmlkID0gTWF0aC5yYW5kb20oKTtcbiAgfVxuICBmdW5jdGlvbiBDVkNvbnRleHREYXRhKCkge1xuICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyID0gbmV3IE1hdHJpeCgpO1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSAxNTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHZhciBjYW52YXNDb250ZXh0ID0gbmV3IENhbnZhc0NvbnRleHQoKTtcbiAgICAgIHRoaXMuc3RhY2tbaV0gPSBjYW52YXNDb250ZXh0O1xuICAgIH1cbiAgICB0aGlzLl9sZW5ndGggPSBsZW47XG4gICAgdGhpcy5uYXRpdmVDb250ZXh0ID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICB0aGlzLmN1cnJlbnRPcGFjaXR5ID0gMTtcbiAgICAvL1xuICAgIHRoaXMuY3VycmVudEZpbGxTdHlsZSA9ICcnO1xuICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9ICcnO1xuICAgIC8vXG4gICAgdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGUgPSAnJztcbiAgICB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSA9ICcnO1xuICAgIC8vXG4gICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkTGluZVdpZHRoID0gJyc7XG4gICAgLy9cbiAgICB0aGlzLmN1cnJlbnRMaW5lQ2FwID0gJyc7XG4gICAgdGhpcy5hcHBsaWVkTGluZUNhcCA9ICcnO1xuICAgIC8vXG4gICAgdGhpcy5jdXJyZW50TGluZUpvaW4gPSAnJztcbiAgICB0aGlzLmFwcGxpZWRMaW5lSm9pbiA9ICcnO1xuICAgIC8vXG4gICAgdGhpcy5hcHBsaWVkTWl0ZXJMaW1pdCA9ICcnO1xuICAgIHRoaXMuY3VycmVudE1pdGVyTGltaXQgPSAnJztcbiAgfVxuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5kdXBsaWNhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG5ld0xlbmd0aCA9IHRoaXMuX2xlbmd0aCAqIDI7XG4gICAgdmFyIGkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMuX2xlbmd0aDsgaSA8IG5ld0xlbmd0aDsgaSArPSAxKSB7XG4gICAgICB0aGlzLnN0YWNrW2ldID0gbmV3IENhbnZhc0NvbnRleHQoKTtcbiAgICB9XG4gICAgdGhpcy5fbGVuZ3RoID0gbmV3TGVuZ3RoO1xuICB9O1xuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmNBcnJQb3MgPSAwO1xuICAgIHRoaXMuY1RyLnJlc2V0KCk7XG4gICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSAxO1xuICB9O1xuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5yZXN0b3JlID0gZnVuY3Rpb24gKGZvcmNlUmVzdG9yZSkge1xuICAgIHRoaXMuY0FyclBvcyAtPSAxO1xuICAgIHZhciBjdXJyZW50Q29udGV4dCA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXTtcbiAgICB2YXIgdHJhbnNmb3JtID0gY3VycmVudENvbnRleHQudHJhbnNmb3JtO1xuICAgIHZhciBpO1xuICAgIHZhciBhcnIgPSB0aGlzLmNUci5wcm9wcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgYXJyW2ldID0gdHJhbnNmb3JtW2ldO1xuICAgIH1cbiAgICBpZiAoZm9yY2VSZXN0b3JlKSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgdmFyIHByZXZTdGFjayA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zICsgMV07XG4gICAgICB0aGlzLmFwcGxpZWRGaWxsU3R5bGUgPSBwcmV2U3RhY2suZmlsbFN0eWxlO1xuICAgICAgdGhpcy5hcHBsaWVkU3Ryb2tlU3R5bGUgPSBwcmV2U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSBwcmV2U3RhY2subGluZVdpZHRoO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUNhcCA9IHByZXZTdGFjay5saW5lQ2FwO1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUpvaW4gPSBwcmV2U3RhY2subGluZUpvaW47XG4gICAgICB0aGlzLmFwcGxpZWRNaXRlckxpbWl0ID0gcHJldlN0YWNrLm1pdGVyTGltaXQ7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5zZXRUcmFuc2Zvcm0odHJhbnNmb3JtWzBdLCB0cmFuc2Zvcm1bMV0sIHRyYW5zZm9ybVs0XSwgdHJhbnNmb3JtWzVdLCB0cmFuc2Zvcm1bMTJdLCB0cmFuc2Zvcm1bMTNdKTtcbiAgICBpZiAoZm9yY2VSZXN0b3JlIHx8IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHkgIT09IC0xICYmIHRoaXMuY3VycmVudE9wYWNpdHkgIT09IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHkpIHtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5nbG9iYWxBbHBoYSA9IGN1cnJlbnRDb250ZXh0Lm9wYWNpdHk7XG4gICAgICB0aGlzLmN1cnJlbnRPcGFjaXR5ID0gY3VycmVudENvbnRleHQub3BhY2l0eTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50RmlsbFN0eWxlID0gY3VycmVudENvbnRleHQuZmlsbFN0eWxlO1xuICAgIHRoaXMuY3VycmVudFN0cm9rZVN0eWxlID0gY3VycmVudENvbnRleHQuc3Ryb2tlU3R5bGU7XG4gICAgdGhpcy5jdXJyZW50TGluZVdpZHRoID0gY3VycmVudENvbnRleHQubGluZVdpZHRoO1xuICAgIHRoaXMuY3VycmVudExpbmVDYXAgPSBjdXJyZW50Q29udGV4dC5saW5lQ2FwO1xuICAgIHRoaXMuY3VycmVudExpbmVKb2luID0gY3VycmVudENvbnRleHQubGluZUpvaW47XG4gICAgdGhpcy5jdXJyZW50TWl0ZXJMaW1pdCA9IGN1cnJlbnRDb250ZXh0Lm1pdGVyTGltaXQ7XG4gIH07XG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbiAoc2F2ZU9uTmF0aXZlRmxhZykge1xuICAgIGlmIChzYXZlT25OYXRpdmVGbGFnKSB7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuc2F2ZSgpO1xuICAgIH1cbiAgICB2YXIgcHJvcHMgPSB0aGlzLmNUci5wcm9wcztcbiAgICBpZiAodGhpcy5fbGVuZ3RoIDw9IHRoaXMuY0FyclBvcykge1xuICAgICAgdGhpcy5kdXBsaWNhdGUoKTtcbiAgICB9XG4gICAgdmFyIGN1cnJlbnRTdGFjayA9IHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXTtcbiAgICB2YXIgaTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkgKz0gMSkge1xuICAgICAgY3VycmVudFN0YWNrLnRyYW5zZm9ybVtpXSA9IHByb3BzW2ldO1xuICAgIH1cbiAgICB0aGlzLmNBcnJQb3MgKz0gMTtcbiAgICB2YXIgbmV3U3RhY2sgPSB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc107XG4gICAgbmV3U3RhY2sub3BhY2l0eSA9IGN1cnJlbnRTdGFjay5vcGFjaXR5O1xuICAgIG5ld1N0YWNrLmZpbGxTdHlsZSA9IGN1cnJlbnRTdGFjay5maWxsU3R5bGU7XG4gICAgbmV3U3RhY2suc3Ryb2tlU3R5bGUgPSBjdXJyZW50U3RhY2suc3Ryb2tlU3R5bGU7XG4gICAgbmV3U3RhY2subGluZVdpZHRoID0gY3VycmVudFN0YWNrLmxpbmVXaWR0aDtcbiAgICBuZXdTdGFjay5saW5lQ2FwID0gY3VycmVudFN0YWNrLmxpbmVDYXA7XG4gICAgbmV3U3RhY2subGluZUpvaW4gPSBjdXJyZW50U3RhY2subGluZUpvaW47XG4gICAgbmV3U3RhY2subWl0ZXJMaW1pdCA9IGN1cnJlbnRTdGFjay5taXRlckxpbWl0O1xuICB9O1xuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5zZXRPcGFjaXR5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSB2YWx1ZTtcbiAgfTtcbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc2V0Q29udGV4dCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIHRoaXMubmF0aXZlQ29udGV4dCA9IHZhbHVlO1xuICB9O1xuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5maWxsU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudEZpbGxTdHlsZSA9IHZhbHVlO1xuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmZpbGxTdHlsZSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc3Ryb2tlU3R5bGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLnN0cm9rZVN0eWxlICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGUgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5zdHJva2VTdHlsZSA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUubGluZVdpZHRoID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5saW5lV2lkdGggIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lV2lkdGggPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5saW5lV2lkdGggPSB2YWx1ZTtcbiAgICB9XG4gIH07XG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmxpbmVDYXAgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVDYXAgIT09IHZhbHVlKSB7XG4gICAgICB0aGlzLmN1cnJlbnRMaW5lQ2FwID0gdmFsdWU7XG4gICAgICB0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubGluZUNhcCA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUubGluZUpvaW4gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICBpZiAodGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLmxpbmVKb2luICE9PSB2YWx1ZSkge1xuICAgICAgdGhpcy5jdXJyZW50TGluZUpvaW4gPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5saW5lSm9pbiA9IHZhbHVlO1xuICAgIH1cbiAgfTtcbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUubWl0ZXJMaW1pdCA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ubWl0ZXJMaW1pdCAhPT0gdmFsdWUpIHtcbiAgICAgIHRoaXMuY3VycmVudE1pdGVyTGltaXQgPSB2YWx1ZTtcbiAgICAgIHRoaXMuc3RhY2tbdGhpcy5jQXJyUG9zXS5taXRlckxpbWl0ID0gdmFsdWU7XG4gICAgfVxuICB9O1xuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS50cmFuc2Zvcm0gPSBmdW5jdGlvbiAocHJvcHMpIHtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdC5jbG9uZUZyb21Qcm9wcyhwcm9wcyk7XG4gICAgLy8gVGFraW5nIHRoZSBsYXN0IHRyYW5zZm9ybSB2YWx1ZSBmcm9tIHRoZSBzdG9yZWQgc3RhY2sgb2YgdHJhbnNmb3Jtc1xuICAgIHZhciBjdXJyZW50VHJhbnNmb3JtID0gdGhpcy5jVHI7XG4gICAgLy8gQXBwbHlpbmcgdGhlIGxhc3QgdHJhbnNmb3JtIHZhbHVlIGFmdGVyIHRoZSBuZXcgdHJhbnNmb3JtIHRvIHJlc3BlY3QgdGhlIG9yZGVyIG9mIHRyYW5zZm9ybWF0aW9uc1xuICAgIHRoaXMudHJhbnNmb3JtTWF0Lm11bHRpcGx5KGN1cnJlbnRUcmFuc2Zvcm0pO1xuICAgIC8vIFN0b3JpbmcgdGhlIG5ldyB0cmFuc2Zvcm1lZCB2YWx1ZSBpbiB0aGUgc3RvcmVkIHRyYW5zZm9ybVxuICAgIGN1cnJlbnRUcmFuc2Zvcm0uY2xvbmVGcm9tUHJvcHModGhpcy50cmFuc2Zvcm1NYXQucHJvcHMpO1xuICAgIHZhciB0clByb3BzID0gY3VycmVudFRyYW5zZm9ybS5wcm9wcztcbiAgICAvLyBBcHBseWluZyB0aGUgbmV3IHRyYW5zZm9ybSB0byB0aGUgY2FudmFzXG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LnNldFRyYW5zZm9ybSh0clByb3BzWzBdLCB0clByb3BzWzFdLCB0clByb3BzWzRdLCB0clByb3BzWzVdLCB0clByb3BzWzEyXSwgdHJQcm9wc1sxM10pO1xuICB9O1xuICBDVkNvbnRleHREYXRhLnByb3RvdHlwZS5vcGFjaXR5ID0gZnVuY3Rpb24gKG9wKSB7XG4gICAgdmFyIGN1cnJlbnRPcGFjaXR5ID0gdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHk7XG4gICAgY3VycmVudE9wYWNpdHkgKj0gb3AgPCAwID8gMCA6IG9wO1xuICAgIGlmICh0aGlzLnN0YWNrW3RoaXMuY0FyclBvc10ub3BhY2l0eSAhPT0gY3VycmVudE9wYWNpdHkpIHtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRPcGFjaXR5ICE9PSBvcCkge1xuICAgICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuZ2xvYmFsQWxwaGEgPSBvcDtcbiAgICAgICAgdGhpcy5jdXJyZW50T3BhY2l0eSA9IG9wO1xuICAgICAgfVxuICAgICAgdGhpcy5zdGFja1t0aGlzLmNBcnJQb3NdLm9wYWNpdHkgPSBjdXJyZW50T3BhY2l0eTtcbiAgICB9XG4gIH07XG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiAocnVsZSkge1xuICAgIGlmICh0aGlzLmFwcGxpZWRGaWxsU3R5bGUgIT09IHRoaXMuY3VycmVudEZpbGxTdHlsZSkge1xuICAgICAgdGhpcy5hcHBsaWVkRmlsbFN0eWxlID0gdGhpcy5jdXJyZW50RmlsbFN0eWxlO1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0LmZpbGxTdHlsZSA9IHRoaXMuYXBwbGllZEZpbGxTdHlsZTtcbiAgICB9XG4gICAgdGhpcy5uYXRpdmVDb250ZXh0LmZpbGwocnVsZSk7XG4gIH07XG4gIENWQ29udGV4dERhdGEucHJvdG90eXBlLmZpbGxSZWN0ID0gZnVuY3Rpb24gKHgsIHksIHcsIGgpIHtcbiAgICBpZiAodGhpcy5hcHBsaWVkRmlsbFN0eWxlICE9PSB0aGlzLmN1cnJlbnRGaWxsU3R5bGUpIHtcbiAgICAgIHRoaXMuYXBwbGllZEZpbGxTdHlsZSA9IHRoaXMuY3VycmVudEZpbGxTdHlsZTtcbiAgICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsU3R5bGUgPSB0aGlzLmFwcGxpZWRGaWxsU3R5bGU7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlQ29udGV4dC5maWxsUmVjdCh4LCB5LCB3LCBoKTtcbiAgfTtcbiAgQ1ZDb250ZXh0RGF0YS5wcm90b3R5cGUuc3Ryb2tlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFwcGxpZWRTdHJva2VTdHlsZSAhPT0gdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGUpIHtcbiAgICAgIHRoaXMuYXBwbGllZFN0cm9rZVN0eWxlID0gdGhpcy5jdXJyZW50U3Ryb2tlU3R5bGU7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQuc3Ryb2tlU3R5bGUgPSB0aGlzLmFwcGxpZWRTdHJva2VTdHlsZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBwbGllZExpbmVXaWR0aCAhPT0gdGhpcy5jdXJyZW50TGluZVdpZHRoKSB7XG4gICAgICB0aGlzLmFwcGxpZWRMaW5lV2lkdGggPSB0aGlzLmN1cnJlbnRMaW5lV2lkdGg7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubGluZVdpZHRoID0gdGhpcy5hcHBsaWVkTGluZVdpZHRoO1xuICAgIH1cbiAgICBpZiAodGhpcy5hcHBsaWVkTGluZUNhcCAhPT0gdGhpcy5jdXJyZW50TGluZUNhcCkge1xuICAgICAgdGhpcy5hcHBsaWVkTGluZUNhcCA9IHRoaXMuY3VycmVudExpbmVDYXA7XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubGluZUNhcCA9IHRoaXMuYXBwbGllZExpbmVDYXA7XG4gICAgfVxuICAgIGlmICh0aGlzLmFwcGxpZWRMaW5lSm9pbiAhPT0gdGhpcy5jdXJyZW50TGluZUpvaW4pIHtcbiAgICAgIHRoaXMuYXBwbGllZExpbmVKb2luID0gdGhpcy5jdXJyZW50TGluZUpvaW47XG4gICAgICB0aGlzLm5hdGl2ZUNvbnRleHQubGluZUpvaW4gPSB0aGlzLmFwcGxpZWRMaW5lSm9pbjtcbiAgICB9XG4gICAgaWYgKHRoaXMuYXBwbGllZE1pdGVyTGltaXQgIT09IHRoaXMuY3VycmVudE1pdGVyTGltaXQpIHtcbiAgICAgIHRoaXMuYXBwbGllZE1pdGVyTGltaXQgPSB0aGlzLmN1cnJlbnRNaXRlckxpbWl0O1xuICAgICAgdGhpcy5uYXRpdmVDb250ZXh0Lm1pdGVyTGltaXQgPSB0aGlzLmFwcGxpZWRNaXRlckxpbWl0O1xuICAgIH1cbiAgICB0aGlzLm5hdGl2ZUNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ1ZDb21wRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHRoaXMubGF5ZXJzID0gZGF0YS5sYXllcnM7XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRzID0gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy50bSA9IGRhdGEudG0gPyBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcCh0aGlzLCBkYXRhLnRtLCAwLCBnbG9iYWxEYXRhLmZyYW1lUmF0ZSwgdGhpcykgOiB7XG4gICAgICBfcGxhY2Vob2xkZXI6IHRydWVcbiAgICB9O1xuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbQ2FudmFzUmVuZGVyZXJCYXNlLCBJQ29tcEVsZW1lbnQsIENWQmFzZUVsZW1lbnRdLCBDVkNvbXBFbGVtZW50KTtcbiAgQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjdHggPSB0aGlzLmNhbnZhc0NvbnRleHQ7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oMCwgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgMCk7XG4gICAgY3R4LmxpbmVUbyh0aGlzLmRhdGEudywgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgdGhpcy5kYXRhLmgpO1xuICAgIGN0eC5saW5lVG8oMCwgMCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICBpZiAodGhpcy5jb21wbGV0ZUxheWVycyB8fCB0aGlzLmVsZW1lbnRzW2ldKSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0ucmVuZGVyRnJhbWUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIENWQ29tcEVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHRoaXMubGF5ZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSBsZW4gLSAxOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0pIHtcbiAgICAgICAgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMubGF5ZXJzID0gbnVsbDtcbiAgICB0aGlzLmVsZW1lbnRzID0gbnVsbDtcbiAgfTtcbiAgQ1ZDb21wRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29tcCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgcmV0dXJuIG5ldyBDVkNvbXBFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG5cbiAgZnVuY3Rpb24gQ2FudmFzUmVuZGVyZXIoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcbiAgICB0aGlzLnJlbmRlckNvbmZpZyA9IHtcbiAgICAgIGNsZWFyQ2FudmFzOiBjb25maWcgJiYgY29uZmlnLmNsZWFyQ2FudmFzICE9PSB1bmRlZmluZWQgPyBjb25maWcuY2xlYXJDYW52YXMgOiB0cnVlLFxuICAgICAgY29udGV4dDogY29uZmlnICYmIGNvbmZpZy5jb250ZXh0IHx8IG51bGwsXG4gICAgICBwcm9ncmVzc2l2ZUxvYWQ6IGNvbmZpZyAmJiBjb25maWcucHJvZ3Jlc3NpdmVMb2FkIHx8IGZhbHNlLFxuICAgICAgcHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5wcmVzZXJ2ZUFzcGVjdFJhdGlvIHx8ICd4TWlkWU1pZCBtZWV0JyxcbiAgICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIHNsaWNlJyxcbiAgICAgIGNvbnRlbnRWaXNpYmlsaXR5OiBjb25maWcgJiYgY29uZmlnLmNvbnRlbnRWaXNpYmlsaXR5IHx8ICd2aXNpYmxlJyxcbiAgICAgIGNsYXNzTmFtZTogY29uZmlnICYmIGNvbmZpZy5jbGFzc05hbWUgfHwgJycsXG4gICAgICBpZDogY29uZmlnICYmIGNvbmZpZy5pZCB8fCAnJyxcbiAgICAgIHJ1bkV4cHJlc3Npb25zOiAhY29uZmlnIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9ucyA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5ydW5FeHByZXNzaW9uc1xuICAgIH07XG4gICAgdGhpcy5yZW5kZXJDb25maWcuZHByID0gY29uZmlnICYmIGNvbmZpZy5kcHIgfHwgMTtcbiAgICBpZiAodGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIpIHtcbiAgICAgIHRoaXMucmVuZGVyQ29uZmlnLmRwciA9IGNvbmZpZyAmJiBjb25maWcuZHByIHx8IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG4gICAgfVxuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IC0xO1xuICAgIHRoaXMuZ2xvYmFsRGF0YSA9IHtcbiAgICAgIGZyYW1lTnVtOiAtMSxcbiAgICAgIF9tZGY6IGZhbHNlLFxuICAgICAgcmVuZGVyQ29uZmlnOiB0aGlzLnJlbmRlckNvbmZpZyxcbiAgICAgIGN1cnJlbnRHbG9iYWxBbHBoYTogLTFcbiAgICB9O1xuICAgIHRoaXMuY29udGV4dERhdGEgPSBuZXcgQ1ZDb250ZXh0RGF0YSgpO1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuY29tcGxldGVMYXllcnMgPSBmYWxzZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdjYW52YXMnO1xuICAgIGlmICh0aGlzLnJlbmRlckNvbmZpZy5jbGVhckNhbnZhcykge1xuICAgICAgdGhpcy5jdHhUcmFuc2Zvcm0gPSB0aGlzLmNvbnRleHREYXRhLnRyYW5zZm9ybS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhPcGFjaXR5ID0gdGhpcy5jb250ZXh0RGF0YS5vcGFjaXR5LmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eEZpbGxTdHlsZSA9IHRoaXMuY29udGV4dERhdGEuZmlsbFN0eWxlLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eFN0cm9rZVN0eWxlID0gdGhpcy5jb250ZXh0RGF0YS5zdHJva2VTdHlsZS5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhMaW5lV2lkdGggPSB0aGlzLmNvbnRleHREYXRhLmxpbmVXaWR0aC5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhMaW5lQ2FwID0gdGhpcy5jb250ZXh0RGF0YS5saW5lQ2FwLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eExpbmVKb2luID0gdGhpcy5jb250ZXh0RGF0YS5saW5lSm9pbi5iaW5kKHRoaXMuY29udGV4dERhdGEpO1xuICAgICAgdGhpcy5jdHhNaXRlckxpbWl0ID0gdGhpcy5jb250ZXh0RGF0YS5taXRlckxpbWl0LmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eEZpbGwgPSB0aGlzLmNvbnRleHREYXRhLmZpbGwuYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICAgIHRoaXMuY3R4RmlsbFJlY3QgPSB0aGlzLmNvbnRleHREYXRhLmZpbGxSZWN0LmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLmN0eFN0cm9rZSA9IHRoaXMuY29udGV4dERhdGEuc3Ryb2tlLmJpbmQodGhpcy5jb250ZXh0RGF0YSk7XG4gICAgICB0aGlzLnNhdmUgPSB0aGlzLmNvbnRleHREYXRhLnNhdmUuYmluZCh0aGlzLmNvbnRleHREYXRhKTtcbiAgICB9XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtDYW52YXNSZW5kZXJlckJhc2VdLCBDYW52YXNSZW5kZXJlcik7XG4gIENhbnZhc1JlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gbmV3IENWQ29tcEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcblxuICBmdW5jdGlvbiBIQmFzZUVsZW1lbnQoKSB7fVxuICBIQmFzZUVsZW1lbnQucHJvdG90eXBlID0ge1xuICAgIGNoZWNrQmxlbmRNb2RlOiBmdW5jdGlvbiBjaGVja0JsZW5kTW9kZSgpIHt9LFxuICAgIGluaXRSZW5kZXJlckVsZW1lbnQ6IGZ1bmN0aW9uIGluaXRSZW5kZXJlckVsZW1lbnQoKSB7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50ID0gY3JlYXRlVGFnKHRoaXMuZGF0YS50ZyB8fCAnZGl2Jyk7XG4gICAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50ID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5sYXllckVsZW1lbnQpO1xuICAgICAgICB0aGlzLmJhc2VFbGVtZW50LmFwcGVuZENoaWxkKHRoaXMuc3ZnRWxlbWVudCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudCA9IHRoaXMuYmFzZUVsZW1lbnQ7XG4gICAgICB9XG4gICAgICBzdHlsZURpdih0aGlzLmJhc2VFbGVtZW50KTtcbiAgICB9LFxuICAgIGNyZWF0ZUNvbnRhaW5lckVsZW1lbnRzOiBmdW5jdGlvbiBjcmVhdGVDb250YWluZXJFbGVtZW50cygpIHtcbiAgICAgIHRoaXMucmVuZGVyYWJsZUVmZmVjdHNNYW5hZ2VyID0gbmV3IENWRWZmZWN0cyh0aGlzKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcbiAgICAgIHRoaXMubWFza2VkRWxlbWVudCA9IHRoaXMubGF5ZXJFbGVtZW50O1xuICAgICAgaWYgKHRoaXMuZGF0YS5sbikge1xuICAgICAgICB0aGlzLmxheWVyRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5kYXRhLmxuKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmRhdGEuY2wpIHtcbiAgICAgICAgdGhpcy5sYXllckVsZW1lbnQuc2V0QXR0cmlidXRlKCdjbGFzcycsIHRoaXMuZGF0YS5jbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmJtICE9PSAwKSB7XG4gICAgICAgIHRoaXMuc2V0QmxlbmRNb2RlKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICByZW5kZXJFbGVtZW50OiBmdW5jdGlvbiByZW5kZXJFbGVtZW50KCkge1xuICAgICAgdmFyIHRyYW5zZm9ybWVkRWxlbWVudFN0eWxlID0gdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPyB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudC5zdHlsZSA6IHt9O1xuICAgICAgaWYgKHRoaXMuZmluYWxUcmFuc2Zvcm0uX21hdE1kZikge1xuICAgICAgICB2YXIgbWF0cml4VmFsdWUgPSB0aGlzLmZpbmFsVHJhbnNmb3JtLm1hdC50b0NTUygpO1xuICAgICAgICB0cmFuc2Zvcm1lZEVsZW1lbnRTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXhWYWx1ZTtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4VmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5maW5hbFRyYW5zZm9ybS5fb3BNZGYpIHtcbiAgICAgICAgdHJhbnNmb3JtZWRFbGVtZW50U3R5bGUub3BhY2l0eSA9IHRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3Auby52O1xuICAgICAgfVxuICAgIH0sXG4gICAgcmVuZGVyRnJhbWU6IGZ1bmN0aW9uIHJlbmRlckZyYW1lKCkge1xuICAgICAgLy8gSWYgaXQgaXMgZXhwb3J0ZWQgYXMgaGlkZGVuIChkYXRhLmhkID09PSB0cnVlKSBubyBuZWVkIHRvIHJlbmRlclxuICAgICAgLy8gSWYgaXQgaXMgbm90IHZpc2libGUgbm8gbmVlZCB0byByZW5kZXJcbiAgICAgIGlmICh0aGlzLmRhdGEuaGQgfHwgdGhpcy5oaWRkZW4pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5yZW5kZXJUcmFuc2Zvcm0oKTtcbiAgICAgIHRoaXMucmVuZGVyUmVuZGVyYWJsZSgpO1xuICAgICAgdGhpcy5yZW5kZXJFbGVtZW50KCk7XG4gICAgICB0aGlzLnJlbmRlcklubmVyQ29udGVudCgpO1xuICAgICAgaWYgKHRoaXMuX2lzRmlyc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLnRyYW5zZm9ybWVkRWxlbWVudCA9IG51bGw7XG4gICAgICBpZiAodGhpcy5tYXR0ZUVsZW1lbnQpIHtcbiAgICAgICAgdGhpcy5tYXR0ZUVsZW1lbnQgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubWFza01hbmFnZXIpIHtcbiAgICAgICAgdGhpcy5tYXNrTWFuYWdlci5kZXN0cm95KCk7XG4gICAgICAgIHRoaXMubWFza01hbmFnZXIgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgY3JlYXRlUmVuZGVyYWJsZUNvbXBvbmVudHM6IGZ1bmN0aW9uIGNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzKCkge1xuICAgICAgdGhpcy5tYXNrTWFuYWdlciA9IG5ldyBNYXNrRWxlbWVudCh0aGlzLmRhdGEsIHRoaXMsIHRoaXMuZ2xvYmFsRGF0YSk7XG4gICAgfSxcbiAgICBhZGRFZmZlY3RzOiBmdW5jdGlvbiBhZGRFZmZlY3RzKCkge30sXG4gICAgc2V0TWF0dGU6IGZ1bmN0aW9uIHNldE1hdHRlKCkge31cbiAgfTtcbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IFNWR0Jhc2VFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudDtcbiAgSEJhc2VFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95QmFzZUVsZW1lbnQgPSBIQmFzZUVsZW1lbnQucHJvdG90eXBlLmRlc3Ryb3k7XG4gIEhCYXNlRWxlbWVudC5wcm90b3R5cGUuYnVpbGRFbGVtZW50UGFyZW50aW5nID0gQmFzZVJlbmRlcmVyLnByb3RvdHlwZS5idWlsZEVsZW1lbnRQYXJlbnRpbmc7XG5cbiAgZnVuY3Rpb24gSFNvbGlkRWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKSB7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnRdLCBIU29saWRFbGVtZW50KTtcbiAgSFNvbGlkRWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcmVjdDtcbiAgICBpZiAodGhpcy5kYXRhLmhhc01hc2spIHtcbiAgICAgIHJlY3QgPSBjcmVhdGVOUygncmVjdCcpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5kYXRhLnN3KTtcbiAgICAgIHJlY3Quc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmRhdGEuc2gpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCB0aGlzLmRhdGEuc2MpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmRhdGEuc3cpO1xuICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5kYXRhLnNoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVjdCA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgICByZWN0LnN0eWxlLndpZHRoID0gdGhpcy5kYXRhLnN3ICsgJ3B4JztcbiAgICAgIHJlY3Quc3R5bGUuaGVpZ2h0ID0gdGhpcy5kYXRhLnNoICsgJ3B4JztcbiAgICAgIHJlY3Quc3R5bGUuYmFja2dyb3VuZENvbG9yID0gdGhpcy5kYXRhLnNjO1xuICAgIH1cbiAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChyZWN0KTtcbiAgfTtcblxuICBmdW5jdGlvbiBIU2hhcGVFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICAvLyBMaXN0IG9mIGRyYXdhYmxlIGVsZW1lbnRzXG4gICAgdGhpcy5zaGFwZXMgPSBbXTtcbiAgICAvLyBGdWxsIHNoYXBlIGRhdGFcbiAgICB0aGlzLnNoYXBlc0RhdGEgPSBkYXRhLnNoYXBlcztcbiAgICAvLyBMaXN0IG9mIHN0eWxlcyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBzaGFwZXNcbiAgICB0aGlzLnN0eWxlc0xpc3QgPSBbXTtcbiAgICAvLyBMaXN0IG9mIG1vZGlmaWVycyB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBzaGFwZXNcbiAgICB0aGlzLnNoYXBlTW9kaWZpZXJzID0gW107XG4gICAgLy8gTGlzdCBvZiBpdGVtcyBpbiBzaGFwZSB0cmVlXG4gICAgdGhpcy5pdGVtc0RhdGEgPSBbXTtcbiAgICAvLyBMaXN0IG9mIGl0ZW1zIGluIHByZXZpb3VzIHNoYXBlIHRyZWVcbiAgICB0aGlzLnByb2Nlc3NlZEVsZW1lbnRzID0gW107XG4gICAgLy8gTGlzdCBvZiBhbmltYXRlZCBjb21wb25lbnRzXG4gICAgdGhpcy5hbmltYXRlZENvbnRlbnRzID0gW107XG4gICAgdGhpcy5zaGFwZXNDb250YWluZXIgPSBjcmVhdGVOUygnZycpO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgLy8gTW92aW5nIGFueSBwcm9wZXJ0eSB0aGF0IGRvZXNuJ3QgZ2V0IHRvbyBtdWNoIGFjY2VzcyBhZnRlciBpbml0aWFsaXphdGlvbiBiZWNhdXNlIG9mIHY4IHdheSBvZiBoYW5kbGluZyBtb3JlIHRoYW4gMTAgcHJvcGVydGllcy5cbiAgICAvLyBMaXN0IG9mIGVsZW1lbnRzIHRoYXQgaGF2ZSBiZWVuIGNyZWF0ZWRcbiAgICB0aGlzLnByZXZWaWV3RGF0YSA9IFtdO1xuICAgIHRoaXMuY3VycmVudEJCb3ggPSB7XG4gICAgICB4OiA5OTk5OTksXG4gICAgICB5OiAtOTk5OTk5LFxuICAgICAgaDogMCxcbiAgICAgIHc6IDBcbiAgICB9O1xuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbQmFzZUVsZW1lbnQsIFRyYW5zZm9ybUVsZW1lbnQsIEhTb2xpZEVsZW1lbnQsIFNWR1NoYXBlRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSFNoYXBlRWxlbWVudCk7XG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLl9yZW5kZXJTaGFwZUZyYW1lID0gSFNoYXBlRWxlbWVudC5wcm90b3R5cGUucmVuZGVySW5uZXJDb250ZW50O1xuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250ZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBjb250O1xuICAgIHRoaXMuYmFzZUVsZW1lbnQuc3R5bGUuZm9udFNpemUgPSAwO1xuICAgIGlmICh0aGlzLmRhdGEuaGFzTWFzaykge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQodGhpcy5zaGFwZXNDb250YWluZXIpO1xuICAgICAgY29udCA9IHRoaXMuc3ZnRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29udCA9IGNyZWF0ZU5TKCdzdmcnKTtcbiAgICAgIHZhciBzaXplID0gdGhpcy5jb21wLmRhdGEgPyB0aGlzLmNvbXAuZGF0YSA6IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZTtcbiAgICAgIGNvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHNpemUudyk7XG4gICAgICBjb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0Jywgc2l6ZS5oKTtcbiAgICAgIGNvbnQuYXBwZW5kQ2hpbGQodGhpcy5zaGFwZXNDb250YWluZXIpO1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoY29udCk7XG4gICAgfVxuICAgIHRoaXMuc2VhcmNoU2hhcGVzKHRoaXMuc2hhcGVzRGF0YSwgdGhpcy5pdGVtc0RhdGEsIHRoaXMucHJldlZpZXdEYXRhLCB0aGlzLnNoYXBlc0NvbnRhaW5lciwgMCwgW10sIHRydWUpO1xuICAgIHRoaXMuZmlsdGVyVW5pcXVlU2hhcGVzKCk7XG4gICAgdGhpcy5zaGFwZUNvbnQgPSBjb250O1xuICB9O1xuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5nZXRUcmFuc2Zvcm1lZFBvaW50ID0gZnVuY3Rpb24gKHRyYW5zZm9ybWVycywgcG9pbnQpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdHJhbnNmb3JtZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHBvaW50ID0gdHJhbnNmb3JtZXJzW2ldLm1Qcm9wcy52LmFwcGx5VG9Qb2ludEFycmF5KHBvaW50WzBdLCBwb2ludFsxXSwgMCk7XG4gICAgfVxuICAgIHJldHVybiBwb2ludDtcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2FsY3VsYXRlU2hhcGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChpdGVtLCBib3VuZGluZ0JveCkge1xuICAgIHZhciBzaGFwZSA9IGl0ZW0uc2gudjtcbiAgICB2YXIgdHJhbnNmb3JtZXJzID0gaXRlbS50cmFuc2Zvcm1lcnM7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IHNoYXBlLl9sZW5ndGg7XG4gICAgdmFyIHZQb2ludDtcbiAgICB2YXIgb1BvaW50O1xuICAgIHZhciBuZXh0SVBvaW50O1xuICAgIHZhciBuZXh0VlBvaW50O1xuICAgIGlmIChsZW4gPD0gMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuIC0gMTsgaSArPSAxKSB7XG4gICAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcbiAgICAgIG9Qb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLm9baV0pO1xuICAgICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbaSArIDFdKTtcbiAgICAgIG5leHRWUG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2kgKyAxXSk7XG4gICAgICB0aGlzLmNoZWNrQm91bmRzKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50LCBib3VuZGluZ0JveCk7XG4gICAgfVxuICAgIGlmIChzaGFwZS5jKSB7XG4gICAgICB2UG9pbnQgPSB0aGlzLmdldFRyYW5zZm9ybWVkUG9pbnQodHJhbnNmb3JtZXJzLCBzaGFwZS52W2ldKTtcbiAgICAgIG9Qb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLm9baV0pO1xuICAgICAgbmV4dElQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLmlbMF0pO1xuICAgICAgbmV4dFZQb2ludCA9IHRoaXMuZ2V0VHJhbnNmb3JtZWRQb2ludCh0cmFuc2Zvcm1lcnMsIHNoYXBlLnZbMF0pO1xuICAgICAgdGhpcy5jaGVja0JvdW5kcyh2UG9pbnQsIG9Qb2ludCwgbmV4dElQb2ludCwgbmV4dFZQb2ludCwgYm91bmRpbmdCb3gpO1xuICAgIH1cbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2hlY2tCb3VuZHMgPSBmdW5jdGlvbiAodlBvaW50LCBvUG9pbnQsIG5leHRJUG9pbnQsIG5leHRWUG9pbnQsIGJvdW5kaW5nQm94KSB7XG4gICAgdGhpcy5nZXRCb3VuZHNPZkN1cnZlKHZQb2ludCwgb1BvaW50LCBuZXh0SVBvaW50LCBuZXh0VlBvaW50KTtcbiAgICB2YXIgYm91bmRzID0gdGhpcy5zaGFwZUJvdW5kaW5nQm94O1xuICAgIGJvdW5kaW5nQm94LnggPSBibU1pbihib3VuZHMubGVmdCwgYm91bmRpbmdCb3gueCk7XG4gICAgYm91bmRpbmdCb3gueE1heCA9IGJtTWF4KGJvdW5kcy5yaWdodCwgYm91bmRpbmdCb3gueE1heCk7XG4gICAgYm91bmRpbmdCb3gueSA9IGJtTWluKGJvdW5kcy50b3AsIGJvdW5kaW5nQm94LnkpO1xuICAgIGJvdW5kaW5nQm94LnlNYXggPSBibU1heChib3VuZHMuYm90dG9tLCBib3VuZGluZ0JveC55TWF4KTtcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuc2hhcGVCb3VuZGluZ0JveCA9IHtcbiAgICBsZWZ0OiAwLFxuICAgIHJpZ2h0OiAwLFxuICAgIHRvcDogMCxcbiAgICBib3R0b206IDBcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUudGVtcEJvdW5kaW5nQm94ID0ge1xuICAgIHg6IDAsXG4gICAgeE1heDogMCxcbiAgICB5OiAwLFxuICAgIHlNYXg6IDAsXG4gICAgd2lkdGg6IDAsXG4gICAgaGVpZ2h0OiAwXG4gIH07XG4gIEhTaGFwZUVsZW1lbnQucHJvdG90eXBlLmdldEJvdW5kc09mQ3VydmUgPSBmdW5jdGlvbiAocDAsIHAxLCBwMiwgcDMpIHtcbiAgICB2YXIgYm91bmRzID0gW1twMFswXSwgcDNbMF1dLCBbcDBbMV0sIHAzWzFdXV07XG4gICAgZm9yICh2YXIgYSwgYiwgYywgdCwgYjJhYywgdDEsIHQyLCBpID0gMDsgaSA8IDI7ICsraSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wbHVzcGx1c1xuICAgICAgYiA9IDYgKiBwMFtpXSAtIDEyICogcDFbaV0gKyA2ICogcDJbaV07XG4gICAgICBhID0gLTMgKiBwMFtpXSArIDkgKiBwMVtpXSAtIDkgKiBwMltpXSArIDMgKiBwM1tpXTtcbiAgICAgIGMgPSAzICogcDFbaV0gLSAzICogcDBbaV07XG4gICAgICBiIHw9IDA7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tYml0d2lzZVxuICAgICAgYSB8PSAwOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWJpdHdpc2VcbiAgICAgIGMgfD0gMDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1iaXR3aXNlXG5cbiAgICAgIGlmIChhID09PSAwICYmIGIgPT09IDApIHtcbiAgICAgICAgLy9cbiAgICAgIH0gZWxzZSBpZiAoYSA9PT0gMCkge1xuICAgICAgICB0ID0gLWMgLyBiO1xuICAgICAgICBpZiAodCA+IDAgJiYgdCA8IDEpIHtcbiAgICAgICAgICBib3VuZHNbaV0ucHVzaCh0aGlzLmNhbGN1bGF0ZUYodCwgcDAsIHAxLCBwMiwgcDMsIGkpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYjJhYyA9IGIgKiBiIC0gNCAqIGMgKiBhO1xuICAgICAgICBpZiAoYjJhYyA+PSAwKSB7XG4gICAgICAgICAgdDEgPSAoLWIgKyBibVNxcnQoYjJhYykpIC8gKDIgKiBhKTtcbiAgICAgICAgICBpZiAodDEgPiAwICYmIHQxIDwgMSkgYm91bmRzW2ldLnB1c2godGhpcy5jYWxjdWxhdGVGKHQxLCBwMCwgcDEsIHAyLCBwMywgaSkpO1xuICAgICAgICAgIHQyID0gKC1iIC0gYm1TcXJ0KGIyYWMpKSAvICgyICogYSk7XG4gICAgICAgICAgaWYgKHQyID4gMCAmJiB0MiA8IDEpIGJvdW5kc1tpXS5wdXNoKHRoaXMuY2FsY3VsYXRlRih0MiwgcDAsIHAxLCBwMiwgcDMsIGkpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnNoYXBlQm91bmRpbmdCb3gubGVmdCA9IGJtTWluLmFwcGx5KG51bGwsIGJvdW5kc1swXSk7XG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LnRvcCA9IGJtTWluLmFwcGx5KG51bGwsIGJvdW5kc1sxXSk7XG4gICAgdGhpcy5zaGFwZUJvdW5kaW5nQm94LnJpZ2h0ID0gYm1NYXguYXBwbHkobnVsbCwgYm91bmRzWzBdKTtcbiAgICB0aGlzLnNoYXBlQm91bmRpbmdCb3guYm90dG9tID0gYm1NYXguYXBwbHkobnVsbCwgYm91bmRzWzFdKTtcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY2FsY3VsYXRlRiA9IGZ1bmN0aW9uICh0LCBwMCwgcDEsIHAyLCBwMywgaSkge1xuICAgIHJldHVybiBibVBvdygxIC0gdCwgMykgKiBwMFtpXSArIDMgKiBibVBvdygxIC0gdCwgMikgKiB0ICogcDFbaV0gKyAzICogKDEgLSB0KSAqIGJtUG93KHQsIDIpICogcDJbaV0gKyBibVBvdyh0LCAzKSAqIHAzW2ldO1xuICB9O1xuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5jYWxjdWxhdGVCb3VuZGluZ0JveCA9IGZ1bmN0aW9uIChpdGVtc0RhdGEsIGJvdW5kaW5nQm94KSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIGxlbiA9IGl0ZW1zRGF0YS5sZW5ndGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoaXRlbXNEYXRhW2ldICYmIGl0ZW1zRGF0YVtpXS5zaCkge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3goaXRlbXNEYXRhW2ldLCBib3VuZGluZ0JveCk7XG4gICAgICB9IGVsc2UgaWYgKGl0ZW1zRGF0YVtpXSAmJiBpdGVtc0RhdGFbaV0uaXQpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVCb3VuZGluZ0JveChpdGVtc0RhdGFbaV0uaXQsIGJvdW5kaW5nQm94KTtcbiAgICAgIH0gZWxzZSBpZiAoaXRlbXNEYXRhW2ldICYmIGl0ZW1zRGF0YVtpXS5zdHlsZSAmJiBpdGVtc0RhdGFbaV0udykge1xuICAgICAgICB0aGlzLmV4cGFuZFN0cm9rZUJvdW5kaW5nQm94KGl0ZW1zRGF0YVtpXS53LCBib3VuZGluZ0JveCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5leHBhbmRTdHJva2VCb3VuZGluZ0JveCA9IGZ1bmN0aW9uICh3aWR0aFByb3BlcnR5LCBib3VuZGluZ0JveCkge1xuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgaWYgKHdpZHRoUHJvcGVydHkua2V5ZnJhbWVzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHdpZHRoUHJvcGVydHkua2V5ZnJhbWVzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHZhciBrZncgPSB3aWR0aFByb3BlcnR5LmtleWZyYW1lc1tpXS5zO1xuICAgICAgICBpZiAoa2Z3ID4gd2lkdGgpIHtcbiAgICAgICAgICB3aWR0aCA9IGtmdztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgd2lkdGggKj0gd2lkdGhQcm9wZXJ0eS5tdWx0O1xuICAgIH0gZWxzZSB7XG4gICAgICB3aWR0aCA9IHdpZHRoUHJvcGVydHkudiAqIHdpZHRoUHJvcGVydHkubXVsdDtcbiAgICB9XG4gICAgYm91bmRpbmdCb3gueCAtPSB3aWR0aDtcbiAgICBib3VuZGluZ0JveC54TWF4ICs9IHdpZHRoO1xuICAgIGJvdW5kaW5nQm94LnkgLT0gd2lkdGg7XG4gICAgYm91bmRpbmdCb3gueU1heCArPSB3aWR0aDtcbiAgfTtcbiAgSFNoYXBlRWxlbWVudC5wcm90b3R5cGUuY3VycmVudEJveENvbnRhaW5zID0gZnVuY3Rpb24gKGJveCkge1xuICAgIHJldHVybiB0aGlzLmN1cnJlbnRCQm94LnggPD0gYm94LnggJiYgdGhpcy5jdXJyZW50QkJveC55IDw9IGJveC55ICYmIHRoaXMuY3VycmVudEJCb3gud2lkdGggKyB0aGlzLmN1cnJlbnRCQm94LnggPj0gYm94LnggKyBib3gud2lkdGggJiYgdGhpcy5jdXJyZW50QkJveC5oZWlnaHQgKyB0aGlzLmN1cnJlbnRCQm94LnkgPj0gYm94LnkgKyBib3guaGVpZ2h0O1xuICB9O1xuICBIU2hhcGVFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJJbm5lckNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fcmVuZGVyU2hhcGVGcmFtZSgpO1xuICAgIGlmICghdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XG4gICAgICB2YXIgdGVtcEJvdW5kaW5nQm94ID0gdGhpcy50ZW1wQm91bmRpbmdCb3g7XG4gICAgICB2YXIgbWF4ID0gOTk5OTk5O1xuICAgICAgdGVtcEJvdW5kaW5nQm94LnggPSBtYXg7XG4gICAgICB0ZW1wQm91bmRpbmdCb3gueE1heCA9IC1tYXg7XG4gICAgICB0ZW1wQm91bmRpbmdCb3gueSA9IG1heDtcbiAgICAgIHRlbXBCb3VuZGluZ0JveC55TWF4ID0gLW1heDtcbiAgICAgIHRoaXMuY2FsY3VsYXRlQm91bmRpbmdCb3godGhpcy5pdGVtc0RhdGEsIHRlbXBCb3VuZGluZ0JveCk7XG4gICAgICB0ZW1wQm91bmRpbmdCb3gud2lkdGggPSB0ZW1wQm91bmRpbmdCb3gueE1heCA8IHRlbXBCb3VuZGluZ0JveC54ID8gMCA6IHRlbXBCb3VuZGluZ0JveC54TWF4IC0gdGVtcEJvdW5kaW5nQm94Lng7XG4gICAgICB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0ID0gdGVtcEJvdW5kaW5nQm94LnlNYXggPCB0ZW1wQm91bmRpbmdCb3gueSA/IDAgOiB0ZW1wQm91bmRpbmdCb3gueU1heCAtIHRlbXBCb3VuZGluZ0JveC55O1xuICAgICAgLy8gdmFyIHRlbXBCb3VuZGluZ0JveCA9IHRoaXMuc2hhcGVDb250LmdldEJCb3goKTtcbiAgICAgIGlmICh0aGlzLmN1cnJlbnRCb3hDb250YWlucyh0ZW1wQm91bmRpbmdCb3gpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFuZ2VkID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC53ICE9PSB0ZW1wQm91bmRpbmdCb3gud2lkdGgpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gdGVtcEJvdW5kaW5nQm94LndpZHRoO1xuICAgICAgICB0aGlzLnNoYXBlQ29udC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGVtcEJvdW5kaW5nQm94LndpZHRoKTtcbiAgICAgICAgY2hhbmdlZCA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSB0ZW1wQm91bmRpbmdCb3guaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3guaCA9IHRlbXBCb3VuZGluZ0JveC5oZWlnaHQ7XG4gICAgICAgIHRoaXMuc2hhcGVDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGVtcEJvdW5kaW5nQm94LmhlaWdodCk7XG4gICAgICAgIGNoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGNoYW5nZWQgfHwgdGhpcy5jdXJyZW50QkJveC54ICE9PSB0ZW1wQm91bmRpbmdCb3gueCB8fCB0aGlzLmN1cnJlbnRCQm94LnkgIT09IHRlbXBCb3VuZGluZ0JveC55KSB7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gudyA9IHRlbXBCb3VuZGluZ0JveC53aWR0aDtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gdGVtcEJvdW5kaW5nQm94LmhlaWdodDtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC54ID0gdGVtcEJvdW5kaW5nQm94Lng7XG4gICAgICAgIHRoaXMuY3VycmVudEJCb3gueSA9IHRlbXBCb3VuZGluZ0JveC55O1xuICAgICAgICB0aGlzLnNoYXBlQ29udC5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB0aGlzLmN1cnJlbnRCQm94LnggKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LnkgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LncgKyAnICcgKyB0aGlzLmN1cnJlbnRCQm94LmgpO1xuICAgICAgICB2YXIgc2hhcGVTdHlsZSA9IHRoaXMuc2hhcGVDb250LnN0eWxlO1xuICAgICAgICB2YXIgc2hhcGVUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyB0aGlzLmN1cnJlbnRCQm94LnggKyAncHgsJyArIHRoaXMuY3VycmVudEJCb3gueSArICdweCknO1xuICAgICAgICBzaGFwZVN0eWxlLnRyYW5zZm9ybSA9IHNoYXBlVHJhbnNmb3JtO1xuICAgICAgICBzaGFwZVN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHNoYXBlVHJhbnNmb3JtO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIVGV4dEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMudGV4dFNwYW5zID0gW107XG4gICAgdGhpcy50ZXh0UGF0aHMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRCQm94ID0ge1xuICAgICAgeDogOTk5OTk5LFxuICAgICAgeTogLTk5OTk5OSxcbiAgICAgIGg6IDAsXG4gICAgICB3OiAwXG4gICAgfTtcbiAgICB0aGlzLnJlbmRlclR5cGUgPSAnc3ZnJztcbiAgICB0aGlzLmlzTWFza2VkID0gZmFsc2U7XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBUcmFuc2Zvcm1FbGVtZW50LCBIQmFzZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnQsIEZyYW1lRWxlbWVudCwgUmVuZGVyYWJsZURPTUVsZW1lbnQsIElUZXh0RWxlbWVudF0sIEhUZXh0RWxlbWVudCk7XG4gIEhUZXh0RWxlbWVudC5wcm90b3R5cGUuY3JlYXRlQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmlzTWFza2VkID0gdGhpcy5jaGVja01hc2tzKCk7XG4gICAgaWYgKHRoaXMuaXNNYXNrZWQpIHtcbiAgICAgIHRoaXMucmVuZGVyVHlwZSA9ICdzdmcnO1xuICAgICAgdGhpcy5jb21wVyA9IHRoaXMuY29tcC5kYXRhLnc7XG4gICAgICB0aGlzLmNvbXBIID0gdGhpcy5jb21wLmRhdGEuaDtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgdGhpcy5jb21wVyk7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmNvbXBIKTtcbiAgICAgIHZhciBnID0gY3JlYXRlTlMoJ2cnKTtcbiAgICAgIHRoaXMubWFza2VkRWxlbWVudC5hcHBlbmRDaGlsZChnKTtcbiAgICAgIHRoaXMuaW5uZXJFbGVtID0gZztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5yZW5kZXJUeXBlID0gJ2h0bWwnO1xuICAgICAgdGhpcy5pbm5lckVsZW0gPSB0aGlzLmxheWVyRWxlbWVudDtcbiAgICB9XG4gICAgdGhpcy5jaGVja1BhcmVudGluZygpO1xuICB9O1xuICBIVGV4dEVsZW1lbnQucHJvdG90eXBlLmJ1aWxkTmV3VGV4dCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZG9jdW1lbnREYXRhID0gdGhpcy50ZXh0UHJvcGVydHkuY3VycmVudERhdGE7XG4gICAgdGhpcy5yZW5kZXJlZExldHRlcnMgPSBjcmVhdGVTaXplZEFycmF5KGRvY3VtZW50RGF0YS5sID8gZG9jdW1lbnREYXRhLmwubGVuZ3RoIDogMCk7XG4gICAgdmFyIGlubmVyRWxlbVN0eWxlID0gdGhpcy5pbm5lckVsZW0uc3R5bGU7XG4gICAgdmFyIHRleHRDb2xvciA9IGRvY3VtZW50RGF0YS5mYyA/IHRoaXMuYnVpbGRDb2xvcihkb2N1bWVudERhdGEuZmMpIDogJ3JnYmEoMCwwLDAsMCknO1xuICAgIGlubmVyRWxlbVN0eWxlLmZpbGwgPSB0ZXh0Q29sb3I7XG4gICAgaW5uZXJFbGVtU3R5bGUuY29sb3IgPSB0ZXh0Q29sb3I7XG4gICAgaWYgKGRvY3VtZW50RGF0YS5zYykge1xuICAgICAgaW5uZXJFbGVtU3R5bGUuc3Ryb2tlID0gdGhpcy5idWlsZENvbG9yKGRvY3VtZW50RGF0YS5zYyk7XG4gICAgICBpbm5lckVsZW1TdHlsZS5zdHJva2VXaWR0aCA9IGRvY3VtZW50RGF0YS5zdyArICdweCc7XG4gICAgfVxuICAgIHZhciBmb250RGF0YSA9IHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5nZXRGb250QnlOYW1lKGRvY3VtZW50RGF0YS5mKTtcbiAgICBpZiAoIXRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udFNpemUgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcbiAgICAgIGlubmVyRWxlbVN0eWxlLmxpbmVIZWlnaHQgPSBkb2N1bWVudERhdGEuZmluYWxTaXplICsgJ3B4JztcbiAgICAgIGlmIChmb250RGF0YS5mQ2xhc3MpIHtcbiAgICAgICAgdGhpcy5pbm5lckVsZW0uY2xhc3NOYW1lID0gZm9udERhdGEuZkNsYXNzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5uZXJFbGVtU3R5bGUuZm9udEZhbWlseSA9IGZvbnREYXRhLmZGYW1pbHk7XG4gICAgICAgIHZhciBmV2VpZ2h0ID0gZG9jdW1lbnREYXRhLmZXZWlnaHQ7XG4gICAgICAgIHZhciBmU3R5bGUgPSBkb2N1bWVudERhdGEuZlN0eWxlO1xuICAgICAgICBpbm5lckVsZW1TdHlsZS5mb250U3R5bGUgPSBmU3R5bGU7XG4gICAgICAgIGlubmVyRWxlbVN0eWxlLmZvbnRXZWlnaHQgPSBmV2VpZ2h0O1xuICAgICAgfVxuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBsZXR0ZXJzID0gZG9jdW1lbnREYXRhLmw7XG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgdmFyIHRTcGFuO1xuICAgIHZhciB0UGFyZW50O1xuICAgIHZhciB0Q29udDtcbiAgICB2YXIgbWF0cml4SGVscGVyID0gdGhpcy5tSGVscGVyO1xuICAgIHZhciBzaGFwZXM7XG4gICAgdmFyIHNoYXBlU3RyID0gJyc7XG4gICAgdmFyIGNudCA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5nbG9iYWxEYXRhLmZvbnRNYW5hZ2VyLmNoYXJzKSB7XG4gICAgICAgIGlmICghdGhpcy50ZXh0UGF0aHNbY250XSkge1xuICAgICAgICAgIHRTcGFuID0gY3JlYXRlTlMoJ3BhdGgnKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgbGluZUNhcEVudW1bMV0pO1xuICAgICAgICAgIHRTcGFuLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgbGluZUpvaW5FbnVtWzJdKTtcbiAgICAgICAgICB0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1taXRlcmxpbWl0JywgJzQnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0U3BhbiA9IHRoaXMudGV4dFBhdGhzW2NudF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzTWFza2VkKSB7XG4gICAgICAgICAgaWYgKHRoaXMudGV4dFNwYW5zW2NudF0pIHtcbiAgICAgICAgICAgIHRQYXJlbnQgPSB0aGlzLnRleHRTcGFuc1tjbnRdO1xuICAgICAgICAgICAgdENvbnQgPSB0UGFyZW50LmNoaWxkcmVuWzBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0UGFyZW50ID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICAgICAgICAgIHRQYXJlbnQuc3R5bGUubGluZUhlaWdodCA9IDA7XG4gICAgICAgICAgICB0Q29udCA9IGNyZWF0ZU5TKCdzdmcnKTtcbiAgICAgICAgICAgIHRDb250LmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgICAgIHN0eWxlRGl2KHRQYXJlbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICBpZiAodGhpcy50ZXh0U3BhbnNbY250XSkge1xuICAgICAgICAgIHRQYXJlbnQgPSB0aGlzLnRleHRTcGFuc1tjbnRdO1xuICAgICAgICAgIHRTcGFuID0gdGhpcy50ZXh0UGF0aHNbY250XTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0UGFyZW50ID0gY3JlYXRlVGFnKCdzcGFuJyk7XG4gICAgICAgICAgc3R5bGVEaXYodFBhcmVudCk7XG4gICAgICAgICAgdFNwYW4gPSBjcmVhdGVUYWcoJ3NwYW4nKTtcbiAgICAgICAgICBzdHlsZURpdih0U3Bhbik7XG4gICAgICAgICAgdFBhcmVudC5hcHBlbmRDaGlsZCh0U3Bhbik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRTcGFuID0gdGhpcy50ZXh0UGF0aHNbY250XSA/IHRoaXMudGV4dFBhdGhzW2NudF0gOiBjcmVhdGVOUygndGV4dCcpO1xuICAgICAgfVxuICAgICAgLy8gdFNwYW4uc2V0QXR0cmlidXRlKCd2aXNpYmlsaXR5JywgJ2hpZGRlbicpO1xuICAgICAgaWYgKHRoaXMuZ2xvYmFsRGF0YS5mb250TWFuYWdlci5jaGFycykge1xuICAgICAgICB2YXIgY2hhckRhdGEgPSB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Q2hhckRhdGEoZG9jdW1lbnREYXRhLmZpbmFsVGV4dFtpXSwgZm9udERhdGEuZlN0eWxlLCB0aGlzLmdsb2JhbERhdGEuZm9udE1hbmFnZXIuZ2V0Rm9udEJ5TmFtZShkb2N1bWVudERhdGEuZikuZkZhbWlseSk7XG4gICAgICAgIHZhciBzaGFwZURhdGE7XG4gICAgICAgIGlmIChjaGFyRGF0YSkge1xuICAgICAgICAgIHNoYXBlRGF0YSA9IGNoYXJEYXRhLmRhdGE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2hhcGVEYXRhID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBtYXRyaXhIZWxwZXIucmVzZXQoKTtcbiAgICAgICAgaWYgKHNoYXBlRGF0YSAmJiBzaGFwZURhdGEuc2hhcGVzICYmIHNoYXBlRGF0YS5zaGFwZXMubGVuZ3RoKSB7XG4gICAgICAgICAgc2hhcGVzID0gc2hhcGVEYXRhLnNoYXBlc1swXS5pdDtcbiAgICAgICAgICBtYXRyaXhIZWxwZXIuc2NhbGUoZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCwgZG9jdW1lbnREYXRhLmZpbmFsU2l6ZSAvIDEwMCk7XG4gICAgICAgICAgc2hhcGVTdHIgPSB0aGlzLmNyZWF0ZVBhdGhTaGFwZShtYXRyaXhIZWxwZXIsIHNoYXBlcyk7XG4gICAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlKCdkJywgc2hhcGVTdHIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRQYXJlbnQpO1xuICAgICAgICAgIGlmIChzaGFwZURhdGEgJiYgc2hhcGVEYXRhLnNoYXBlcykge1xuICAgICAgICAgICAgLy8gZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCBpcyBuZWVkZWQgdG8gZ2V0IGV4YWN0IG1lYXN1cmUgb2Ygc2hhcGVcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodENvbnQpO1xuICAgICAgICAgICAgdmFyIGJvdW5kaW5nQm94ID0gdENvbnQuZ2V0QkJveCgpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIGJvdW5kaW5nQm94LndpZHRoICsgMik7XG4gICAgICAgICAgICB0Q29udC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGJvdW5kaW5nQm94LmhlaWdodCArIDIpO1xuICAgICAgICAgICAgdENvbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgYm91bmRpbmdCb3gueCAtIDEgKyAnICcgKyAoYm91bmRpbmdCb3gueSAtIDEpICsgJyAnICsgKGJvdW5kaW5nQm94LndpZHRoICsgMikgKyAnICcgKyAoYm91bmRpbmdCb3guaGVpZ2h0ICsgMikpO1xuICAgICAgICAgICAgdmFyIHRDb250U3R5bGUgPSB0Q29udC5zdHlsZTtcbiAgICAgICAgICAgIHZhciB0Q29udFRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnICsgKGJvdW5kaW5nQm94LnggLSAxKSArICdweCwnICsgKGJvdW5kaW5nQm94LnkgLSAxKSArICdweCknO1xuICAgICAgICAgICAgdENvbnRTdHlsZS50cmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgdENvbnRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0Q29udFRyYW5zbGF0aW9uO1xuICAgICAgICAgICAgbGV0dGVyc1tpXS55T2Zmc2V0ID0gYm91bmRpbmdCb3gueSAtIDE7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAxKTtcbiAgICAgICAgICAgIHRDb250LnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRQYXJlbnQuYXBwZW5kQ2hpbGQodENvbnQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdFNwYW4udGV4dENvbnRlbnQgPSBsZXR0ZXJzW2ldLnZhbDtcbiAgICAgICAgdFNwYW4uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZScsICd4bWw6c3BhY2UnLCAncHJlc2VydmUnKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTWFza2VkKSB7XG4gICAgICAgICAgdGhpcy5pbm5lckVsZW0uYXBwZW5kQ2hpbGQodFBhcmVudCk7XG4gICAgICAgICAgLy9cbiAgICAgICAgICB2YXIgdFN0eWxlID0gdFNwYW4uc3R5bGU7XG4gICAgICAgICAgdmFyIHRTcGFuVHJhbnNsYXRpb24gPSAndHJhbnNsYXRlM2QoMCwnICsgLWRvY3VtZW50RGF0YS5maW5hbFNpemUgLyAxLjIgKyAncHgsMCknO1xuICAgICAgICAgIHRTdHlsZS50cmFuc2Zvcm0gPSB0U3BhblRyYW5zbGF0aW9uO1xuICAgICAgICAgIHRTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSB0U3BhblRyYW5zbGF0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuaW5uZXJFbGVtLmFwcGVuZENoaWxkKHRTcGFuKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy9cbiAgICAgIGlmICghdGhpcy5pc01hc2tlZCkge1xuICAgICAgICB0aGlzLnRleHRTcGFuc1tjbnRdID0gdFBhcmVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0gPSB0U3BhbjtcbiAgICAgIH1cbiAgICAgIHRoaXMudGV4dFNwYW5zW2NudF0uc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICB0aGlzLnRleHRQYXRoc1tjbnRdID0gdFNwYW47XG4gICAgICBjbnQgKz0gMTtcbiAgICB9XG4gICAgd2hpbGUgKGNudCA8IHRoaXMudGV4dFNwYW5zLmxlbmd0aCkge1xuICAgICAgdGhpcy50ZXh0U3BhbnNbY250XS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgY250ICs9IDE7XG4gICAgfVxuICB9O1xuICBIVGV4dEVsZW1lbnQucHJvdG90eXBlLnJlbmRlcklubmVyQ29udGVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnZhbGlkYXRlVGV4dCgpO1xuICAgIHZhciBzdmdTdHlsZTtcbiAgICBpZiAodGhpcy5kYXRhLnNpbmdsZVNoYXBlKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzRmlyc3RGcmFtZSAmJiAhdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuaXNNYXNrZWQgJiYgdGhpcy5maW5hbFRyYW5zZm9ybS5fbWF0TWRmKSB7XG4gICAgICAgIC8vIFRvZG8gQmVuY2htYXJrIGlmIHVzaW5nIHRoaXMgaXMgYmV0dGVyIHRoYW4gZ2V0QkJveFxuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgLXRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AucC52WzBdICsgJyAnICsgLXRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AucC52WzFdICsgJyAnICsgdGhpcy5jb21wVyArICcgJyArIHRoaXMuY29tcEgpO1xuICAgICAgICBzdmdTdHlsZSA9IHRoaXMuc3ZnRWxlbWVudC5zdHlsZTtcbiAgICAgICAgdmFyIHRyYW5zbGF0aW9uID0gJ3RyYW5zbGF0ZSgnICsgLXRoaXMuZmluYWxUcmFuc2Zvcm0ubVByb3AucC52WzBdICsgJ3B4LCcgKyAtdGhpcy5maW5hbFRyYW5zZm9ybS5tUHJvcC5wLnZbMV0gKyAncHgpJztcbiAgICAgICAgc3ZnU3R5bGUudHJhbnNmb3JtID0gdHJhbnNsYXRpb247XG4gICAgICAgIHN2Z1N0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHRyYW5zbGF0aW9uO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLnRleHRBbmltYXRvci5nZXRNZWFzdXJlcyh0aGlzLnRleHRQcm9wZXJ0eS5jdXJyZW50RGF0YSwgdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcpO1xuICAgIGlmICghdGhpcy5sZXR0ZXJzQ2hhbmdlZEZsYWcgJiYgIXRoaXMudGV4dEFuaW1hdG9yLmxldHRlcnNDaGFuZ2VkRmxhZykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIHJlbmRlcmVkTGV0dGVycyA9IHRoaXMudGV4dEFuaW1hdG9yLnJlbmRlcmVkTGV0dGVycztcbiAgICB2YXIgbGV0dGVycyA9IHRoaXMudGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLmw7XG4gICAgbGVuID0gbGV0dGVycy5sZW5ndGg7XG4gICAgdmFyIHJlbmRlcmVkTGV0dGVyO1xuICAgIHZhciB0ZXh0U3BhbjtcbiAgICB2YXIgdGV4dFBhdGg7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAobGV0dGVyc1tpXS5uKSB7XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0ZXh0U3BhbiA9IHRoaXMudGV4dFNwYW5zW2ldO1xuICAgICAgICB0ZXh0UGF0aCA9IHRoaXMudGV4dFBhdGhzW2ldO1xuICAgICAgICByZW5kZXJlZExldHRlciA9IHJlbmRlcmVkTGV0dGVyc1tjb3VudF07XG4gICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5fbWRmLm0pIHtcbiAgICAgICAgICBpZiAoIXRoaXMuaXNNYXNrZWQpIHtcbiAgICAgICAgICAgIHRleHRTcGFuLnN0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHJlbmRlcmVkTGV0dGVyLm07XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zdHlsZS50cmFuc2Zvcm0gPSByZW5kZXJlZExldHRlci5tO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0ZXh0U3Bhbi5zZXRBdHRyaWJ1dGUoJ3RyYW5zZm9ybScsIHJlbmRlcmVkTGV0dGVyLm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLy8gL3RleHRTcGFuLnNldEF0dHJpYnV0ZSgnb3BhY2l0eScscmVuZGVyZWRMZXR0ZXIubyk7XG4gICAgICAgIHRleHRTcGFuLnN0eWxlLm9wYWNpdHkgPSByZW5kZXJlZExldHRlci5vO1xuICAgICAgICBpZiAocmVuZGVyZWRMZXR0ZXIuc3cgJiYgcmVuZGVyZWRMZXR0ZXIuX21kZi5zdykge1xuICAgICAgICAgIHRleHRQYXRoLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgcmVuZGVyZWRMZXR0ZXIuc3cpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZW5kZXJlZExldHRlci5zYyAmJiByZW5kZXJlZExldHRlci5fbWRmLnNjKSB7XG4gICAgICAgICAgdGV4dFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UnLCByZW5kZXJlZExldHRlci5zYyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlbmRlcmVkTGV0dGVyLmZjICYmIHJlbmRlcmVkTGV0dGVyLl9tZGYuZmMpIHtcbiAgICAgICAgICB0ZXh0UGF0aC5zZXRBdHRyaWJ1dGUoJ2ZpbGwnLCByZW5kZXJlZExldHRlci5mYyk7XG4gICAgICAgICAgdGV4dFBhdGguc3R5bGUuY29sb3IgPSByZW5kZXJlZExldHRlci5mYztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5pbm5lckVsZW0uZ2V0QkJveCAmJiAhdGhpcy5oaWRkZW4gJiYgKHRoaXMuX2lzRmlyc3RGcmFtZSB8fCB0aGlzLl9tZGYpKSB7XG4gICAgICB2YXIgYm91bmRpbmdCb3ggPSB0aGlzLmlubmVyRWxlbS5nZXRCQm94KCk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC53ICE9PSBib3VuZGluZ0JveC53aWR0aCkge1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LncgPSBib3VuZGluZ0JveC53aWR0aDtcbiAgICAgICAgdGhpcy5zdmdFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBib3VuZGluZ0JveC53aWR0aCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC5oICE9PSBib3VuZGluZ0JveC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC5oID0gYm91bmRpbmdCb3guaGVpZ2h0O1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCBib3VuZGluZ0JveC5oZWlnaHQpO1xuICAgICAgfVxuICAgICAgdmFyIG1hcmdpbiA9IDE7XG4gICAgICBpZiAodGhpcy5jdXJyZW50QkJveC53ICE9PSBib3VuZGluZ0JveC53aWR0aCArIG1hcmdpbiAqIDIgfHwgdGhpcy5jdXJyZW50QkJveC5oICE9PSBib3VuZGluZ0JveC5oZWlnaHQgKyBtYXJnaW4gKiAyIHx8IHRoaXMuY3VycmVudEJCb3gueCAhPT0gYm91bmRpbmdCb3gueCAtIG1hcmdpbiB8fCB0aGlzLmN1cnJlbnRCQm94LnkgIT09IGJvdW5kaW5nQm94LnkgLSBtYXJnaW4pIHtcbiAgICAgICAgdGhpcy5jdXJyZW50QkJveC53ID0gYm91bmRpbmdCb3gud2lkdGggKyBtYXJnaW4gKiAyO1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LmggPSBib3VuZGluZ0JveC5oZWlnaHQgKyBtYXJnaW4gKiAyO1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnggPSBib3VuZGluZ0JveC54IC0gbWFyZ2luO1xuICAgICAgICB0aGlzLmN1cnJlbnRCQm94LnkgPSBib3VuZGluZ0JveC55IC0gbWFyZ2luO1xuICAgICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgdGhpcy5jdXJyZW50QkJveC54ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC55ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC53ICsgJyAnICsgdGhpcy5jdXJyZW50QkJveC5oKTtcbiAgICAgICAgc3ZnU3R5bGUgPSB0aGlzLnN2Z0VsZW1lbnQuc3R5bGU7XG4gICAgICAgIHZhciBzdmdUcmFuc2Zvcm0gPSAndHJhbnNsYXRlKCcgKyB0aGlzLmN1cnJlbnRCQm94LnggKyAncHgsJyArIHRoaXMuY3VycmVudEJCb3gueSArICdweCknO1xuICAgICAgICBzdmdTdHlsZS50cmFuc2Zvcm0gPSBzdmdUcmFuc2Zvcm07XG4gICAgICAgIHN2Z1N0eWxlLndlYmtpdFRyYW5zZm9ybSA9IHN2Z1RyYW5zZm9ybTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSENhbWVyYUVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCkge1xuICAgIHRoaXMuaW5pdEZyYW1lKCk7XG4gICAgdGhpcy5pbml0QmFzZURhdGEoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gICAgdGhpcy5pbml0SGllcmFyY2h5KCk7XG4gICAgdmFyIGdldFByb3AgPSBQcm9wZXJ0eUZhY3RvcnkuZ2V0UHJvcDtcbiAgICB0aGlzLnBlID0gZ2V0UHJvcCh0aGlzLCBkYXRhLnBlLCAwLCAwLCB0aGlzKTtcbiAgICBpZiAoZGF0YS5rcy5wLnMpIHtcbiAgICAgIHRoaXMucHggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC54LCAxLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMucHkgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC55LCAxLCAwLCB0aGlzKTtcbiAgICAgIHRoaXMucHogPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucC56LCAxLCAwLCB0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnAsIDEsIDAsIHRoaXMpO1xuICAgIH1cbiAgICBpZiAoZGF0YS5rcy5hKSB7XG4gICAgICB0aGlzLmEgPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MuYSwgMSwgMCwgdGhpcyk7XG4gICAgfVxuICAgIGlmIChkYXRhLmtzLm9yLmsubGVuZ3RoICYmIGRhdGEua3Mub3Iua1swXS50bykge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gZGF0YS5rcy5vci5rLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICBkYXRhLmtzLm9yLmtbaV0udG8gPSBudWxsO1xuICAgICAgICBkYXRhLmtzLm9yLmtbaV0udGkgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9yID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLm9yLCAxLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMub3Iuc2ggPSB0cnVlO1xuICAgIHRoaXMucnggPSBnZXRQcm9wKHRoaXMsIGRhdGEua3MucngsIDAsIGRlZ1RvUmFkcywgdGhpcyk7XG4gICAgdGhpcy5yeSA9IGdldFByb3AodGhpcywgZGF0YS5rcy5yeSwgMCwgZGVnVG9SYWRzLCB0aGlzKTtcbiAgICB0aGlzLnJ6ID0gZ2V0UHJvcCh0aGlzLCBkYXRhLmtzLnJ6LCAwLCBkZWdUb1JhZHMsIHRoaXMpO1xuICAgIHRoaXMubWF0ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMuX3ByZXZNYXQgPSBuZXcgTWF0cml4KCk7XG4gICAgdGhpcy5faXNGaXJzdEZyYW1lID0gdHJ1ZTtcblxuICAgIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIG1ha2UgdGhlIEhDYW1lcmEgZWxlbWVudCB0byBiZSBjb21wYXRpYmxlIHdpdGggdGhlIExheWVySW50ZXJmYWNlIGFuZCBUcmFuc2Zvcm1JbnRlcmZhY2UuXG4gICAgdGhpcy5maW5hbFRyYW5zZm9ybSA9IHtcbiAgICAgIG1Qcm9wOiB0aGlzXG4gICAgfTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VFbGVtZW50LCBGcmFtZUVsZW1lbnQsIEhpZXJhcmNoeUVsZW1lbnRdLCBIQ2FtZXJhRWxlbWVudCk7XG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5zZXR1cCA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcbiAgICB2YXIgY29tcDtcbiAgICB2YXIgcGVyc3BlY3RpdmVTdHlsZTtcbiAgICB2YXIgY29udGFpbmVyU3R5bGU7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAvLyBbcGVyc3BlY3RpdmVFbGVtLGNvbnRhaW5lcl1cbiAgICAgIGNvbXAgPSB0aGlzLmNvbXAudGhyZWVERWxlbWVudHNbaV07XG4gICAgICBpZiAoY29tcC50eXBlID09PSAnM2QnKSB7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUgPSBjb21wLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUgPSBjb21wLmNvbnRhaW5lci5zdHlsZTtcbiAgICAgICAgdmFyIHBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgdmFyIG9yaWdpbiA9ICcwcHggMHB4IDBweCc7XG4gICAgICAgIHZhciBtYXRyaXggPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xuICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gcGVyc3BlY3RpdmU7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBwZXJzcGVjdGl2ZTtcbiAgICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtT3JpZ2luID0gb3JpZ2luO1xuICAgICAgICBjb250YWluZXJTdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBvcmlnaW47XG4gICAgICAgIGNvbnRhaW5lclN0eWxlLndlYmtpdFRyYW5zZm9ybU9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS50cmFuc2Zvcm0gPSBtYXRyaXg7XG4gICAgICAgIHBlcnNwZWN0aXZlU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4O1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUVsZW1lbnRzID0gZnVuY3Rpb24gKCkge307XG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5oaWRlID0gZnVuY3Rpb24gKCkge307XG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX21kZiA9IHRoaXMuX2lzRmlyc3RGcmFtZTtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIGlmICh0aGlzLmhpZXJhcmNoeSkge1xuICAgICAgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIF9tZGYgPSB0aGlzLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5fbWRmIHx8IF9tZGY7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChfbWRmIHx8IHRoaXMucGUuX21kZiB8fCB0aGlzLnAgJiYgdGhpcy5wLl9tZGYgfHwgdGhpcy5weCAmJiAodGhpcy5weC5fbWRmIHx8IHRoaXMucHkuX21kZiB8fCB0aGlzLnB6Ll9tZGYpIHx8IHRoaXMucnguX21kZiB8fCB0aGlzLnJ5Ll9tZGYgfHwgdGhpcy5yei5fbWRmIHx8IHRoaXMub3IuX21kZiB8fCB0aGlzLmEgJiYgdGhpcy5hLl9tZGYpIHtcbiAgICAgIHRoaXMubWF0LnJlc2V0KCk7XG4gICAgICBpZiAodGhpcy5oaWVyYXJjaHkpIHtcbiAgICAgICAgbGVuID0gdGhpcy5oaWVyYXJjaHkubGVuZ3RoIC0gMTtcbiAgICAgICAgZm9yIChpID0gbGVuOyBpID49IDA7IGkgLT0gMSkge1xuICAgICAgICAgIHZhciBtVHJhbnNmID0gdGhpcy5oaWVyYXJjaHlbaV0uZmluYWxUcmFuc2Zvcm0ubVByb3A7XG4gICAgICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKC1tVHJhbnNmLnAudlswXSwgLW1UcmFuc2YucC52WzFdLCBtVHJhbnNmLnAudlsyXSk7XG4gICAgICAgICAgdGhpcy5tYXQucm90YXRlWCgtbVRyYW5zZi5vci52WzBdKS5yb3RhdGVZKC1tVHJhbnNmLm9yLnZbMV0pLnJvdGF0ZVoobVRyYW5zZi5vci52WzJdKTtcbiAgICAgICAgICB0aGlzLm1hdC5yb3RhdGVYKC1tVHJhbnNmLnJ4LnYpLnJvdGF0ZVkoLW1UcmFuc2Yucnkudikucm90YXRlWihtVHJhbnNmLnJ6LnYpO1xuICAgICAgICAgIHRoaXMubWF0LnNjYWxlKDEgLyBtVHJhbnNmLnMudlswXSwgMSAvIG1UcmFuc2Yucy52WzFdLCAxIC8gbVRyYW5zZi5zLnZbMl0pO1xuICAgICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZShtVHJhbnNmLmEudlswXSwgbVRyYW5zZi5hLnZbMV0sIG1UcmFuc2YuYS52WzJdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMucCkge1xuICAgICAgICB0aGlzLm1hdC50cmFuc2xhdGUoLXRoaXMucC52WzBdLCAtdGhpcy5wLnZbMV0sIHRoaXMucC52WzJdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgtdGhpcy5weC52LCAtdGhpcy5weS52LCB0aGlzLnB6LnYpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYSkge1xuICAgICAgICB2YXIgZGlmZlZlY3RvcjtcbiAgICAgICAgaWYgKHRoaXMucCkge1xuICAgICAgICAgIGRpZmZWZWN0b3IgPSBbdGhpcy5wLnZbMF0gLSB0aGlzLmEudlswXSwgdGhpcy5wLnZbMV0gLSB0aGlzLmEudlsxXSwgdGhpcy5wLnZbMl0gLSB0aGlzLmEudlsyXV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZGlmZlZlY3RvciA9IFt0aGlzLnB4LnYgLSB0aGlzLmEudlswXSwgdGhpcy5weS52IC0gdGhpcy5hLnZbMV0sIHRoaXMucHoudiAtIHRoaXMuYS52WzJdXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWFnID0gTWF0aC5zcXJ0KE1hdGgucG93KGRpZmZWZWN0b3JbMF0sIDIpICsgTWF0aC5wb3coZGlmZlZlY3RvclsxXSwgMikgKyBNYXRoLnBvdyhkaWZmVmVjdG9yWzJdLCAyKSk7XG4gICAgICAgIC8vIHZhciBsb29rRGlyID0gZ2V0Tm9ybWFsaXplZFBvaW50KGdldERpZmZWZWN0b3IodGhpcy5hLnYsdGhpcy5wLnYpKTtcbiAgICAgICAgdmFyIGxvb2tEaXIgPSBbZGlmZlZlY3RvclswXSAvIG1hZywgZGlmZlZlY3RvclsxXSAvIG1hZywgZGlmZlZlY3RvclsyXSAvIG1hZ107XG4gICAgICAgIHZhciBsb29rTGVuZ3RoT25YWiA9IE1hdGguc3FydChsb29rRGlyWzJdICogbG9va0RpclsyXSArIGxvb2tEaXJbMF0gKiBsb29rRGlyWzBdKTtcbiAgICAgICAgdmFyIG1Sb3RhdGlvblggPSBNYXRoLmF0YW4yKGxvb2tEaXJbMV0sIGxvb2tMZW5ndGhPblhaKTtcbiAgICAgICAgdmFyIG1Sb3RhdGlvblkgPSBNYXRoLmF0YW4yKGxvb2tEaXJbMF0sIC1sb29rRGlyWzJdKTtcbiAgICAgICAgdGhpcy5tYXQucm90YXRlWShtUm90YXRpb25ZKS5yb3RhdGVYKC1tUm90YXRpb25YKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubWF0LnJvdGF0ZVgoLXRoaXMucngudikucm90YXRlWSgtdGhpcy5yeS52KS5yb3RhdGVaKHRoaXMucnoudik7XG4gICAgICB0aGlzLm1hdC5yb3RhdGVYKC10aGlzLm9yLnZbMF0pLnJvdGF0ZVkoLXRoaXMub3IudlsxXSkucm90YXRlWih0aGlzLm9yLnZbMl0pO1xuICAgICAgdGhpcy5tYXQudHJhbnNsYXRlKHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53IC8gMiwgdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggLyAyLCAwKTtcbiAgICAgIHRoaXMubWF0LnRyYW5zbGF0ZSgwLCAwLCB0aGlzLnBlLnYpO1xuICAgICAgdmFyIGhhc01hdHJpeENoYW5nZWQgPSAhdGhpcy5fcHJldk1hdC5lcXVhbHModGhpcy5tYXQpO1xuICAgICAgaWYgKChoYXNNYXRyaXhDaGFuZ2VkIHx8IHRoaXMucGUuX21kZikgJiYgdGhpcy5jb21wLnRocmVlREVsZW1lbnRzKSB7XG4gICAgICAgIGxlbiA9IHRoaXMuY29tcC50aHJlZURFbGVtZW50cy5sZW5ndGg7XG4gICAgICAgIHZhciBjb21wO1xuICAgICAgICB2YXIgcGVyc3BlY3RpdmVTdHlsZTtcbiAgICAgICAgdmFyIGNvbnRhaW5lclN0eWxlO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBjb21wID0gdGhpcy5jb21wLnRocmVlREVsZW1lbnRzW2ldO1xuICAgICAgICAgIGlmIChjb21wLnR5cGUgPT09ICczZCcpIHtcbiAgICAgICAgICAgIGlmIChoYXNNYXRyaXhDaGFuZ2VkKSB7XG4gICAgICAgICAgICAgIHZhciBtYXRWYWx1ZSA9IHRoaXMubWF0LnRvQ1NTKCk7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlID0gY29tcC5jb250YWluZXIuc3R5bGU7XG4gICAgICAgICAgICAgIGNvbnRhaW5lclN0eWxlLnRyYW5zZm9ybSA9IG1hdFZhbHVlO1xuICAgICAgICAgICAgICBjb250YWluZXJTdHlsZS53ZWJraXRUcmFuc2Zvcm0gPSBtYXRWYWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnBlLl9tZGYpIHtcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZSA9IGNvbXAucGVyc3BlY3RpdmVFbGVtLnN0eWxlO1xuICAgICAgICAgICAgICBwZXJzcGVjdGl2ZVN0eWxlLnBlcnNwZWN0aXZlID0gdGhpcy5wZS52ICsgJ3B4JztcbiAgICAgICAgICAgICAgcGVyc3BlY3RpdmVTdHlsZS53ZWJraXRQZXJzcGVjdGl2ZSA9IHRoaXMucGUudiArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMubWF0LmNsb25lKHRoaXMuX3ByZXZNYXQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9pc0ZpcnN0RnJhbWUgPSBmYWxzZTtcbiAgfTtcbiAgSENhbWVyYUVsZW1lbnQucHJvdG90eXBlLnByZXBhcmVGcmFtZSA9IGZ1bmN0aW9uIChudW0pIHtcbiAgICB0aGlzLnByZXBhcmVQcm9wZXJ0aWVzKG51bSwgdHJ1ZSk7XG4gIH07XG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge307XG4gIEhDYW1lcmFFbGVtZW50LnByb3RvdHlwZS5nZXRCYXNlRWxlbWVudCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBmdW5jdGlvbiBISW1hZ2VFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmFzc2V0RGF0YSA9IGdsb2JhbERhdGEuZ2V0QXNzZXREYXRhKGRhdGEucmVmSWQpO1xuICAgIHRoaXMuaW5pdEVsZW1lbnQoZGF0YSwgZ2xvYmFsRGF0YSwgY29tcCk7XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtCYXNlRWxlbWVudCwgVHJhbnNmb3JtRWxlbWVudCwgSEJhc2VFbGVtZW50LCBIU29saWRFbGVtZW50LCBIaWVyYXJjaHlFbGVtZW50LCBGcmFtZUVsZW1lbnQsIFJlbmRlcmFibGVFbGVtZW50XSwgSEltYWdlRWxlbWVudCk7XG4gIEhJbWFnZUVsZW1lbnQucHJvdG90eXBlLmNyZWF0ZUNvbnRlbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFzc2V0UGF0aCA9IHRoaXMuZ2xvYmFsRGF0YS5nZXRBc3NldHNQYXRoKHRoaXMuYXNzZXREYXRhKTtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrKSB7XG4gICAgICB0aGlzLmltYWdlRWxlbSA9IGNyZWF0ZU5TKCdpbWFnZScpO1xuICAgICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuYXNzZXREYXRhLncgKyAncHgnKTtcbiAgICAgIHRoaXMuaW1hZ2VFbGVtLnNldEF0dHJpYnV0ZSgnaGVpZ2h0JywgdGhpcy5hc3NldERhdGEuaCArICdweCcpO1xuICAgICAgdGhpcy5pbWFnZUVsZW0uc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCAnaHJlZicsIGFzc2V0UGF0aCk7XG4gICAgICB0aGlzLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZCh0aGlzLmltYWdlRWxlbSk7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnd2lkdGgnLCB0aGlzLmFzc2V0RGF0YS53KTtcbiAgICAgIHRoaXMuYmFzZUVsZW1lbnQuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCB0aGlzLmFzc2V0RGF0YS5oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sYXllckVsZW1lbnQuYXBwZW5kQ2hpbGQoaW1nKTtcbiAgICB9XG4gICAgaW1nLmNyb3NzT3JpZ2luID0gJ2Fub255bW91cyc7XG4gICAgaW1nLnNyYyA9IGFzc2V0UGF0aDtcbiAgICBpZiAodGhpcy5kYXRhLmxuKSB7XG4gICAgICB0aGlzLmJhc2VFbGVtZW50LnNldEF0dHJpYnV0ZSgnaWQnLCB0aGlzLmRhdGEubG4pO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBIeWJyaWRSZW5kZXJlckJhc2UoYW5pbWF0aW9uSXRlbSwgY29uZmlnKSB7XG4gICAgdGhpcy5hbmltYXRpb25JdGVtID0gYW5pbWF0aW9uSXRlbTtcbiAgICB0aGlzLmxheWVycyA9IG51bGw7XG4gICAgdGhpcy5yZW5kZXJlZEZyYW1lID0gLTE7XG4gICAgdGhpcy5yZW5kZXJDb25maWcgPSB7XG4gICAgICBjbGFzc05hbWU6IGNvbmZpZyAmJiBjb25maWcuY2xhc3NOYW1lIHx8ICcnLFxuICAgICAgaW1hZ2VQcmVzZXJ2ZUFzcGVjdFJhdGlvOiBjb25maWcgJiYgY29uZmlnLmltYWdlUHJlc2VydmVBc3BlY3RSYXRpbyB8fCAneE1pZFlNaWQgc2xpY2UnLFxuICAgICAgaGlkZU9uVHJhbnNwYXJlbnQ6ICEoY29uZmlnICYmIGNvbmZpZy5oaWRlT25UcmFuc3BhcmVudCA9PT0gZmFsc2UpLFxuICAgICAgZmlsdGVyU2l6ZToge1xuICAgICAgICB3aWR0aDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLndpZHRoIHx8ICc0MDAlJyxcbiAgICAgICAgaGVpZ2h0OiBjb25maWcgJiYgY29uZmlnLmZpbHRlclNpemUgJiYgY29uZmlnLmZpbHRlclNpemUuaGVpZ2h0IHx8ICc0MDAlJyxcbiAgICAgICAgeDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnggfHwgJy0xMDAlJyxcbiAgICAgICAgeTogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLnkgfHwgJy0xMDAlJ1xuICAgICAgfVxuICAgIH07XG4gICAgdGhpcy5nbG9iYWxEYXRhID0ge1xuICAgICAgX21kZjogZmFsc2UsXG4gICAgICBmcmFtZU51bTogLTEsXG4gICAgICByZW5kZXJDb25maWc6IHRoaXMucmVuZGVyQ29uZmlnXG4gICAgfTtcbiAgICB0aGlzLnBlbmRpbmdFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLnRocmVlREVsZW1lbnRzID0gW107XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhbWVyYSA9IG51bGw7XG4gICAgdGhpcy5zdXBwb3J0czNkID0gdHJ1ZTtcbiAgICB0aGlzLnJlbmRlcmVyVHlwZSA9ICdodG1sJztcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW0Jhc2VSZW5kZXJlcl0sIEh5YnJpZFJlbmRlcmVyQmFzZSk7XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuYnVpbGRJdGVtID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmJ1aWxkSXRlbTtcbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jaGVja1BlbmRpbmdFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB3aGlsZSAodGhpcy5wZW5kaW5nRWxlbWVudHMubGVuZ3RoKSB7XG4gICAgICB2YXIgZWxlbWVudCA9IHRoaXMucGVuZGluZ0VsZW1lbnRzLnBvcCgpO1xuICAgICAgZWxlbWVudC5jaGVja1BhcmVudGluZygpO1xuICAgIH1cbiAgfTtcbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5hcHBlbmRFbGVtZW50SW5Qb3MgPSBmdW5jdGlvbiAoZWxlbWVudCwgcG9zKSB7XG4gICAgdmFyIG5ld0RPTUVsZW1lbnQgPSBlbGVtZW50LmdldEJhc2VFbGVtZW50KCk7XG4gICAgaWYgKCFuZXdET01FbGVtZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBsYXllciA9IHRoaXMubGF5ZXJzW3Bvc107XG4gICAgaWYgKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgaWYgKHRoaXMudGhyZWVERWxlbWVudHMpIHtcbiAgICAgICAgdGhpcy5hZGRUbzNkQ29udGFpbmVyKG5ld0RPTUVsZW1lbnQsIHBvcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBuZXh0RE9NRWxlbWVudDtcbiAgICAgICAgdmFyIG5leHRMYXllcjtcbiAgICAgICAgdmFyIHRtcERPTUVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChpIDwgcG9zKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXSAhPT0gdHJ1ZSAmJiB0aGlzLmVsZW1lbnRzW2ldLmdldEJhc2VFbGVtZW50KSB7XG4gICAgICAgICAgICBuZXh0TGF5ZXIgPSB0aGlzLmVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgdG1wRE9NRWxlbWVudCA9IHRoaXMubGF5ZXJzW2ldLmRkZCA/IHRoaXMuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MoaSkgOiBuZXh0TGF5ZXIuZ2V0QmFzZUVsZW1lbnQoKTtcbiAgICAgICAgICAgIG5leHRET01FbGVtZW50ID0gdG1wRE9NRWxlbWVudCB8fCBuZXh0RE9NRWxlbWVudDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChuZXh0RE9NRWxlbWVudCkge1xuICAgICAgICAgIGlmICghbGF5ZXIuZGRkIHx8ICF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShuZXdET01FbGVtZW50LCBuZXh0RE9NRWxlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCFsYXllci5kZGQgfHwgIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKG5ld0RPTUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuYWRkVG8zZENvbnRhaW5lcihuZXdET01FbGVtZW50LCBwb3MpO1xuICAgIH1cbiAgfTtcbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTaGFwZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgU1ZHU2hhcGVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSFNoYXBlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIGlmICghdGhpcy5zdXBwb3J0czNkKSB7XG4gICAgICByZXR1cm4gbmV3IFNWR1RleHRMb3R0aWVFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSFRleHRFbGVtZW50KGRhdGEsIHRoaXMuZ2xvYmFsRGF0YSwgdGhpcyk7XG4gIH07XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY3JlYXRlQ2FtZXJhID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLmNhbWVyYSA9IG5ldyBIQ2FtZXJhRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIHJldHVybiB0aGlzLmNhbWVyYTtcbiAgfTtcbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVJbWFnZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgSUltYWdlRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhJbWFnZUVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVTb2xpZCA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzM2QpIHtcbiAgICAgIHJldHVybiBuZXcgSVNvbGlkRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhTb2xpZEVsZW1lbnQoZGF0YSwgdGhpcy5nbG9iYWxEYXRhLCB0aGlzKTtcbiAgfTtcbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5jcmVhdGVOdWxsID0gU1ZHUmVuZGVyZXIucHJvdG90eXBlLmNyZWF0ZU51bGw7XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuZ2V0VGhyZWVEQ29udGFpbmVyQnlQb3MgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgdmFyIGkgPSAwO1xuICAgIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcbiAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgaWYgKHRoaXMudGhyZWVERWxlbWVudHNbaV0uc3RhcnRQb3MgPD0gcG9zICYmIHRoaXMudGhyZWVERWxlbWVudHNbaV0uZW5kUG9zID49IHBvcykge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJlZURFbGVtZW50c1tpXS5wZXJzcGVjdGl2ZUVsZW07XG4gICAgICB9XG4gICAgICBpICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmNyZWF0ZVRocmVlRENvbnRhaW5lciA9IGZ1bmN0aW9uIChwb3MsIHR5cGUpIHtcbiAgICB2YXIgcGVyc3BlY3RpdmVFbGVtID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICB2YXIgc3R5bGU7XG4gICAgdmFyIGNvbnRhaW5lclN0eWxlO1xuICAgIHN0eWxlRGl2KHBlcnNwZWN0aXZlRWxlbSk7XG4gICAgdmFyIGNvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgc3R5bGVEaXYoY29udGFpbmVyKTtcbiAgICBpZiAodHlwZSA9PT0gJzNkJykge1xuICAgICAgc3R5bGUgPSBwZXJzcGVjdGl2ZUVsZW0uc3R5bGU7XG4gICAgICBzdHlsZS53aWR0aCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS53ICsgJ3B4JztcbiAgICAgIHN0eWxlLmhlaWdodCA9IHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oICsgJ3B4JztcbiAgICAgIHZhciBjZW50ZXIgPSAnNTAlIDUwJSc7XG4gICAgICBzdHlsZS53ZWJraXRUcmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XG4gICAgICBzdHlsZS5tb3pUcmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XG4gICAgICBzdHlsZS50cmFuc2Zvcm1PcmlnaW4gPSBjZW50ZXI7XG4gICAgICBjb250YWluZXJTdHlsZSA9IGNvbnRhaW5lci5zdHlsZTtcbiAgICAgIHZhciBtYXRyaXggPSAnbWF0cml4M2QoMSwwLDAsMCwwLDEsMCwwLDAsMCwxLDAsMCwwLDAsMSknO1xuICAgICAgY29udGFpbmVyU3R5bGUudHJhbnNmb3JtID0gbWF0cml4O1xuICAgICAgY29udGFpbmVyU3R5bGUud2Via2l0VHJhbnNmb3JtID0gbWF0cml4O1xuICAgIH1cbiAgICBwZXJzcGVjdGl2ZUVsZW0uYXBwZW5kQ2hpbGQoY29udGFpbmVyKTtcbiAgICAvLyB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHBlcnNwZWN0aXZlRWxlbSk7XG4gICAgdmFyIHRocmVlRENvbnRhaW5lckRhdGEgPSB7XG4gICAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICAgIHBlcnNwZWN0aXZlRWxlbTogcGVyc3BlY3RpdmVFbGVtLFxuICAgICAgc3RhcnRQb3M6IHBvcyxcbiAgICAgIGVuZFBvczogcG9zLFxuICAgICAgdHlwZTogdHlwZVxuICAgIH07XG4gICAgdGhpcy50aHJlZURFbGVtZW50cy5wdXNoKHRocmVlRENvbnRhaW5lckRhdGEpO1xuICAgIHJldHVybiB0aHJlZURDb250YWluZXJEYXRhO1xuICB9O1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmJ1aWxkM2RDb250YWluZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLmxheWVycy5sZW5ndGg7XG4gICAgdmFyIGxhc3RUaHJlZURDb250YWluZXJEYXRhO1xuICAgIHZhciBjdXJyZW50Q29udGFpbmVyID0gJyc7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnNbaV0uZGRkICYmIHRoaXMubGF5ZXJzW2ldLnR5ICE9PSAzKSB7XG4gICAgICAgIGlmIChjdXJyZW50Q29udGFpbmVyICE9PSAnM2QnKSB7XG4gICAgICAgICAgY3VycmVudENvbnRhaW5lciA9ICczZCc7XG4gICAgICAgICAgbGFzdFRocmVlRENvbnRhaW5lckRhdGEgPSB0aGlzLmNyZWF0ZVRocmVlRENvbnRhaW5lcihpLCAnM2QnKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MgPSBNYXRoLm1heChsYXN0VGhyZWVEQ29udGFpbmVyRGF0YS5lbmRQb3MsIGkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGN1cnJlbnRDb250YWluZXIgIT09ICcyZCcpIHtcbiAgICAgICAgICBjdXJyZW50Q29udGFpbmVyID0gJzJkJztcbiAgICAgICAgICBsYXN0VGhyZWVEQ29udGFpbmVyRGF0YSA9IHRoaXMuY3JlYXRlVGhyZWVEQ29udGFpbmVyKGksICcyZCcpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RUaHJlZURDb250YWluZXJEYXRhLmVuZFBvcyA9IE1hdGgubWF4KGxhc3RUaHJlZURDb250YWluZXJEYXRhLmVuZFBvcywgaSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgaSAtPSAxKSB7XG4gICAgICB0aGlzLnJlc2l6ZXJFbGVtLmFwcGVuZENoaWxkKHRoaXMudGhyZWVERWxlbWVudHNbaV0ucGVyc3BlY3RpdmVFbGVtKTtcbiAgICB9XG4gIH07XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuYWRkVG8zZENvbnRhaW5lciA9IGZ1bmN0aW9uIChlbGVtLCBwb3MpIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IHRoaXMudGhyZWVERWxlbWVudHMubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAocG9zIDw9IHRoaXMudGhyZWVERWxlbWVudHNbaV0uZW5kUG9zKSB7XG4gICAgICAgIHZhciBqID0gdGhpcy50aHJlZURFbGVtZW50c1tpXS5zdGFydFBvcztcbiAgICAgICAgdmFyIG5leHRFbGVtZW50O1xuICAgICAgICB3aGlsZSAoaiA8IHBvcykge1xuICAgICAgICAgIGlmICh0aGlzLmVsZW1lbnRzW2pdICYmIHRoaXMuZWxlbWVudHNbal0uZ2V0QmFzZUVsZW1lbnQpIHtcbiAgICAgICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBqICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5leHRFbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy50aHJlZURFbGVtZW50c1tpXS5jb250YWluZXIuaW5zZXJ0QmVmb3JlKGVsZW0sIG5leHRFbGVtZW50KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnRocmVlREVsZW1lbnRzW2ldLmNvbnRhaW5lci5hcHBlbmRDaGlsZChlbGVtKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gIH07XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuY29uZmlnQW5pbWF0aW9uID0gZnVuY3Rpb24gKGFuaW1EYXRhKSB7XG4gICAgdmFyIHJlc2l6ZXJFbGVtID0gY3JlYXRlVGFnKCdkaXYnKTtcbiAgICB2YXIgd3JhcHBlciA9IHRoaXMuYW5pbWF0aW9uSXRlbS53cmFwcGVyO1xuICAgIHZhciBzdHlsZSA9IHJlc2l6ZXJFbGVtLnN0eWxlO1xuICAgIHN0eWxlLndpZHRoID0gYW5pbURhdGEudyArICdweCc7XG4gICAgc3R5bGUuaGVpZ2h0ID0gYW5pbURhdGEuaCArICdweCc7XG4gICAgdGhpcy5yZXNpemVyRWxlbSA9IHJlc2l6ZXJFbGVtO1xuICAgIHN0eWxlRGl2KHJlc2l6ZXJFbGVtKTtcbiAgICBzdHlsZS50cmFuc2Zvcm1TdHlsZSA9ICdmbGF0JztcbiAgICBzdHlsZS5tb3pUcmFuc2Zvcm1TdHlsZSA9ICdmbGF0JztcbiAgICBzdHlsZS53ZWJraXRUcmFuc2Zvcm1TdHlsZSA9ICdmbGF0JztcbiAgICBpZiAodGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKSB7XG4gICAgICByZXNpemVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgdGhpcy5yZW5kZXJDb25maWcuY2xhc3NOYW1lKTtcbiAgICB9XG4gICAgd3JhcHBlci5hcHBlbmRDaGlsZChyZXNpemVyRWxlbSk7XG4gICAgc3R5bGUub3ZlcmZsb3cgPSAnaGlkZGVuJztcbiAgICB2YXIgc3ZnID0gY3JlYXRlTlMoJ3N2ZycpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoJ3dpZHRoJywgJzEnKTtcbiAgICBzdmcuc2V0QXR0cmlidXRlKCdoZWlnaHQnLCAnMScpO1xuICAgIHN0eWxlRGl2KHN2Zyk7XG4gICAgdGhpcy5yZXNpemVyRWxlbS5hcHBlbmRDaGlsZChzdmcpO1xuICAgIHZhciBkZWZzID0gY3JlYXRlTlMoJ2RlZnMnKTtcbiAgICBzdmcuYXBwZW5kQ2hpbGQoZGVmcyk7XG4gICAgdGhpcy5kYXRhID0gYW5pbURhdGE7XG4gICAgLy8gTWFzayBhbmltYXRpb25cbiAgICB0aGlzLnNldHVwR2xvYmFsRGF0YShhbmltRGF0YSwgc3ZnKTtcbiAgICB0aGlzLmdsb2JhbERhdGEuZGVmcyA9IGRlZnM7XG4gICAgdGhpcy5sYXllcnMgPSBhbmltRGF0YS5sYXllcnM7XG4gICAgdGhpcy5sYXllckVsZW1lbnQgPSB0aGlzLnJlc2l6ZXJFbGVtO1xuICAgIHRoaXMuYnVpbGQzZENvbnRhaW5lcnMoKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRhaW5lclNpemUoKTtcbiAgfTtcbiAgSHlicmlkUmVuZGVyZXJCYXNlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlcikge1xuICAgICAgdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIuaW5uZXJUZXh0ID0gJyc7XG4gICAgfVxuICAgIHRoaXMuYW5pbWF0aW9uSXRlbS5jb250YWluZXIgPSBudWxsO1xuICAgIHRoaXMuZ2xvYmFsRGF0YS5kZWZzID0gbnVsbDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuID0gdGhpcy5sYXllcnMgPyB0aGlzLmxheWVycy5sZW5ndGggOiAwO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgaWYgKHRoaXMuZWxlbWVudHNbaV0gJiYgdGhpcy5lbGVtZW50c1tpXS5kZXN0cm95KSB7XG4gICAgICAgIHRoaXMuZWxlbWVudHNbaV0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmVsZW1lbnRzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IG51bGw7XG4gIH07XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUudXBkYXRlQ29udGFpbmVyU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbWVudFdpZHRoID0gdGhpcy5hbmltYXRpb25JdGVtLndyYXBwZXIub2Zmc2V0V2lkdGg7XG4gICAgdmFyIGVsZW1lbnRIZWlnaHQgPSB0aGlzLmFuaW1hdGlvbkl0ZW0ud3JhcHBlci5vZmZzZXRIZWlnaHQ7XG4gICAgdmFyIGVsZW1lbnRSZWwgPSBlbGVtZW50V2lkdGggLyBlbGVtZW50SGVpZ2h0O1xuICAgIHZhciBhbmltYXRpb25SZWwgPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgIHZhciBzeDtcbiAgICB2YXIgc3k7XG4gICAgdmFyIHR4O1xuICAgIHZhciB0eTtcbiAgICBpZiAoYW5pbWF0aW9uUmVsID4gZWxlbWVudFJlbCkge1xuICAgICAgc3ggPSBlbGVtZW50V2lkdGggLyB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIHN5ID0gZWxlbWVudFdpZHRoIC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLnc7XG4gICAgICB0eCA9IDA7XG4gICAgICB0eSA9IChlbGVtZW50SGVpZ2h0IC0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmggKiAoZWxlbWVudFdpZHRoIC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLncpKSAvIDI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN4ID0gZWxlbWVudEhlaWdodCAvIHRoaXMuZ2xvYmFsRGF0YS5jb21wU2l6ZS5oO1xuICAgICAgc3kgPSBlbGVtZW50SGVpZ2h0IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICB0eCA9IChlbGVtZW50V2lkdGggLSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudyAqIChlbGVtZW50SGVpZ2h0IC8gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmgpKSAvIDI7XG4gICAgICB0eSA9IDA7XG4gICAgfVxuICAgIHZhciBzdHlsZSA9IHRoaXMucmVzaXplckVsZW0uc3R5bGU7XG4gICAgc3R5bGUud2Via2l0VHJhbnNmb3JtID0gJ21hdHJpeDNkKCcgKyBzeCArICcsMCwwLDAsMCwnICsgc3kgKyAnLDAsMCwwLDAsMSwwLCcgKyB0eCArICcsJyArIHR5ICsgJywwLDEpJztcbiAgICBzdHlsZS50cmFuc2Zvcm0gPSBzdHlsZS53ZWJraXRUcmFuc2Zvcm07XG4gIH07XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBTVkdSZW5kZXJlci5wcm90b3R5cGUucmVuZGVyRnJhbWU7XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuaGlkZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gIH07XG4gIEh5YnJpZFJlbmRlcmVyQmFzZS5wcm90b3R5cGUuc2hvdyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLnJlc2l6ZXJFbGVtLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuICB9O1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLmluaXRJdGVtcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmJ1aWxkQWxsSXRlbXMoKTtcbiAgICBpZiAodGhpcy5jYW1lcmEpIHtcbiAgICAgIHRoaXMuY2FtZXJhLnNldHVwKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBjV2lkdGggPSB0aGlzLmdsb2JhbERhdGEuY29tcFNpemUudztcbiAgICAgIHZhciBjSGVpZ2h0ID0gdGhpcy5nbG9iYWxEYXRhLmNvbXBTaXplLmg7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB0aGlzLnRocmVlREVsZW1lbnRzLmxlbmd0aDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICB2YXIgc3R5bGUgPSB0aGlzLnRocmVlREVsZW1lbnRzW2ldLnBlcnNwZWN0aXZlRWxlbS5zdHlsZTtcbiAgICAgICAgc3R5bGUud2Via2l0UGVyc3BlY3RpdmUgPSBNYXRoLnNxcnQoTWF0aC5wb3coY1dpZHRoLCAyKSArIE1hdGgucG93KGNIZWlnaHQsIDIpKSArICdweCc7XG4gICAgICAgIHN0eWxlLnBlcnNwZWN0aXZlID0gc3R5bGUud2Via2l0UGVyc3BlY3RpdmU7XG4gICAgICB9XG4gICAgfVxuICB9O1xuICBIeWJyaWRSZW5kZXJlckJhc2UucHJvdG90eXBlLnNlYXJjaEV4dHJhQ29tcG9zaXRpb25zID0gZnVuY3Rpb24gKGFzc2V0cykge1xuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSBhc3NldHMubGVuZ3RoO1xuICAgIHZhciBmbG9hdGluZ0NvbnRhaW5lciA9IGNyZWF0ZVRhZygnZGl2Jyk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICBpZiAoYXNzZXRzW2ldLnh0KSB7XG4gICAgICAgIHZhciBjb21wID0gdGhpcy5jcmVhdGVDb21wKGFzc2V0c1tpXSwgZmxvYXRpbmdDb250YWluZXIsIHRoaXMuZ2xvYmFsRGF0YS5jb21wLCBudWxsKTtcbiAgICAgICAgY29tcC5pbml0RXhwcmVzc2lvbnMoKTtcbiAgICAgICAgdGhpcy5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UucmVnaXN0ZXJDb21wb3NpdGlvbihjb21wKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gSENvbXBFbGVtZW50KGRhdGEsIGdsb2JhbERhdGEsIGNvbXApIHtcbiAgICB0aGlzLmxheWVycyA9IGRhdGEubGF5ZXJzO1xuICAgIHRoaXMuc3VwcG9ydHMzZCA9ICFkYXRhLmhhc01hc2s7XG4gICAgdGhpcy5jb21wbGV0ZUxheWVycyA9IGZhbHNlO1xuICAgIHRoaXMucGVuZGluZ0VsZW1lbnRzID0gW107XG4gICAgdGhpcy5lbGVtZW50cyA9IHRoaXMubGF5ZXJzID8gY3JlYXRlU2l6ZWRBcnJheSh0aGlzLmxheWVycy5sZW5ndGgpIDogW107XG4gICAgdGhpcy5pbml0RWxlbWVudChkYXRhLCBnbG9iYWxEYXRhLCBjb21wKTtcbiAgICB0aGlzLnRtID0gZGF0YS50bSA/IFByb3BlcnR5RmFjdG9yeS5nZXRQcm9wKHRoaXMsIGRhdGEudG0sIDAsIGdsb2JhbERhdGEuZnJhbWVSYXRlLCB0aGlzKSA6IHtcbiAgICAgIF9wbGFjZWhvbGRlcjogdHJ1ZVxuICAgIH07XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtIeWJyaWRSZW5kZXJlckJhc2UsIElDb21wRWxlbWVudCwgSEJhc2VFbGVtZW50XSwgSENvbXBFbGVtZW50KTtcbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5fY3JlYXRlQmFzZUNvbnRhaW5lckVsZW1lbnRzID0gSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cztcbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb250YWluZXJFbGVtZW50cyA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMoKTtcbiAgICAvLyBkaXZFbGVtZW50LnN0eWxlLmNsaXAgPSAncmVjdCgwcHgsICcrdGhpcy5kYXRhLncrJ3B4LCAnK3RoaXMuZGF0YS5oKydweCwgMHB4KSc7XG4gICAgaWYgKHRoaXMuZGF0YS5oYXNNYXNrKSB7XG4gICAgICB0aGlzLnN2Z0VsZW1lbnQuc2V0QXR0cmlidXRlKCd3aWR0aCcsIHRoaXMuZGF0YS53KTtcbiAgICAgIHRoaXMuc3ZnRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIHRoaXMuZGF0YS5oKTtcbiAgICAgIHRoaXMudHJhbnNmb3JtZWRFbGVtZW50ID0gdGhpcy5iYXNlRWxlbWVudDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy50cmFuc2Zvcm1lZEVsZW1lbnQgPSB0aGlzLmxheWVyRWxlbWVudDtcbiAgICB9XG4gIH07XG4gIEhDb21wRWxlbWVudC5wcm90b3R5cGUuYWRkVG8zZENvbnRhaW5lciA9IGZ1bmN0aW9uIChlbGVtLCBwb3MpIHtcbiAgICB2YXIgaiA9IDA7XG4gICAgdmFyIG5leHRFbGVtZW50O1xuICAgIHdoaWxlIChqIDwgcG9zKSB7XG4gICAgICBpZiAodGhpcy5lbGVtZW50c1tqXSAmJiB0aGlzLmVsZW1lbnRzW2pdLmdldEJhc2VFbGVtZW50KSB7XG4gICAgICAgIG5leHRFbGVtZW50ID0gdGhpcy5lbGVtZW50c1tqXS5nZXRCYXNlRWxlbWVudCgpO1xuICAgICAgfVxuICAgICAgaiArPSAxO1xuICAgIH1cbiAgICBpZiAobmV4dEVsZW1lbnQpIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50Lmluc2VydEJlZm9yZShlbGVtLCBuZXh0RWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubGF5ZXJFbGVtZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgIH1cbiAgfTtcbiAgSENvbXBFbGVtZW50LnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIEh5YnJpZFJlbmRlcmVyKGFuaW1hdGlvbkl0ZW0sIGNvbmZpZykge1xuICAgIHRoaXMuYW5pbWF0aW9uSXRlbSA9IGFuaW1hdGlvbkl0ZW07XG4gICAgdGhpcy5sYXllcnMgPSBudWxsO1xuICAgIHRoaXMucmVuZGVyZWRGcmFtZSA9IC0xO1xuICAgIHRoaXMucmVuZGVyQ29uZmlnID0ge1xuICAgICAgY2xhc3NOYW1lOiBjb25maWcgJiYgY29uZmlnLmNsYXNzTmFtZSB8fCAnJyxcbiAgICAgIGltYWdlUHJlc2VydmVBc3BlY3RSYXRpbzogY29uZmlnICYmIGNvbmZpZy5pbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8gfHwgJ3hNaWRZTWlkIHNsaWNlJyxcbiAgICAgIGhpZGVPblRyYW5zcGFyZW50OiAhKGNvbmZpZyAmJiBjb25maWcuaGlkZU9uVHJhbnNwYXJlbnQgPT09IGZhbHNlKSxcbiAgICAgIGZpbHRlclNpemU6IHtcbiAgICAgICAgd2lkdGg6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS53aWR0aCB8fCAnNDAwJScsXG4gICAgICAgIGhlaWdodDogY29uZmlnICYmIGNvbmZpZy5maWx0ZXJTaXplICYmIGNvbmZpZy5maWx0ZXJTaXplLmhlaWdodCB8fCAnNDAwJScsXG4gICAgICAgIHg6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS54IHx8ICctMTAwJScsXG4gICAgICAgIHk6IGNvbmZpZyAmJiBjb25maWcuZmlsdGVyU2l6ZSAmJiBjb25maWcuZmlsdGVyU2l6ZS55IHx8ICctMTAwJSdcbiAgICAgIH0sXG4gICAgICBydW5FeHByZXNzaW9uczogIWNvbmZpZyB8fCBjb25maWcucnVuRXhwcmVzc2lvbnMgPT09IHVuZGVmaW5lZCB8fCBjb25maWcucnVuRXhwcmVzc2lvbnNcbiAgICB9O1xuICAgIHRoaXMuZ2xvYmFsRGF0YSA9IHtcbiAgICAgIF9tZGY6IGZhbHNlLFxuICAgICAgZnJhbWVOdW06IC0xLFxuICAgICAgcmVuZGVyQ29uZmlnOiB0aGlzLnJlbmRlckNvbmZpZ1xuICAgIH07XG4gICAgdGhpcy5wZW5kaW5nRWxlbWVudHMgPSBbXTtcbiAgICB0aGlzLmVsZW1lbnRzID0gW107XG4gICAgdGhpcy50aHJlZURFbGVtZW50cyA9IFtdO1xuICAgIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5jYW1lcmEgPSBudWxsO1xuICAgIHRoaXMuc3VwcG9ydHMzZCA9IHRydWU7XG4gICAgdGhpcy5yZW5kZXJlclR5cGUgPSAnaHRtbCc7XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtIeWJyaWRSZW5kZXJlckJhc2VdLCBIeWJyaWRSZW5kZXJlcik7XG4gIEh5YnJpZFJlbmRlcmVyLnByb3RvdHlwZS5jcmVhdGVDb21wID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMuc3VwcG9ydHMzZCkge1xuICAgICAgcmV0dXJuIG5ldyBTVkdDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IEhDb21wRWxlbWVudChkYXRhLCB0aGlzLmdsb2JhbERhdGEsIHRoaXMpO1xuICB9O1xuXG4gIHZhciBDb21wRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGNvbXApIHtcbiAgICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGNvbXAubGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoY29tcC5sYXllcnNbaV0ubm0gPT09IG5hbWUgfHwgY29tcC5sYXllcnNbaV0uaW5kID09PSBuYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gY29tcC5lbGVtZW50c1tpXS5sYXllckludGVyZmFjZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAvLyByZXR1cm4ge2FjdGl2ZTpmYWxzZX07XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNMYXllckZ1bmN0aW9uLCAnX25hbWUnLCB7XG4gICAgICAgIHZhbHVlOiBjb21wLmRhdGEubm1cbiAgICAgIH0pO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmxheWVyID0gX3RoaXNMYXllckZ1bmN0aW9uO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnBpeGVsQXNwZWN0ID0gMTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5oZWlnaHQgPSBjb21wLmRhdGEuaCB8fCBjb21wLmdsb2JhbERhdGEuY29tcFNpemUuaDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi53aWR0aCA9IGNvbXAuZGF0YS53IHx8IGNvbXAuZ2xvYmFsRGF0YS5jb21wU2l6ZS53O1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnBpeGVsQXNwZWN0ID0gMTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcmFtZUR1cmF0aW9uID0gMSAvIGNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZGlzcGxheVN0YXJ0VGltZSA9IDA7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24ubnVtTGF5ZXJzID0gY29tcC5sYXllcnMubGVuZ3RoO1xuICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQyKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiQyID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2YkMihvKTsgfVxuICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuICAvKlxuICAgQ29weXJpZ2h0IDIwMTQgRGF2aWQgQmF1LlxuXG4gICBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmdcbiAgIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuICAgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4gICB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4gICBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG9cbiAgIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0b1xuICAgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG4gICBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZVxuICAgaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAgIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXG4gICBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcbiAgIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC5cbiAgIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZXG4gICBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULFxuICAgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEVcbiAgIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHNlZWRSYW5kb20ocG9vbCwgbWF0aCkge1xuICAgIC8vXG4gICAgLy8gVGhlIGZvbGxvd2luZyBjb25zdGFudHMgYXJlIHJlbGF0ZWQgdG8gSUVFRSA3NTQgbGltaXRzLlxuICAgIC8vXG4gICAgdmFyIGdsb2JhbCA9IHRoaXMsXG4gICAgICB3aWR0aCA9IDI1NixcbiAgICAgIC8vIGVhY2ggUkM0IG91dHB1dCBpcyAwIDw9IHggPCAyNTZcbiAgICAgIGNodW5rcyA9IDYsXG4gICAgICAvLyBhdCBsZWFzdCBzaXggUkM0IG91dHB1dHMgZm9yIGVhY2ggZG91YmxlXG4gICAgICBkaWdpdHMgPSA1MixcbiAgICAgIC8vIHRoZXJlIGFyZSA1MiBzaWduaWZpY2FudCBkaWdpdHMgaW4gYSBkb3VibGVcbiAgICAgIHJuZ25hbWUgPSAncmFuZG9tJyxcbiAgICAgIC8vIHJuZ25hbWU6IG5hbWUgZm9yIE1hdGgucmFuZG9tIGFuZCBNYXRoLnNlZWRyYW5kb21cbiAgICAgIHN0YXJ0ZGVub20gPSBtYXRoLnBvdyh3aWR0aCwgY2h1bmtzKSxcbiAgICAgIHNpZ25pZmljYW5jZSA9IG1hdGgucG93KDIsIGRpZ2l0cyksXG4gICAgICBvdmVyZmxvdyA9IHNpZ25pZmljYW5jZSAqIDIsXG4gICAgICBtYXNrID0gd2lkdGggLSAxLFxuICAgICAgbm9kZWNyeXB0bzsgLy8gbm9kZS5qcyBjcnlwdG8gbW9kdWxlLCBpbml0aWFsaXplZCBhdCB0aGUgYm90dG9tLlxuXG4gICAgLy9cbiAgICAvLyBzZWVkcmFuZG9tKClcbiAgICAvLyBUaGlzIGlzIHRoZSBzZWVkcmFuZG9tIGZ1bmN0aW9uIGRlc2NyaWJlZCBhYm92ZS5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIHNlZWRyYW5kb20oc2VlZCwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgIHZhciBrZXkgPSBbXTtcbiAgICAgIG9wdGlvbnMgPSBvcHRpb25zID09PSB0cnVlID8ge1xuICAgICAgICBlbnRyb3B5OiB0cnVlXG4gICAgICB9IDogb3B0aW9ucyB8fCB7fTtcblxuICAgICAgLy8gRmxhdHRlbiB0aGUgc2VlZCBzdHJpbmcgb3IgYnVpbGQgb25lIGZyb20gbG9jYWwgZW50cm9weSBpZiBuZWVkZWQuXG4gICAgICB2YXIgc2hvcnRzZWVkID0gbWl4a2V5KGZsYXR0ZW4ob3B0aW9ucy5lbnRyb3B5ID8gW3NlZWQsIHRvc3RyaW5nKHBvb2wpXSA6IHNlZWQgPT09IG51bGwgPyBhdXRvc2VlZCgpIDogc2VlZCwgMyksIGtleSk7XG5cbiAgICAgIC8vIFVzZSB0aGUgc2VlZCB0byBpbml0aWFsaXplIGFuIEFSQzQgZ2VuZXJhdG9yLlxuICAgICAgdmFyIGFyYzQgPSBuZXcgQVJDNChrZXkpO1xuXG4gICAgICAvLyBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSByYW5kb20gZG91YmxlIGluIFswLCAxKSB0aGF0IGNvbnRhaW5zXG4gICAgICAvLyByYW5kb21uZXNzIGluIGV2ZXJ5IGJpdCBvZiB0aGUgbWFudGlzc2Egb2YgdGhlIElFRUUgNzU0IHZhbHVlLlxuICAgICAgdmFyIHBybmcgPSBmdW5jdGlvbiBwcm5nKCkge1xuICAgICAgICB2YXIgbiA9IGFyYzQuZyhjaHVua3MpLFxuICAgICAgICAgIC8vIFN0YXJ0IHdpdGggYSBudW1lcmF0b3IgbiA8IDIgXiA0OFxuICAgICAgICAgIGQgPSBzdGFydGRlbm9tLFxuICAgICAgICAgIC8vICAgYW5kIGRlbm9taW5hdG9yIGQgPSAyIF4gNDguXG4gICAgICAgICAgeCA9IDA7IC8vICAgYW5kIG5vICdleHRyYSBsYXN0IGJ5dGUnLlxuICAgICAgICB3aGlsZSAobiA8IHNpZ25pZmljYW5jZSkge1xuICAgICAgICAgIC8vIEZpbGwgdXAgYWxsIHNpZ25pZmljYW50IGRpZ2l0cyBieVxuICAgICAgICAgIG4gPSAobiArIHgpICogd2lkdGg7IC8vICAgc2hpZnRpbmcgbnVtZXJhdG9yIGFuZFxuICAgICAgICAgIGQgKj0gd2lkdGg7IC8vICAgZGVub21pbmF0b3IgYW5kIGdlbmVyYXRpbmcgYVxuICAgICAgICAgIHggPSBhcmM0LmcoMSk7IC8vICAgbmV3IGxlYXN0LXNpZ25pZmljYW50LWJ5dGUuXG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKG4gPj0gb3ZlcmZsb3cpIHtcbiAgICAgICAgICAvLyBUbyBhdm9pZCByb3VuZGluZyB1cCwgYmVmb3JlIGFkZGluZ1xuICAgICAgICAgIG4gLz0gMjsgLy8gICBsYXN0IGJ5dGUsIHNoaWZ0IGV2ZXJ5dGhpbmdcbiAgICAgICAgICBkIC89IDI7IC8vICAgcmlnaHQgdXNpbmcgaW50ZWdlciBtYXRoIHVudGlsXG4gICAgICAgICAgeCA+Pj49IDE7IC8vICAgd2UgaGF2ZSBleGFjdGx5IHRoZSBkZXNpcmVkIGJpdHMuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChuICsgeCkgLyBkOyAvLyBGb3JtIHRoZSBudW1iZXIgd2l0aGluIFswLCAxKS5cbiAgICAgIH07XG4gICAgICBwcm5nLmludDMyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJjNC5nKDQpIHwgMDtcbiAgICAgIH07XG4gICAgICBwcm5nLnF1aWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJjNC5nKDQpIC8gMHgxMDAwMDAwMDA7XG4gICAgICB9O1xuICAgICAgcHJuZ1tcImRvdWJsZVwiXSA9IHBybmc7XG5cbiAgICAgIC8vIE1peCB0aGUgcmFuZG9tbmVzcyBpbnRvIGFjY3VtdWxhdGVkIGVudHJvcHkuXG4gICAgICBtaXhrZXkodG9zdHJpbmcoYXJjNC5TKSwgcG9vbCk7XG5cbiAgICAgIC8vIENhbGxpbmcgY29udmVudGlvbjogd2hhdCB0byByZXR1cm4gYXMgYSBmdW5jdGlvbiBvZiBwcm5nLCBzZWVkLCBpc19tYXRoLlxuICAgICAgcmV0dXJuIChvcHRpb25zLnBhc3MgfHwgY2FsbGJhY2sgfHwgZnVuY3Rpb24gKHBybmcsIHNlZWQsIGlzX21hdGhfY2FsbCwgc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlKSB7XG4gICAgICAgICAgLy8gTG9hZCB0aGUgYXJjNCBzdGF0ZSBmcm9tIHRoZSBnaXZlbiBzdGF0ZSBpZiBpdCBoYXMgYW4gUyBhcnJheS5cbiAgICAgICAgICBpZiAoc3RhdGUuUykge1xuICAgICAgICAgICAgY29weShzdGF0ZSwgYXJjNCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE9ubHkgcHJvdmlkZSB0aGUgLnN0YXRlIG1ldGhvZCBpZiByZXF1ZXN0ZWQgdmlhIG9wdGlvbnMuc3RhdGUuXG4gICAgICAgICAgcHJuZy5zdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjb3B5KGFyYzQsIHt9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgY2FsbGVkIGFzIGEgbWV0aG9kIG9mIE1hdGggKE1hdGguc2VlZHJhbmRvbSgpKSwgbXV0YXRlXG4gICAgICAgIC8vIE1hdGgucmFuZG9tIGJlY2F1c2UgdGhhdCBpcyBob3cgc2VlZHJhbmRvbS5qcyBoYXMgd29ya2VkIHNpbmNlIHYxLjAuXG4gICAgICAgIGlmIChpc19tYXRoX2NhbGwpIHtcbiAgICAgICAgICBtYXRoW3JuZ25hbWVdID0gcHJuZztcbiAgICAgICAgICByZXR1cm4gc2VlZDtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE90aGVyd2lzZSwgaXQgaXMgYSBuZXdlciBjYWxsaW5nIGNvbnZlbnRpb24sIHNvIHJldHVybiB0aGVcbiAgICAgICAgLy8gcHJuZyBkaXJlY3RseS5cbiAgICAgICAgZWxzZSByZXR1cm4gcHJuZztcbiAgICAgIH0pKHBybmcsIHNob3J0c2VlZCwgJ2dsb2JhbCcgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZ2xvYmFsIDogdGhpcyA9PSBtYXRoLCBvcHRpb25zLnN0YXRlKTtcbiAgICB9XG4gICAgbWF0aFsnc2VlZCcgKyBybmduYW1lXSA9IHNlZWRyYW5kb207XG5cbiAgICAvL1xuICAgIC8vIEFSQzRcbiAgICAvL1xuICAgIC8vIEFuIEFSQzQgaW1wbGVtZW50YXRpb24uICBUaGUgY29uc3RydWN0b3IgdGFrZXMgYSBrZXkgaW4gdGhlIGZvcm0gb2ZcbiAgICAvLyBhbiBhcnJheSBvZiBhdCBtb3N0ICh3aWR0aCkgaW50ZWdlcnMgdGhhdCBzaG91bGQgYmUgMCA8PSB4IDwgKHdpZHRoKS5cbiAgICAvL1xuICAgIC8vIFRoZSBnKGNvdW50KSBtZXRob2QgcmV0dXJucyBhIHBzZXVkb3JhbmRvbSBpbnRlZ2VyIHRoYXQgY29uY2F0ZW5hdGVzXG4gICAgLy8gdGhlIG5leHQgKGNvdW50KSBvdXRwdXRzIGZyb20gQVJDNC4gIEl0cyByZXR1cm4gdmFsdWUgaXMgYSBudW1iZXIgeFxuICAgIC8vIHRoYXQgaXMgaW4gdGhlIHJhbmdlIDAgPD0geCA8ICh3aWR0aCBeIGNvdW50KS5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIEFSQzQoa2V5KSB7XG4gICAgICB2YXIgdCxcbiAgICAgICAga2V5bGVuID0ga2V5Lmxlbmd0aCxcbiAgICAgICAgbWUgPSB0aGlzLFxuICAgICAgICBpID0gMCxcbiAgICAgICAgaiA9IG1lLmkgPSBtZS5qID0gMCxcbiAgICAgICAgcyA9IG1lLlMgPSBbXTtcblxuICAgICAgLy8gVGhlIGVtcHR5IGtleSBbXSBpcyB0cmVhdGVkIGFzIFswXS5cbiAgICAgIGlmICgha2V5bGVuKSB7XG4gICAgICAgIGtleSA9IFtrZXlsZW4rK107XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBTIHVzaW5nIHRoZSBzdGFuZGFyZCBrZXkgc2NoZWR1bGluZyBhbGdvcml0aG0uXG4gICAgICB3aGlsZSAoaSA8IHdpZHRoKSB7XG4gICAgICAgIHNbaV0gPSBpKys7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgd2lkdGg7IGkrKykge1xuICAgICAgICBzW2ldID0gc1tqID0gbWFzayAmIGogKyBrZXlbaSAlIGtleWxlbl0gKyAodCA9IHNbaV0pXTtcbiAgICAgICAgc1tqXSA9IHQ7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSBcImdcIiBtZXRob2QgcmV0dXJucyB0aGUgbmV4dCAoY291bnQpIG91dHB1dHMgYXMgb25lIG51bWJlci5cbiAgICAgIG1lLmcgPSBmdW5jdGlvbiAoY291bnQpIHtcbiAgICAgICAgLy8gVXNpbmcgaW5zdGFuY2UgbWVtYmVycyBpbnN0ZWFkIG9mIGNsb3N1cmUgc3RhdGUgbmVhcmx5IGRvdWJsZXMgc3BlZWQuXG4gICAgICAgIHZhciB0LFxuICAgICAgICAgIHIgPSAwLFxuICAgICAgICAgIGkgPSBtZS5pLFxuICAgICAgICAgIGogPSBtZS5qLFxuICAgICAgICAgIHMgPSBtZS5TO1xuICAgICAgICB3aGlsZSAoY291bnQtLSkge1xuICAgICAgICAgIHQgPSBzW2kgPSBtYXNrICYgaSArIDFdO1xuICAgICAgICAgIHIgPSByICogd2lkdGggKyBzW21hc2sgJiAoc1tpXSA9IHNbaiA9IG1hc2sgJiBqICsgdF0pICsgKHNbal0gPSB0KV07XG4gICAgICAgIH1cbiAgICAgICAgbWUuaSA9IGk7XG4gICAgICAgIG1lLmogPSBqO1xuICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgLy8gRm9yIHJvYnVzdCB1bnByZWRpY3RhYmlsaXR5LCB0aGUgZnVuY3Rpb24gY2FsbCBiZWxvdyBhdXRvbWF0aWNhbGx5XG4gICAgICAgIC8vIGRpc2NhcmRzIGFuIGluaXRpYWwgYmF0Y2ggb2YgdmFsdWVzLiAgVGhpcyBpcyBjYWxsZWQgUkM0LWRyb3BbMjU2XS5cbiAgICAgICAgLy8gU2VlIGh0dHA6Ly9nb29nbGUuY29tL3NlYXJjaD9xPXJzYStmbHVocmVyK3Jlc3BvbnNlJmJ0bklcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBjb3B5KClcbiAgICAvLyBDb3BpZXMgaW50ZXJuYWwgc3RhdGUgb2YgQVJDNCB0byBvciBmcm9tIGEgcGxhaW4gb2JqZWN0LlxuICAgIC8vXG4gICAgZnVuY3Rpb24gY29weShmLCB0KSB7XG4gICAgICB0LmkgPSBmLmk7XG4gICAgICB0LmogPSBmLmo7XG4gICAgICB0LlMgPSBmLlMuc2xpY2UoKTtcbiAgICAgIHJldHVybiB0O1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gZmxhdHRlbigpXG4gICAgLy8gQ29udmVydHMgYW4gb2JqZWN0IHRyZWUgdG8gbmVzdGVkIGFycmF5cyBvZiBzdHJpbmdzLlxuICAgIC8vXG4gICAgZnVuY3Rpb24gZmxhdHRlbihvYmosIGRlcHRoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW10sXG4gICAgICAgIHR5cCA9IF90eXBlb2YkMihvYmopLFxuICAgICAgICBwcm9wO1xuICAgICAgaWYgKGRlcHRoICYmIHR5cCA9PSAnb2JqZWN0Jykge1xuICAgICAgICBmb3IgKHByb3AgaW4gb2JqKSB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGZsYXR0ZW4ob2JqW3Byb3BdLCBkZXB0aCAtIDEpKTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0Lmxlbmd0aCA/IHJlc3VsdCA6IHR5cCA9PSAnc3RyaW5nJyA/IG9iaiA6IG9iaiArICdcXDAnO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gbWl4a2V5KClcbiAgICAvLyBNaXhlcyBhIHN0cmluZyBzZWVkIGludG8gYSBrZXkgdGhhdCBpcyBhbiBhcnJheSBvZiBpbnRlZ2VycywgYW5kXG4gICAgLy8gcmV0dXJucyBhIHNob3J0ZW5lZCBzdHJpbmcgc2VlZCB0aGF0IGlzIGVxdWl2YWxlbnQgdG8gdGhlIHJlc3VsdCBrZXkuXG4gICAgLy9cbiAgICBmdW5jdGlvbiBtaXhrZXkoc2VlZCwga2V5KSB7XG4gICAgICB2YXIgc3RyaW5nc2VlZCA9IHNlZWQgKyAnJyxcbiAgICAgICAgc21lYXIsXG4gICAgICAgIGogPSAwO1xuICAgICAgd2hpbGUgKGogPCBzdHJpbmdzZWVkLmxlbmd0aCkge1xuICAgICAgICBrZXlbbWFzayAmIGpdID0gbWFzayAmIChzbWVhciBePSBrZXlbbWFzayAmIGpdICogMTkpICsgc3RyaW5nc2VlZC5jaGFyQ29kZUF0KGorKyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9zdHJpbmcoa2V5KTtcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIGF1dG9zZWVkKClcbiAgICAvLyBSZXR1cm5zIGFuIG9iamVjdCBmb3IgYXV0b3NlZWRpbmcsIHVzaW5nIHdpbmRvdy5jcnlwdG8gYW5kIE5vZGUgY3J5cHRvXG4gICAgLy8gbW9kdWxlIGlmIGF2YWlsYWJsZS5cbiAgICAvL1xuICAgIGZ1bmN0aW9uIGF1dG9zZWVkKCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKG5vZGVjcnlwdG8pIHtcbiAgICAgICAgICByZXR1cm4gdG9zdHJpbmcobm9kZWNyeXB0by5yYW5kb21CeXRlcyh3aWR0aCkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBvdXQgPSBuZXcgVWludDhBcnJheSh3aWR0aCk7XG4gICAgICAgIChnbG9iYWwuY3J5cHRvIHx8IGdsb2JhbC5tc0NyeXB0bykuZ2V0UmFuZG9tVmFsdWVzKG91dCk7XG4gICAgICAgIHJldHVybiB0b3N0cmluZyhvdXQpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICB2YXIgYnJvd3NlciA9IGdsb2JhbC5uYXZpZ2F0b3IsXG4gICAgICAgICAgcGx1Z2lucyA9IGJyb3dzZXIgJiYgYnJvd3Nlci5wbHVnaW5zO1xuICAgICAgICByZXR1cm4gWytuZXcgRGF0ZSgpLCBnbG9iYWwsIHBsdWdpbnMsIGdsb2JhbC5zY3JlZW4sIHRvc3RyaW5nKHBvb2wpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIHRvc3RyaW5nKClcbiAgICAvLyBDb252ZXJ0cyBhbiBhcnJheSBvZiBjaGFyY29kZXMgdG8gYSBzdHJpbmdcbiAgICAvL1xuICAgIGZ1bmN0aW9uIHRvc3RyaW5nKGEpIHtcbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KDAsIGEpO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gV2hlbiBzZWVkcmFuZG9tLmpzIGlzIGxvYWRlZCwgd2UgaW1tZWRpYXRlbHkgbWl4IGEgZmV3IGJpdHNcbiAgICAvLyBmcm9tIHRoZSBidWlsdC1pbiBSTkcgaW50byB0aGUgZW50cm9weSBwb29sLiAgQmVjYXVzZSB3ZSBkb1xuICAgIC8vIG5vdCB3YW50IHRvIGludGVyZmVyZSB3aXRoIGRldGVybWluaXN0aWMgUFJORyBzdGF0ZSBsYXRlcixcbiAgICAvLyBzZWVkcmFuZG9tIHdpbGwgbm90IGNhbGwgbWF0aC5yYW5kb20gb24gaXRzIG93biBhZ2FpbiBhZnRlclxuICAgIC8vIGluaXRpYWxpemF0aW9uLlxuICAgIC8vXG4gICAgbWl4a2V5KG1hdGgucmFuZG9tKCksIHBvb2wpO1xuXG4gICAgLy9cbiAgICAvLyBOb2RlanMgYW5kIEFNRCBzdXBwb3J0OiBleHBvcnQgdGhlIGltcGxlbWVudGF0aW9uIGFzIGEgbW9kdWxlIHVzaW5nXG4gICAgLy8gZWl0aGVyIGNvbnZlbnRpb24uXG4gICAgLy9cblxuICAgIC8vIEVuZCBhbm9ueW1vdXMgc2NvcGUsIGFuZCBwYXNzIGluaXRpYWwgdmFsdWVzLlxuICB9XG4gIDtcbiAgZnVuY3Rpb24gaW5pdGlhbGl6ZSQyKEJNTWF0aCkge1xuICAgIHNlZWRSYW5kb20oW10sIEJNTWF0aCk7XG4gIH1cblxuICB2YXIgcHJvcFR5cGVzID0ge1xuICAgIFNIQVBFOiAnc2hhcGUnXG4gIH07XG5cbiAgZnVuY3Rpb24gX3R5cGVvZiQxKG8pIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyByZXR1cm4gX3R5cGVvZiQxID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2YkMShvKTsgfVxuICB2YXIgRXhwcmVzc2lvbk1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9iID0ge307XG4gICAgdmFyIE1hdGggPSBCTU1hdGg7XG4gICAgdmFyIHdpbmRvdyA9IG51bGw7XG4gICAgdmFyIGRvY3VtZW50ID0gbnVsbDtcbiAgICB2YXIgWE1MSHR0cFJlcXVlc3QgPSBudWxsO1xuICAgIHZhciBmZXRjaCA9IG51bGw7XG4gICAgdmFyIGZyYW1lcyA9IG51bGw7XG4gICAgdmFyIF9sb3R0aWVHbG9iYWwgPSB7fTtcbiAgICBpbml0aWFsaXplJDIoQk1NYXRoKTtcbiAgICBmdW5jdGlvbiByZXNldEZyYW1lKCkge1xuICAgICAgX2xvdHRpZUdsb2JhbCA9IHt9O1xuICAgIH1cbiAgICBmdW5jdGlvbiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYXJyKSB7XG4gICAgICByZXR1cm4gYXJyLmNvbnN0cnVjdG9yID09PSBBcnJheSB8fCBhcnIuY29uc3RydWN0b3IgPT09IEZsb2F0MzJBcnJheTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaXNOdW1lcmFibGUodE9mViwgdikge1xuICAgICAgcmV0dXJuIHRPZlYgPT09ICdudW1iZXInIHx8IHYgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdE9mViA9PT0gJ2Jvb2xlYW4nIHx8IHRPZlYgPT09ICdzdHJpbmcnO1xuICAgIH1cbiAgICBmdW5jdGlvbiAkYm1fbmVnKGEpIHtcbiAgICAgIHZhciB0T2ZBID0gX3R5cGVvZiQxKGEpO1xuICAgICAgaWYgKHRPZkEgPT09ICdudW1iZXInIHx8IGEgaW5zdGFuY2VvZiBOdW1iZXIgfHwgdE9mQSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHJldHVybiAtYTtcbiAgICAgIH1cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbkE7IGkgKz0gMSkge1xuICAgICAgICAgIHJldEFycltpXSA9IC1hW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG4gICAgICBpZiAoYS5wcm9wVHlwZSkge1xuICAgICAgICByZXR1cm4gYS52O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC1hO1xuICAgIH1cbiAgICB2YXIgZWFzZUluQmV6ID0gQmV6aWVyRmFjdG9yeS5nZXRCZXppZXJFYXNpbmcoMC4zMzMsIDAsIDAuODMzLCAwLjgzMywgJ2Vhc2VJbicpLmdldDtcbiAgICB2YXIgZWFzZU91dEJleiA9IEJlemllckZhY3RvcnkuZ2V0QmV6aWVyRWFzaW5nKDAuMTY3LCAwLjE2NywgMC42NjcsIDEsICdlYXNlT3V0JykuZ2V0O1xuICAgIHZhciBlYXNlSW5PdXRCZXogPSBCZXppZXJGYWN0b3J5LmdldEJlemllckVhc2luZygwLjMzLCAwLCAwLjY2NywgMSwgJ2Vhc2VJbk91dCcpLmdldDtcbiAgICBmdW5jdGlvbiBzdW0oYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG4gICAgICB2YXIgdE9mQiA9IF90eXBlb2YkMShiKTtcbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSB8fCB0T2ZBID09PSAnc3RyaW5nJyB8fCB0T2ZCID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gYSArIGI7XG4gICAgICB9XG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGEgPSBhLnNsaWNlKDApO1xuICAgICAgICBhWzBdICs9IGI7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfVxuICAgICAgaWYgKGlzTnVtZXJhYmxlKHRPZkEsIGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICBiID0gYi5zbGljZSgwKTtcbiAgICAgICAgYlswXSA9IGEgKyBiWzBdO1xuICAgICAgICByZXR1cm4gYjtcbiAgICAgIH1cbiAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkoYSkgJiYgJGJtX2lzSW5zdGFuY2VPZkFycmF5KGIpKSB7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbkEgPSBhLmxlbmd0aDtcbiAgICAgICAgdmFyIGxlbkIgPSBiLmxlbmd0aDtcbiAgICAgICAgdmFyIHJldEFyciA9IFtdO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbkEgfHwgaSA8IGxlbkIpIHtcbiAgICAgICAgICBpZiAoKHR5cGVvZiBhW2ldID09PSAnbnVtYmVyJyB8fCBhW2ldIGluc3RhbmNlb2YgTnVtYmVyKSAmJiAodHlwZW9mIGJbaV0gPT09ICdudW1iZXInIHx8IGJbaV0gaW5zdGFuY2VvZiBOdW1iZXIpKSB7XG4gICAgICAgICAgICByZXRBcnJbaV0gPSBhW2ldICsgYltpXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYltpXSA9PT0gdW5kZWZpbmVkID8gYVtpXSA6IGFbaV0gfHwgYltpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXRBcnI7XG4gICAgICB9XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG4gICAgdmFyIGFkZCA9IHN1bTtcbiAgICBmdW5jdGlvbiBzdWIoYSwgYikge1xuICAgICAgdmFyIHRPZkEgPSBfdHlwZW9mJDEoYSk7XG4gICAgICB2YXIgdE9mQiA9IF90eXBlb2YkMShiKTtcbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICBpZiAodE9mQSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBhID0gcGFyc2VJbnQoYSwgMTApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0T2ZCID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGIgPSBwYXJzZUludChiLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGEgLSBiO1xuICAgICAgfVxuICAgICAgaWYgKCRibV9pc0luc3RhbmNlT2ZBcnJheShhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICBhID0gYS5zbGljZSgwKTtcbiAgICAgICAgYVswXSAtPSBiO1xuICAgICAgICByZXR1cm4gYTtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcbiAgICAgICAgYiA9IGIuc2xpY2UoMCk7XG4gICAgICAgIGJbMF0gPSBhIC0gYlswXTtcbiAgICAgICAgcmV0dXJuIGI7XG4gICAgICB9XG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmICRibV9pc0luc3RhbmNlT2ZBcnJheShiKSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW5BID0gYS5sZW5ndGg7XG4gICAgICAgIHZhciBsZW5CID0gYi5sZW5ndGg7XG4gICAgICAgIHZhciByZXRBcnIgPSBbXTtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW5BIHx8IGkgPCBsZW5CKSB7XG4gICAgICAgICAgaWYgKCh0eXBlb2YgYVtpXSA9PT0gJ251bWJlcicgfHwgYVtpXSBpbnN0YW5jZW9mIE51bWJlcikgJiYgKHR5cGVvZiBiW2ldID09PSAnbnVtYmVyJyB8fCBiW2ldIGluc3RhbmNlb2YgTnVtYmVyKSkge1xuICAgICAgICAgICAgcmV0QXJyW2ldID0gYVtpXSAtIGJbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldEFycltpXSA9IGJbaV0gPT09IHVuZGVmaW5lZCA/IGFbaV0gOiBhW2ldIHx8IGJbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0QXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG11bChhLCBiKSB7XG4gICAgICB2YXIgdE9mQSA9IF90eXBlb2YkMShhKTtcbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuICAgICAgdmFyIGFycjtcbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICByZXR1cm4gYSAqIGI7XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGxlbiA9IGEubGVuZ3RoO1xuICAgICAgICBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYVtpXSAqIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcbiAgICAgICAgbGVuID0gYi5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJbaV0gPSBhICogYltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpdihhLCBiKSB7XG4gICAgICB2YXIgdE9mQSA9IF90eXBlb2YkMShhKTtcbiAgICAgIHZhciB0T2ZCID0gX3R5cGVvZiQxKGIpO1xuICAgICAgdmFyIGFycjtcbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiBpc051bWVyYWJsZSh0T2ZCLCBiKSkge1xuICAgICAgICByZXR1cm4gYSAvIGI7XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICBpZiAoJGJtX2lzSW5zdGFuY2VPZkFycmF5KGEpICYmIGlzTnVtZXJhYmxlKHRPZkIsIGIpKSB7XG4gICAgICAgIGxlbiA9IGEubGVuZ3RoO1xuICAgICAgICBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyW2ldID0gYVtpXSAvIGI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH1cbiAgICAgIGlmIChpc051bWVyYWJsZSh0T2ZBLCBhKSAmJiAkYm1faXNJbnN0YW5jZU9mQXJyYXkoYikpIHtcbiAgICAgICAgbGVuID0gYi5sZW5ndGg7XG4gICAgICAgIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJbaV0gPSBhIC8gYltpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vZChhLCBiKSB7XG4gICAgICBpZiAodHlwZW9mIGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGEgPSBwYXJzZUludChhLCAxMCk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGIgPSBwYXJzZUludChiLCAxMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYSAlIGI7XG4gICAgfVxuICAgIHZhciAkYm1fc3VtID0gc3VtO1xuICAgIHZhciAkYm1fc3ViID0gc3ViO1xuICAgIHZhciAkYm1fbXVsID0gbXVsO1xuICAgIHZhciAkYm1fZGl2ID0gZGl2O1xuICAgIHZhciAkYm1fbW9kID0gbW9kO1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bSwgbWluLCBtYXgpIHtcbiAgICAgIGlmIChtaW4gPiBtYXgpIHtcbiAgICAgICAgdmFyIG1tID0gbWF4O1xuICAgICAgICBtYXggPSBtaW47XG4gICAgICAgIG1pbiA9IG1tO1xuICAgICAgfVxuICAgICAgcmV0dXJuIE1hdGgubWluKE1hdGgubWF4KG51bSwgbWluKSwgbWF4KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmFkaWFuc1RvRGVncmVlcyh2YWwpIHtcbiAgICAgIHJldHVybiB2YWwgLyBkZWdUb1JhZHM7XG4gICAgfVxuICAgIHZhciByYWRpYW5zX3RvX2RlZ3JlZXMgPSByYWRpYW5zVG9EZWdyZWVzO1xuICAgIGZ1bmN0aW9uIGRlZ3JlZXNUb1JhZGlhbnModmFsKSB7XG4gICAgICByZXR1cm4gdmFsICogZGVnVG9SYWRzO1xuICAgIH1cbiAgICB2YXIgZGVncmVlc190b19yYWRpYW5zID0gcmFkaWFuc1RvRGVncmVlcztcbiAgICB2YXIgaGVscGVyTGVuZ3RoQXJyYXkgPSBbMCwgMCwgMCwgMCwgMCwgMF07XG4gICAgZnVuY3Rpb24gbGVuZ3RoKGFycjEsIGFycjIpIHtcbiAgICAgIGlmICh0eXBlb2YgYXJyMSA9PT0gJ251bWJlcicgfHwgYXJyMSBpbnN0YW5jZW9mIE51bWJlcikge1xuICAgICAgICBhcnIyID0gYXJyMiB8fCAwO1xuICAgICAgICByZXR1cm4gTWF0aC5hYnMoYXJyMSAtIGFycjIpO1xuICAgICAgfVxuICAgICAgaWYgKCFhcnIyKSB7XG4gICAgICAgIGFycjIgPSBoZWxwZXJMZW5ndGhBcnJheTtcbiAgICAgIH1cbiAgICAgIHZhciBpO1xuICAgICAgdmFyIGxlbiA9IE1hdGgubWluKGFycjEubGVuZ3RoLCBhcnIyLmxlbmd0aCk7XG4gICAgICB2YXIgYWRkZWRMZW5ndGggPSAwO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZGVkTGVuZ3RoICs9IE1hdGgucG93KGFycjJbaV0gLSBhcnIxW2ldLCAyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNxcnQoYWRkZWRMZW5ndGgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBub3JtYWxpemUodmVjKSB7XG4gICAgICByZXR1cm4gZGl2KHZlYywgbGVuZ3RoKHZlYykpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZ2JUb0hzbCh2YWwpIHtcbiAgICAgIHZhciByID0gdmFsWzBdO1xuICAgICAgdmFyIGcgPSB2YWxbMV07XG4gICAgICB2YXIgYiA9IHZhbFsyXTtcbiAgICAgIHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKTtcbiAgICAgIHZhciBtaW4gPSBNYXRoLm1pbihyLCBnLCBiKTtcbiAgICAgIHZhciBoO1xuICAgICAgdmFyIHM7XG4gICAgICB2YXIgbCA9IChtYXggKyBtaW4pIC8gMjtcbiAgICAgIGlmIChtYXggPT09IG1pbikge1xuICAgICAgICBoID0gMDsgLy8gYWNocm9tYXRpY1xuICAgICAgICBzID0gMDsgLy8gYWNocm9tYXRpY1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGQgPSBtYXggLSBtaW47XG4gICAgICAgIHMgPSBsID4gMC41ID8gZCAvICgyIC0gbWF4IC0gbWluKSA6IGQgLyAobWF4ICsgbWluKTtcbiAgICAgICAgc3dpdGNoIChtYXgpIHtcbiAgICAgICAgICBjYXNlIHI6XG4gICAgICAgICAgICBoID0gKGcgLSBiKSAvIGQgKyAoZyA8IGIgPyA2IDogMCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIGc6XG4gICAgICAgICAgICBoID0gKGIgLSByKSAvIGQgKyAyO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBiOlxuICAgICAgICAgICAgaCA9IChyIC0gZykgLyBkICsgNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBoIC89IDY7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2gsIHMsIGwsIHZhbFszXV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGh1ZTJyZ2IocCwgcSwgdCkge1xuICAgICAgaWYgKHQgPCAwKSB0ICs9IDE7XG4gICAgICBpZiAodCA+IDEpIHQgLT0gMTtcbiAgICAgIGlmICh0IDwgMSAvIDYpIHJldHVybiBwICsgKHEgLSBwKSAqIDYgKiB0O1xuICAgICAgaWYgKHQgPCAxIC8gMikgcmV0dXJuIHE7XG4gICAgICBpZiAodCA8IDIgLyAzKSByZXR1cm4gcCArIChxIC0gcCkgKiAoMiAvIDMgLSB0KSAqIDY7XG4gICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgZnVuY3Rpb24gaHNsVG9SZ2IodmFsKSB7XG4gICAgICB2YXIgaCA9IHZhbFswXTtcbiAgICAgIHZhciBzID0gdmFsWzFdO1xuICAgICAgdmFyIGwgPSB2YWxbMl07XG4gICAgICB2YXIgcjtcbiAgICAgIHZhciBnO1xuICAgICAgdmFyIGI7XG4gICAgICBpZiAocyA9PT0gMCkge1xuICAgICAgICByID0gbDsgLy8gYWNocm9tYXRpY1xuICAgICAgICBiID0gbDsgLy8gYWNocm9tYXRpY1xuICAgICAgICBnID0gbDsgLy8gYWNocm9tYXRpY1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHEgPSBsIDwgMC41ID8gbCAqICgxICsgcykgOiBsICsgcyAtIGwgKiBzO1xuICAgICAgICB2YXIgcCA9IDIgKiBsIC0gcTtcbiAgICAgICAgciA9IGh1ZTJyZ2IocCwgcSwgaCArIDEgLyAzKTtcbiAgICAgICAgZyA9IGh1ZTJyZ2IocCwgcSwgaCk7XG4gICAgICAgIGIgPSBodWUycmdiKHAsIHEsIGggLSAxIC8gMyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW3IsIGcsIGIsIHZhbFszXV07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGxpbmVhcih0LCB0TWluLCB0TWF4LCB2YWx1ZTEsIHZhbHVlMikge1xuICAgICAgaWYgKHZhbHVlMSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlMiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlMSA9IHRNaW47XG4gICAgICAgIHZhbHVlMiA9IHRNYXg7XG4gICAgICAgIHRNaW4gPSAwO1xuICAgICAgICB0TWF4ID0gMTtcbiAgICAgIH1cbiAgICAgIGlmICh0TWF4IDwgdE1pbikge1xuICAgICAgICB2YXIgX3RNaW4gPSB0TWF4O1xuICAgICAgICB0TWF4ID0gdE1pbjtcbiAgICAgICAgdE1pbiA9IF90TWluO1xuICAgICAgfVxuICAgICAgaWYgKHQgPD0gdE1pbikge1xuICAgICAgICByZXR1cm4gdmFsdWUxO1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gdE1heCkge1xuICAgICAgICByZXR1cm4gdmFsdWUyO1xuICAgICAgfVxuICAgICAgdmFyIHBlcmMgPSB0TWF4ID09PSB0TWluID8gMCA6ICh0IC0gdE1pbikgLyAodE1heCAtIHRNaW4pO1xuICAgICAgaWYgKCF2YWx1ZTEubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTEgKyAodmFsdWUyIC0gdmFsdWUxKSAqIHBlcmM7XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSB2YWx1ZTEubGVuZ3RoO1xuICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFycltpXSA9IHZhbHVlMVtpXSArICh2YWx1ZTJbaV0gLSB2YWx1ZTFbaV0pICogcGVyYztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnI7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJhbmRvbShtaW4sIG1heCkge1xuICAgICAgaWYgKG1heCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChtaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1pbiA9IDA7XG4gICAgICAgICAgbWF4ID0gMTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtYXggPSBtaW47XG4gICAgICAgICAgbWluID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAobWF4Lmxlbmd0aCkge1xuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IG1heC5sZW5ndGg7XG4gICAgICAgIGlmICghbWluKSB7XG4gICAgICAgICAgbWluID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgICB2YXIgcm5kID0gQk1NYXRoLnJhbmRvbSgpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICBhcnJbaV0gPSBtaW5baV0gKyBybmQgKiAobWF4W2ldIC0gbWluW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgfVxuICAgICAgaWYgKG1pbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG1pbiA9IDA7XG4gICAgICB9XG4gICAgICB2YXIgcm5kbSA9IEJNTWF0aC5yYW5kb20oKTtcbiAgICAgIHJldHVybiBtaW4gKyBybmRtICogKG1heCAtIG1pbik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZVBhdGgocG9pbnRzLCBpblRhbmdlbnRzLCBvdXRUYW5nZW50cywgY2xvc2VkKSB7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBwb2ludHMubGVuZ3RoO1xuICAgICAgdmFyIHBhdGggPSBzaGFwZVBvb2wubmV3RWxlbWVudCgpO1xuICAgICAgcGF0aC5zZXRQYXRoRGF0YSghIWNsb3NlZCwgbGVuKTtcbiAgICAgIHZhciBhcnJQbGFjZWhvbGRlciA9IFswLCAwXTtcbiAgICAgIHZhciBpblZlcnRleFBvaW50O1xuICAgICAgdmFyIG91dFZlcnRleFBvaW50O1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGluVmVydGV4UG9pbnQgPSBpblRhbmdlbnRzICYmIGluVGFuZ2VudHNbaV0gPyBpblRhbmdlbnRzW2ldIDogYXJyUGxhY2Vob2xkZXI7XG4gICAgICAgIG91dFZlcnRleFBvaW50ID0gb3V0VGFuZ2VudHMgJiYgb3V0VGFuZ2VudHNbaV0gPyBvdXRUYW5nZW50c1tpXSA6IGFyclBsYWNlaG9sZGVyO1xuICAgICAgICBwYXRoLnNldFRyaXBsZUF0KHBvaW50c1tpXVswXSwgcG9pbnRzW2ldWzFdLCBvdXRWZXJ0ZXhQb2ludFswXSArIHBvaW50c1tpXVswXSwgb3V0VmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGluVmVydGV4UG9pbnRbMF0gKyBwb2ludHNbaV1bMF0sIGluVmVydGV4UG9pbnRbMV0gKyBwb2ludHNbaV1bMV0sIGksIHRydWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGluaXRpYXRlRXhwcmVzc2lvbihlbGVtLCBkYXRhLCBwcm9wZXJ0eSkge1xuICAgICAgLy8gQmFpbCBvdXQgaWYgd2UgZG9uJ3Qgd2FudCBleHByZXNzaW9uc1xuICAgICAgZnVuY3Rpb24gbm9PcChfdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIF92YWx1ZTtcbiAgICAgIH1cbiAgICAgIGlmICghZWxlbS5nbG9iYWxEYXRhLnJlbmRlckNvbmZpZy5ydW5FeHByZXNzaW9ucykge1xuICAgICAgICByZXR1cm4gbm9PcDtcbiAgICAgIH1cbiAgICAgIHZhciB2YWwgPSBkYXRhLng7XG4gICAgICB2YXIgbmVlZHNWZWxvY2l0eSA9IC92ZWxvY2l0eSg/IVtcXHdcXGRdKS8udGVzdCh2YWwpO1xuICAgICAgdmFyIF9uZWVkc1JhbmRvbSA9IHZhbC5pbmRleE9mKCdyYW5kb20nKSAhPT0gLTE7XG4gICAgICB2YXIgZWxlbVR5cGUgPSBlbGVtLmRhdGEudHk7XG4gICAgICB2YXIgdHJhbnNmb3JtO1xuICAgICAgdmFyICRibV90cmFuc2Zvcm07XG4gICAgICB2YXIgY29udGVudDtcbiAgICAgIHZhciBlZmZlY3Q7XG4gICAgICB2YXIgdGhpc1Byb3BlcnR5ID0gcHJvcGVydHk7XG4gICAgICB0aGlzUHJvcGVydHkuX25hbWUgPSBlbGVtLmRhdGEubm07XG4gICAgICB0aGlzUHJvcGVydHkudmFsdWVBdFRpbWUgPSB0aGlzUHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpc1Byb3BlcnR5LCAndmFsdWUnLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiB0aGlzUHJvcGVydHkudjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBlbGVtLmNvbXAuZnJhbWVEdXJhdGlvbiA9IDEgLyBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICBlbGVtLmNvbXAuZGlzcGxheVN0YXJ0VGltZSA9IDA7XG4gICAgICB2YXIgaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciBvdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIHZhciB3aWR0aCA9IGVsZW0uZGF0YS5zdyA/IGVsZW0uZGF0YS5zdyA6IDA7XG4gICAgICB2YXIgaGVpZ2h0ID0gZWxlbS5kYXRhLnNoID8gZWxlbS5kYXRhLnNoIDogMDtcbiAgICAgIHZhciBuYW1lID0gZWxlbS5kYXRhLm5tO1xuICAgICAgdmFyIGxvb3BJbjtcbiAgICAgIHZhciBsb29wX2luO1xuICAgICAgdmFyIGxvb3BPdXQ7XG4gICAgICB2YXIgbG9vcF9vdXQ7XG4gICAgICB2YXIgc21vb3RoO1xuICAgICAgdmFyIHRvV29ybGQ7XG4gICAgICB2YXIgZnJvbVdvcmxkO1xuICAgICAgdmFyIGZyb21Db21wO1xuICAgICAgdmFyIHRvQ29tcDtcbiAgICAgIHZhciBmcm9tQ29tcFRvU3VyZmFjZTtcbiAgICAgIHZhciBwb3NpdGlvbjtcbiAgICAgIHZhciByb3RhdGlvbjtcbiAgICAgIHZhciBhbmNob3JQb2ludDtcbiAgICAgIHZhciBzY2FsZTtcbiAgICAgIHZhciB0aGlzTGF5ZXI7XG4gICAgICB2YXIgdGhpc0NvbXA7XG4gICAgICB2YXIgbWFzaztcbiAgICAgIHZhciB2YWx1ZUF0VGltZTtcbiAgICAgIHZhciB2ZWxvY2l0eUF0VGltZTtcbiAgICAgIHZhciBzY29wZWRfYm1fcnQ7XG4gICAgICAvLyB2YWwgPSB2YWwucmVwbGFjZSgvKFxcXFw/XCJ8JykoKGh0dHApKHMpPyg6XFwvKSk/XFwvLio/KFxcXFw/XCJ8JykvZywgXCJcXFwiXFxcIlwiKTsgLy8gZGV0ZXIgcG90ZW50aWFsIG5ldHdvcmsgY2FsbHNcbiAgICAgIHZhciBleHByZXNzaW9uX2Z1bmN0aW9uID0gZXZhbCgnW2Z1bmN0aW9uIF9leHByZXNzaW9uX2Z1bmN0aW9uKCl7JyArIHZhbCArICc7c2NvcGVkX2JtX3J0PSRibV9ydH1dJylbMF07IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tZXZhbFxuICAgICAgdmFyIG51bUtleXMgPSBwcm9wZXJ0eS5rZiA/IGRhdGEuay5sZW5ndGggOiAwO1xuICAgICAgdmFyIGFjdGl2ZSA9ICF0aGlzLmRhdGEgfHwgdGhpcy5kYXRhLmhkICE9PSB0cnVlO1xuICAgICAgdmFyIHdpZ2dsZSA9IGZ1bmN0aW9uIHdpZ2dsZShmcmVxLCBhbXApIHtcbiAgICAgICAgdmFyIGlXaWdnbGU7XG4gICAgICAgIHZhciBqO1xuICAgICAgICB2YXIgbGVuV2lnZ2xlID0gdGhpcy5wdi5sZW5ndGggPyB0aGlzLnB2Lmxlbmd0aCA6IDE7XG4gICAgICAgIHZhciBhZGRlZEFtcHMgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuV2lnZ2xlKTtcbiAgICAgICAgZnJlcSA9IDU7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcih0aW1lICogZnJlcSk7XG4gICAgICAgIGlXaWdnbGUgPSAwO1xuICAgICAgICBqID0gMDtcbiAgICAgICAgd2hpbGUgKGlXaWdnbGUgPCBpdGVyYXRpb25zKSB7XG4gICAgICAgICAgLy8gdmFyIHJuZCA9IEJNTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuV2lnZ2xlOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wICogMiAqIEJNTWF0aC5yYW5kb20oKTtcbiAgICAgICAgICAgIC8vIGFkZGVkQW1wc1tqXSArPSAtYW1wICsgYW1wKjIqcm5kO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpV2lnZ2xlICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gdmFyIHJuZDIgPSBCTU1hdGgucmFuZG9tKCk7XG4gICAgICAgIHZhciBwZXJpb2RzID0gdGltZSAqIGZyZXE7XG4gICAgICAgIHZhciBwZXJjID0gcGVyaW9kcyAtIE1hdGguZmxvb3IocGVyaW9kcyk7XG4gICAgICAgIHZhciBhcnIgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgbGVuV2lnZ2xlKTtcbiAgICAgICAgaWYgKGxlbldpZ2dsZSA+IDEpIHtcbiAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgbGVuV2lnZ2xlOyBqICs9IDEpIHtcbiAgICAgICAgICAgIGFycltqXSA9IHRoaXMucHZbal0gKyBhZGRlZEFtcHNbal0gKyAoLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCkpICogcGVyYztcbiAgICAgICAgICAgIC8vIGFycltqXSA9IHRoaXMucHZbal0gKyBhZGRlZEFtcHNbal0gKyAoLWFtcCArIGFtcCoyKnJuZCkqcGVyYztcbiAgICAgICAgICAgIC8vIGFycltpXSA9IHRoaXMucHZbaV0gKyBhZGRlZEFtcCArIGFtcDEqcGVyYyArIGFtcDIqKDEtcGVyYyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHYgKyBhZGRlZEFtcHNbMF0gKyAoLWFtcCArIGFtcCAqIDIgKiBCTU1hdGgucmFuZG9tKCkpICogcGVyYztcbiAgICAgIH0uYmluZCh0aGlzKTtcbiAgICAgIGlmICh0aGlzUHJvcGVydHkubG9vcEluKSB7XG4gICAgICAgIGxvb3BJbiA9IHRoaXNQcm9wZXJ0eS5sb29wSW4uYmluZCh0aGlzUHJvcGVydHkpO1xuICAgICAgICBsb29wX2luID0gbG9vcEluO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXNQcm9wZXJ0eS5sb29wT3V0KSB7XG4gICAgICAgIGxvb3BPdXQgPSB0aGlzUHJvcGVydHkubG9vcE91dC5iaW5kKHRoaXNQcm9wZXJ0eSk7XG4gICAgICAgIGxvb3Bfb3V0ID0gbG9vcE91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzUHJvcGVydHkuc21vb3RoKSB7XG4gICAgICAgIHNtb290aCA9IHRoaXNQcm9wZXJ0eS5zbW9vdGguYmluZCh0aGlzUHJvcGVydHkpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gbG9vcEluRHVyYXRpb24odHlwZSwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvb3BJbih0eXBlLCBkdXJhdGlvbiwgdHJ1ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBsb29wT3V0RHVyYXRpb24odHlwZSwgZHVyYXRpb24pIHtcbiAgICAgICAgcmV0dXJuIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZ2V0VmFsdWVBdFRpbWUpIHtcbiAgICAgICAgdmFsdWVBdFRpbWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lLmJpbmQodGhpcyk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5nZXRWZWxvY2l0eUF0VGltZSkge1xuICAgICAgICB2ZWxvY2l0eUF0VGltZSA9IHRoaXMuZ2V0VmVsb2NpdHlBdFRpbWUuYmluZCh0aGlzKTtcbiAgICAgIH1cbiAgICAgIHZhciBjb21wID0gZWxlbS5jb21wLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5iaW5kKGVsZW0uY29tcC5nbG9iYWxEYXRhLnByb2plY3RJbnRlcmZhY2UpO1xuICAgICAgZnVuY3Rpb24gbG9va0F0KGVsZW0xLCBlbGVtMikge1xuICAgICAgICB2YXIgZlZlYyA9IFtlbGVtMlswXSAtIGVsZW0xWzBdLCBlbGVtMlsxXSAtIGVsZW0xWzFdLCBlbGVtMlsyXSAtIGVsZW0xWzJdXTtcbiAgICAgICAgdmFyIHBpdGNoID0gTWF0aC5hdGFuMihmVmVjWzBdLCBNYXRoLnNxcnQoZlZlY1sxXSAqIGZWZWNbMV0gKyBmVmVjWzJdICogZlZlY1syXSkpIC8gZGVnVG9SYWRzO1xuICAgICAgICB2YXIgeWF3ID0gLU1hdGguYXRhbjIoZlZlY1sxXSwgZlZlY1syXSkgLyBkZWdUb1JhZHM7XG4gICAgICAgIHJldHVybiBbeWF3LCBwaXRjaCwgMF07XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBlYXNlT3V0KHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcbiAgICAgICAgcmV0dXJuIGFwcGx5RWFzZShlYXNlT3V0QmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVhc2VJbih0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKSB7XG4gICAgICAgIHJldHVybiBhcHBseUVhc2UoZWFzZUluQmV6LCB0LCB0TWluLCB0TWF4LCB2YWwxLCB2YWwyKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIGVhc2UodCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMikge1xuICAgICAgICByZXR1cm4gYXBwbHlFYXNlKGVhc2VJbk91dEJleiwgdCwgdE1pbiwgdE1heCwgdmFsMSwgdmFsMik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBhcHBseUVhc2UoZm4sIHQsIHRNaW4sIHRNYXgsIHZhbDEsIHZhbDIpIHtcbiAgICAgICAgaWYgKHZhbDEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHZhbDEgPSB0TWluO1xuICAgICAgICAgIHZhbDIgPSB0TWF4O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHQgPSAodCAtIHRNaW4pIC8gKHRNYXggLSB0TWluKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodCA+IDEpIHtcbiAgICAgICAgICB0ID0gMTtcbiAgICAgICAgfSBlbHNlIGlmICh0IDwgMCkge1xuICAgICAgICAgIHQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHZhciBtdWx0ID0gZm4odCk7XG4gICAgICAgIGlmICgkYm1faXNJbnN0YW5jZU9mQXJyYXkodmFsMSkpIHtcbiAgICAgICAgICB2YXIgaUtleTtcbiAgICAgICAgICB2YXIgbGVuS2V5ID0gdmFsMS5sZW5ndGg7XG4gICAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW5LZXkpO1xuICAgICAgICAgIGZvciAoaUtleSA9IDA7IGlLZXkgPCBsZW5LZXk7IGlLZXkgKz0gMSkge1xuICAgICAgICAgICAgYXJyW2lLZXldID0gKHZhbDJbaUtleV0gLSB2YWwxW2lLZXldKSAqIG11bHQgKyB2YWwxW2lLZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gYXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAodmFsMiAtIHZhbDEpICogbXVsdCArIHZhbDE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBuZWFyZXN0S2V5KHRpbWUpIHtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXkgPSBkYXRhLmsubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXg7XG4gICAgICAgIHZhciBrZXlUaW1lO1xuICAgICAgICBpZiAoIWRhdGEuay5sZW5ndGggfHwgdHlwZW9mIGRhdGEua1swXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgICAga2V5VGltZSA9IDA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5kZXggPSAtMTtcbiAgICAgICAgICB0aW1lICo9IGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgICBpZiAodGltZSA8IGRhdGEua1swXS50KSB7XG4gICAgICAgICAgICBpbmRleCA9IDE7XG4gICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rWzBdLnQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoaUtleSA9IDA7IGlLZXkgPCBsZW5LZXkgLSAxOyBpS2V5ICs9IDEpIHtcbiAgICAgICAgICAgICAgaWYgKHRpbWUgPT09IGRhdGEua1tpS2V5XS50KSB7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMTtcbiAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXldLnQ7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAodGltZSA+IGRhdGEua1tpS2V5XS50ICYmIHRpbWUgPCBkYXRhLmtbaUtleSArIDFdLnQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGltZSAtIGRhdGEua1tpS2V5XS50ID4gZGF0YS5rW2lLZXkgKyAxXS50IC0gdGltZSkge1xuICAgICAgICAgICAgICAgICAgaW5kZXggPSBpS2V5ICsgMjtcbiAgICAgICAgICAgICAgICAgIGtleVRpbWUgPSBkYXRhLmtbaUtleSArIDFdLnQ7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDE7XG4gICAgICAgICAgICAgICAgICBrZXlUaW1lID0gZGF0YS5rW2lLZXldLnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IC0xKSB7XG4gICAgICAgICAgICAgIGluZGV4ID0gaUtleSArIDE7XG4gICAgICAgICAgICAgIGtleVRpbWUgPSBkYXRhLmtbaUtleV0udDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9iS2V5ID0ge307XG4gICAgICAgIG9iS2V5LmluZGV4ID0gaW5kZXg7XG4gICAgICAgIG9iS2V5LnRpbWUgPSBrZXlUaW1lIC8gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICByZXR1cm4gb2JLZXk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBrZXkoaW5kKSB7XG4gICAgICAgIHZhciBvYktleTtcbiAgICAgICAgdmFyIGlLZXk7XG4gICAgICAgIHZhciBsZW5LZXk7XG4gICAgICAgIGlmICghZGF0YS5rLmxlbmd0aCB8fCB0eXBlb2YgZGF0YS5rWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByb3BlcnR5IGhhcyBubyBrZXlmcmFtZSBhdCBpbmRleCAnICsgaW5kKTtcbiAgICAgICAgfVxuICAgICAgICBpbmQgLT0gMTtcbiAgICAgICAgb2JLZXkgPSB7XG4gICAgICAgICAgdGltZTogZGF0YS5rW2luZF0udCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSxcbiAgICAgICAgICB2YWx1ZTogW11cbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGFyciA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkYXRhLmtbaW5kXSwgJ3MnKSA/IGRhdGEua1tpbmRdLnMgOiBkYXRhLmtbaW5kIC0gMV0uZTtcbiAgICAgICAgbGVuS2V5ID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yIChpS2V5ID0gMDsgaUtleSA8IGxlbktleTsgaUtleSArPSAxKSB7XG4gICAgICAgICAgb2JLZXlbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgICAgb2JLZXkudmFsdWVbaUtleV0gPSBhcnJbaUtleV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iS2V5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gZnJhbWVzVG9UaW1lKGZyLCBmcHMpIHtcbiAgICAgICAgaWYgKCFmcHMpIHtcbiAgICAgICAgICBmcHMgPSBlbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZyIC8gZnBzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gdGltZVRvRnJhbWVzKHQsIGZwcykge1xuICAgICAgICBpZiAoIXQgJiYgdCAhPT0gMCkge1xuICAgICAgICAgIHQgPSB0aW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZnBzKSB7XG4gICAgICAgICAgZnBzID0gZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0ICogZnBzO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2VlZFJhbmRvbShzZWVkKSB7XG4gICAgICAgIEJNTWF0aC5zZWVkcmFuZG9tKHJhbmRTZWVkICsgc2VlZCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzb3VyY2VSZWN0QXRUaW1lKCkge1xuICAgICAgICByZXR1cm4gZWxlbS5zb3VyY2VSZWN0QXRUaW1lKCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBzdWJzdHJpbmcoaW5pdCwgZW5kKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKGluaXQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdmFsdWUuc3Vic3RyaW5nKGluaXQsIGVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc3Vic3RyKGluaXQsIGVuZCkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHZhbHVlLnN1YnN0cihpbml0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAnJztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIHBvc3Rlcml6ZVRpbWUoZnJhbWVzUGVyU2Vjb25kKSB7XG4gICAgICAgIHRpbWUgPSBmcmFtZXNQZXJTZWNvbmQgPT09IDAgPyAwIDogTWF0aC5mbG9vcih0aW1lICogZnJhbWVzUGVyU2Vjb25kKSAvIGZyYW1lc1BlclNlY29uZDtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgIH1cbiAgICAgIHZhciB0aW1lO1xuICAgICAgdmFyIHZlbG9jaXR5O1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgdmFyIHRleHQ7XG4gICAgICB2YXIgdGV4dEluZGV4O1xuICAgICAgdmFyIHRleHRUb3RhbDtcbiAgICAgIHZhciBzZWxlY3RvclZhbHVlO1xuICAgICAgdmFyIGluZGV4ID0gZWxlbS5kYXRhLmluZDtcbiAgICAgIHZhciBoYXNQYXJlbnQgPSAhIShlbGVtLmhpZXJhcmNoeSAmJiBlbGVtLmhpZXJhcmNoeS5sZW5ndGgpO1xuICAgICAgdmFyIHBhcmVudDtcbiAgICAgIHZhciByYW5kU2VlZCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xuICAgICAgdmFyIGdsb2JhbERhdGEgPSBlbGVtLmdsb2JhbERhdGE7XG4gICAgICBmdW5jdGlvbiBleGVjdXRlRXhwcmVzc2lvbihfdmFsdWUpIHtcbiAgICAgICAgLy8gZ2xvYmFsRGF0YS5wdXNoRXhwcmVzc2lvbigpO1xuICAgICAgICB2YWx1ZSA9IF92YWx1ZTtcbiAgICAgICAgaWYgKHRoaXMuZnJhbWVFeHByZXNzaW9uSWQgPT09IGVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkICYmIHRoaXMucHJvcFR5cGUgIT09ICd0ZXh0U2VsZWN0b3InKSB7XG4gICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnByb3BUeXBlID09PSAndGV4dFNlbGVjdG9yJykge1xuICAgICAgICAgIHRleHRJbmRleCA9IHRoaXMudGV4dEluZGV4O1xuICAgICAgICAgIHRleHRUb3RhbCA9IHRoaXMudGV4dFRvdGFsO1xuICAgICAgICAgIHNlbGVjdG9yVmFsdWUgPSB0aGlzLnNlbGVjdG9yVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzTGF5ZXIpIHtcbiAgICAgICAgICB0ZXh0ID0gZWxlbS5sYXllckludGVyZmFjZS50ZXh0O1xuICAgICAgICAgIHRoaXNMYXllciA9IGVsZW0ubGF5ZXJJbnRlcmZhY2U7XG4gICAgICAgICAgdGhpc0NvbXAgPSBlbGVtLmNvbXAuY29tcEludGVyZmFjZTtcbiAgICAgICAgICB0b1dvcmxkID0gdGhpc0xheWVyLnRvV29ybGQuYmluZCh0aGlzTGF5ZXIpO1xuICAgICAgICAgIGZyb21Xb3JsZCA9IHRoaXNMYXllci5mcm9tV29ybGQuYmluZCh0aGlzTGF5ZXIpO1xuICAgICAgICAgIGZyb21Db21wID0gdGhpc0xheWVyLmZyb21Db21wLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICB0b0NvbXAgPSB0aGlzTGF5ZXIudG9Db21wLmJpbmQodGhpc0xheWVyKTtcbiAgICAgICAgICBtYXNrID0gdGhpc0xheWVyLm1hc2sgPyB0aGlzTGF5ZXIubWFzay5iaW5kKHRoaXNMYXllcikgOiBudWxsO1xuICAgICAgICAgIGZyb21Db21wVG9TdXJmYWNlID0gZnJvbUNvbXA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgICB0cmFuc2Zvcm0gPSBlbGVtLmxheWVySW50ZXJmYWNlKCdBREJFIFRyYW5zZm9ybSBHcm91cCcpO1xuICAgICAgICAgICRibV90cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgICAgICAgaWYgKHRyYW5zZm9ybSkge1xuICAgICAgICAgICAgYW5jaG9yUG9pbnQgPSB0cmFuc2Zvcm0uYW5jaG9yUG9pbnQ7XG4gICAgICAgICAgICAvKiBwb3NpdGlvbiA9IHRyYW5zZm9ybS5wb3NpdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICByb3RhdGlvbiA9IHRyYW5zZm9ybS5yb3RhdGlvbjtcbiAgICAgICAgICAgICAgICAgICAgICBzY2FsZSA9IHRyYW5zZm9ybS5zY2FsZTsgKi9cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVsZW1UeXBlID09PSA0ICYmICFjb250ZW50KSB7XG4gICAgICAgICAgY29udGVudCA9IHRoaXNMYXllcignQURCRSBSb290IFZlY3RvcnMgR3JvdXAnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWVmZmVjdCkge1xuICAgICAgICAgIGVmZmVjdCA9IHRoaXNMYXllcig0KTtcbiAgICAgICAgfVxuICAgICAgICBoYXNQYXJlbnQgPSAhIShlbGVtLmhpZXJhcmNoeSAmJiBlbGVtLmhpZXJhcmNoeS5sZW5ndGgpO1xuICAgICAgICBpZiAoaGFzUGFyZW50ICYmICFwYXJlbnQpIHtcbiAgICAgICAgICBwYXJlbnQgPSBlbGVtLmhpZXJhcmNoeVswXS5sYXllckludGVyZmFjZTtcbiAgICAgICAgfVxuICAgICAgICB0aW1lID0gdGhpcy5jb21wLnJlbmRlcmVkRnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGU7XG4gICAgICAgIGlmIChfbmVlZHNSYW5kb20pIHtcbiAgICAgICAgICBzZWVkUmFuZG9tKHJhbmRTZWVkICsgdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5lZWRzVmVsb2NpdHkpIHtcbiAgICAgICAgICB2ZWxvY2l0eSA9IHZlbG9jaXR5QXRUaW1lKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGV4cHJlc3Npb25fZnVuY3Rpb24oKTtcbiAgICAgICAgdGhpcy5mcmFtZUV4cHJlc3Npb25JZCA9IGVsZW0uZ2xvYmFsRGF0YS5mcmFtZUlkO1xuXG4gICAgICAgIC8vIFRPRE86IENoZWNrIGlmIGl0J3MgcG9zc2libGUgdG8gcmV0dXJuIG9uIFNoYXBlSW50ZXJmYWNlIHRoZSAudiB2YWx1ZVxuICAgICAgICAvLyBDaGFuZ2VkIHRoaXMgdG8gYSB0ZXJuYXJ5IG9wZXJhdGlvbiBiZWNhdXNlIFJvbGx1cCBmYWlsZWQgY29tcGlsaW5nIGl0IGNvcnJlY3RseVxuICAgICAgICBzY29wZWRfYm1fcnQgPSBzY29wZWRfYm1fcnQucHJvcFR5cGUgPT09IHByb3BUeXBlcy5TSEFQRSA/IHNjb3BlZF9ibV9ydC52IDogc2NvcGVkX2JtX3J0O1xuICAgICAgICByZXR1cm4gc2NvcGVkX2JtX3J0O1xuICAgICAgfVxuICAgICAgLy8gQnVuZGxlcnMgd2lsbCBzZWUgdGhlc2UgYXMgZGVhZCBjb2RlIGFuZCB1bmxlc3Mgd2UgcmVmZXJlbmNlIHRoZW1cbiAgICAgIGV4ZWN1dGVFeHByZXNzaW9uLl9fcHJldmVudERlYWRDb2RlUmVtb3ZhbCA9IFskYm1fdHJhbnNmb3JtLCBhbmNob3JQb2ludCwgdGltZSwgdmVsb2NpdHksIGluUG9pbnQsIG91dFBvaW50LCB3aWR0aCwgaGVpZ2h0LCBuYW1lLCBsb29wX2luLCBsb29wX291dCwgc21vb3RoLCB0b0NvbXAsIGZyb21Db21wVG9TdXJmYWNlLCB0b1dvcmxkLCBmcm9tV29ybGQsIG1hc2ssIHBvc2l0aW9uLCByb3RhdGlvbiwgc2NhbGUsIHRoaXNDb21wLCBudW1LZXlzLCBhY3RpdmUsIHdpZ2dsZSwgbG9vcEluRHVyYXRpb24sIGxvb3BPdXREdXJhdGlvbiwgY29tcCwgbG9va0F0LCBlYXNlT3V0LCBlYXNlSW4sIGVhc2UsIG5lYXJlc3RLZXksIGtleSwgdGV4dCwgdGV4dEluZGV4LCB0ZXh0VG90YWwsIHNlbGVjdG9yVmFsdWUsIGZyYW1lc1RvVGltZSwgdGltZVRvRnJhbWVzLCBzb3VyY2VSZWN0QXRUaW1lLCBzdWJzdHJpbmcsIHN1YnN0ciwgcG9zdGVyaXplVGltZSwgaW5kZXgsIGdsb2JhbERhdGFdO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVFeHByZXNzaW9uO1xuICAgIH1cbiAgICBvYi5pbml0aWF0ZUV4cHJlc3Npb24gPSBpbml0aWF0ZUV4cHJlc3Npb247XG4gICAgb2IuX19wcmV2ZW50RGVhZENvZGVSZW1vdmFsID0gW3dpbmRvdywgZG9jdW1lbnQsIFhNTEh0dHBSZXF1ZXN0LCBmZXRjaCwgZnJhbWVzLCAkYm1fbmVnLCBhZGQsICRibV9zdW0sICRibV9zdWIsICRibV9tdWwsICRibV9kaXYsICRibV9tb2QsIGNsYW1wLCByYWRpYW5zX3RvX2RlZ3JlZXMsIGRlZ3JlZXNUb1JhZGlhbnMsIGRlZ3JlZXNfdG9fcmFkaWFucywgbm9ybWFsaXplLCByZ2JUb0hzbCwgaHNsVG9SZ2IsIGxpbmVhciwgcmFuZG9tLCBjcmVhdGVQYXRoLCBfbG90dGllR2xvYmFsXTtcbiAgICBvYi5yZXNldEZyYW1lID0gcmVzZXRGcmFtZTtcbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgRXhwcmVzc2lvbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG9iID0ge307XG4gICAgb2IuaW5pdEV4cHJlc3Npb25zID0gaW5pdEV4cHJlc3Npb25zO1xuICAgIG9iLnJlc2V0RnJhbWUgPSBFeHByZXNzaW9uTWFuYWdlci5yZXNldEZyYW1lO1xuICAgIGZ1bmN0aW9uIGluaXRFeHByZXNzaW9ucyhhbmltYXRpb24pIHtcbiAgICAgIHZhciBzdGFja0NvdW50ID0gMDtcbiAgICAgIHZhciByZWdpc3RlcnMgPSBbXTtcbiAgICAgIGZ1bmN0aW9uIHB1c2hFeHByZXNzaW9uKCkge1xuICAgICAgICBzdGFja0NvdW50ICs9IDE7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBwb3BFeHByZXNzaW9uKCkge1xuICAgICAgICBzdGFja0NvdW50IC09IDE7XG4gICAgICAgIGlmIChzdGFja0NvdW50ID09PSAwKSB7XG4gICAgICAgICAgcmVsZWFzZUluc3RhbmNlcygpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eShleHByZXNzaW9uKSB7XG4gICAgICAgIGlmIChyZWdpc3RlcnMuaW5kZXhPZihleHByZXNzaW9uKSA9PT0gLTEpIHtcbiAgICAgICAgICByZWdpc3RlcnMucHVzaChleHByZXNzaW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcmVsZWFzZUluc3RhbmNlcygpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSByZWdpc3RlcnMubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICByZWdpc3RlcnNbaV0ucmVsZWFzZSgpO1xuICAgICAgICB9XG4gICAgICAgIHJlZ2lzdGVycy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmNvbXBJbnRlcmZhY2UgPSBDb21wRXhwcmVzc2lvbkludGVyZmFjZShhbmltYXRpb24ucmVuZGVyZXIpO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucHJvamVjdEludGVyZmFjZS5yZWdpc3RlckNvbXBvc2l0aW9uKGFuaW1hdGlvbi5yZW5kZXJlcik7XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5wdXNoRXhwcmVzc2lvbiA9IHB1c2hFeHByZXNzaW9uO1xuICAgICAgYW5pbWF0aW9uLnJlbmRlcmVyLmdsb2JhbERhdGEucG9wRXhwcmVzc2lvbiA9IHBvcEV4cHJlc3Npb247XG4gICAgICBhbmltYXRpb24ucmVuZGVyZXIuZ2xvYmFsRGF0YS5yZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eSA9IHJlZ2lzdGVyRXhwcmVzc2lvblByb3BlcnR5O1xuICAgIH1cbiAgICByZXR1cm4gb2I7XG4gIH0oKTtcblxuICB2YXIgTWFza01hbmFnZXJJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWFza0ludGVyZmFjZShtYXNrLCBkYXRhKSB7XG4gICAgICB0aGlzLl9tYXNrID0gbWFzaztcbiAgICAgIHRoaXMuX2RhdGEgPSBkYXRhO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoTWFza0ludGVyZmFjZS5wcm90b3R5cGUsICdtYXNrUGF0aCcsIHtcbiAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICBpZiAodGhpcy5fbWFzay5wcm9wLmspIHtcbiAgICAgICAgICB0aGlzLl9tYXNrLnByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fbWFzay5wcm9wO1xuICAgICAgfVxuICAgIH0pO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShNYXNrSW50ZXJmYWNlLnByb3RvdHlwZSwgJ21hc2tPcGFjaXR5Jywge1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9tYXNrLm9wLmspIHtcbiAgICAgICAgICB0aGlzLl9tYXNrLm9wLmdldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX21hc2sub3AudiAqIDEwMDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgTWFza01hbmFnZXIgPSBmdW5jdGlvbiBNYXNrTWFuYWdlcihtYXNrTWFuYWdlcikge1xuICAgICAgdmFyIF9tYXNrc0ludGVyZmFjZXMgPSBjcmVhdGVTaXplZEFycmF5KG1hc2tNYW5hZ2VyLnZpZXdEYXRhLmxlbmd0aCk7XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBtYXNrTWFuYWdlci52aWV3RGF0YS5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgX21hc2tzSW50ZXJmYWNlc1tpXSA9IG5ldyBNYXNrSW50ZXJmYWNlKG1hc2tNYW5hZ2VyLnZpZXdEYXRhW2ldLCBtYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXNbaV0pO1xuICAgICAgfVxuICAgICAgdmFyIG1hc2tGdW5jdGlvbiA9IGZ1bmN0aW9uIG1hc2tGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIGkgPSAwO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmIChtYXNrTWFuYWdlci5tYXNrc1Byb3BlcnRpZXNbaV0ubm0gPT09IG5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiBfbWFza3NJbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9O1xuICAgICAgcmV0dXJuIG1hc2tGdW5jdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBNYXNrTWFuYWdlcjtcbiAgfSgpO1xuXG4gIHZhciBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGRlZmF1bHRVbmlkaW1lbnNpb25hbFZhbHVlID0ge1xuICAgICAgcHY6IDAsXG4gICAgICB2OiAwLFxuICAgICAgbXVsdDogMVxuICAgIH07XG4gICAgdmFyIGRlZmF1bHRNdWx0aWRpbWVuc2lvbmFsVmFsdWUgPSB7XG4gICAgICBwdjogWzAsIDAsIDBdLFxuICAgICAgdjogWzAsIDAsIDBdLFxuICAgICAgbXVsdDogMVxuICAgIH07XG4gICAgZnVuY3Rpb24gY29tcGxldGVQcm9wZXJ0eShleHByZXNzaW9uVmFsdWUsIHByb3BlcnR5LCB0eXBlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCAndmVsb2NpdHknLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIHJldHVybiBwcm9wZXJ0eS5nZXRWZWxvY2l0eUF0VGltZShwcm9wZXJ0eS5jb21wLmN1cnJlbnRGcmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZXhwcmVzc2lvblZhbHVlLm51bUtleXMgPSBwcm9wZXJ0eS5rZXlmcmFtZXMgPyBwcm9wZXJ0eS5rZXlmcmFtZXMubGVuZ3RoIDogMDtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS5rZXkgPSBmdW5jdGlvbiAocG9zKSB7XG4gICAgICAgIGlmICghZXhwcmVzc2lvblZhbHVlLm51bUtleXMpIHtcbiAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdmFsdWUgPSAnJztcbiAgICAgICAgaWYgKCdzJyBpbiBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0pIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAxXS5zO1xuICAgICAgICB9IGVsc2UgaWYgKCdlJyBpbiBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMl0pIHtcbiAgICAgICAgICB2YWx1ZSA9IHByb3BlcnR5LmtleWZyYW1lc1twb3MgLSAyXS5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbHVlID0gcHJvcGVydHkua2V5ZnJhbWVzW3BvcyAtIDJdLnM7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHZhbHVlUHJvcCA9IHR5cGUgPT09ICd1bmlkaW1lbnNpb25hbCcgPyBuZXcgTnVtYmVyKHZhbHVlKSA6IE9iamVjdC5hc3NpZ24oe30sIHZhbHVlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICAgICAgdmFsdWVQcm9wLnRpbWUgPSBwcm9wZXJ0eS5rZXlmcmFtZXNbcG9zIC0gMV0udCAvIHByb3BlcnR5LmVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgICAgdmFsdWVQcm9wLnZhbHVlID0gdHlwZSA9PT0gJ3VuaWRpbWVuc2lvbmFsJyA/IHZhbHVlWzBdIDogdmFsdWU7XG4gICAgICAgIHJldHVybiB2YWx1ZVByb3A7XG4gICAgICB9O1xuICAgICAgZXhwcmVzc2lvblZhbHVlLnZhbHVlQXRUaW1lID0gcHJvcGVydHkuZ2V0VmFsdWVBdFRpbWU7XG4gICAgICBleHByZXNzaW9uVmFsdWUuc3BlZWRBdFRpbWUgPSBwcm9wZXJ0eS5nZXRTcGVlZEF0VGltZTtcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52ZWxvY2l0eUF0VGltZSA9IHByb3BlcnR5LmdldFZlbG9jaXR5QXRUaW1lO1xuICAgICAgZXhwcmVzc2lvblZhbHVlLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eS5wcm9wZXJ0eUdyb3VwO1xuICAgIH1cbiAgICBmdW5jdGlvbiBVbmlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5IHx8ICEoJ3B2JyBpbiBwcm9wZXJ0eSkpIHtcbiAgICAgICAgcHJvcGVydHkgPSBkZWZhdWx0VW5pZGltZW5zaW9uYWxWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtdWx0ID0gMSAvIHByb3BlcnR5Lm11bHQ7XG4gICAgICB2YXIgdmFsID0gcHJvcGVydHkucHYgKiBtdWx0O1xuICAgICAgdmFyIGV4cHJlc3Npb25WYWx1ZSA9IG5ldyBOdW1iZXIodmFsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICAgIGV4cHJlc3Npb25WYWx1ZS52YWx1ZSA9IHZhbDtcbiAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ3VuaWRpbWVuc2lvbmFsJyk7XG4gICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAocHJvcGVydHkuaykge1xuICAgICAgICAgIHByb3BlcnR5LmdldFZhbHVlKCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gcHJvcGVydHkudiAqIG11bHQ7XG4gICAgICAgIGlmIChleHByZXNzaW9uVmFsdWUudmFsdWUgIT09IHZhbCkge1xuICAgICAgICAgIGV4cHJlc3Npb25WYWx1ZSA9IG5ldyBOdW1iZXIodmFsKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcbiAgICAgICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSB2YWw7XG4gICAgICAgICAgZXhwcmVzc2lvblZhbHVlWzBdID0gdmFsO1xuICAgICAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ3VuaWRpbWVuc2lvbmFsJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGV4cHJlc3Npb25WYWx1ZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIE11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZShwcm9wZXJ0eSkge1xuICAgICAgaWYgKCFwcm9wZXJ0eSB8fCAhKCdwdicgaW4gcHJvcGVydHkpKSB7XG4gICAgICAgIHByb3BlcnR5ID0gZGVmYXVsdE11bHRpZGltZW5zaW9uYWxWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciBtdWx0ID0gMSAvIHByb3BlcnR5Lm11bHQ7XG4gICAgICB2YXIgbGVuID0gcHJvcGVydHkuZGF0YSAmJiBwcm9wZXJ0eS5kYXRhLmwgfHwgcHJvcGVydHkucHYubGVuZ3RoO1xuICAgICAgdmFyIGV4cHJlc3Npb25WYWx1ZSA9IGNyZWF0ZVR5cGVkQXJyYXkoJ2Zsb2F0MzInLCBsZW4pO1xuICAgICAgdmFyIGFyclZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIGxlbik7XG4gICAgICBleHByZXNzaW9uVmFsdWUudmFsdWUgPSBhcnJWYWx1ZTtcbiAgICAgIGNvbXBsZXRlUHJvcGVydHkoZXhwcmVzc2lvblZhbHVlLCBwcm9wZXJ0eSwgJ211bHRpZGltZW5zaW9uYWwnKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChwcm9wZXJ0eS5rKSB7XG4gICAgICAgICAgcHJvcGVydHkuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgYXJyVmFsdWVbaV0gPSBwcm9wZXJ0eS52W2ldICogbXVsdDtcbiAgICAgICAgICBleHByZXNzaW9uVmFsdWVbaV0gPSBhcnJWYWx1ZVtpXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblZhbHVlO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBUT0RPOiB0cnkgdG8gYXZvaWQgdXNpbmcgdGhpcyBnZXR0ZXJcbiAgICBmdW5jdGlvbiBkZWZhdWx0R2V0dGVyKCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRVbmlkaW1lbnNpb25hbFZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKHByb3BlcnR5KSB7XG4gICAgICBpZiAoIXByb3BlcnR5KSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0R2V0dGVyO1xuICAgICAgfVxuICAgICAgaWYgKHByb3BlcnR5LnByb3BUeXBlID09PSAndW5pZGltZW5zaW9uYWwnKSB7XG4gICAgICAgIHJldHVybiBVbmlkaW1lbnNpb25hbFByb3BlcnR5SW50ZXJmYWNlKHByb3BlcnR5KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHlJbnRlcmZhY2UocHJvcGVydHkpO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgVHJhbnNmb3JtRXhwcmVzc2lvbkludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRyYW5zZm9ybSkge1xuICAgICAgZnVuY3Rpb24gX3RoaXNGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ3NjYWxlJzpcbiAgICAgICAgICBjYXNlICdTY2FsZSc6XG4gICAgICAgICAgY2FzZSAnQURCRSBTY2FsZSc6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24uc2NhbGU7XG4gICAgICAgICAgY2FzZSAncm90YXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1JvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFJvdGF0ZSBaJzpcbiAgICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ucm90YXRpb247XG4gICAgICAgICAgY2FzZSAnQURCRSBSb3RhdGUgWCc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi54Um90YXRpb247XG4gICAgICAgICAgY2FzZSAnQURCRSBSb3RhdGUgWSc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi55Um90YXRpb247XG4gICAgICAgICAgY2FzZSAncG9zaXRpb24nOlxuICAgICAgICAgIGNhc2UgJ1Bvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uJzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgICBjYXNlICdBREJFIFBvc2l0aW9uXzAnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24ueFBvc2l0aW9uO1xuICAgICAgICAgIGNhc2UgJ0FEQkUgUG9zaXRpb25fMSc6XG4gICAgICAgICAgICByZXR1cm4gX3RoaXNGdW5jdGlvbi55UG9zaXRpb247XG4gICAgICAgICAgY2FzZSAnQURCRSBQb3NpdGlvbl8yJzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLnpQb3NpdGlvbjtcbiAgICAgICAgICBjYXNlICdhbmNob3JQb2ludCc6XG4gICAgICAgICAgY2FzZSAnQW5jaG9yUG9pbnQnOlxuICAgICAgICAgIGNhc2UgJ0FuY2hvciBQb2ludCc6XG4gICAgICAgICAgY2FzZSAnQURCRSBBbmNob3JQb2ludCc6XG4gICAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzRnVuY3Rpb24uYW5jaG9yUG9pbnQ7XG4gICAgICAgICAgY2FzZSAnb3BhY2l0eSc6XG4gICAgICAgICAgY2FzZSAnT3BhY2l0eSc6XG4gICAgICAgICAgY2FzZSAxMTpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uLm9wYWNpdHk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3JvdGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0uciB8fCB0cmFuc2Zvcm0ucnopXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnelJvdGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucnogfHwgdHJhbnNmb3JtLnIpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneFJvdGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucngpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneVJvdGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucnkpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnc2NhbGUnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zKVxuICAgICAgfSk7XG4gICAgICB2YXIgX3B4O1xuICAgICAgdmFyIF9weTtcbiAgICAgIHZhciBfcHo7XG4gICAgICB2YXIgX3RyYW5zZm9ybUZhY3Rvcnk7XG4gICAgICBpZiAodHJhbnNmb3JtLnApIHtcbiAgICAgICAgX3RyYW5zZm9ybUZhY3RvcnkgPSBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgX3B4ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weCk7XG4gICAgICAgIF9weSA9IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpO1xuICAgICAgICBpZiAodHJhbnNmb3JtLnB6KSB7XG4gICAgICAgICAgX3B6ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5weik7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAncG9zaXRpb24nLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgIGlmICh0cmFuc2Zvcm0ucCkge1xuICAgICAgICAgICAgcmV0dXJuIF90cmFuc2Zvcm1GYWN0b3J5KCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBbX3B4KCksIF9weSgpLCBfcHogPyBfcHooKSA6IDBdO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneFBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHgpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAneVBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHkpXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnelBvc2l0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ucHopXG4gICAgICB9KTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0Z1bmN0aW9uLCAnYW5jaG9yUG9pbnQnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5hKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29wYWNpdHknLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5vKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ3NrZXcnLCB7XG4gICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHRyYW5zZm9ybS5zaylcbiAgICAgIH0pO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KF90aGlzRnVuY3Rpb24sICdza2V3QXhpcycsIHtcbiAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UodHJhbnNmb3JtLnNhKVxuICAgICAgfSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3RoaXNGdW5jdGlvbiwgJ29yaWVudGF0aW9uJywge1xuICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh0cmFuc2Zvcm0ub3IpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0Z1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgTGF5ZXJFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIGdldE1hdHJpeCh0aW1lKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIGlmICh0aW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFyIHByb3BNYXRyaXggPSB0aGlzLl9lbGVtLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBwcm9wTWF0cml4LmNsb25lKHRvV29ybGRNYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRyYW5zZm9ybU1hdCA9IHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3A7XG4gICAgICAgIHRyYW5zZm9ybU1hdC5hcHBseVRvTWF0cml4KHRvV29ybGRNYXQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRvV29ybGRNYXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHRvV29ybGRWZWMoYXJyLCB0aW1lKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IHRoaXMuZ2V0TWF0cml4KHRpbWUpO1xuICAgICAgdG9Xb3JsZE1hdC5wcm9wc1sxMl0gPSAwO1xuICAgICAgdG9Xb3JsZE1hdC5wcm9wc1sxM10gPSAwO1xuICAgICAgdG9Xb3JsZE1hdC5wcm9wc1sxNF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuYXBwbHlQb2ludCh0b1dvcmxkTWF0LCBhcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0b1dvcmxkKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHJldHVybiB0aGlzLmFwcGx5UG9pbnQodG9Xb3JsZE1hdCwgYXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbVdvcmxkVmVjKGFyciwgdGltZSkge1xuICAgICAgdmFyIHRvV29ybGRNYXQgPSB0aGlzLmdldE1hdHJpeCh0aW1lKTtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTJdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTNdID0gMDtcbiAgICAgIHRvV29ybGRNYXQucHJvcHNbMTRdID0gMDtcbiAgICAgIHJldHVybiB0aGlzLmludmVydFBvaW50KHRvV29ybGRNYXQsIGFycik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZyb21Xb3JsZChhcnIsIHRpbWUpIHtcbiAgICAgIHZhciB0b1dvcmxkTWF0ID0gdGhpcy5nZXRNYXRyaXgodGltZSk7XG4gICAgICByZXR1cm4gdGhpcy5pbnZlcnRQb2ludCh0b1dvcmxkTWF0LCBhcnIpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBhcHBseVBvaW50KG1hdHJpeCwgYXJyKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbS5oaWVyYXJjaHkgJiYgdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICB2YXIgbGVuID0gdGhpcy5fZWxlbS5oaWVyYXJjaHkubGVuZ3RoO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICB0aGlzLl9lbGVtLmhpZXJhcmNoeVtpXS5maW5hbFRyYW5zZm9ybS5tUHJvcC5hcHBseVRvTWF0cml4KG1hdHJpeCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBtYXRyaXguYXBwbHlUb1BvaW50QXJyYXkoYXJyWzBdLCBhcnJbMV0sIGFyclsyXSB8fCAwKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaW52ZXJ0UG9pbnQobWF0cml4LCBhcnIpIHtcbiAgICAgIGlmICh0aGlzLl9lbGVtLmhpZXJhcmNoeSAmJiB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgobWF0cml4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdHJpeC5pbnZlcnNlUG9pbnQoYXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZnJvbUNvbXAoYXJyKSB7XG4gICAgICB2YXIgdG9Xb3JsZE1hdCA9IG5ldyBNYXRyaXgoKTtcbiAgICAgIHRvV29ybGRNYXQucmVzZXQoKTtcbiAgICAgIHRoaXMuX2VsZW0uZmluYWxUcmFuc2Zvcm0ubVByb3AuYXBwbHlUb01hdHJpeCh0b1dvcmxkTWF0KTtcbiAgICAgIGlmICh0aGlzLl9lbGVtLmhpZXJhcmNoeSAmJiB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSB0aGlzLl9lbGVtLmhpZXJhcmNoeS5sZW5ndGg7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgIHRoaXMuX2VsZW0uaGllcmFyY2h5W2ldLmZpbmFsVHJhbnNmb3JtLm1Qcm9wLmFwcGx5VG9NYXRyaXgodG9Xb3JsZE1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvV29ybGRNYXQuaW52ZXJzZVBvaW50KGFycik7XG4gICAgICB9XG4gICAgICByZXR1cm4gdG9Xb3JsZE1hdC5pbnZlcnNlUG9pbnQoYXJyKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc2FtcGxlSW1hZ2UoKSB7XG4gICAgICByZXR1cm4gWzEsIDEsIDEsIDFdO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2U7XG4gICAgICBmdW5jdGlvbiBfcmVnaXN0ZXJNYXNrSW50ZXJmYWNlKG1hc2tNYW5hZ2VyKSB7XG4gICAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5tYXNrID0gbmV3IE1hc2tNYW5hZ2VySW50ZXJmYWNlKG1hc2tNYW5hZ2VyLCBlbGVtKTtcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF9yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2UoZWZmZWN0cykge1xuICAgICAgICBfdGhpc0xheWVyRnVuY3Rpb24uZWZmZWN0ID0gZWZmZWN0cztcbiAgICAgIH1cbiAgICAgIGZ1bmN0aW9uIF90aGlzTGF5ZXJGdW5jdGlvbihuYW1lKSB7XG4gICAgICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgICAgIGNhc2UgJ0FEQkUgUm9vdCBWZWN0b3JzIEdyb3VwJzpcbiAgICAgICAgICBjYXNlICdDb250ZW50cyc6XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5zaGFwZUludGVyZmFjZTtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGNhc2UgJ1RyYW5zZm9ybSc6XG4gICAgICAgICAgY2FzZSAndHJhbnNmb3JtJzpcbiAgICAgICAgICBjYXNlICdBREJFIFRyYW5zZm9ybSBHcm91cCc6XG4gICAgICAgICAgICByZXR1cm4gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBjYXNlICdBREJFIEVmZmVjdCBQYXJhZGUnOlxuICAgICAgICAgIGNhc2UgJ2VmZmVjdHMnOlxuICAgICAgICAgIGNhc2UgJ0VmZmVjdHMnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi5lZmZlY3Q7XG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IFByb3BlcnRpZXMnOlxuICAgICAgICAgICAgcmV0dXJuIF90aGlzTGF5ZXJGdW5jdGlvbi50ZXh0SW50ZXJmYWNlO1xuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmdldE1hdHJpeCA9IGdldE1hdHJpeDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5pbnZlcnRQb2ludCA9IGludmVydFBvaW50O1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmFwcGx5UG9pbnQgPSBhcHBseVBvaW50O1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvV29ybGQgPSB0b1dvcmxkO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnRvV29ybGRWZWMgPSB0b1dvcmxkVmVjO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmZyb21Xb3JsZCA9IGZyb21Xb3JsZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tV29ybGRWZWMgPSBmcm9tV29ybGRWZWM7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24udG9Db21wID0gdG9Xb3JsZDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5mcm9tQ29tcCA9IGZyb21Db21wO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnNhbXBsZUltYWdlID0gc2FtcGxlSW1hZ2U7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlUmVjdEF0VGltZSA9IGVsZW0uc291cmNlUmVjdEF0VGltZS5iaW5kKGVsZW0pO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLl9lbGVtID0gZWxlbTtcbiAgICAgIHRyYW5zZm9ybUludGVyZmFjZSA9IFRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UoZWxlbS5maW5hbFRyYW5zZm9ybS5tUHJvcCk7XG4gICAgICB2YXIgYW5jaG9yUG9pbnREZXNjcmlwdG9yID0gZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdhbmNob3JQb2ludCcpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoX3RoaXNMYXllckZ1bmN0aW9uLCB7XG4gICAgICAgIGhhc1BhcmVudDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uaGllcmFyY2h5Lmxlbmd0aDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHBhcmVudDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGVsZW0uaGllcmFyY2h5WzBdLmxheWVySW50ZXJmYWNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgcm90YXRpb246IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAncm90YXRpb24nKSxcbiAgICAgICAgc2NhbGU6IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAnc2NhbGUnKSxcbiAgICAgICAgcG9zaXRpb246IGdldERlc2NyaXB0b3IodHJhbnNmb3JtSW50ZXJmYWNlLCAncG9zaXRpb24nKSxcbiAgICAgICAgb3BhY2l0eTogZ2V0RGVzY3JpcHRvcih0cmFuc2Zvcm1JbnRlcmZhY2UsICdvcGFjaXR5JyksXG4gICAgICAgIGFuY2hvclBvaW50OiBhbmNob3JQb2ludERlc2NyaXB0b3IsXG4gICAgICAgIGFuY2hvcl9wb2ludDogYW5jaG9yUG9pbnREZXNjcmlwdG9yLFxuICAgICAgICB0cmFuc2Zvcm06IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cmFuc2Zvcm1JbnRlcmZhY2U7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhY3RpdmU6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBlbGVtLmlzSW5SYW5nZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnN0YXJ0VGltZSA9IGVsZW0uZGF0YS5zdDtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5pbmRleCA9IGVsZW0uZGF0YS5pbmQ7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlID0gZWxlbS5kYXRhLnJlZklkO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLmhlaWdodCA9IGVsZW0uZGF0YS50eSA9PT0gMCA/IGVsZW0uZGF0YS5oIDogMTAwO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLndpZHRoID0gZWxlbS5kYXRhLnR5ID09PSAwID8gZWxlbS5kYXRhLncgOiAxMDA7XG4gICAgICBfdGhpc0xheWVyRnVuY3Rpb24uaW5Qb2ludCA9IGVsZW0uZGF0YS5pcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5vdXRQb2ludCA9IGVsZW0uZGF0YS5vcCAvIGVsZW0uY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5fbmFtZSA9IGVsZW0uZGF0YS5ubTtcbiAgICAgIF90aGlzTGF5ZXJGdW5jdGlvbi5yZWdpc3Rlck1hc2tJbnRlcmZhY2UgPSBfcmVnaXN0ZXJNYXNrSW50ZXJmYWNlO1xuICAgICAgX3RoaXNMYXllckZ1bmN0aW9uLnJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZSA9IF9yZWdpc3RlckVmZmVjdHNJbnRlcmZhY2U7XG4gICAgICByZXR1cm4gX3RoaXNMYXllckZ1bmN0aW9uO1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgcHJvcGVydHlHcm91cEZhY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChpbnRlcmZhY2VGdW5jdGlvbiwgcGFyZW50UHJvcGVydHlHcm91cCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgdmFsID0gdmFsID09PSB1bmRlZmluZWQgPyAxIDogdmFsO1xuICAgICAgICBpZiAodmFsIDw9IDApIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmVudFByb3BlcnR5R3JvdXAodmFsIC0gMSk7XG4gICAgICB9O1xuICAgIH07XG4gIH0oKTtcblxuICB2YXIgUHJvcGVydHlJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChwcm9wZXJ0eU5hbWUsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBpbnRlcmZhY2VGdW5jdGlvbiA9IHtcbiAgICAgICAgX25hbWU6IHByb3BlcnR5TmFtZVxuICAgICAgfTtcbiAgICAgIGZ1bmN0aW9uIF9wcm9wZXJ0eUdyb3VwKHZhbCkge1xuICAgICAgICB2YWwgPSB2YWwgPT09IHVuZGVmaW5lZCA/IDEgOiB2YWw7XG4gICAgICAgIGlmICh2YWwgPD0gMCkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cCh2YWwgLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBfcHJvcGVydHlHcm91cDtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIEVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBvYiA9IHtcbiAgICAgIGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2U6IGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2VcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUVmZmVjdHNJbnRlcmZhY2UoZWxlbSwgcHJvcGVydHlHcm91cCkge1xuICAgICAgaWYgKGVsZW0uZWZmZWN0c01hbmFnZXIpIHtcbiAgICAgICAgdmFyIGVmZmVjdEVsZW1lbnRzID0gW107XG4gICAgICAgIHZhciBlZmZlY3RzRGF0YSA9IGVsZW0uZGF0YS5lZjtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIHZhciBsZW4gPSBlbGVtLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzLmxlbmd0aDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgZWZmZWN0RWxlbWVudHMucHVzaChjcmVhdGVHcm91cEludGVyZmFjZShlZmZlY3RzRGF0YVtpXSwgZWxlbS5lZmZlY3RzTWFuYWdlci5lZmZlY3RFbGVtZW50c1tpXSwgcHJvcGVydHlHcm91cCwgZWxlbSkpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBlZmZlY3RzID0gZWxlbS5kYXRhLmVmIHx8IFtdO1xuICAgICAgICB2YXIgZ3JvdXBJbnRlcmZhY2UgPSBmdW5jdGlvbiBncm91cEludGVyZmFjZShuYW1lKSB7XG4gICAgICAgICAgaSA9IDA7XG4gICAgICAgICAgbGVuID0gZWZmZWN0cy5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSBlZmZlY3RzW2ldLm5tIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0ubW4gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5peCkge1xuICAgICAgICAgICAgICByZXR1cm4gZWZmZWN0RWxlbWVudHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpICs9IDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9O1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ3JvdXBJbnRlcmZhY2UsICdudW1Qcm9wZXJ0aWVzJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdHMubGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBncm91cEludGVyZmFjZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVHcm91cEludGVyZmFjZShkYXRhLCBlbGVtZW50cywgcHJvcGVydHlHcm91cCwgZWxlbSkge1xuICAgICAgZnVuY3Rpb24gZ3JvdXBJbnRlcmZhY2UobmFtZSkge1xuICAgICAgICB2YXIgZWZmZWN0cyA9IGRhdGEuZWY7XG4gICAgICAgIHZhciBpID0gMDtcbiAgICAgICAgdmFyIGxlbiA9IGVmZmVjdHMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmIChuYW1lID09PSBlZmZlY3RzW2ldLm5tIHx8IG5hbWUgPT09IGVmZmVjdHNbaV0ubW4gfHwgbmFtZSA9PT0gZWZmZWN0c1tpXS5peCkge1xuICAgICAgICAgICAgaWYgKGVmZmVjdHNbaV0udHkgPT09IDUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzW2ldKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGkgKz0gMTtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoKTtcbiAgICAgIH1cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGdyb3VwSW50ZXJmYWNlLCBwcm9wZXJ0eUdyb3VwKTtcbiAgICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gZGF0YS5lZi5sZW5ndGg7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGRhdGEuZWZbaV0udHkgPT09IDUpIHtcbiAgICAgICAgICBlZmZlY3RFbGVtZW50cy5wdXNoKGNyZWF0ZUdyb3VwSW50ZXJmYWNlKGRhdGEuZWZbaV0sIGVsZW1lbnRzLmVmZmVjdEVsZW1lbnRzW2ldLCBlbGVtZW50cy5lZmZlY3RFbGVtZW50c1tpXS5wcm9wZXJ0eUdyb3VwLCBlbGVtKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWZmZWN0RWxlbWVudHMucHVzaChjcmVhdGVWYWx1ZUludGVyZmFjZShlbGVtZW50cy5lZmZlY3RFbGVtZW50c1tpXSwgZGF0YS5lZltpXS50eSwgZWxlbSwgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGRhdGEubW4gPT09ICdBREJFIENvbG9yIENvbnRyb2wnKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShncm91cEludGVyZmFjZSwgJ2NvbG9yJywge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGVmZmVjdEVsZW1lbnRzWzBdKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGdyb3VwSW50ZXJmYWNlLCB7XG4gICAgICAgIG51bVByb3BlcnRpZXM6IHtcbiAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLm5wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogZGF0YS5ubVxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IF9wcm9wZXJ0eUdyb3VwXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgZ3JvdXBJbnRlcmZhY2UuZW5hYmxlZCA9IGRhdGEuZW4gIT09IDA7XG4gICAgICBncm91cEludGVyZmFjZS5hY3RpdmUgPSBncm91cEludGVyZmFjZS5lbmFibGVkO1xuICAgICAgcmV0dXJuIGdyb3VwSW50ZXJmYWNlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjcmVhdGVWYWx1ZUludGVyZmFjZShlbGVtZW50LCB0eXBlLCBlbGVtLCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgZXhwcmVzc2lvblByb3BlcnR5ID0gRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKGVsZW1lbnQucCk7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHR5cGUgPT09IDEwKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW0uY29tcC5jb21wSW50ZXJmYWNlKGVsZW1lbnQucC52KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhwcmVzc2lvblByb3BlcnR5KCk7XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudC5wLnNldEdyb3VwUHJvcGVydHkpIHtcbiAgICAgICAgZWxlbWVudC5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJycsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIG9iO1xuICB9KCk7XG5cbiAgdmFyIFNoYXBlUGF0aEludGVyZmFjZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gcGF0aEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBwcm9wID0gdmlldy5zaDtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAodmFsID09PSAnU2hhcGUnIHx8IHZhbCA9PT0gJ3NoYXBlJyB8fCB2YWwgPT09ICdQYXRoJyB8fCB2YWwgPT09ICdwYXRoJyB8fCB2YWwgPT09ICdBREJFIFZlY3RvciBTaGFwZScgfHwgdmFsID09PSAyKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1BhdGgnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgcGF0aDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgaWYgKHByb3Auaykge1xuICAgICAgICAgICAgICBwcm9wLmdldFZhbHVlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcHJvcDtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHNoYXBlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgICAgICAgIHByb3AuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwcm9wO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgaXg6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUuaXhcbiAgICAgICAgfSxcbiAgICAgICAgcHJvcGVydHlJbmRleDoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5peFxuICAgICAgICB9LFxuICAgICAgICBtbjoge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5tblxuICAgICAgICB9LFxuICAgICAgICBwcm9wZXJ0eUdyb3VwOiB7XG4gICAgICAgICAgdmFsdWU6IHByb3BlcnR5R3JvdXBcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBTaGFwZUV4cHJlc3Npb25JbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlcywgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGFyciA9IFtdO1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuID0gc2hhcGVzID8gc2hhcGVzLmxlbmd0aCA6IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2dyJykge1xuICAgICAgICAgIGFyci5wdXNoKGdyb3VwSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdmbCcpIHtcbiAgICAgICAgICBhcnIucHVzaChmaWxsSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdzdCcpIHtcbiAgICAgICAgICBhcnIucHVzaChzdHJva2VJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3RtJykge1xuICAgICAgICAgIGFyci5wdXNoKHRyaW1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3RyJykge1xuICAgICAgICAgIC8vIGFyci5wdXNoKHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLHZpZXdbaV0scHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ2VsJykge1xuICAgICAgICAgIGFyci5wdXNoKGVsbGlwc2VJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3NyJykge1xuICAgICAgICAgIGFyci5wdXNoKHN0YXJJbnRlcmZhY2VGYWN0b3J5KHNoYXBlc1tpXSwgdmlld1tpXSwgcHJvcGVydHlHcm91cCkpO1xuICAgICAgICB9IGVsc2UgaWYgKHNoYXBlc1tpXS50eSA9PT0gJ3NoJykge1xuICAgICAgICAgIGFyci5wdXNoKFNoYXBlUGF0aEludGVyZmFjZShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdyYycpIHtcbiAgICAgICAgICBhcnIucHVzaChyZWN0SW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdyZCcpIHtcbiAgICAgICAgICBhcnIucHVzaChyb3VuZGVkSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIGlmIChzaGFwZXNbaV0udHkgPT09ICdycCcpIHtcbiAgICAgICAgICBhcnIucHVzaChyZXBlYXRlckludGVyZmFjZUZhY3Rvcnkoc2hhcGVzW2ldLCB2aWV3W2ldLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc2hhcGVzW2ldLnR5ID09PSAnZ2YnKSB7XG4gICAgICAgICAgYXJyLnB1c2goZ3JhZGllbnRGaWxsSW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhcnIucHVzaChkZWZhdWx0SW50ZXJmYWNlRmFjdG9yeShzaGFwZXNbaV0sIHZpZXdbaV0sIHByb3BlcnR5R3JvdXApKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgZnVuY3Rpb24gY29udGVudHNJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgaW50ZXJmYWNlcztcbiAgICAgIHZhciBpbnRlcmZhY2VGdW5jdGlvbiA9IGZ1bmN0aW9uIF9pbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBpbnRlcmZhY2VzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICAgICAgICBpZiAoaW50ZXJmYWNlc1tpXS5fbmFtZSA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5tbiA9PT0gdmFsdWUgfHwgaW50ZXJmYWNlc1tpXS5wcm9wZXJ0eUluZGV4ID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLml4ID09PSB2YWx1ZSB8fCBpbnRlcmZhY2VzW2ldLmluZCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW2ldO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1t2YWx1ZSAtIDFdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VzID0gaXRlcmF0ZUVsZW1lbnRzKHNoYXBlLml0LCB2aWV3Lml0LCBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm51bVByb3BlcnRpZXMgPSBpbnRlcmZhY2VzLmxlbmd0aDtcbiAgICAgIHZhciB0cmFuc2Zvcm1JbnRlcmZhY2UgPSB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLml0W3NoYXBlLml0Lmxlbmd0aCAtIDFdLCB2aWV3Lml0W3ZpZXcuaXQubGVuZ3RoIC0gMV0sIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24udHJhbnNmb3JtID0gdHJhbnNmb3JtSW50ZXJmYWNlO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLmNpeDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gc2hhcGUubm07XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdyb3VwSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgdmFyIGludGVyZmFjZUZ1bmN0aW9uID0gZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICBjYXNlICdBREJFIFZlY3RvcnMgR3JvdXAnOlxuICAgICAgICAgIGNhc2UgJ0NvbnRlbnRzJzpcbiAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29udGVudDtcbiAgICAgICAgICAvLyBOb3QgbmVjZXNzYXJ5IGZvciBub3cuIEtlZXBpbmcgdGhlbSBoZXJlIGluIGNhc2UgYSBuZXcgY2FzZSBhcHBlYXJzXG4gICAgICAgICAgLy8gY2FzZSAnQURCRSBWZWN0b3IgVHJhbnNmb3JtIEdyb3VwJzpcbiAgICAgICAgICAvLyBjYXNlIDM6XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi50cmFuc2Zvcm07XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIGNvbnRlbnQgPSBjb250ZW50c0ludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIHRyYW5zZm9ybUludGVyZmFjZSA9IHRyYW5zZm9ybUludGVyZmFjZUZhY3Rvcnkoc2hhcGUuaXRbc2hhcGUuaXQubGVuZ3RoIC0gMV0sIHZpZXcuaXRbdmlldy5pdC5sZW5ndGggLSAxXSwgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlHcm91cCk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5jb250ZW50ID0gY29udGVudDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnRyYW5zZm9ybSA9IHRyYW5zZm9ybUludGVyZmFjZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnRlcmZhY2VGdW5jdGlvbiwgJ19uYW1lJywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICByZXR1cm4gc2hhcGUubm07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgLy8gaW50ZXJmYWNlRnVuY3Rpb24uY29udGVudCA9IGludGVyZmFjZUZ1bmN0aW9uO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubnVtUHJvcGVydGllcyA9IHNoYXBlLm5wO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubm0gPSBzaGFwZS5ubTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZpbGxJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ0NvbG9yJyB8fCB2YWwgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gJ09wYWNpdHknIHx8IHZhbCA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBjb2xvcjoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuYylcbiAgICAgICAgfSxcbiAgICAgICAgb3BhY2l0eToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgbW46IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2aWV3LmMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQ29sb3InLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3Lm8uc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIHByb3BlcnR5R3JvdXApKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ3JhZGllbnRGaWxsSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09ICdTdGFydCBQb2ludCcgfHwgdmFsID09PSAnc3RhcnQgcG9pbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnN0YXJ0UG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gJ0VuZCBQb2ludCcgfHwgdmFsID09PSAnZW5kIHBvaW50Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5lbmRQb2ludDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09PSAnT3BhY2l0eScgfHwgdmFsID09PSAnb3BhY2l0eScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub3BhY2l0eTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHN0YXJ0UG9pbnQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnMpXG4gICAgICAgIH0sXG4gICAgICAgIGVuZFBvaW50OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5lKVxuICAgICAgICB9LFxuICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5vKVxuICAgICAgICB9LFxuICAgICAgICB0eXBlOiB7XG4gICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2EnO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfSxcbiAgICAgICAgbW46IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubW5cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB2aWV3LnMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU3RhcnQgUG9pbnQnLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LmUuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnRW5kIFBvaW50JywgcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09wYWNpdHknLCBwcm9wZXJ0eUdyb3VwKSk7XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlZmF1bHRJbnRlcmZhY2VGYWN0b3J5KCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiBzdHJva2VJbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICB2YXIgX2Rhc2hQcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoZGFzaE9iLCBfcHJvcGVydHlHcm91cCk7XG4gICAgICBmdW5jdGlvbiBhZGRQcm9wZXJ0eVRvRGFzaE9iKGkpIHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRhc2hPYiwgc2hhcGUuZFtpXS5ubSwge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcuZC5kYXRhUHJvcHNbaV0ucClcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW4gPSBzaGFwZS5kID8gc2hhcGUuZC5sZW5ndGggOiAwO1xuICAgICAgdmFyIGRhc2hPYiA9IHt9O1xuICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgIGFkZFByb3BlcnR5VG9EYXNoT2IoaSk7XG4gICAgICAgIHZpZXcuZC5kYXRhUHJvcHNbaV0ucC5zZXRHcm91cFByb3BlcnR5KF9kYXNoUHJvcGVydHlHcm91cCk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWwpIHtcbiAgICAgICAgaWYgKHZhbCA9PT0gJ0NvbG9yJyB8fCB2YWwgPT09ICdjb2xvcicpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uY29sb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gJ09wYWNpdHknIHx8IHZhbCA9PT0gJ29wYWNpdHknKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbCA9PT0gJ1N0cm9rZSBXaWR0aCcgfHwgdmFsID09PSAnc3Ryb2tlIHdpZHRoJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zdHJva2VXaWR0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIGNvbG9yOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5jKVxuICAgICAgICB9LFxuICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5vKVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2VXaWR0aDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcudylcbiAgICAgICAgfSxcbiAgICAgICAgZGFzaDoge1xuICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIGRhc2hPYjtcbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH0sXG4gICAgICAgIG1uOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm1uXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgdmlldy5jLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0NvbG9yJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTdHJva2UgV2lkdGgnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmltSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsKSB7XG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLmUuaXggfHwgdmFsID09PSAnRW5kJyB8fCB2YWwgPT09ICdlbmQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmVuZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsID09PSBzaGFwZS5zLml4KSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnN0YXJ0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWwgPT09IHNoYXBlLm8uaXgpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ub2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ucHJvcGVydHlJbmRleCA9IHNoYXBlLml4O1xuICAgICAgdmlldy5zLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1N0YXJ0JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcuZS5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdFbmQnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgdmlldy5vLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ09mZnNldCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGludGVyZmFjZUZ1bmN0aW9uLCB7XG4gICAgICAgIHN0YXJ0OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy5zKVxuICAgICAgICB9LFxuICAgICAgICBlbmQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LmUpXG4gICAgICAgIH0sXG4gICAgICAgIG9mZnNldDoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHZpZXcubylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm1JbnRlcmZhY2VGYWN0b3J5KHNoYXBlLCB2aWV3LCBwcm9wZXJ0eUdyb3VwKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAoc2hhcGUuYS5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdBbmNob3IgUG9pbnQnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmFuY2hvclBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZS5vLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ09wYWNpdHknKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlLnAuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnUG9zaXRpb24nKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnBvc2l0aW9uO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZS5yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1JvdGF0aW9uJyB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFJvdGF0aW9uJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yb3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGUucy5peCA9PT0gdmFsdWUgfHwgdmFsdWUgPT09ICdTY2FsZScpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2NhbGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlLnNrICYmIHNoYXBlLnNrLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NrZXcnKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLnNrZXc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlLnNhICYmIHNoYXBlLnNhLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NrZXcgQXhpcycpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2tld0F4aXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPcGFjaXR5JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5wLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1Bvc2l0aW9uJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5hLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ0FuY2hvciBQb2ludCcsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMucy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTY2FsZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICB2aWV3LnRyYW5zZm9ybS5tUHJvcHMuci5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdSb3RhdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBpZiAodmlldy50cmFuc2Zvcm0ubVByb3BzLnNrKSB7XG4gICAgICAgIHZpZXcudHJhbnNmb3JtLm1Qcm9wcy5zay5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdTa2V3JywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgICAgdmlldy50cmFuc2Zvcm0ubVByb3BzLnNhLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1NrZXcgQW5nbGUnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuICAgICAgdmlldy50cmFuc2Zvcm0ub3Auc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3BhY2l0eScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICBvcGFjaXR5OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLm8pXG4gICAgICAgIH0sXG4gICAgICAgIHBvc2l0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnApXG4gICAgICAgIH0sXG4gICAgICAgIGFuY2hvclBvaW50OiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLmEpXG4gICAgICAgIH0sXG4gICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnMpXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnIpXG4gICAgICAgIH0sXG4gICAgICAgIHNrZXc6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZSh2aWV3LnRyYW5zZm9ybS5tUHJvcHMuc2spXG4gICAgICAgIH0sXG4gICAgICAgIHNrZXdBeGlzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2Uodmlldy50cmFuc2Zvcm0ubVByb3BzLnNhKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnR5ID0gJ3RyJztcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cDtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gZWxsaXBzZUludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGUucy5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24uc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIHZhciBfcHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXBGYWN0b3J5KGludGVyZmFjZUZ1bmN0aW9uLCBwcm9wZXJ0eUdyb3VwKTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHZhciBwcm9wID0gdmlldy5zaC50eSA9PT0gJ3RtJyA/IHZpZXcuc2gucHJvcCA6IHZpZXcuc2g7XG4gICAgICBwcm9wLnMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2l6ZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnAuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9zaXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucylcbiAgICAgICAgfSxcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnApXG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3RhckludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm90YXRpb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlLnB0Lml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb2ludHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlLm9yLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ0FEQkUgVmVjdG9yIFN0YXIgT3V0ZXIgUmFkaXVzJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRlclJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGUub3MuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLm91dGVyUm91bmRuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZS5pciAmJiAoc2hhcGUuaXIuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQURCRSBWZWN0b3IgU3RhciBJbm5lciBSYWRpdXMnKSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5pbm5lclJhZGl1cztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGUuaXMgJiYgc2hhcGUuaXMuaXggPT09IHZhbHVlKSB7XG4gICAgICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uLmlubmVyUm91bmRuZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoLnR5ID09PSAndG0nID8gdmlldy5zaC5wcm9wIDogdmlldy5zaDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHByb3Aub3Iuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3V0ZXIgUmFkaXVzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Aub3Muc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnT3V0ZXIgUm91bmRuZXNzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3AucHQuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUG9pbnRzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQb3NpdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnIuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUm90YXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgaWYgKHNoYXBlLmlyKSB7XG4gICAgICAgIHByb3AuaXIuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnSW5uZXIgUmFkaXVzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgICAgcHJvcC5pcy5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdJbm5lciBSb3VuZG5lc3MnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgfVxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnApXG4gICAgICAgIH0sXG4gICAgICAgIHJvdGF0aW9uOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5yKVxuICAgICAgICB9LFxuICAgICAgICBwb2ludHM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnB0KVxuICAgICAgICB9LFxuICAgICAgICBvdXRlclJhZGl1czoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3Aub3IpXG4gICAgICAgIH0sXG4gICAgICAgIG91dGVyUm91bmRuZXNzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5vcylcbiAgICAgICAgfSxcbiAgICAgICAgaW5uZXJSYWRpdXM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLmlyKVxuICAgICAgICB9LFxuICAgICAgICBpbm5lclJvdW5kbmVzczoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AuaXMpXG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjdEludGVyZmFjZUZhY3Rvcnkoc2hhcGUsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIGZ1bmN0aW9uIGludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChzaGFwZS5wLml4ID09PSB2YWx1ZSkge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5wb3NpdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2hhcGUuci5peCA9PT0gdmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb24ucm91bmRuZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzaGFwZS5zLml4ID09PSB2YWx1ZSB8fCB2YWx1ZSA9PT0gJ1NpemUnIHx8IHZhbHVlID09PSAnQURCRSBWZWN0b3IgUmVjdCBTaXplJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5zaXplO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgdmFyIF9wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoaW50ZXJmYWNlRnVuY3Rpb24sIHByb3BlcnR5R3JvdXApO1xuICAgICAgdmFyIHByb3AgPSB2aWV3LnNoLnR5ID09PSAndG0nID8gdmlldy5zaC5wcm9wIDogdmlldy5zaDtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLnByb3BlcnR5SW5kZXggPSBzaGFwZS5peDtcbiAgICAgIHByb3AucC5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdQb3NpdGlvbicsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnU2l6ZScsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBwcm9wLnIuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnUm90YXRpb24nLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgcG9zaXRpb246IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnApXG4gICAgICAgIH0sXG4gICAgICAgIHJvdW5kbmVzczoge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucilcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIGdldDogRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlKHByb3AucylcbiAgICAgICAgfSxcbiAgICAgICAgX25hbWU6IHtcbiAgICAgICAgICB2YWx1ZTogc2hhcGUubm1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5tbiA9IHNoYXBlLm1uO1xuICAgICAgcmV0dXJuIGludGVyZmFjZUZ1bmN0aW9uO1xuICAgIH1cbiAgICBmdW5jdGlvbiByb3VuZGVkSW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNoYXBlLnIuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnUm91bmQgQ29ybmVycyAxJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5yYWRpdXM7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICB2YXIgcHJvcCA9IHZpZXc7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBwcm9wLnJkLnNldEdyb3VwUHJvcGVydHkoUHJvcGVydHlJbnRlcmZhY2UoJ1JhZGl1cycsIF9wcm9wZXJ0eUdyb3VwKSk7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnRlcmZhY2VGdW5jdGlvbiwge1xuICAgICAgICByYWRpdXM6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLnJkKVxuICAgICAgICB9LFxuICAgICAgICBfbmFtZToge1xuICAgICAgICAgIHZhbHVlOiBzaGFwZS5ubVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm1uID0gc2hhcGUubW47XG4gICAgICByZXR1cm4gaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJlcGVhdGVySW50ZXJmYWNlRmFjdG9yeShzaGFwZSwgdmlldywgcHJvcGVydHlHcm91cCkge1xuICAgICAgZnVuY3Rpb24gaW50ZXJmYWNlRnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgaWYgKHNoYXBlLmMuaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnQ29waWVzJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5jb3BpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNoYXBlLm8uaXggPT09IHZhbHVlIHx8IHZhbHVlID09PSAnT2Zmc2V0Jykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vZmZzZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB2YXIgX3Byb3BlcnR5R3JvdXAgPSBwcm9wZXJ0eUdyb3VwRmFjdG9yeShpbnRlcmZhY2VGdW5jdGlvbiwgcHJvcGVydHlHcm91cCk7XG4gICAgICB2YXIgcHJvcCA9IHZpZXc7XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUluZGV4ID0gc2hhcGUuaXg7XG4gICAgICBwcm9wLmMuc2V0R3JvdXBQcm9wZXJ0eShQcm9wZXJ0eUludGVyZmFjZSgnQ29waWVzJywgX3Byb3BlcnR5R3JvdXApKTtcbiAgICAgIHByb3Auby5zZXRHcm91cFByb3BlcnR5KFByb3BlcnR5SW50ZXJmYWNlKCdPZmZzZXQnLCBfcHJvcGVydHlHcm91cCkpO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW50ZXJmYWNlRnVuY3Rpb24sIHtcbiAgICAgICAgY29waWVzOiB7XG4gICAgICAgICAgZ2V0OiBFeHByZXNzaW9uUHJvcGVydHlJbnRlcmZhY2UocHJvcC5jKVxuICAgICAgICB9LFxuICAgICAgICBvZmZzZXQ6IHtcbiAgICAgICAgICBnZXQ6IEV4cHJlc3Npb25Qcm9wZXJ0eUludGVyZmFjZShwcm9wLm8pXG4gICAgICAgIH0sXG4gICAgICAgIF9uYW1lOiB7XG4gICAgICAgICAgdmFsdWU6IHNoYXBlLm5tXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgaW50ZXJmYWNlRnVuY3Rpb24ubW4gPSBzaGFwZS5tbjtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChzaGFwZXMsIHZpZXcsIHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHZhciBpbnRlcmZhY2VzO1xuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gMSA6IHZhbHVlO1xuICAgICAgICAgIGlmICh2YWx1ZSA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3BlcnR5R3JvdXA7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VzW3ZhbHVlIC0gMV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGkgPSAwO1xuICAgICAgICB2YXIgbGVuID0gaW50ZXJmYWNlcy5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICAgICAgaWYgKGludGVyZmFjZXNbaV0uX25hbWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaW50ZXJmYWNlc1tpXTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaSArPSAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGFyZW50R3JvdXBXcmFwcGVyKCkge1xuICAgICAgICByZXR1cm4gcHJvcGVydHlHcm91cDtcbiAgICAgIH1cbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwID0gcHJvcGVydHlHcm91cEZhY3RvcnkoX2ludGVyZmFjZUZ1bmN0aW9uLCBwYXJlbnRHcm91cFdyYXBwZXIpO1xuICAgICAgaW50ZXJmYWNlcyA9IGl0ZXJhdGVFbGVtZW50cyhzaGFwZXMsIHZpZXcsIF9pbnRlcmZhY2VGdW5jdGlvbi5wcm9wZXJ0eUdyb3VwKTtcbiAgICAgIF9pbnRlcmZhY2VGdW5jdGlvbi5udW1Qcm9wZXJ0aWVzID0gaW50ZXJmYWNlcy5sZW5ndGg7XG4gICAgICBfaW50ZXJmYWNlRnVuY3Rpb24uX25hbWUgPSAnQ29udGVudHMnO1xuICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIFRleHRFeHByZXNzaW9uSW50ZXJmYWNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgdmFyIF9zb3VyY2VUZXh0O1xuICAgICAgZnVuY3Rpb24gX3RoaXNMYXllckZ1bmN0aW9uKG5hbWUpIHtcbiAgICAgICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICAgICAgY2FzZSAnQURCRSBUZXh0IERvY3VtZW50JzpcbiAgICAgICAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb24uc291cmNlVGV4dDtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShfdGhpc0xheWVyRnVuY3Rpb24sICdzb3VyY2VUZXh0Jywge1xuICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICBlbGVtLnRleHRQcm9wZXJ0eS5nZXRWYWx1ZSgpO1xuICAgICAgICAgIHZhciBzdHJpbmdWYWx1ZSA9IGVsZW0udGV4dFByb3BlcnR5LmN1cnJlbnREYXRhLnQ7XG4gICAgICAgICAgaWYgKCFfc291cmNlVGV4dCB8fCBzdHJpbmdWYWx1ZSAhPT0gX3NvdXJjZVRleHQudmFsdWUpIHtcbiAgICAgICAgICAgIF9zb3VyY2VUZXh0ID0gbmV3IFN0cmluZyhzdHJpbmdWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgICAgICAgICAvLyBJZiBzdHJpbmdWYWx1ZSBpcyBhbiBlbXB0eSBzdHJpbmcsIGV2YWwgcmV0dXJucyB1bmRlZmluZWQsIHNvIGl0IGhhcyB0byBiZSByZXR1cm5lZCBhcyBhIFN0cmluZyBwcmltaXRpdmVcbiAgICAgICAgICAgIF9zb3VyY2VUZXh0LnZhbHVlID0gc3RyaW5nVmFsdWUgfHwgbmV3IFN0cmluZyhzdHJpbmdWYWx1ZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoX3NvdXJjZVRleHQsICdzdHlsZScsIHtcbiAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgIGZpbGxDb2xvcjogZWxlbS50ZXh0UHJvcGVydHkuY3VycmVudERhdGEuZmNcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIF9zb3VyY2VUZXh0O1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiBfdGhpc0xheWVyRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIF90eXBlb2YobykgeyBcIkBiYWJlbC9oZWxwZXJzIC0gdHlwZW9mXCI7IHJldHVybiBfdHlwZW9mID0gXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgXCJzeW1ib2xcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG8pIHsgcmV0dXJuIHR5cGVvZiBvOyB9IDogZnVuY3Rpb24gKG8pIHsgcmV0dXJuIG8gJiYgXCJmdW5jdGlvblwiID09IHR5cGVvZiBTeW1ib2wgJiYgby5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG8gIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG87IH0sIF90eXBlb2Yobyk7IH1cbiAgdmFyIEZvb3RhZ2VJbnRlcmZhY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIG91dGxpbmVJbnRlcmZhY2VGYWN0b3J5ID0gZnVuY3Rpb24gb3V0bGluZUludGVyZmFjZUZhY3RvcnkoZWxlbSkge1xuICAgICAgdmFyIGN1cnJlbnRQcm9wZXJ0eU5hbWUgPSAnJztcbiAgICAgIHZhciBjdXJyZW50UHJvcGVydHkgPSBlbGVtLmdldEZvb3RhZ2VEYXRhKCk7XG4gICAgICBmdW5jdGlvbiBpbml0KCkge1xuICAgICAgICBjdXJyZW50UHJvcGVydHlOYW1lID0gJyc7XG4gICAgICAgIGN1cnJlbnRQcm9wZXJ0eSA9IGVsZW0uZ2V0Rm9vdGFnZURhdGEoKTtcbiAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gc2VhcmNoUHJvcGVydHkodmFsdWUpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRQcm9wZXJ0eVt2YWx1ZV0pIHtcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHlOYW1lID0gdmFsdWU7XG4gICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5W3ZhbHVlXTtcbiAgICAgICAgICBpZiAoX3R5cGVvZihjdXJyZW50UHJvcGVydHkpID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgcmV0dXJuIHNlYXJjaFByb3BlcnR5O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gY3VycmVudFByb3BlcnR5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwcm9wZXJ0eU5hbWVJbmRleCA9IHZhbHVlLmluZGV4T2YoY3VycmVudFByb3BlcnR5TmFtZSk7XG4gICAgICAgIGlmIChwcm9wZXJ0eU5hbWVJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXJzZUludCh2YWx1ZS5zdWJzdHIocHJvcGVydHlOYW1lSW5kZXggKyBjdXJyZW50UHJvcGVydHlOYW1lLmxlbmd0aCksIDEwKTtcbiAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHlbaW5kZXhdO1xuICAgICAgICAgIGlmIChfdHlwZW9mKGN1cnJlbnRQcm9wZXJ0eSkgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VhcmNoUHJvcGVydHk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBjdXJyZW50UHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICcnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluaXQ7XG4gICAgfTtcbiAgICB2YXIgZGF0YUludGVyZmFjZUZhY3RvcnkgPSBmdW5jdGlvbiBkYXRhSW50ZXJmYWNlRmFjdG9yeShlbGVtKSB7XG4gICAgICBmdW5jdGlvbiBpbnRlcmZhY2VGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgPT09ICdPdXRsaW5lJykge1xuICAgICAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbi5vdXRsaW5lSW50ZXJmYWNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBpbnRlcmZhY2VGdW5jdGlvbi5fbmFtZSA9ICdPdXRsaW5lJztcbiAgICAgIGludGVyZmFjZUZ1bmN0aW9uLm91dGxpbmVJbnRlcmZhY2UgPSBvdXRsaW5lSW50ZXJmYWNlRmFjdG9yeShlbGVtKTtcbiAgICAgIHJldHVybiBpbnRlcmZhY2VGdW5jdGlvbjtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbiAoZWxlbSkge1xuICAgICAgZnVuY3Rpb24gX2ludGVyZmFjZUZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gJ0RhdGEnKSB7XG4gICAgICAgICAgcmV0dXJuIF9pbnRlcmZhY2VGdW5jdGlvbi5kYXRhSW50ZXJmYWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgX2ludGVyZmFjZUZ1bmN0aW9uLl9uYW1lID0gJ0RhdGEnO1xuICAgICAgX2ludGVyZmFjZUZ1bmN0aW9uLmRhdGFJbnRlcmZhY2UgPSBkYXRhSW50ZXJmYWNlRmFjdG9yeShlbGVtKTtcbiAgICAgIHJldHVybiBfaW50ZXJmYWNlRnVuY3Rpb247XG4gICAgfTtcbiAgfSgpO1xuXG4gIHZhciBpbnRlcmZhY2VzID0ge1xuICAgIGxheWVyOiBMYXllckV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgZWZmZWN0czogRWZmZWN0c0V4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgY29tcDogQ29tcEV4cHJlc3Npb25JbnRlcmZhY2UsXG4gICAgc2hhcGU6IFNoYXBlRXhwcmVzc2lvbkludGVyZmFjZSxcbiAgICB0ZXh0OiBUZXh0RXhwcmVzc2lvbkludGVyZmFjZSxcbiAgICBmb290YWdlOiBGb290YWdlSW50ZXJmYWNlXG4gIH07XG4gIGZ1bmN0aW9uIGdldEludGVyZmFjZSh0eXBlKSB7XG4gICAgcmV0dXJuIGludGVyZmFjZXNbdHlwZV0gfHwgbnVsbDtcbiAgfVxuXG4gIHZhciBleHByZXNzaW9uSGVscGVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBzZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLCBwcm9wKSB7XG4gICAgICBpZiAoZGF0YS54KSB7XG4gICAgICAgIHByb3AuayA9IHRydWU7XG4gICAgICAgIHByb3AueCA9IHRydWU7XG4gICAgICAgIHByb3AuaW5pdGlhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uO1xuICAgICAgICBwcm9wLmVmZmVjdHNTZXF1ZW5jZS5wdXNoKHByb3AuaW5pdGlhdGVFeHByZXNzaW9uKGVsZW0sIGRhdGEsIHByb3ApLmJpbmQocHJvcCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRWYWx1ZUF0VGltZShmcmFtZU51bSkge1xuICAgICAgZnJhbWVOdW0gKj0gdGhpcy5lbGVtLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgZnJhbWVOdW0gLT0gdGhpcy5vZmZzZXRUaW1lO1xuICAgICAgaWYgKGZyYW1lTnVtICE9PSB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA9IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdEZyYW1lIDwgZnJhbWVOdW0gPyB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA6IDA7XG4gICAgICAgIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWUgPSB0aGlzLmludGVycG9sYXRlVmFsdWUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUpO1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RGcmFtZSA9IGZyYW1lTnVtO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX2NhY2hpbmdBdFRpbWUudmFsdWU7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFNwZWVkQXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICB2YXIgZGVsdGEgPSAtMC4wMTtcbiAgICAgIHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pO1xuICAgICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcbiAgICAgIHZhciBzcGVlZCA9IDA7XG4gICAgICBpZiAodjEubGVuZ3RoKSB7XG4gICAgICAgIHZhciBpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdjEubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICBzcGVlZCArPSBNYXRoLnBvdyh2MltpXSAtIHYxW2ldLCAyKTtcbiAgICAgICAgfVxuICAgICAgICBzcGVlZCA9IE1hdGguc3FydChzcGVlZCkgKiAxMDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzcGVlZCA9IDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gc3BlZWQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFZlbG9jaXR5QXRUaW1lKGZyYW1lTnVtKSB7XG4gICAgICBpZiAodGhpcy52ZWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gdGhpcy52ZWw7XG4gICAgICB9XG4gICAgICB2YXIgZGVsdGEgPSAtMC4wMDE7XG4gICAgICAvLyBmcmFtZU51bSArPSB0aGlzLmVsZW0uZGF0YS5zdDtcbiAgICAgIHZhciB2MSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoZnJhbWVOdW0pO1xuICAgICAgdmFyIHYyID0gdGhpcy5nZXRWYWx1ZUF0VGltZShmcmFtZU51bSArIGRlbHRhKTtcbiAgICAgIHZhciB2ZWxvY2l0eTtcbiAgICAgIGlmICh2MS5sZW5ndGgpIHtcbiAgICAgICAgdmVsb2NpdHkgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgdjEubGVuZ3RoKTtcbiAgICAgICAgdmFyIGk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgIC8vIHJlbW92aW5nIGZyYW1lUmF0ZVxuICAgICAgICAgIC8vIGlmIG5lZWRlZCwgZG9uJ3QgYWRkIGl0IGhlcmVcbiAgICAgICAgICAvLyB2ZWxvY2l0eVtpXSA9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZSooKHYyW2ldIC0gdjFbaV0pL2RlbHRhKTtcbiAgICAgICAgICB2ZWxvY2l0eVtpXSA9ICh2MltpXSAtIHYxW2ldKSAvIGRlbHRhO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2ZWxvY2l0eSA9ICh2MiAtIHYxKSAvIGRlbHRhO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZlbG9jaXR5O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdGF0aWNWYWx1ZUF0VGltZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgIH1cbiAgICBmdW5jdGlvbiBzZXRHcm91cFByb3BlcnR5KHByb3BlcnR5R3JvdXApIHtcbiAgICAgIHRoaXMucHJvcGVydHlHcm91cCA9IHByb3BlcnR5R3JvdXA7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBzZWFyY2hFeHByZXNzaW9uczogc2VhcmNoRXhwcmVzc2lvbnMsXG4gICAgICBnZXRTcGVlZEF0VGltZTogZ2V0U3BlZWRBdFRpbWUsXG4gICAgICBnZXRWZWxvY2l0eUF0VGltZTogZ2V0VmVsb2NpdHlBdFRpbWUsXG4gICAgICBnZXRWYWx1ZUF0VGltZTogZ2V0VmFsdWVBdFRpbWUsXG4gICAgICBnZXRTdGF0aWNWYWx1ZUF0VGltZTogZ2V0U3RhdGljVmFsdWVBdFRpbWUsXG4gICAgICBzZXRHcm91cFByb3BlcnR5OiBzZXRHcm91cFByb3BlcnR5XG4gICAgfTtcbiAgfSgpO1xuXG4gIGZ1bmN0aW9uIGFkZFByb3BlcnR5RGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIGxvb3BPdXQodHlwZSwgZHVyYXRpb24sIGR1cmF0aW9uRmxhZykge1xuICAgICAgaWYgKCF0aGlzLmsgfHwgIXRoaXMua2V5ZnJhbWVzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgIHZhciBjdXJyZW50RnJhbWUgPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZTtcbiAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgIHZhciBsYXN0S2V5RnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDFdLnQ7XG4gICAgICBpZiAoY3VycmVudEZyYW1lIDw9IGxhc3RLZXlGcmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cbiAgICAgIHZhciBjeWNsZUR1cmF0aW9uO1xuICAgICAgdmFyIGZpcnN0S2V5RnJhbWU7XG4gICAgICBpZiAoIWR1cmF0aW9uRmxhZykge1xuICAgICAgICBpZiAoIWR1cmF0aW9uIHx8IGR1cmF0aW9uID4ga2V5ZnJhbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkdXJhdGlvbiA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGZpcnN0S2V5RnJhbWUgPSBrZXlmcmFtZXNba2V5ZnJhbWVzLmxlbmd0aCAtIDEgLSBkdXJhdGlvbl0udDtcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGxhc3RLZXlGcmFtZSAtIGZpcnN0S2V5RnJhbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGgubWF4KDAsIGxhc3RLZXlGcmFtZSAtIHRoaXMuZWxlbS5kYXRhLmlwKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjeWNsZUR1cmF0aW9uID0gTWF0aC5hYnMobGFzdEtleUZyYW1lIC0gdGhpcy5lbGVtLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUgKiBkdXJhdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZmlyc3RLZXlGcmFtZSA9IGxhc3RLZXlGcmFtZSAtIGN5Y2xlRHVyYXRpb247XG4gICAgICB9XG4gICAgICB2YXIgaTtcbiAgICAgIHZhciBsZW47XG4gICAgICB2YXIgcmV0O1xuICAgICAgaWYgKHR5cGUgPT09ICdwaW5ncG9uZycpIHtcbiAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBNYXRoLmZsb29yKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pO1xuICAgICAgICBpZiAoaXRlcmF0aW9ucyAlIDIgIT09IDApIHtcbiAgICAgICAgICByZXR1cm4gdGhpcy5nZXRWYWx1ZUF0VGltZSgoY3ljbGVEdXJhdGlvbiAtIChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICB2YXIgaW5pdFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgZW5kViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKCgoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgJSBjeWNsZUR1cmF0aW9uICsgZmlyc3RLZXlGcmFtZSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gICAgICAgIHZhciByZXBlYXRzID0gTWF0aC5mbG9vcigoY3VycmVudEZyYW1lIC0gZmlyc3RLZXlGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IChlbmRWW2ldIC0gaW5pdFZbaV0pICogcmVwZWF0cyArIGN1cnJlbnRbaV07XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIChlbmRWIC0gaW5pdFYpICogcmVwZWF0cyArIGN1cnJlbnQ7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb250aW51ZScpIHtcbiAgICAgICAgdmFyIGxhc3RWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIG5leHRMYXN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChsYXN0S2V5RnJhbWUgLSAwLjAwMSkgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICBpZiAodGhpcy5wdi5sZW5ndGgpIHtcbiAgICAgICAgICByZXQgPSBuZXcgQXJyYXkobGFzdFZhbHVlLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IGxhc3RWYWx1ZVtpXSArIChsYXN0VmFsdWVbaV0gLSBuZXh0TGFzdFZhbHVlW2ldKSAqICgoY3VycmVudEZyYW1lIC0gbGFzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSkgLyAwLjAwMDU7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbGFzdFZhbHVlICsgKGxhc3RWYWx1ZSAtIG5leHRMYXN0VmFsdWUpICogKChjdXJyZW50RnJhbWUgLSBsYXN0S2V5RnJhbWUpIC8gMC4wMDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKChjdXJyZW50RnJhbWUgLSBmaXJzdEtleUZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG4gICAgZnVuY3Rpb24gbG9vcEluKHR5cGUsIGR1cmF0aW9uLCBkdXJhdGlvbkZsYWcpIHtcbiAgICAgIGlmICghdGhpcy5rKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnB2O1xuICAgICAgfVxuICAgICAgdHlwZSA9IHR5cGUgPyB0eXBlLnRvTG93ZXJDYXNlKCkgOiAnJztcbiAgICAgIHZhciBjdXJyZW50RnJhbWUgPSB0aGlzLmNvbXAucmVuZGVyZWRGcmFtZTtcbiAgICAgIHZhciBrZXlmcmFtZXMgPSB0aGlzLmtleWZyYW1lcztcbiAgICAgIHZhciBmaXJzdEtleUZyYW1lID0ga2V5ZnJhbWVzWzBdLnQ7XG4gICAgICBpZiAoY3VycmVudEZyYW1lID49IGZpcnN0S2V5RnJhbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHY7XG4gICAgICB9XG4gICAgICB2YXIgY3ljbGVEdXJhdGlvbjtcbiAgICAgIHZhciBsYXN0S2V5RnJhbWU7XG4gICAgICBpZiAoIWR1cmF0aW9uRmxhZykge1xuICAgICAgICBpZiAoIWR1cmF0aW9uIHx8IGR1cmF0aW9uID4ga2V5ZnJhbWVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkdXJhdGlvbiA9IGtleWZyYW1lcy5sZW5ndGggLSAxO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RLZXlGcmFtZSA9IGtleWZyYW1lc1tkdXJhdGlvbl0udDtcbiAgICAgICAgY3ljbGVEdXJhdGlvbiA9IGxhc3RLZXlGcmFtZSAtIGZpcnN0S2V5RnJhbWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIWR1cmF0aW9uKSB7XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGgubWF4KDAsIHRoaXMuZWxlbS5kYXRhLm9wIC0gZmlyc3RLZXlGcmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3ljbGVEdXJhdGlvbiA9IE1hdGguYWJzKHRoaXMuZWxlbS5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlICogZHVyYXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RLZXlGcmFtZSA9IGZpcnN0S2V5RnJhbWUgKyBjeWNsZUR1cmF0aW9uO1xuICAgICAgfVxuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGVuO1xuICAgICAgdmFyIHJldDtcbiAgICAgIGlmICh0eXBlID09PSAncGluZ3BvbmcnKSB7XG4gICAgICAgIHZhciBpdGVyYXRpb25zID0gTWF0aC5mbG9vcigoZmlyc3RLZXlGcmFtZSAtIGN1cnJlbnRGcmFtZSkgLyBjeWNsZUR1cmF0aW9uKTtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnMgJSAyID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAlIGN5Y2xlRHVyYXRpb24gKyBmaXJzdEtleUZyYW1lKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlID09PSAnb2Zmc2V0Jykge1xuICAgICAgICB2YXIgaW5pdFYgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgZW5kViA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUobGFzdEtleUZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChjeWNsZUR1cmF0aW9uIC0gKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgdmFyIHJlcGVhdHMgPSBNYXRoLmZsb29yKChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIGN5Y2xlRHVyYXRpb24pICsgMTtcbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGluaXRWLmxlbmd0aCk7XG4gICAgICAgICAgbGVuID0gcmV0Lmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgICAgICAgIHJldFtpXSA9IGN1cnJlbnRbaV0gLSAoZW5kVltpXSAtIGluaXRWW2ldKSAqIHJlcGVhdHM7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGN1cnJlbnQgLSAoZW5kViAtIGluaXRWKSAqIHJlcGVhdHM7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjb250aW51ZScpIHtcbiAgICAgICAgdmFyIGZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKGZpcnN0S2V5RnJhbWUgLyB0aGlzLmNvbXAuZ2xvYmFsRGF0YS5mcmFtZVJhdGUsIDApO1xuICAgICAgICB2YXIgbmV4dEZpcnN0VmFsdWUgPSB0aGlzLmdldFZhbHVlQXRUaW1lKChmaXJzdEtleUZyYW1lICsgMC4wMDEpIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlLCAwKTtcbiAgICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgICAgcmV0ID0gbmV3IEFycmF5KGZpcnN0VmFsdWUubGVuZ3RoKTtcbiAgICAgICAgICBsZW4gPSByZXQubGVuZ3RoO1xuICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgcmV0W2ldID0gZmlyc3RWYWx1ZVtpXSArIChmaXJzdFZhbHVlW2ldIC0gbmV4dEZpcnN0VmFsdWVbaV0pICogKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpIC8gMC4wMDE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZpcnN0VmFsdWUgKyAoZmlyc3RWYWx1ZSAtIG5leHRGaXJzdFZhbHVlKSAqIChmaXJzdEtleUZyYW1lIC0gY3VycmVudEZyYW1lKSAvIDAuMDAxO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWVBdFRpbWUoKGN5Y2xlRHVyYXRpb24gLSAoKGZpcnN0S2V5RnJhbWUgLSBjdXJyZW50RnJhbWUpICUgY3ljbGVEdXJhdGlvbiArIGZpcnN0S2V5RnJhbWUpKSAvIHRoaXMuY29tcC5nbG9iYWxEYXRhLmZyYW1lUmF0ZSwgMCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgICB9XG4gICAgZnVuY3Rpb24gc21vb3RoKHdpZHRoLCBzYW1wbGVzKSB7XG4gICAgICBpZiAoIXRoaXMuaykge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cbiAgICAgIHdpZHRoID0gKHdpZHRoIHx8IDAuNCkgKiAwLjU7XG4gICAgICBzYW1wbGVzID0gTWF0aC5mbG9vcihzYW1wbGVzIHx8IDUpO1xuICAgICAgaWYgKHNhbXBsZXMgPD0gMSkge1xuICAgICAgICByZXR1cm4gdGhpcy5wdjtcbiAgICAgIH1cbiAgICAgIHZhciBjdXJyZW50VGltZSA9IHRoaXMuY29tcC5yZW5kZXJlZEZyYW1lIC8gdGhpcy5jb21wLmdsb2JhbERhdGEuZnJhbWVSYXRlO1xuICAgICAgdmFyIGluaXRGcmFtZSA9IGN1cnJlbnRUaW1lIC0gd2lkdGg7XG4gICAgICB2YXIgZW5kRnJhbWUgPSBjdXJyZW50VGltZSArIHdpZHRoO1xuICAgICAgdmFyIHNhbXBsZUZyZXF1ZW5jeSA9IHNhbXBsZXMgPiAxID8gKGVuZEZyYW1lIC0gaW5pdEZyYW1lKSAvIChzYW1wbGVzIC0gMSkgOiAxO1xuICAgICAgdmFyIGkgPSAwO1xuICAgICAgdmFyIGogPSAwO1xuICAgICAgdmFyIHZhbHVlO1xuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgIHZhbHVlID0gY3JlYXRlVHlwZWRBcnJheSgnZmxvYXQzMicsIHRoaXMucHYubGVuZ3RoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhbHVlID0gMDtcbiAgICAgIH1cbiAgICAgIHZhciBzYW1wbGVWYWx1ZTtcbiAgICAgIHdoaWxlIChpIDwgc2FtcGxlcykge1xuICAgICAgICBzYW1wbGVWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVBdFRpbWUoaW5pdEZyYW1lICsgaSAqIHNhbXBsZUZyZXF1ZW5jeSk7XG4gICAgICAgIGlmICh0aGlzLnB2Lmxlbmd0aCkge1xuICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnB2Lmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgICB2YWx1ZVtqXSArPSBzYW1wbGVWYWx1ZVtqXTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFsdWUgKz0gc2FtcGxlVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaSArPSAxO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMucHYubGVuZ3RoKSB7XG4gICAgICAgIGZvciAoaiA9IDA7IGogPCB0aGlzLnB2Lmxlbmd0aDsgaiArPSAxKSB7XG4gICAgICAgICAgdmFsdWVbal0gLz0gc2FtcGxlcztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsdWUgLz0gc2FtcGxlcztcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0VHJhbnNmb3JtVmFsdWVBdFRpbWUodGltZSkge1xuICAgICAgaWYgKCF0aGlzLl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybUNhY2hpbmdBdFRpbWUgPSB7XG4gICAgICAgICAgdjogbmV3IE1hdHJpeCgpXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICAvLy8gL1xuICAgICAgdmFyIG1hdHJpeCA9IHRoaXMuX3RyYW5zZm9ybUNhY2hpbmdBdFRpbWUudjtcbiAgICAgIG1hdHJpeC5jbG9uZUZyb21Qcm9wcyh0aGlzLnByZS5wcm9wcyk7XG4gICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMSkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5hLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgudHJhbnNsYXRlKC1hbmNob3JbMF0gKiB0aGlzLmEubXVsdCwgLWFuY2hvclsxXSAqIHRoaXMuYS5tdWx0LCBhbmNob3JbMl0gKiB0aGlzLmEubXVsdCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5hcHBsaWVkVHJhbnNmb3JtYXRpb25zIDwgMikge1xuICAgICAgICB2YXIgc2NhbGUgPSB0aGlzLnMuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC5zY2FsZShzY2FsZVswXSAqIHRoaXMucy5tdWx0LCBzY2FsZVsxXSAqIHRoaXMucy5tdWx0LCBzY2FsZVsyXSAqIHRoaXMucy5tdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnNrICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDMpIHtcbiAgICAgICAgdmFyIHNrZXcgPSB0aGlzLnNrLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgc2tld0F4aXMgPSB0aGlzLnNhLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXguc2tld0Zyb21BeGlzKC1za2V3ICogdGhpcy5zay5tdWx0LCBza2V3QXhpcyAqIHRoaXMuc2EubXVsdCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5yICYmIHRoaXMuYXBwbGllZFRyYW5zZm9ybWF0aW9ucyA8IDQpIHtcbiAgICAgICAgdmFyIHJvdGF0aW9uID0gdGhpcy5yLmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBtYXRyaXgucm90YXRlKC1yb3RhdGlvbiAqIHRoaXMuci5tdWx0KTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuciAmJiB0aGlzLmFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMgPCA0KSB7XG4gICAgICAgIHZhciByb3RhdGlvblogPSB0aGlzLnJ6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICB2YXIgcm90YXRpb25ZID0gdGhpcy5yeS5nZXRWYWx1ZUF0VGltZSh0aW1lKTtcbiAgICAgICAgdmFyIHJvdGF0aW9uWCA9IHRoaXMucnguZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIHZhciBvcmllbnRhdGlvbiA9IHRoaXMub3IuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC5yb3RhdGVaKC1yb3RhdGlvblogKiB0aGlzLnJ6Lm11bHQpLnJvdGF0ZVkocm90YXRpb25ZICogdGhpcy5yeS5tdWx0KS5yb3RhdGVYKHJvdGF0aW9uWCAqIHRoaXMucngubXVsdCkucm90YXRlWigtb3JpZW50YXRpb25bMl0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVkob3JpZW50YXRpb25bMV0gKiB0aGlzLm9yLm11bHQpLnJvdGF0ZVgob3JpZW50YXRpb25bMF0gKiB0aGlzLm9yLm11bHQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5wICYmIHRoaXMuZGF0YS5wLnMpIHtcbiAgICAgICAgdmFyIHBvc2l0aW9uWCA9IHRoaXMucHguZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIHZhciBwb3NpdGlvblkgPSB0aGlzLnB5LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICBpZiAodGhpcy5kYXRhLnAueikge1xuICAgICAgICAgIHZhciBwb3NpdGlvblogPSB0aGlzLnB6LmdldFZhbHVlQXRUaW1lKHRpbWUpO1xuICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25YICogdGhpcy5weC5tdWx0LCBwb3NpdGlvblkgKiB0aGlzLnB5Lm11bHQsIC1wb3NpdGlvblogKiB0aGlzLnB6Lm11bHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25YICogdGhpcy5weC5tdWx0LCBwb3NpdGlvblkgKiB0aGlzLnB5Lm11bHQsIDApO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnAuZ2V0VmFsdWVBdFRpbWUodGltZSk7XG4gICAgICAgIG1hdHJpeC50cmFuc2xhdGUocG9zaXRpb25bMF0gKiB0aGlzLnAubXVsdCwgcG9zaXRpb25bMV0gKiB0aGlzLnAubXVsdCwgLXBvc2l0aW9uWzJdICogdGhpcy5wLm11bHQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hdHJpeDtcbiAgICAgIC8vLyAvXG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldFRyYW5zZm9ybVN0YXRpY1ZhbHVlQXRUaW1lKCkge1xuICAgICAgcmV0dXJuIHRoaXMudi5jbG9uZShuZXcgTWF0cml4KCkpO1xuICAgIH1cbiAgICB2YXIgZ2V0VHJhbnNmb3JtUHJvcGVydHkgPSBUcmFuc2Zvcm1Qcm9wZXJ0eUZhY3RvcnkuZ2V0VHJhbnNmb3JtUHJvcGVydHk7XG4gICAgVHJhbnNmb3JtUHJvcGVydHlGYWN0b3J5LmdldFRyYW5zZm9ybVByb3BlcnR5ID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIGNvbnRhaW5lcikge1xuICAgICAgdmFyIHByb3AgPSBnZXRUcmFuc2Zvcm1Qcm9wZXJ0eShlbGVtLCBkYXRhLCBjb250YWluZXIpO1xuICAgICAgaWYgKHByb3AuZHluYW1pY1Byb3BlcnRpZXMubGVuZ3RoKSB7XG4gICAgICAgIHByb3AuZ2V0VmFsdWVBdFRpbWUgPSBnZXRUcmFuc2Zvcm1WYWx1ZUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGdldFRyYW5zZm9ybVN0YXRpY1ZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XG4gICAgICB9XG4gICAgICBwcm9wLnNldEdyb3VwUHJvcGVydHkgPSBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5O1xuICAgICAgcmV0dXJuIHByb3A7XG4gICAgfTtcbiAgICB2YXIgcHJvcGVydHlHZXRQcm9wID0gUHJvcGVydHlGYWN0b3J5LmdldFByb3A7XG4gICAgUHJvcGVydHlGYWN0b3J5LmdldFByb3AgPSBmdW5jdGlvbiAoZWxlbSwgZGF0YSwgdHlwZSwgbXVsdCwgY29udGFpbmVyKSB7XG4gICAgICB2YXIgcHJvcCA9IHByb3BlcnR5R2V0UHJvcChlbGVtLCBkYXRhLCB0eXBlLCBtdWx0LCBjb250YWluZXIpO1xuICAgICAgLy8gcHJvcC5nZXRWZWxvY2l0eUF0VGltZSA9IGdldFZlbG9jaXR5QXRUaW1lO1xuICAgICAgLy8gcHJvcC5sb29wT3V0ID0gbG9vcE91dDtcbiAgICAgIC8vIHByb3AubG9vcEluID0gbG9vcEluO1xuICAgICAgaWYgKHByb3Aua2YpIHtcbiAgICAgICAgcHJvcC5nZXRWYWx1ZUF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFZhbHVlQXRUaW1lLmJpbmQocHJvcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9wLmdldFZhbHVlQXRUaW1lID0gZXhwcmVzc2lvbkhlbHBlcnMuZ2V0U3RhdGljVmFsdWVBdFRpbWUuYmluZChwcm9wKTtcbiAgICAgIH1cbiAgICAgIHByb3Auc2V0R3JvdXBQcm9wZXJ0eSA9IGV4cHJlc3Npb25IZWxwZXJzLnNldEdyb3VwUHJvcGVydHk7XG4gICAgICBwcm9wLmxvb3BPdXQgPSBsb29wT3V0O1xuICAgICAgcHJvcC5sb29wSW4gPSBsb29wSW47XG4gICAgICBwcm9wLnNtb290aCA9IHNtb290aDtcbiAgICAgIHByb3AuZ2V0VmVsb2NpdHlBdFRpbWUgPSBleHByZXNzaW9uSGVscGVycy5nZXRWZWxvY2l0eUF0VGltZS5iaW5kKHByb3ApO1xuICAgICAgcHJvcC5nZXRTcGVlZEF0VGltZSA9IGV4cHJlc3Npb25IZWxwZXJzLmdldFNwZWVkQXRUaW1lLmJpbmQocHJvcCk7XG4gICAgICBwcm9wLm51bUtleXMgPSBkYXRhLmEgPT09IDEgPyBkYXRhLmsubGVuZ3RoIDogMDtcbiAgICAgIHByb3AucHJvcGVydHlJbmRleCA9IGRhdGEuaXg7XG4gICAgICB2YXIgdmFsdWUgPSAwO1xuICAgICAgaWYgKHR5cGUgIT09IDApIHtcbiAgICAgICAgdmFsdWUgPSBjcmVhdGVUeXBlZEFycmF5KCdmbG9hdDMyJywgZGF0YS5hID09PSAxID8gZGF0YS5rWzBdLnMubGVuZ3RoIDogZGF0YS5rLmxlbmd0aCk7XG4gICAgICB9XG4gICAgICBwcm9wLl9jYWNoaW5nQXRUaW1lID0ge1xuICAgICAgICBsYXN0RnJhbWU6IGluaXRpYWxEZWZhdWx0RnJhbWUsXG4gICAgICAgIGxhc3RJbmRleDogMCxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICAgICAgZXhwcmVzc2lvbkhlbHBlcnMuc2VhcmNoRXhwcmVzc2lvbnMoZWxlbSwgZGF0YSwgcHJvcCk7XG4gICAgICBpZiAocHJvcC5rKSB7XG4gICAgICAgIGNvbnRhaW5lci5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9O1xuICAgIGZ1bmN0aW9uIGdldFNoYXBlVmFsdWVBdFRpbWUoZnJhbWVOdW0pIHtcbiAgICAgIC8vIEZvciBub3cgdGhpcyBjYWNoaW5nIG9iamVjdCBpcyBjcmVhdGVkIG9ubHkgd2hlbiBuZWVkZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBpdCB3aGVuIHRoZSBzaGFwZSBpcyBpbml0aWFsaXplZC5cbiAgICAgIGlmICghdGhpcy5fY2FjaGluZ0F0VGltZSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lID0ge1xuICAgICAgICAgIHNoYXBlVmFsdWU6IHNoYXBlUG9vbC5jbG9uZSh0aGlzLnB2KSxcbiAgICAgICAgICBsYXN0SW5kZXg6IDAsXG4gICAgICAgICAgbGFzdFRpbWU6IGluaXRpYWxEZWZhdWx0RnJhbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGZyYW1lTnVtICo9IHRoaXMuZWxlbS5nbG9iYWxEYXRhLmZyYW1lUmF0ZTtcbiAgICAgIGZyYW1lTnVtIC09IHRoaXMub2Zmc2V0VGltZTtcbiAgICAgIGlmIChmcmFtZU51bSAhPT0gdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSkge1xuICAgICAgICB0aGlzLl9jYWNoaW5nQXRUaW1lLmxhc3RJbmRleCA9IHRoaXMuX2NhY2hpbmdBdFRpbWUubGFzdFRpbWUgPCBmcmFtZU51bSA/IHRoaXMuX2NhY2hpbmcubGFzdEluZGV4IDogMDtcbiAgICAgICAgdGhpcy5fY2FjaGluZ0F0VGltZS5sYXN0VGltZSA9IGZyYW1lTnVtO1xuICAgICAgICB0aGlzLmludGVycG9sYXRlU2hhcGUoZnJhbWVOdW0sIHRoaXMuX2NhY2hpbmdBdFRpbWUuc2hhcGVWYWx1ZSwgdGhpcy5fY2FjaGluZ0F0VGltZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5fY2FjaGluZ0F0VGltZS5zaGFwZVZhbHVlO1xuICAgIH1cbiAgICB2YXIgU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24gPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRDb25zdHJ1Y3RvckZ1bmN0aW9uKCk7XG4gICAgdmFyIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uID0gU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbigpO1xuICAgIGZ1bmN0aW9uIFNoYXBlRXhwcmVzc2lvbnMoKSB7fVxuICAgIFNoYXBlRXhwcmVzc2lvbnMucHJvdG90eXBlID0ge1xuICAgICAgdmVydGljZXM6IGZ1bmN0aW9uIHZlcnRpY2VzKHByb3AsIHRpbWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaykge1xuICAgICAgICAgIHRoaXMuZ2V0VmFsdWUoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xuICAgICAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2hhcGVQYXRoID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lLCAwKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgaTtcbiAgICAgICAgdmFyIGxlbiA9IHNoYXBlUGF0aC5fbGVuZ3RoO1xuICAgICAgICB2YXIgdmVydGljZXMgPSBzaGFwZVBhdGhbcHJvcF07XG4gICAgICAgIHZhciBwb2ludHMgPSBzaGFwZVBhdGgudjtcbiAgICAgICAgdmFyIGFyciA9IGNyZWF0ZVNpemVkQXJyYXkobGVuKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSArPSAxKSB7XG4gICAgICAgICAgaWYgKHByb3AgPT09ICdpJyB8fCBwcm9wID09PSAnbycpIHtcbiAgICAgICAgICAgIGFycltpXSA9IFt2ZXJ0aWNlc1tpXVswXSAtIHBvaW50c1tpXVswXSwgdmVydGljZXNbaV1bMV0gLSBwb2ludHNbaV1bMV1dO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhcnJbaV0gPSBbdmVydGljZXNbaV1bMF0sIHZlcnRpY2VzW2ldWzFdXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICAgIH0sXG4gICAgICBwb2ludHM6IGZ1bmN0aW9uIHBvaW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCd2JywgdGltZSk7XG4gICAgICB9LFxuICAgICAgaW5UYW5nZW50czogZnVuY3Rpb24gaW5UYW5nZW50cyh0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlcnRpY2VzKCdpJywgdGltZSk7XG4gICAgICB9LFxuICAgICAgb3V0VGFuZ2VudHM6IGZ1bmN0aW9uIG91dFRhbmdlbnRzKHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVydGljZXMoJ28nLCB0aW1lKTtcbiAgICAgIH0sXG4gICAgICBpc0Nsb3NlZDogZnVuY3Rpb24gaXNDbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnYuYztcbiAgICAgIH0sXG4gICAgICBwb2ludE9uUGF0aDogZnVuY3Rpb24gcG9pbnRPblBhdGgocGVyYywgdGltZSkge1xuICAgICAgICB2YXIgc2hhcGVQYXRoID0gdGhpcy52O1xuICAgICAgICBpZiAodGltZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgc2hhcGVQYXRoID0gdGhpcy5nZXRWYWx1ZUF0VGltZSh0aW1lLCAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX3NlZ21lbnRzTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fc2VnbWVudHNMZW5ndGggPSBiZXouZ2V0U2VnbWVudHNMZW5ndGgoc2hhcGVQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2VnbWVudHNMZW5ndGggPSB0aGlzLl9zZWdtZW50c0xlbmd0aDtcbiAgICAgICAgdmFyIGxlbmd0aHMgPSBzZWdtZW50c0xlbmd0aC5sZW5ndGhzO1xuICAgICAgICB2YXIgbGVuZ3RoUG9zID0gc2VnbWVudHNMZW5ndGgudG90YWxMZW5ndGggKiBwZXJjO1xuICAgICAgICB2YXIgaSA9IDA7XG4gICAgICAgIHZhciBsZW4gPSBsZW5ndGhzLmxlbmd0aDtcbiAgICAgICAgdmFyIGFjY3VtdWxhdGVkTGVuZ3RoID0gMDtcbiAgICAgICAgdmFyIHB0O1xuICAgICAgICB3aGlsZSAoaSA8IGxlbikge1xuICAgICAgICAgIGlmIChhY2N1bXVsYXRlZExlbmd0aCArIGxlbmd0aHNbaV0uYWRkZWRMZW5ndGggPiBsZW5ndGhQb3MpIHtcbiAgICAgICAgICAgIHZhciBpbml0SW5kZXggPSBpO1xuICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gc2hhcGVQYXRoLmMgJiYgaSA9PT0gbGVuIC0gMSA/IDAgOiBpICsgMTtcbiAgICAgICAgICAgIHZhciBzZWdtZW50UGVyYyA9IChsZW5ndGhQb3MgLSBhY2N1bXVsYXRlZExlbmd0aCkgLyBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgICAgcHQgPSBiZXouZ2V0UG9pbnRJblNlZ21lbnQoc2hhcGVQYXRoLnZbaW5pdEluZGV4XSwgc2hhcGVQYXRoLnZbZW5kSW5kZXhdLCBzaGFwZVBhdGgub1tpbml0SW5kZXhdLCBzaGFwZVBhdGguaVtlbmRJbmRleF0sIHNlZ21lbnRQZXJjLCBsZW5ndGhzW2ldKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZExlbmd0aCArPSBsZW5ndGhzW2ldLmFkZGVkTGVuZ3RoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwdCkge1xuICAgICAgICAgIHB0ID0gc2hhcGVQYXRoLmMgPyBbc2hhcGVQYXRoLnZbMF1bMF0sIHNoYXBlUGF0aC52WzBdWzFdXSA6IFtzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzBdLCBzaGFwZVBhdGgudltzaGFwZVBhdGguX2xlbmd0aCAtIDFdWzFdXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHQ7XG4gICAgICB9LFxuICAgICAgdmVjdG9yT25QYXRoOiBmdW5jdGlvbiB2ZWN0b3JPblBhdGgocGVyYywgdGltZSwgdmVjdG9yVHlwZSkge1xuICAgICAgICAvLyBwZXJjIGRvZXNuJ3QgdXNlIHRyaXBsZSBlcXVhbGl0eSBiZWNhdXNlIGl0IGNhbiBiZSBhIE51bWJlciBvYmplY3QgYXMgd2VsbCBhcyBhIHByaW1pdGl2ZS5cbiAgICAgICAgaWYgKHBlcmMgPT0gMSkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgICAgcGVyYyA9IHRoaXMudi5jO1xuICAgICAgICB9IGVsc2UgaWYgKHBlcmMgPT0gMCkge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICAgICAgcGVyYyA9IDAuOTk5O1xuICAgICAgICB9XG4gICAgICAgIHZhciBwdDEgPSB0aGlzLnBvaW50T25QYXRoKHBlcmMsIHRpbWUpO1xuICAgICAgICB2YXIgcHQyID0gdGhpcy5wb2ludE9uUGF0aChwZXJjICsgMC4wMDEsIHRpbWUpO1xuICAgICAgICB2YXIgeExlbmd0aCA9IHB0MlswXSAtIHB0MVswXTtcbiAgICAgICAgdmFyIHlMZW5ndGggPSBwdDJbMV0gLSBwdDFbMV07XG4gICAgICAgIHZhciBtYWduaXR1ZGUgPSBNYXRoLnNxcnQoTWF0aC5wb3coeExlbmd0aCwgMikgKyBNYXRoLnBvdyh5TGVuZ3RoLCAyKSk7XG4gICAgICAgIGlmIChtYWduaXR1ZGUgPT09IDApIHtcbiAgICAgICAgICByZXR1cm4gWzAsIDBdO1xuICAgICAgICB9XG4gICAgICAgIHZhciB1bml0VmVjdG9yID0gdmVjdG9yVHlwZSA9PT0gJ3RhbmdlbnQnID8gW3hMZW5ndGggLyBtYWduaXR1ZGUsIHlMZW5ndGggLyBtYWduaXR1ZGVdIDogWy15TGVuZ3RoIC8gbWFnbml0dWRlLCB4TGVuZ3RoIC8gbWFnbml0dWRlXTtcbiAgICAgICAgcmV0dXJuIHVuaXRWZWN0b3I7XG4gICAgICB9LFxuICAgICAgdGFuZ2VudE9uUGF0aDogZnVuY3Rpb24gdGFuZ2VudE9uUGF0aChwZXJjLCB0aW1lKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnZlY3Rvck9uUGF0aChwZXJjLCB0aW1lLCAndGFuZ2VudCcpO1xuICAgICAgfSxcbiAgICAgIG5vcm1hbE9uUGF0aDogZnVuY3Rpb24gbm9ybWFsT25QYXRoKHBlcmMsIHRpbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmVjdG9yT25QYXRoKHBlcmMsIHRpbWUsICdub3JtYWwnKTtcbiAgICAgIH0sXG4gICAgICBzZXRHcm91cFByb3BlcnR5OiBleHByZXNzaW9uSGVscGVycy5zZXRHcm91cFByb3BlcnR5LFxuICAgICAgZ2V0VmFsdWVBdFRpbWU6IGV4cHJlc3Npb25IZWxwZXJzLmdldFN0YXRpY1ZhbHVlQXRUaW1lXG4gICAgfTtcbiAgICBleHRlbmRQcm90b3R5cGUoW1NoYXBlRXhwcmVzc2lvbnNdLCBTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbik7XG4gICAgZXh0ZW5kUHJvdG90eXBlKFtTaGFwZUV4cHJlc3Npb25zXSwgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24pO1xuICAgIEtleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uLnByb3RvdHlwZS5nZXRWYWx1ZUF0VGltZSA9IGdldFNoYXBlVmFsdWVBdFRpbWU7XG4gICAgS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eUNvbnN0cnVjdG9yRnVuY3Rpb24ucHJvdG90eXBlLmluaXRpYXRlRXhwcmVzc2lvbiA9IEV4cHJlc3Npb25NYW5hZ2VyLmluaXRpYXRlRXhwcmVzc2lvbjtcbiAgICB2YXIgcHJvcGVydHlHZXRTaGFwZVByb3AgPSBTaGFwZVByb3BlcnR5RmFjdG9yeS5nZXRTaGFwZVByb3A7XG4gICAgU2hhcGVQcm9wZXJ0eUZhY3RvcnkuZ2V0U2hhcGVQcm9wID0gZnVuY3Rpb24gKGVsZW0sIGRhdGEsIHR5cGUsIGFyciwgdHJpbXMpIHtcbiAgICAgIHZhciBwcm9wID0gcHJvcGVydHlHZXRTaGFwZVByb3AoZWxlbSwgZGF0YSwgdHlwZSwgYXJyLCB0cmltcyk7XG4gICAgICBwcm9wLnByb3BlcnR5SW5kZXggPSBkYXRhLml4O1xuICAgICAgcHJvcC5sb2NrID0gZmFsc2U7XG4gICAgICBpZiAodHlwZSA9PT0gMykge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLnB0LCBwcm9wKTtcbiAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gNCkge1xuICAgICAgICBleHByZXNzaW9uSGVscGVycy5zZWFyY2hFeHByZXNzaW9ucyhlbGVtLCBkYXRhLmtzLCBwcm9wKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wLmspIHtcbiAgICAgICAgZWxlbS5hZGREeW5hbWljUHJvcGVydHkocHJvcCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcHJvcDtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGluaXRpYWxpemUkMSgpIHtcbiAgICBhZGRQcm9wZXJ0eURlY29yYXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkRGVjb3JhdG9yKCkge1xuICAgIGZ1bmN0aW9uIHNlYXJjaEV4cHJlc3Npb25zKCkge1xuICAgICAgaWYgKHRoaXMuZGF0YS5kLngpIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVFeHByZXNzaW9uID0gRXhwcmVzc2lvbk1hbmFnZXIuaW5pdGlhdGVFeHByZXNzaW9uLmJpbmQodGhpcykodGhpcy5lbGVtLCB0aGlzLmRhdGEuZCwgdGhpcyk7XG4gICAgICAgIHRoaXMuYWRkRWZmZWN0KHRoaXMuZ2V0RXhwcmVzc2lvblZhbHVlLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBUZXh0UHJvcGVydHkucHJvdG90eXBlLmdldEV4cHJlc3Npb25WYWx1ZSA9IGZ1bmN0aW9uIChjdXJyZW50VmFsdWUsIHRleHQpIHtcbiAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMuY2FsY3VsYXRlRXhwcmVzc2lvbih0ZXh0KTtcbiAgICAgIGlmIChjdXJyZW50VmFsdWUudCAhPT0gbmV3VmFsdWUpIHtcbiAgICAgICAgdmFyIG5ld0RhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5jb3B5RGF0YShuZXdEYXRhLCBjdXJyZW50VmFsdWUpO1xuICAgICAgICBuZXdEYXRhLnQgPSBuZXdWYWx1ZS50b1N0cmluZygpO1xuICAgICAgICBuZXdEYXRhLl9fY29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgICB9XG4gICAgICByZXR1cm4gY3VycmVudFZhbHVlO1xuICAgIH07XG4gICAgVGV4dFByb3BlcnR5LnByb3RvdHlwZS5zZWFyY2hQcm9wZXJ0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBpc0tleWZyYW1lZCA9IHRoaXMuc2VhcmNoS2V5ZnJhbWVzKCk7XG4gICAgICB2YXIgaGFzRXhwcmVzc2lvbnMgPSB0aGlzLnNlYXJjaEV4cHJlc3Npb25zKCk7XG4gICAgICB0aGlzLmtmID0gaXNLZXlmcmFtZWQgfHwgaGFzRXhwcmVzc2lvbnM7XG4gICAgICByZXR1cm4gdGhpcy5rZjtcbiAgICB9O1xuICAgIFRleHRQcm9wZXJ0eS5wcm90b3R5cGUuc2VhcmNoRXhwcmVzc2lvbnMgPSBzZWFyY2hFeHByZXNzaW9ucztcbiAgfVxuICBmdW5jdGlvbiBpbml0aWFsaXplKCkge1xuICAgIGFkZERlY29yYXRvcigpO1xuICB9XG5cbiAgZnVuY3Rpb24gU1ZHQ29tcG9zYWJsZUVmZmVjdCgpIHt9XG4gIFNWR0NvbXBvc2FibGVFZmZlY3QucHJvdG90eXBlID0ge1xuICAgIGNyZWF0ZU1lcmdlTm9kZTogZnVuY3Rpb24gY3JlYXRlTWVyZ2VOb2RlKHJlc3VsdElkLCBpbnMpIHtcbiAgICAgIHZhciBmZU1lcmdlID0gY3JlYXRlTlMoJ2ZlTWVyZ2UnKTtcbiAgICAgIGZlTWVyZ2Uuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCByZXN1bHRJZCk7XG4gICAgICB2YXIgZmVNZXJnZU5vZGU7XG4gICAgICB2YXIgaTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBpbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgZmVNZXJnZU5vZGUgPSBjcmVhdGVOUygnZmVNZXJnZU5vZGUnKTtcbiAgICAgICAgZmVNZXJnZU5vZGUuc2V0QXR0cmlidXRlKCdpbicsIGluc1tpXSk7XG4gICAgICAgIGZlTWVyZ2UuYXBwZW5kQ2hpbGQoZmVNZXJnZU5vZGUpO1xuICAgICAgICBmZU1lcmdlLmFwcGVuZENoaWxkKGZlTWVyZ2VOb2RlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmZU1lcmdlO1xuICAgIH1cbiAgfTtcblxuICB2YXIgbGluZWFyRmlsdGVyVmFsdWUgPSAnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAnO1xuICBmdW5jdGlvbiBTVkdUaW50RmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQsIHNvdXJjZSkge1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnbGluZWFyUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsIGxpbmVhckZpbHRlclZhbHVlICsgJyAxIDAnKTtcbiAgICB0aGlzLmxpbmVhckZpbHRlciA9IGZlQ29sb3JNYXRyaXg7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ190aW50XzEnKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XG4gICAgZmVDb2xvck1hdHJpeCA9IGNyZWF0ZU5TKCdmZUNvbG9yTWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAnbWF0cml4Jyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ2NvbG9yLWludGVycG9sYXRpb24tZmlsdGVycycsICdzUkdCJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3ZhbHVlcycsICcxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAgMCAwIDAgMCAxIDAnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQgKyAnX3RpbnRfMicpO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbG9yTWF0cml4KTtcbiAgICB0aGlzLm1hdHJpeEZpbHRlciA9IGZlQ29sb3JNYXRyaXg7XG4gICAgdmFyIGZlTWVyZ2UgPSB0aGlzLmNyZWF0ZU1lcmdlTm9kZShpZCwgW3NvdXJjZSwgaWQgKyAnX3RpbnRfMScsIGlkICsgJ190aW50XzInXSk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xuICB9XG4gIGV4dGVuZFByb3RvdHlwZShbU1ZHQ29tcG9zYWJsZUVmZmVjdF0sIFNWR1RpbnRGaWx0ZXIpO1xuICBTVkdUaW50RmlsdGVyLnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmIChmb3JjZVJlbmRlciB8fCB0aGlzLmZpbHRlck1hbmFnZXIuX21kZikge1xuICAgICAgdmFyIGNvbG9yQmxhY2sgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xuICAgICAgdmFyIGNvbG9yV2hpdGUgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52O1xuICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52IC8gMTAwO1xuICAgICAgdGhpcy5saW5lYXJGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCBsaW5lYXJGaWx0ZXJWYWx1ZSArICcgJyArIG9wYWNpdHkgKyAnIDAnKTtcbiAgICAgIHRoaXMubWF0cml4RmlsdGVyLnNldEF0dHJpYnV0ZSgndmFsdWVzJywgY29sb3JXaGl0ZVswXSAtIGNvbG9yQmxhY2tbMF0gKyAnIDAgMCAwICcgKyBjb2xvckJsYWNrWzBdICsgJyAnICsgKGNvbG9yV2hpdGVbMV0gLSBjb2xvckJsYWNrWzFdKSArICcgMCAwIDAgJyArIGNvbG9yQmxhY2tbMV0gKyAnICcgKyAoY29sb3JXaGl0ZVsyXSAtIGNvbG9yQmxhY2tbMl0pICsgJyAwIDAgMCAnICsgY29sb3JCbGFja1syXSArICcgMCAwIDAgMSAwJyk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR0ZpbGxGaWx0ZXIoZmlsdGVyLCBmaWx0ZXJNYW5hZ2VyLCBlbGVtLCBpZCkge1xuICAgIHRoaXMuZmlsdGVyTWFuYWdlciA9IGZpbHRlck1hbmFnZXI7XG4gICAgdmFyIGZlQ29sb3JNYXRyaXggPSBjcmVhdGVOUygnZmVDb2xvck1hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd0eXBlJywgJ21hdHJpeCcpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCdjb2xvci1pbnRlcnBvbGF0aW9uLWZpbHRlcnMnLCAnc1JHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb2xvck1hdHJpeCk7XG4gICAgdGhpcy5tYXRyaXhGaWx0ZXIgPSBmZUNvbG9yTWF0cml4O1xuICB9XG4gIFNWR0ZpbGxGaWx0ZXIucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMl0ucC52O1xuICAgICAgdmFyIG9wYWNpdHkgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC52O1xuICAgICAgdGhpcy5tYXRyaXhGaWx0ZXIuc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMCAwIDAgMCAnICsgY29sb3JbMF0gKyAnIDAgMCAwIDAgJyArIGNvbG9yWzFdICsgJyAwIDAgMCAwICcgKyBjb2xvclsyXSArICcgMCAwIDAgJyArIG9wYWNpdHkgKyAnIDAnKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHU3Ryb2tlRWZmZWN0KGZpbCwgZmlsdGVyTWFuYWdlciwgZWxlbSkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHRoaXMuZWxlbSA9IGVsZW07XG4gICAgdGhpcy5wYXRocyA9IFtdO1xuICB9XG4gIFNWR1N0cm9rZUVmZmVjdC5wcm90b3R5cGUuaW5pdGlhbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWxlbUNoaWxkcmVuID0gdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZHJlbiB8fCB0aGlzLmVsZW0ubGF5ZXJFbGVtZW50LmNoaWxkTm9kZXM7XG4gICAgdmFyIHBhdGg7XG4gICAgdmFyIGdyb3VwUGF0aDtcbiAgICB2YXIgaTtcbiAgICB2YXIgbGVuO1xuICAgIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMV0ucC52ID09PSAxKSB7XG4gICAgICBsZW4gPSB0aGlzLmVsZW0ubWFza01hbmFnZXIubWFza3NQcm9wZXJ0aWVzLmxlbmd0aDtcbiAgICAgIGkgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzBdLnAudiAtIDE7XG4gICAgICBsZW4gPSBpICsgMTtcbiAgICB9XG4gICAgZ3JvdXBQYXRoID0gY3JlYXRlTlMoJ2cnKTtcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKTtcbiAgICBncm91cFBhdGguc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWNhcCcsICdyb3VuZCcpO1xuICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNob2Zmc2V0JywgMSk7XG4gICAgZm9yIChpOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIHBhdGggPSBjcmVhdGVOUygncGF0aCcpO1xuICAgICAgZ3JvdXBQYXRoLmFwcGVuZENoaWxkKHBhdGgpO1xuICAgICAgdGhpcy5wYXRocy5wdXNoKHtcbiAgICAgICAgcDogcGF0aCxcbiAgICAgICAgbTogaVxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMykge1xuICAgICAgdmFyIG1hc2sgPSBjcmVhdGVOUygnbWFzaycpO1xuICAgICAgdmFyIGlkID0gY3JlYXRlRWxlbWVudElEKCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICBtYXNrLnNldEF0dHJpYnV0ZSgnbWFzay10eXBlJywgJ2FscGhhJyk7XG4gICAgICBtYXNrLmFwcGVuZENoaWxkKGdyb3VwUGF0aCk7XG4gICAgICB0aGlzLmVsZW0uZ2xvYmFsRGF0YS5kZWZzLmFwcGVuZENoaWxkKG1hc2spO1xuICAgICAgdmFyIGcgPSBjcmVhdGVOUygnZycpO1xuICAgICAgZy5zZXRBdHRyaWJ1dGUoJ21hc2snLCAndXJsKCcgKyBnZXRMb2NhdGlvbkhyZWYoKSArICcjJyArIGlkICsgJyknKTtcbiAgICAgIHdoaWxlIChlbGVtQ2hpbGRyZW5bMF0pIHtcbiAgICAgICAgZy5hcHBlbmRDaGlsZChlbGVtQ2hpbGRyZW5bMF0pO1xuICAgICAgfVxuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChnKTtcbiAgICAgIHRoaXMubWFza2VyID0gbWFzaztcbiAgICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICcjZmZmJyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMSB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMTBdLnAudiA9PT0gMikge1xuICAgICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICAgIGVsZW1DaGlsZHJlbiA9IHRoaXMuZWxlbS5sYXllckVsZW1lbnQuY2hpbGRyZW4gfHwgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5jaGlsZE5vZGVzO1xuICAgICAgICB3aGlsZSAoZWxlbUNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuZWxlbS5sYXllckVsZW1lbnQucmVtb3ZlQ2hpbGQoZWxlbUNoaWxkcmVuWzBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5hcHBlbmRDaGlsZChncm91cFBhdGgpO1xuICAgICAgdGhpcy5lbGVtLmxheWVyRWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ21hc2snKTtcbiAgICAgIGdyb3VwUGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZScsICcjZmZmJyk7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgIHRoaXMucGF0aE1hc2tlciA9IGdyb3VwUGF0aDtcbiAgfTtcbiAgU1ZHU3Ryb2tlRWZmZWN0LnByb3RvdHlwZS5yZW5kZXJGcmFtZSA9IGZ1bmN0aW9uIChmb3JjZVJlbmRlcikge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICAgIHZhciBpO1xuICAgIHZhciBsZW4gPSB0aGlzLnBhdGhzLmxlbmd0aDtcbiAgICB2YXIgbWFzaztcbiAgICB2YXIgcGF0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDEpIHtcbiAgICAgIGlmICh0aGlzLnBhdGhzW2ldLm0gIT09IC0xKSB7XG4gICAgICAgIG1hc2sgPSB0aGlzLmVsZW0ubWFza01hbmFnZXIudmlld0RhdGFbdGhpcy5wYXRoc1tpXS5tXTtcbiAgICAgICAgcGF0aCA9IHRoaXMucGF0aHNbaV0ucDtcbiAgICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmIHx8IG1hc2sucHJvcC5fbWRmKSB7XG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ2QnLCBtYXNrLmxhc3RQYXRoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzldLnAuX21kZiB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC5fbWRmIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s3XS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzhdLnAuX21kZiB8fCBtYXNrLnByb3AuX21kZikge1xuICAgICAgICAgIHZhciBkYXNoYXJyYXlWYWx1ZTtcbiAgICAgICAgICBpZiAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMCB8fCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52ICE9PSAxMDApIHtcbiAgICAgICAgICAgIHZhciBzID0gTWF0aC5taW4odGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzddLnAudiwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzhdLnAudikgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIGUgPSBNYXRoLm1heCh0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbN10ucC52LCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOF0ucC52KSAqIDAuMDE7XG4gICAgICAgICAgICB2YXIgbCA9IHBhdGguZ2V0VG90YWxMZW5ndGgoKTtcbiAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlID0gJzAgMCAwICcgKyBsICogcyArICcgJztcbiAgICAgICAgICAgIHZhciBsaW5lTGVuZ3RoID0gbCAqIChlIC0gcyk7XG4gICAgICAgICAgICB2YXIgc2VnbWVudCA9IDEgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMiAqIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYgKiAwLjAxO1xuICAgICAgICAgICAgdmFyIHVuaXRzID0gTWF0aC5mbG9vcihsaW5lTGVuZ3RoIC8gc2VnbWVudCk7XG4gICAgICAgICAgICB2YXIgajtcbiAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB1bml0czsgaiArPSAxKSB7XG4gICAgICAgICAgICAgIGRhc2hhcnJheVZhbHVlICs9ICcxICcgKyB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNF0ucC52ICogMiAqIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s5XS5wLnYgKiAwLjAxICsgJyAnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgKz0gJzAgJyArIGwgKiAxMCArICcgMCAwJztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGFzaGFycmF5VmFsdWUgPSAnMSAnICsgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAqIDIgKiB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbOV0ucC52ICogMC4wMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGF0aC5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1kYXNoYXJyYXknLCBkYXNoYXJyYXlWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYpIHtcbiAgICAgIHRoaXMucGF0aE1hc2tlci5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS13aWR0aCcsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s0XS5wLnYgKiAyKTtcbiAgICB9XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1s2XS5wLl9tZGYpIHtcbiAgICAgIHRoaXMucGF0aE1hc2tlci5zZXRBdHRyaWJ1dGUoJ29wYWNpdHknLCB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbNl0ucC52KTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAxIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxMF0ucC52ID09PSAyKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgY29sb3IgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB0aGlzLnBhdGhNYXNrZXIuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAncmdiKCcgKyBibUZsb29yKGNvbG9yWzBdICogMjU1KSArICcsJyArIGJtRmxvb3IoY29sb3JbMV0gKiAyNTUpICsgJywnICsgYm1GbG9vcihjb2xvclsyXSAqIDI1NSkgKyAnKScpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdUcml0b25lRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUNvbG9yTWF0cml4ID0gY3JlYXRlTlMoJ2ZlQ29sb3JNYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgndHlwZScsICdtYXRyaXgnKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ2xpbmVhclJHQicpO1xuICAgIGZlQ29sb3JNYXRyaXguc2V0QXR0cmlidXRlKCd2YWx1ZXMnLCAnMC4zMzMzIDAuMzMzMyAwLjMzMzMgMCAwIDAuMzMzMyAwLjMzMzMgMC4zMzMzIDAgMCAwLjMzMzMgMC4zMzMzIDAuMzMzMyAwIDAgMCAwIDAgMSAwJyk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlQ29sb3JNYXRyaXgpO1xuICAgIHZhciBmZUNvbXBvbmVudFRyYW5zZmVyID0gY3JlYXRlTlMoJ2ZlQ29tcG9uZW50VHJhbnNmZXInKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgncmVzdWx0JywgaWQpO1xuICAgIHRoaXMubWF0cml4RmlsdGVyID0gZmVDb21wb25lbnRUcmFuc2ZlcjtcbiAgICB2YXIgZmVGdW5jUiA9IGNyZWF0ZU5TKCdmZUZ1bmNSJyk7XG4gICAgZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGFibGUnKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZENoaWxkKGZlRnVuY1IpO1xuICAgIHRoaXMuZmVGdW5jUiA9IGZlRnVuY1I7XG4gICAgdmFyIGZlRnVuY0cgPSBjcmVhdGVOUygnZmVGdW5jRycpO1xuICAgIGZlRnVuY0cuc2V0QXR0cmlidXRlKCd0eXBlJywgJ3RhYmxlJyk7XG4gICAgZmVDb21wb25lbnRUcmFuc2Zlci5hcHBlbmRDaGlsZChmZUZ1bmNHKTtcbiAgICB0aGlzLmZlRnVuY0cgPSBmZUZ1bmNHO1xuICAgIHZhciBmZUZ1bmNCID0gY3JlYXRlTlMoJ2ZlRnVuY0InKTtcbiAgICBmZUZ1bmNCLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jQik7XG4gICAgdGhpcy5mZUZ1bmNCID0gZmVGdW5jQjtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gIH1cbiAgU1ZHVHJpdG9uZUZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciBjb2xvcjEgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xuICAgICAgdmFyIGNvbG9yMiA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnY7XG4gICAgICB2YXIgY29sb3IzID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudjtcbiAgICAgIHZhciB0YWJsZVIgPSBjb2xvcjNbMF0gKyAnICcgKyBjb2xvcjJbMF0gKyAnICcgKyBjb2xvcjFbMF07XG4gICAgICB2YXIgdGFibGVHID0gY29sb3IzWzFdICsgJyAnICsgY29sb3IyWzFdICsgJyAnICsgY29sb3IxWzFdO1xuICAgICAgdmFyIHRhYmxlQiA9IGNvbG9yM1syXSArICcgJyArIGNvbG9yMlsyXSArICcgJyArIGNvbG9yMVsyXTtcbiAgICAgIHRoaXMuZmVGdW5jUi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVSKTtcbiAgICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVHKTtcbiAgICAgIHRoaXMuZmVGdW5jQi5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdGFibGVCKTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHUHJvTGV2ZWxzRmlsdGVyKGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQpIHtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBlZmZlY3RFbGVtZW50cyA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50cztcbiAgICB2YXIgZmVDb21wb25lbnRUcmFuc2ZlciA9IGNyZWF0ZU5TKCdmZUNvbXBvbmVudFRyYW5zZmVyJyk7XG5cbiAgICAvLyBSZWRcbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMTBdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTFdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1sxMl0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzEyXS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMTNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMTRdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNSID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY1InLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9XG4gICAgLy8gR3JlZW5cbiAgICBpZiAoZWZmZWN0RWxlbWVudHNbMTddLnAuayB8fCBlZmZlY3RFbGVtZW50c1sxN10ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzE4XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMThdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1sxOV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLnYgIT09IDEgfHwgZWZmZWN0RWxlbWVudHNbMjBdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syMF0ucC52ICE9PSAwIHx8IGVmZmVjdEVsZW1lbnRzWzIxXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjFdLnAudiAhPT0gMSkge1xuICAgICAgdGhpcy5mZUZ1bmNHID0gdGhpcy5jcmVhdGVGZUZ1bmMoJ2ZlRnVuY0cnLCBmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9XG4gICAgLy8gQmx1ZVxuICAgIGlmIChlZmZlY3RFbGVtZW50c1syNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI0XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syNV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzI2XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMjZdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1syN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzI3XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAuayB8fCBlZmZlY3RFbGVtZW50c1syOF0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0IgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQicsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cbiAgICAvLyBBbHBoYVxuICAgIGlmIChlZmZlY3RFbGVtZW50c1szMV0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzMxXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzJdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szMl0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzMzXS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzM0XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbMzVdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szNV0ucC52ICE9PSAxKSB7XG4gICAgICB0aGlzLmZlRnVuY0EgPSB0aGlzLmNyZWF0ZUZlRnVuYygnZmVGdW5jQScsIGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIH1cbiAgICAvLyBSR0JcbiAgICBpZiAodGhpcy5mZUZ1bmNSIHx8IHRoaXMuZmVGdW5jRyB8fCB0aGlzLmZlRnVuY0IgfHwgdGhpcy5mZUZ1bmNBKSB7XG4gICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvbmVudFRyYW5zZmVyKTtcbiAgICB9XG4gICAgaWYgKGVmZmVjdEVsZW1lbnRzWzNdLnAuayB8fCBlZmZlY3RFbGVtZW50c1szXS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbNF0ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzRdLnAudiAhPT0gMSB8fCBlZmZlY3RFbGVtZW50c1s1XS5wLmsgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC52ICE9PSAxIHx8IGVmZmVjdEVsZW1lbnRzWzZdLnAuayB8fCBlZmZlY3RFbGVtZW50c1s2XS5wLnYgIT09IDAgfHwgZWZmZWN0RWxlbWVudHNbN10ucC5rIHx8IGVmZmVjdEVsZW1lbnRzWzddLnAudiAhPT0gMSkge1xuICAgICAgZmVDb21wb25lbnRUcmFuc2ZlciA9IGNyZWF0ZU5TKCdmZUNvbXBvbmVudFRyYW5zZmVyJyk7XG4gICAgICBmZUNvbXBvbmVudFRyYW5zZmVyLnNldEF0dHJpYnV0ZSgnY29sb3ItaW50ZXJwb2xhdGlvbi1maWx0ZXJzJywgJ3NSR0InKTtcbiAgICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCk7XG4gICAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgICB0aGlzLmZlRnVuY1JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNSJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgICB0aGlzLmZlRnVuY0dDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNHJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgICB0aGlzLmZlRnVuY0JDb21wb3NlZCA9IHRoaXMuY3JlYXRlRmVGdW5jKCdmZUZ1bmNCJywgZmVDb21wb25lbnRUcmFuc2Zlcik7XG4gICAgfVxuICB9XG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUuY3JlYXRlRmVGdW5jID0gZnVuY3Rpb24gKHR5cGUsIGZlQ29tcG9uZW50VHJhbnNmZXIpIHtcbiAgICB2YXIgZmVGdW5jID0gY3JlYXRlTlModHlwZSk7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZSgndHlwZScsICd0YWJsZScpO1xuICAgIGZlQ29tcG9uZW50VHJhbnNmZXIuYXBwZW5kQ2hpbGQoZmVGdW5jKTtcbiAgICByZXR1cm4gZmVGdW5jO1xuICB9O1xuICBTVkdQcm9MZXZlbHNGaWx0ZXIucHJvdG90eXBlLmdldFRhYmxlVmFsdWUgPSBmdW5jdGlvbiAoaW5wdXRCbGFjaywgaW5wdXRXaGl0ZSwgZ2FtbWEsIG91dHB1dEJsYWNrLCBvdXRwdXRXaGl0ZSkge1xuICAgIHZhciBjbnQgPSAwO1xuICAgIHZhciBzZWdtZW50cyA9IDI1NjtcbiAgICB2YXIgcGVyYztcbiAgICB2YXIgbWluID0gTWF0aC5taW4oaW5wdXRCbGFjaywgaW5wdXRXaGl0ZSk7XG4gICAgdmFyIG1heCA9IE1hdGgubWF4KGlucHV0QmxhY2ssIGlucHV0V2hpdGUpO1xuICAgIHZhciB0YWJsZSA9IEFycmF5LmNhbGwobnVsbCwge1xuICAgICAgbGVuZ3RoOiBzZWdtZW50c1xuICAgIH0pO1xuICAgIHZhciBjb2xvclZhbHVlO1xuICAgIHZhciBwb3MgPSAwO1xuICAgIHZhciBvdXRwdXREZWx0YSA9IG91dHB1dFdoaXRlIC0gb3V0cHV0QmxhY2s7XG4gICAgdmFyIGlucHV0RGVsdGEgPSBpbnB1dFdoaXRlIC0gaW5wdXRCbGFjaztcbiAgICB3aGlsZSAoY250IDw9IDI1Nikge1xuICAgICAgcGVyYyA9IGNudCAvIDI1NjtcbiAgICAgIGlmIChwZXJjIDw9IG1pbikge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRXaGl0ZSA6IG91dHB1dEJsYWNrO1xuICAgICAgfSBlbHNlIGlmIChwZXJjID49IG1heCkge1xuICAgICAgICBjb2xvclZhbHVlID0gaW5wdXREZWx0YSA8IDAgPyBvdXRwdXRCbGFjayA6IG91dHB1dFdoaXRlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29sb3JWYWx1ZSA9IG91dHB1dEJsYWNrICsgb3V0cHV0RGVsdGEgKiBNYXRoLnBvdygocGVyYyAtIGlucHV0QmxhY2spIC8gaW5wdXREZWx0YSwgMSAvIGdhbW1hKTtcbiAgICAgIH1cbiAgICAgIHRhYmxlW3Bvc10gPSBjb2xvclZhbHVlO1xuICAgICAgcG9zICs9IDE7XG4gICAgICBjbnQgKz0gMjU2IC8gKHNlZ21lbnRzIC0gMSk7XG4gICAgfVxuICAgIHJldHVybiB0YWJsZS5qb2luKCcgJyk7XG4gIH07XG4gIFNWR1Byb0xldmVsc0ZpbHRlci5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VSZW5kZXIpIHtcbiAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLl9tZGYpIHtcbiAgICAgIHZhciB2YWw7XG4gICAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHM7XG4gICAgICBpZiAodGhpcy5mZUZ1bmNSQ29tcG9zZWQgJiYgKGZvcmNlUmVuZGVyIHx8IGVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s0XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbNV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzZdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1s3XS5wLl9tZGYpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1szXS5wLnYsIGVmZmVjdEVsZW1lbnRzWzRdLnAudiwgZWZmZWN0RWxlbWVudHNbNV0ucC52LCBlZmZlY3RFbGVtZW50c1s2XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzddLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jUkNvbXBvc2VkLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgICB0aGlzLmZlRnVuY0dDb21wb3NlZC5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgICAgdGhpcy5mZUZ1bmNCQ29tcG9zZWQuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mZUZ1bmNSICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1sxMF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzExXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMTJdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxM10ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE0XS5wLl9tZGYpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1sxMF0ucC52LCBlZmZlY3RFbGVtZW50c1sxMV0ucC52LCBlZmZlY3RFbGVtZW50c1sxMl0ucC52LCBlZmZlY3RFbGVtZW50c1sxM10ucC52LCBlZmZlY3RFbGVtZW50c1sxNF0ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNSLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZmVGdW5jRyAmJiAoZm9yY2VSZW5kZXIgfHwgZWZmZWN0RWxlbWVudHNbMTddLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1sxOF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzE5XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjBdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syMV0ucC5fbWRmKSkge1xuICAgICAgICB2YWwgPSB0aGlzLmdldFRhYmxlVmFsdWUoZWZmZWN0RWxlbWVudHNbMTddLnAudiwgZWZmZWN0RWxlbWVudHNbMThdLnAudiwgZWZmZWN0RWxlbWVudHNbMTldLnAudiwgZWZmZWN0RWxlbWVudHNbMjBdLnAudiwgZWZmZWN0RWxlbWVudHNbMjFdLnAudik7XG4gICAgICAgIHRoaXMuZmVGdW5jRy5zZXRBdHRyaWJ1dGUoJ3RhYmxlVmFsdWVzJywgdmFsKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmZlRnVuY0IgJiYgKGZvcmNlUmVuZGVyIHx8IGVmZmVjdEVsZW1lbnRzWzI0XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjVdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1syNl0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzI3XS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMjhdLnAuX21kZikpIHtcbiAgICAgICAgdmFsID0gdGhpcy5nZXRUYWJsZVZhbHVlKGVmZmVjdEVsZW1lbnRzWzI0XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzI1XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzI2XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzI3XS5wLnYsIGVmZmVjdEVsZW1lbnRzWzI4XS5wLnYpO1xuICAgICAgICB0aGlzLmZlRnVuY0Iuc2V0QXR0cmlidXRlKCd0YWJsZVZhbHVlcycsIHZhbCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5mZUZ1bmNBICYmIChmb3JjZVJlbmRlciB8fCBlZmZlY3RFbGVtZW50c1szMV0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzMyXS5wLl9tZGYgfHwgZWZmZWN0RWxlbWVudHNbMzNdLnAuX21kZiB8fCBlZmZlY3RFbGVtZW50c1szNF0ucC5fbWRmIHx8IGVmZmVjdEVsZW1lbnRzWzM1XS5wLl9tZGYpKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuZ2V0VGFibGVWYWx1ZShlZmZlY3RFbGVtZW50c1szMV0ucC52LCBlZmZlY3RFbGVtZW50c1szMl0ucC52LCBlZmZlY3RFbGVtZW50c1szM10ucC52LCBlZmZlY3RFbGVtZW50c1szNF0ucC52LCBlZmZlY3RFbGVtZW50c1szNV0ucC52KTtcbiAgICAgICAgdGhpcy5mZUZ1bmNBLnNldEF0dHJpYnV0ZSgndGFibGVWYWx1ZXMnLCB2YWwpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBTVkdEcm9wU2hhZG93RWZmZWN0KGZpbHRlciwgZmlsdGVyTWFuYWdlciwgZWxlbSwgaWQsIHNvdXJjZSkge1xuICAgIHZhciBnbG9iYWxGaWx0ZXJTaXplID0gZmlsdGVyTWFuYWdlci5jb250YWluZXIuZ2xvYmFsRGF0YS5yZW5kZXJDb25maWcuZmlsdGVyU2l6ZTtcbiAgICB2YXIgZmlsdGVyU2l6ZSA9IGZpbHRlck1hbmFnZXIuZGF0YS5mcyB8fCBnbG9iYWxGaWx0ZXJTaXplO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3gnLCBmaWx0ZXJTaXplLnggfHwgZ2xvYmFsRmlsdGVyU2l6ZS54KTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd5JywgZmlsdGVyU2l6ZS55IHx8IGdsb2JhbEZpbHRlclNpemUueSk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCBmaWx0ZXJTaXplLndpZHRoIHx8IGdsb2JhbEZpbHRlclNpemUud2lkdGgpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsIGZpbHRlclNpemUuaGVpZ2h0IHx8IGdsb2JhbEZpbHRlclNpemUuaGVpZ2h0KTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHZhciBmZUdhdXNzaWFuQmx1ciA9IGNyZWF0ZU5TKCdmZUdhdXNzaWFuQmx1cicpO1xuICAgIGZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnaW4nLCAnU291cmNlQWxwaGEnKTtcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ19kcm9wX3NoYWRvd18xJyk7XG4gICAgZmVHYXVzc2lhbkJsdXIuc2V0QXR0cmlidXRlKCdzdGREZXZpYXRpb24nLCAnMCcpO1xuICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIgPSBmZUdhdXNzaWFuQmx1cjtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVHYXVzc2lhbkJsdXIpO1xuICAgIHZhciBmZU9mZnNldCA9IGNyZWF0ZU5TKCdmZU9mZnNldCcpO1xuICAgIGZlT2Zmc2V0LnNldEF0dHJpYnV0ZSgnZHgnLCAnMjUnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R5JywgJzAnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2luJywgaWQgKyAnX2Ryb3Bfc2hhZG93XzEnKTtcbiAgICBmZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkICsgJ19kcm9wX3NoYWRvd18yJyk7XG4gICAgdGhpcy5mZU9mZnNldCA9IGZlT2Zmc2V0O1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZU9mZnNldCk7XG4gICAgdmFyIGZlRmxvb2QgPSBjcmVhdGVOUygnZmVGbG9vZCcpO1xuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdmbG9vZC1jb2xvcicsICcjMDBmZjAwJyk7XG4gICAgZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLW9wYWNpdHknLCAnMScpO1xuICAgIGZlRmxvb2Quc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfMycpO1xuICAgIHRoaXMuZmVGbG9vZCA9IGZlRmxvb2Q7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlRmxvb2QpO1xuICAgIHZhciBmZUNvbXBvc2l0ZSA9IGNyZWF0ZU5TKCdmZUNvbXBvc2l0ZScpO1xuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgnaW4nLCBpZCArICdfZHJvcF9zaGFkb3dfMycpO1xuICAgIGZlQ29tcG9zaXRlLnNldEF0dHJpYnV0ZSgnaW4yJywgaWQgKyAnX2Ryb3Bfc2hhZG93XzInKTtcbiAgICBmZUNvbXBvc2l0ZS5zZXRBdHRyaWJ1dGUoJ29wZXJhdG9yJywgJ2luJyk7XG4gICAgZmVDb21wb3NpdGUuc2V0QXR0cmlidXRlKCdyZXN1bHQnLCBpZCArICdfZHJvcF9zaGFkb3dfNCcpO1xuICAgIGZpbHRlci5hcHBlbmRDaGlsZChmZUNvbXBvc2l0ZSk7XG4gICAgdmFyIGZlTWVyZ2UgPSB0aGlzLmNyZWF0ZU1lcmdlTm9kZShpZCwgW2lkICsgJ19kcm9wX3NoYWRvd180Jywgc291cmNlXSk7XG4gICAgZmlsdGVyLmFwcGVuZENoaWxkKGZlTWVyZ2UpO1xuICAgIC8vXG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtTVkdDb21wb3NhYmxlRWZmZWN0XSwgU1ZHRHJvcFNoYWRvd0VmZmVjdCk7XG4gIFNWR0Ryb3BTaGFkb3dFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICBpZiAoZm9yY2VSZW5kZXIgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAuX21kZikge1xuICAgICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzRdLnAudiAvIDQpO1xuICAgICAgfVxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLl9tZGYpIHtcbiAgICAgICAgdmFyIGNvbCA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnY7XG4gICAgICAgIHRoaXMuZmVGbG9vZC5zZXRBdHRyaWJ1dGUoJ2Zsb29kLWNvbG9yJywgcmdiVG9IZXgoTWF0aC5yb3VuZChjb2xbMF0gKiAyNTUpLCBNYXRoLnJvdW5kKGNvbFsxXSAqIDI1NSksIE1hdGgucm91bmQoY29sWzJdICogMjU1KSkpO1xuICAgICAgfVxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLl9tZGYpIHtcbiAgICAgICAgdGhpcy5mZUZsb29kLnNldEF0dHJpYnV0ZSgnZmxvb2Qtb3BhY2l0eScsIHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1sxXS5wLnYgLyAyNTUpO1xuICAgICAgfVxuICAgICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1syXS5wLl9tZGYgfHwgdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzNdLnAuX21kZikge1xuICAgICAgICB2YXIgZGlzdGFuY2UgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbM10ucC52O1xuICAgICAgICB2YXIgYW5nbGUgPSAodGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiAtIDkwKSAqIGRlZ1RvUmFkcztcbiAgICAgICAgdmFyIHggPSBkaXN0YW5jZSAqIE1hdGguY29zKGFuZ2xlKTtcbiAgICAgICAgdmFyIHkgPSBkaXN0YW5jZSAqIE1hdGguc2luKGFuZ2xlKTtcbiAgICAgICAgdGhpcy5mZU9mZnNldC5zZXRBdHRyaWJ1dGUoJ2R4JywgeCk7XG4gICAgICAgIHRoaXMuZmVPZmZzZXQuc2V0QXR0cmlidXRlKCdkeScsIHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICB2YXIgX3N2Z01hdHRlU3ltYm9scyA9IFtdO1xuICBmdW5jdGlvbiBTVkdNYXR0ZTNFZmZlY3QoZmlsdGVyRWxlbSwgZmlsdGVyTWFuYWdlciwgZWxlbSkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmZpbHRlck1hbmFnZXIgPSBmaWx0ZXJNYW5hZ2VyO1xuICAgIHRoaXMuZmlsdGVyRWxlbSA9IGZpbHRlckVsZW07XG4gICAgdGhpcy5lbGVtID0gZWxlbTtcbiAgICBlbGVtLm1hdHRlRWxlbWVudCA9IGNyZWF0ZU5TKCdnJyk7XG4gICAgZWxlbS5tYXR0ZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZWxlbS5sYXllckVsZW1lbnQpO1xuICAgIGVsZW0ubWF0dGVFbGVtZW50LmFwcGVuZENoaWxkKGVsZW0udHJhbnNmb3JtZWRFbGVtZW50KTtcbiAgICBlbGVtLmJhc2VFbGVtZW50ID0gZWxlbS5tYXR0ZUVsZW1lbnQ7XG4gIH1cbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5maW5kU3ltYm9sID0gZnVuY3Rpb24gKG1hc2spIHtcbiAgICB2YXIgaSA9IDA7XG4gICAgdmFyIGxlbiA9IF9zdmdNYXR0ZVN5bWJvbHMubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoX3N2Z01hdHRlU3ltYm9sc1tpXSA9PT0gbWFzaykge1xuICAgICAgICByZXR1cm4gX3N2Z01hdHRlU3ltYm9sc1tpXTtcbiAgICAgIH1cbiAgICAgIGkgKz0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH07XG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUucmVwbGFjZUluUGFyZW50ID0gZnVuY3Rpb24gKG1hc2ssIHN5bWJvbElkKSB7XG4gICAgdmFyIHBhcmVudE5vZGUgPSBtYXNrLmxheWVyRWxlbWVudC5wYXJlbnROb2RlO1xuICAgIGlmICghcGFyZW50Tm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgY2hpbGRyZW4gPSBwYXJlbnROb2RlLmNoaWxkcmVuO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gY2hpbGRyZW4ubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoY2hpbGRyZW5baV0gPT09IG1hc2subGF5ZXJFbGVtZW50KSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSArPSAxO1xuICAgIH1cbiAgICB2YXIgbmV4dENoaWxkO1xuICAgIGlmIChpIDw9IGxlbiAtIDIpIHtcbiAgICAgIG5leHRDaGlsZCA9IGNoaWxkcmVuW2kgKyAxXTtcbiAgICB9XG4gICAgdmFyIHVzZUVsZW0gPSBjcmVhdGVOUygndXNlJyk7XG4gICAgdXNlRWxlbS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycgKyBzeW1ib2xJZCk7XG4gICAgaWYgKG5leHRDaGlsZCkge1xuICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUodXNlRWxlbSwgbmV4dENoaWxkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyZW50Tm9kZS5hcHBlbmRDaGlsZCh1c2VFbGVtKTtcbiAgICB9XG4gIH07XG4gIFNWR01hdHRlM0VmZmVjdC5wcm90b3R5cGUuc2V0RWxlbWVudEFzTWFzayA9IGZ1bmN0aW9uIChlbGVtLCBtYXNrKSB7XG4gICAgaWYgKCF0aGlzLmZpbmRTeW1ib2wobWFzaykpIHtcbiAgICAgIHZhciBzeW1ib2xJZCA9IGNyZWF0ZUVsZW1lbnRJRCgpO1xuICAgICAgdmFyIG1hc2tlciA9IGNyZWF0ZU5TKCdtYXNrJyk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdpZCcsIG1hc2subGF5ZXJJZCk7XG4gICAgICBtYXNrZXIuc2V0QXR0cmlidXRlKCdtYXNrLXR5cGUnLCAnYWxwaGEnKTtcbiAgICAgIF9zdmdNYXR0ZVN5bWJvbHMucHVzaChtYXNrKTtcbiAgICAgIHZhciBkZWZzID0gZWxlbS5nbG9iYWxEYXRhLmRlZnM7XG4gICAgICBkZWZzLmFwcGVuZENoaWxkKG1hc2tlcik7XG4gICAgICB2YXIgc3ltYm9sID0gY3JlYXRlTlMoJ3N5bWJvbCcpO1xuICAgICAgc3ltYm9sLnNldEF0dHJpYnV0ZSgnaWQnLCBzeW1ib2xJZCk7XG4gICAgICB0aGlzLnJlcGxhY2VJblBhcmVudChtYXNrLCBzeW1ib2xJZCk7XG4gICAgICBzeW1ib2wuYXBwZW5kQ2hpbGQobWFzay5sYXllckVsZW1lbnQpO1xuICAgICAgZGVmcy5hcHBlbmRDaGlsZChzeW1ib2wpO1xuICAgICAgdmFyIHVzZUVsZW0gPSBjcmVhdGVOUygndXNlJyk7XG4gICAgICB1c2VFbGVtLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyArIHN5bWJvbElkKTtcbiAgICAgIG1hc2tlci5hcHBlbmRDaGlsZCh1c2VFbGVtKTtcbiAgICAgIG1hc2suZGF0YS5oZCA9IGZhbHNlO1xuICAgICAgbWFzay5zaG93KCk7XG4gICAgfVxuICAgIGVsZW0uc2V0TWF0dGUobWFzay5sYXllcklkKTtcbiAgfTtcbiAgU1ZHTWF0dGUzRWZmZWN0LnByb3RvdHlwZS5pbml0aWFsaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBpbmQgPSB0aGlzLmZpbHRlck1hbmFnZXIuZWZmZWN0RWxlbWVudHNbMF0ucC52O1xuICAgIHZhciBlbGVtZW50cyA9IHRoaXMuZWxlbS5jb21wLmVsZW1lbnRzO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZWxlbWVudHMubGVuZ3RoO1xuICAgIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgICBpZiAoZWxlbWVudHNbaV0gJiYgZWxlbWVudHNbaV0uZGF0YS5pbmQgPT09IGluZCkge1xuICAgICAgICB0aGlzLnNldEVsZW1lbnRBc01hc2sodGhpcy5lbGVtLCBlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgICBpICs9IDE7XG4gICAgfVxuICAgIHRoaXMuaW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9O1xuICBTVkdNYXR0ZTNFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xuICAgICAgdGhpcy5pbml0aWFsaXplKCk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFNWR0dhdXNzaWFuQmx1ckVmZmVjdChmaWx0ZXIsIGZpbHRlck1hbmFnZXIsIGVsZW0sIGlkKSB7XG4gICAgLy8gT3V0c2V0IHRoZSBmaWx0ZXIgcmVnaW9uIGJ5IDEwMCUgb24gYWxsIHNpZGVzIHRvIGFjY29tbW9kYXRlIGJsdXIgZXhwYW5zaW9uLlxuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ3gnLCAnLTEwMCUnKTtcbiAgICBmaWx0ZXIuc2V0QXR0cmlidXRlKCd5JywgJy0xMDAlJyk7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZSgnd2lkdGgnLCAnMzAwJScpO1xuICAgIGZpbHRlci5zZXRBdHRyaWJ1dGUoJ2hlaWdodCcsICczMDAlJyk7XG4gICAgdGhpcy5maWx0ZXJNYW5hZ2VyID0gZmlsdGVyTWFuYWdlcjtcbiAgICB2YXIgZmVHYXVzc2lhbkJsdXIgPSBjcmVhdGVOUygnZmVHYXVzc2lhbkJsdXInKTtcbiAgICBmZUdhdXNzaWFuQmx1ci5zZXRBdHRyaWJ1dGUoJ3Jlc3VsdCcsIGlkKTtcbiAgICBmaWx0ZXIuYXBwZW5kQ2hpbGQoZmVHYXVzc2lhbkJsdXIpO1xuICAgIHRoaXMuZmVHYXVzc2lhbkJsdXIgPSBmZUdhdXNzaWFuQmx1cjtcbiAgfVxuICBTVkdHYXVzc2lhbkJsdXJFZmZlY3QucHJvdG90eXBlLnJlbmRlckZyYW1lID0gZnVuY3Rpb24gKGZvcmNlUmVuZGVyKSB7XG4gICAgaWYgKGZvcmNlUmVuZGVyIHx8IHRoaXMuZmlsdGVyTWFuYWdlci5fbWRmKSB7XG4gICAgICAvLyBFbXBpcmljYWwgdmFsdWUsIG1hdGNoaW5nIEFFJ3MgYmx1ciBhcHBlYXJhbmNlLlxuICAgICAgdmFyIGtCbHVycmluZXNzVG9TaWdtYSA9IDAuMztcbiAgICAgIHZhciBzaWdtYSA9IHRoaXMuZmlsdGVyTWFuYWdlci5lZmZlY3RFbGVtZW50c1swXS5wLnYgKiBrQmx1cnJpbmVzc1RvU2lnbWE7XG5cbiAgICAgIC8vIERpbWVuc2lvbnMgbWFwcGluZzpcbiAgICAgIC8vXG4gICAgICAvLyAgIDEgLT4gaG9yaXpvbnRhbCAmIHZlcnRpY2FsXG4gICAgICAvLyAgIDIgLT4gaG9yaXpvbnRhbCBvbmx5XG4gICAgICAvLyAgIDMgLT4gdmVydGljYWwgb25seVxuICAgICAgLy9cbiAgICAgIHZhciBkaW1lbnNpb25zID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzFdLnAudjtcbiAgICAgIHZhciBzaWdtYVggPSBkaW1lbnNpb25zID09IDMgPyAwIDogc2lnbWE7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICB2YXIgc2lnbWFZID0gZGltZW5zaW9ucyA9PSAyID8gMCA6IHNpZ21hOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuXG4gICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnc3RkRGV2aWF0aW9uJywgc2lnbWFYICsgJyAnICsgc2lnbWFZKTtcblxuICAgICAgLy8gUmVwZWF0IGVkZ2VzIG1hcHBpbmc6XG4gICAgICAvL1xuICAgICAgLy8gICAwIC0+IG9mZiAtPiBkdXBsaWNhdGVcbiAgICAgIC8vICAgMSAtPiBvbiAgLT4gd3JhcFxuICAgICAgdmFyIGVkZ2VNb2RlID0gdGhpcy5maWx0ZXJNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzWzJdLnAudiA9PSAxID8gJ3dyYXAnIDogJ2R1cGxpY2F0ZSc7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgICB0aGlzLmZlR2F1c3NpYW5CbHVyLnNldEF0dHJpYnV0ZSgnZWRnZU1vZGUnLCBlZGdlTW9kZSk7XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIFRyYW5zZm9ybUVmZmVjdCgpIHt9XG4gIFRyYW5zZm9ybUVmZmVjdC5wcm90b3R5cGUuaW5pdCA9IGZ1bmN0aW9uIChlZmZlY3RzTWFuYWdlcikge1xuICAgIHRoaXMuZWZmZWN0c01hbmFnZXIgPSBlZmZlY3RzTWFuYWdlcjtcbiAgICB0aGlzLnR5cGUgPSBlZmZlY3RUeXBlcy5UUkFOU0ZPUk1fRUZGRUNUO1xuICAgIHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeCgpO1xuICAgIHRoaXMub3BhY2l0eSA9IC0xO1xuICAgIHRoaXMuX21kZiA9IGZhbHNlO1xuICAgIHRoaXMuX29wTWRmID0gZmFsc2U7XG4gIH07XG4gIFRyYW5zZm9ybUVmZmVjdC5wcm90b3R5cGUucmVuZGVyRnJhbWUgPSBmdW5jdGlvbiAoZm9yY2VGcmFtZSkge1xuICAgIHRoaXMuX29wTWRmID0gZmFsc2U7XG4gICAgdGhpcy5fbWRmID0gZmFsc2U7XG4gICAgaWYgKGZvcmNlRnJhbWUgfHwgdGhpcy5lZmZlY3RzTWFuYWdlci5fbWRmKSB7XG4gICAgICB2YXIgZWZmZWN0RWxlbWVudHMgPSB0aGlzLmVmZmVjdHNNYW5hZ2VyLmVmZmVjdEVsZW1lbnRzO1xuICAgICAgdmFyIGFuY2hvciA9IGVmZmVjdEVsZW1lbnRzWzBdLnAudjtcbiAgICAgIHZhciBwb3NpdGlvbiA9IGVmZmVjdEVsZW1lbnRzWzFdLnAudjtcbiAgICAgIHZhciBpc1VuaWZvcm1TY2FsZSA9IGVmZmVjdEVsZW1lbnRzWzJdLnAudiA9PT0gMTtcbiAgICAgIHZhciBzY2FsZUhlaWdodCA9IGVmZmVjdEVsZW1lbnRzWzNdLnAudjtcbiAgICAgIHZhciBzY2FsZVdpZHRoID0gaXNVbmlmb3JtU2NhbGUgPyBzY2FsZUhlaWdodCA6IGVmZmVjdEVsZW1lbnRzWzRdLnAudjtcbiAgICAgIHZhciBza2V3ID0gZWZmZWN0RWxlbWVudHNbNV0ucC52O1xuICAgICAgdmFyIHNrZXdBeGlzID0gZWZmZWN0RWxlbWVudHNbNl0ucC52O1xuICAgICAgdmFyIHJvdGF0aW9uID0gZWZmZWN0RWxlbWVudHNbN10ucC52O1xuICAgICAgdGhpcy5tYXRyaXgucmVzZXQoKTtcbiAgICAgIHRoaXMubWF0cml4LnRyYW5zbGF0ZSgtYW5jaG9yWzBdLCAtYW5jaG9yWzFdLCBhbmNob3JbMl0pO1xuICAgICAgdGhpcy5tYXRyaXguc2NhbGUoc2NhbGVXaWR0aCAqIDAuMDEsIHNjYWxlSGVpZ2h0ICogMC4wMSwgMSk7XG4gICAgICB0aGlzLm1hdHJpeC5yb3RhdGUoLXJvdGF0aW9uICogZGVnVG9SYWRzKTtcbiAgICAgIHRoaXMubWF0cml4LnNrZXdGcm9tQXhpcygtc2tldyAqIGRlZ1RvUmFkcywgKHNrZXdBeGlzICsgOTApICogZGVnVG9SYWRzKTtcbiAgICAgIHRoaXMubWF0cml4LnRyYW5zbGF0ZShwb3NpdGlvblswXSwgcG9zaXRpb25bMV0sIDApO1xuICAgICAgdGhpcy5fbWRmID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLm9wYWNpdHkgIT09IGVmZmVjdEVsZW1lbnRzWzhdLnAudikge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBlZmZlY3RFbGVtZW50c1s4XS5wLnY7XG4gICAgICAgIHRoaXMuX29wTWRmID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gU1ZHVHJhbnNmb3JtRWZmZWN0KF8sIGZpbHRlck1hbmFnZXIpIHtcbiAgICB0aGlzLmluaXQoZmlsdGVyTWFuYWdlcik7XG4gIH1cbiAgZXh0ZW5kUHJvdG90eXBlKFtUcmFuc2Zvcm1FZmZlY3RdLCBTVkdUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIGZ1bmN0aW9uIENWVHJhbnNmb3JtRWZmZWN0KGVmZmVjdHNNYW5hZ2VyKSB7XG4gICAgdGhpcy5pbml0KGVmZmVjdHNNYW5hZ2VyKTtcbiAgfVxuICBleHRlbmRQcm90b3R5cGUoW1RyYW5zZm9ybUVmZmVjdF0sIENWVHJhbnNmb3JtRWZmZWN0KTtcblxuICAvLyBSZWdpc3RlcmluZyByZW5kZXJlcnNcbiAgcmVnaXN0ZXJSZW5kZXJlcignY2FudmFzJywgQ2FudmFzUmVuZGVyZXIpO1xuICByZWdpc3RlclJlbmRlcmVyKCdodG1sJywgSHlicmlkUmVuZGVyZXIpO1xuICByZWdpc3RlclJlbmRlcmVyKCdzdmcnLCBTVkdSZW5kZXJlcik7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgc2hhcGUgbW9kaWZpZXJzXG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3RtJywgVHJpbU1vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncGInLCBQdWNrZXJBbmRCbG9hdE1vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncnAnLCBSZXBlYXRlck1vZGlmaWVyKTtcbiAgU2hhcGVNb2RpZmllcnMucmVnaXN0ZXJNb2RpZmllcigncmQnLCBSb3VuZENvcm5lcnNNb2RpZmllcik7XG4gIFNoYXBlTW9kaWZpZXJzLnJlZ2lzdGVyTW9kaWZpZXIoJ3p6JywgWmlnWmFnTW9kaWZpZXIpO1xuICBTaGFwZU1vZGlmaWVycy5yZWdpc3Rlck1vZGlmaWVyKCdvcCcsIE9mZnNldFBhdGhNb2RpZmllcik7XG5cbiAgLy8gUmVnaXN0ZXJpbmcgZXhwcmVzc2lvbiBwbHVnaW5cbiAgc2V0RXhwcmVzc2lvbnNQbHVnaW4oRXhwcmVzc2lvbnMpO1xuICBzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyhnZXRJbnRlcmZhY2UpO1xuICBpbml0aWFsaXplJDEoKTtcbiAgaW5pdGlhbGl6ZSgpO1xuXG4gIC8vIFJlZ2lzdGVyaW5nIHN2ZyBlZmZlY3RzXG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjAsIFNWR1RpbnRGaWx0ZXIsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDIxLCBTVkdGaWxsRmlsdGVyLCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyMiwgU1ZHU3Ryb2tlRWZmZWN0LCBmYWxzZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjMsIFNWR1RyaXRvbmVGaWx0ZXIsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDI0LCBTVkdQcm9MZXZlbHNGaWx0ZXIsIHRydWUpO1xuICByZWdpc3RlckVmZmVjdCQxKDI1LCBTVkdEcm9wU2hhZG93RWZmZWN0LCB0cnVlKTtcbiAgcmVnaXN0ZXJFZmZlY3QkMSgyOCwgU1ZHTWF0dGUzRWZmZWN0LCBmYWxzZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMjksIFNWR0dhdXNzaWFuQmx1ckVmZmVjdCwgdHJ1ZSk7XG4gIHJlZ2lzdGVyRWZmZWN0JDEoMzUsIFNWR1RyYW5zZm9ybUVmZmVjdCwgZmFsc2UpO1xuICByZWdpc3RlckVmZmVjdCgzNSwgQ1ZUcmFuc2Zvcm1FZmZlY3QpO1xuXG4gIHJldHVybiBsb3R0aWU7XG5cbn0pKTtcbiJdLCJuYW1lcyI6WyJkb2N1bWVudCIsIm5hdmlnYXRvciIsImdsb2JhbCIsImZhY3RvcnkiLCJleHBvcnRzIiwibW9kdWxlIiwiZGVmaW5lIiwiYW1kIiwiZ2xvYmFsVGhpcyIsInNlbGYiLCJsb3R0aWUiLCJzdmdOUyIsImxvY2F0aW9uSHJlZiIsIl91c2VXZWJXb3JrZXIiLCJpbml0aWFsRGVmYXVsdEZyYW1lIiwic2V0V2ViV29ya2VyIiwiZmxhZyIsImdldFdlYldvcmtlciIsInNldExvY2F0aW9uSHJlZiIsInZhbHVlIiwiZ2V0TG9jYXRpb25IcmVmIiwiY3JlYXRlVGFnIiwidHlwZSIsImNyZWF0ZUVsZW1lbnQiLCJleHRlbmRQcm90b3R5cGUiLCJzb3VyY2VzIiwiZGVzdGluYXRpb24iLCJpIiwibGVuIiwibGVuZ3RoIiwic291cmNlUHJvdG90eXBlIiwicHJvdG90eXBlIiwiYXR0ciIsIk9iamVjdCIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImdldERlc2NyaXB0b3IiLCJvYmplY3QiLCJwcm9wIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiY3JlYXRlUHJveHlGdW5jdGlvbiIsIlByb3h5RnVuY3Rpb24iLCJhdWRpb0NvbnRyb2xsZXJGYWN0b3J5IiwiQXVkaW9Db250cm9sbGVyIiwiYXVkaW9GYWN0b3J5IiwiYXVkaW9zIiwiX3ZvbHVtZSIsIl9pc011dGVkIiwiYWRkQXVkaW8iLCJhdWRpbyIsInB1c2giLCJwYXVzZSIsInJlc3VtZSIsInNldFJhdGUiLCJyYXRlVmFsdWUiLCJjcmVhdGVBdWRpbyIsImFzc2V0UGF0aCIsIndpbmRvdyIsIkhvd2wiLCJzcmMiLCJpc1BsYXlpbmciLCJwbGF5Iiwic2VlayIsInBsYXlpbmciLCJyYXRlIiwic2V0Vm9sdW1lIiwic2V0QXVkaW9GYWN0b3J5IiwiX3VwZGF0ZVZvbHVtZSIsIm11dGUiLCJ1bm11dGUiLCJnZXRWb2x1bWUiLCJ2b2x1bWUiLCJjcmVhdGVUeXBlZEFycmF5IiwiY3JlYXRlUmVndWxhckFycmF5IiwiYXJyIiwiY3JlYXRlVHlwZWRBcnJheUZhY3RvcnkiLCJGbG9hdDMyQXJyYXkiLCJJbnQxNkFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJjcmVhdGVTaXplZEFycmF5IiwiQXJyYXkiLCJhcHBseSIsIl90eXBlb2YkNiIsIm8iLCJTeW1ib2wiLCJpdGVyYXRvciIsInN1YmZyYW1lRW5hYmxlZCIsImV4cHJlc3Npb25zUGx1Z2luIiwiZXhwcmVzc2lvbnNJbnRlcmZhY2VzIiwiaWRQcmVmaXgkMSIsImlzU2FmYXJpIiwidGVzdCIsInVzZXJBZ2VudCIsIl9zaG91bGRSb3VuZFZhbHVlcyIsImJtUG93IiwiTWF0aCIsInBvdyIsImJtU3FydCIsInNxcnQiLCJibUZsb29yIiwiZmxvb3IiLCJibU1heCIsIm1heCIsImJtTWluIiwibWluIiwiQk1NYXRoIiwicHJvcGVydHlOYW1lcyIsIlByb2plY3RJbnRlcmZhY2UkMSIsInJhbmRvbSIsImFicyIsInZhbCIsInRPZlZhbCIsImFic0FyciIsImRlZmF1bHRDdXJ2ZVNlZ21lbnRzIiwiZGVnVG9SYWRzIiwiUEkiLCJyb3VuZENvcm5lciIsInJvdW5kVmFsdWVzIiwiYm1SbmQiLCJyb3VuZCIsInN0eWxlRGl2IiwiZWxlbWVudCIsInN0eWxlIiwicG9zaXRpb24iLCJ0b3AiLCJsZWZ0IiwiZGlzcGxheSIsInRyYW5zZm9ybU9yaWdpbiIsIndlYmtpdFRyYW5zZm9ybU9yaWdpbiIsImJhY2tmYWNlVmlzaWJpbGl0eSIsIndlYmtpdEJhY2tmYWNlVmlzaWJpbGl0eSIsInRyYW5zZm9ybVN0eWxlIiwid2Via2l0VHJhbnNmb3JtU3R5bGUiLCJtb3pUcmFuc2Zvcm1TdHlsZSIsIkJNRW50ZXJGcmFtZUV2ZW50IiwiY3VycmVudFRpbWUiLCJ0b3RhbFRpbWUiLCJmcmFtZU11bHRpcGxpZXIiLCJkaXJlY3Rpb24iLCJCTUNvbXBsZXRlRXZlbnQiLCJCTUNvbXBsZXRlTG9vcEV2ZW50IiwidG90YWxMb29wcyIsImN1cnJlbnRMb29wIiwiQk1TZWdtZW50U3RhcnRFdmVudCIsImZpcnN0RnJhbWUiLCJ0b3RhbEZyYW1lcyIsIkJNRGVzdHJveUV2ZW50IiwidGFyZ2V0IiwiQk1SZW5kZXJGcmFtZUVycm9yRXZlbnQiLCJuYXRpdmVFcnJvciIsIkJNQ29uZmlnRXJyb3JFdmVudCIsIkJNQW5pbWF0aW9uQ29uZmlnRXJyb3JFdmVudCIsImNyZWF0ZUVsZW1lbnRJRCIsIl9jb3VudCIsImNyZWF0ZUlEIiwiSFNWdG9SR0IiLCJoIiwicyIsInYiLCJyIiwiZyIsImIiLCJmIiwicCIsInEiLCJ0IiwiUkdCdG9IU1YiLCJkIiwiYWRkU2F0dXJhdGlvblRvUkdCIiwiY29sb3IiLCJvZmZzZXQiLCJoc3YiLCJhZGRCcmlnaHRuZXNzVG9SR0IiLCJhZGRIdWVUb1JHQiIsInJnYlRvSGV4IiwiY29sb3JNYXAiLCJoZXgiLCJ0b1N0cmluZyIsInNldFN1YmZyYW1lRW5hYmxlZCIsImdldFN1YmZyYW1lRW5hYmxlZCIsInNldEV4cHJlc3Npb25zUGx1Z2luIiwiZ2V0RXhwcmVzc2lvbnNQbHVnaW4iLCJzZXRFeHByZXNzaW9uSW50ZXJmYWNlcyIsImdldEV4cHJlc3Npb25JbnRlcmZhY2VzIiwic2V0RGVmYXVsdEN1cnZlU2VnbWVudHMiLCJnZXREZWZhdWx0Q3VydmVTZWdtZW50cyIsInNldElkUHJlZml4IiwiZ2V0SWRQcmVmaXgiLCJjcmVhdGVOUyIsImNyZWF0ZUVsZW1lbnROUyIsIl90eXBlb2YkNSIsImRhdGFNYW5hZ2VyIiwiX2NvdW50ZXJJZCIsInByb2Nlc3NlcyIsIndvcmtlckZuIiwid29ya2VySW5zdGFuY2UiLCJ3b3JrZXJQcm94eSIsIm9ubWVzc2FnZSIsInBvc3RNZXNzYWdlIiwicGF0aCIsImRhdGEiLCJfd29ya2VyU2VsZiIsImNyZWF0ZVdvcmtlciIsImZuIiwiV29ya2VyIiwiQmxvYiIsImJsb2IiLCJ1cmwiLCJVUkwiLCJjcmVhdGVPYmplY3RVUkwiLCJzZXR1cFdvcmtlciIsIndvcmtlclN0YXJ0IiwiZSIsImRhdGFGdW5jdGlvbk1hbmFnZXIiLCJjb21wbGV0ZUxheWVycyIsImxheWVycyIsImNvbXBzIiwibGF5ZXJEYXRhIiwiaiIsImpMZW4iLCJrIiwia0xlbiIsImNvbXBsZXRlZCIsImhhc01hc2siLCJtYXNrUHJvcHMiLCJtYXNrc1Byb3BlcnRpZXMiLCJwdCIsImNvbnZlcnRQYXRoc1RvQWJzb2x1dGVWYWx1ZXMiLCJ0eSIsImZpbmRDb21wTGF5ZXJzIiwicmVmSWQiLCJjb21wbGV0ZVNoYXBlcyIsInNoYXBlcyIsImNvbXBsZXRlVGV4dCIsImNvbXBsZXRlQ2hhcnMiLCJjaGFycyIsImFzc2V0cyIsImZpbmRDb21wIiwiaWQiLCJjb21wIiwiX191c2VkIiwiSlNPTiIsInBhcnNlIiwic3RyaW5naWZ5Iiwia3MiLCJpdCIsImNoZWNrVmVyc2lvbiIsIm1pbmltdW0iLCJhbmltVmVyc2lvblN0cmluZyIsImFuaW1WZXJzaW9uIiwic3BsaXQiLCJjaGVja1RleHQiLCJtaW5pbXVtVmVyc2lvbiIsInVwZGF0ZVRleHRMYXllciIsInRleHRMYXllciIsImRvY3VtZW50RGF0YSIsIml0ZXJhdGVMYXllcnMiLCJhbmltYXRpb25EYXRhIiwiY2hlY2tDaGFycyIsImNoYXJEYXRhIiwiaXAiLCJvcCIsInN0Iiwic3IiLCJhIiwic2siLCJzYSIsImNoZWNrUGF0aFByb3BlcnRpZXMiLCJwYXRoRGF0YSIsImNoZWNrQ29sb3JzIiwiaXRlcmF0ZVNoYXBlcyIsImMiLCJjaGVja1NoYXBlcyIsImNvbXBsZXRlQ2xvc2luZ1NoYXBlcyIsImNsb3NlZCIsImNsIiwiY29tcGxldGVEYXRhIiwiX19jb21wbGV0ZSIsIm1vZHVsZU9iIiwiYXNzZXRMb2FkZXIiLCJmb3JtYXRSZXNwb25zZSIsInhociIsImNvbnRlbnRUeXBlSGVhZGVyIiwiZ2V0UmVzcG9uc2VIZWFkZXIiLCJyZXNwb25zZVR5cGUiLCJpbmRleE9mIiwicmVzcG9uc2UiLCJyZXNwb25zZVRleHQiLCJsb2FkQXNzZXQiLCJmdWxsUGF0aCIsImNhbGxiYWNrIiwiZXJyb3JDYWxsYmFjayIsIlhNTEh0dHBSZXF1ZXN0IiwiZXJyIiwib25yZWFkeXN0YXRlY2hhbmdlIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsIm9wZW4iLCJqb2luIiwiZXJyb3IiLCJzZW5kIiwibG9hZCIsInBheWxvYWQiLCJhbmltYXRpb24iLCJldmVudCIsInByb2Nlc3MiLCJvbkNvbXBsZXRlIiwib25FcnJvciIsImNyZWF0ZVByb2Nlc3MiLCJsb2FkQW5pbWF0aW9uIiwicHJvY2Vzc0lkIiwibG9jYXRpb24iLCJvcmlnaW4iLCJwYXRobmFtZSIsImxvYWREYXRhIiwiY29tcGxldGVBbmltYXRpb24iLCJhbmltIiwiSW1hZ2VQcmVsb2FkZXIiLCJwcm94eUltYWdlIiwiY2FudmFzIiwid2lkdGgiLCJoZWlnaHQiLCJjdHgiLCJnZXRDb250ZXh0IiwiZmlsbFN0eWxlIiwiZmlsbFJlY3QiLCJpbWFnZUxvYWRlZCIsImxvYWRlZEFzc2V0cyIsInRvdGFsSW1hZ2VzIiwibG9hZGVkRm9vdGFnZXNDb3VudCIsInRvdGFsRm9vdGFnZXMiLCJpbWFnZXNMb2FkZWRDYiIsImZvb3RhZ2VMb2FkZWQiLCJnZXRBc3NldHNQYXRoIiwiYXNzZXREYXRhIiwiYXNzZXRzUGF0aCIsIm9yaWdpbmFsUGF0aCIsImltYWdlUGF0aCIsInUiLCJ0ZXN0SW1hZ2VMb2FkZWQiLCJpbWciLCJpbnRlcnZhbElkIiwic2V0SW50ZXJ2YWwiLCJib3giLCJnZXRCQm94IiwiX2ltYWdlTG9hZGVkIiwiY2xlYXJJbnRlcnZhbCIsImJpbmQiLCJjcmVhdGVJbWFnZURhdGEiLCJhZGRFdmVudExpc3RlbmVyIiwib2IiLCJzZXRBdHRyaWJ1dGVOUyIsIl9lbGVtZW50SGVscGVyIiwiYXBwZW5kIiwiYXBwZW5kQ2hpbGQiLCJjcmVhdGVJbWdEYXRhIiwiY3Jvc3NPcmlnaW4iLCJjcmVhdGVGb290YWdlRGF0YSIsImZvb3RhZ2VEYXRhIiwiX2Zvb3RhZ2VMb2FkZWQiLCJsb2FkQXNzZXRzIiwiY2IiLCJpbWFnZXMiLCJfY3JlYXRlSW1hZ2VEYXRhIiwic2V0UGF0aCIsInNldEFzc2V0c1BhdGgiLCJnZXRBc3NldCIsImRlc3Ryb3kiLCJsb2FkZWRJbWFnZXMiLCJsb2FkZWRGb290YWdlcyIsInNldENhY2hlVHlwZSIsImVsZW1lbnRIZWxwZXIiLCJJbWFnZVByZWxvYWRlckZhY3RvcnkiLCJCYXNlRXZlbnQiLCJ0cmlnZ2VyRXZlbnQiLCJldmVudE5hbWUiLCJhcmdzIiwiX2NicyIsImNhbGxiYWNrcyIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzcGxpY2UiLCJtYXJrZXJQYXJzZXIiLCJwYXJzZVBheWxvYWRMaW5lcyIsImxpbmVzIiwia2V5cyIsImxpbmUiLCJrZXlzQ291bnQiLCJ0cmltIiwiRXJyb3IiLCJfbWFya2VycyIsIm1hcmtlcnMiLCJfbWFya2VyIiwibWFya2VyRGF0YSIsInRpbWUiLCJ0bSIsImR1cmF0aW9uIiwiZHIiLCJjbSIsIl8iLCJfXyIsIm5hbWUiLCJQcm9qZWN0SW50ZXJmYWNlIiwicmVnaXN0ZXJDb21wb3NpdGlvbiIsImNvbXBvc2l0aW9ucyIsIl90aGlzUHJvamVjdEZ1bmN0aW9uIiwibm0iLCJwcmVwYXJlRnJhbWUiLCJ4dCIsImN1cnJlbnRGcmFtZSIsImNvbXBJbnRlcmZhY2UiLCJyZW5kZXJlcnMiLCJyZWdpc3RlclJlbmRlcmVyIiwia2V5IiwiZ2V0UmVuZGVyZXIiLCJnZXRSZWdpc3RlcmVkUmVuZGVyZXIiLCJfdHlwZW9mJDQiLCJBbmltYXRpb25JdGVtIiwiaXNMb2FkZWQiLCJjdXJyZW50UmF3RnJhbWUiLCJmcmFtZVJhdGUiLCJmcmFtZU11bHQiLCJwbGF5U3BlZWQiLCJwbGF5RGlyZWN0aW9uIiwicGxheUNvdW50IiwiaXNQYXVzZWQiLCJhdXRvcGxheSIsImxvb3AiLCJyZW5kZXJlciIsImFuaW1hdGlvbklEIiwidGltZUNvbXBsZXRlZCIsInNlZ21lbnRQb3MiLCJpc1N1YmZyYW1lRW5hYmxlZCIsInNlZ21lbnRzIiwiX2lkbGUiLCJfY29tcGxldGVkTG9vcCIsInByb2plY3RJbnRlcmZhY2UiLCJpbWFnZVByZWxvYWRlciIsImF1ZGlvQ29udHJvbGxlciIsImNvbmZpZ0FuaW1hdGlvbiIsIm9uU2V0dXBFcnJvciIsIm9uU2VnbWVudENvbXBsZXRlIiwiZHJhd25GcmFtZUV2ZW50Iiwic2V0UGFyYW1zIiwicGFyYW1zIiwid3JhcHBlciIsImNvbnRhaW5lciIsImFuaW1UeXBlIiwiUmVuZGVyZXJDbGFzcyIsInJlbmRlcmVyU2V0dGluZ3MiLCJnbG9iYWxEYXRhIiwiZGVmcyIsInNldFByb2plY3RJbnRlcmZhY2UiLCJ1bmRlZmluZWQiLCJwYXJzZUludCIsImF1dG9sb2FkU2VnbWVudHMiLCJpbml0aWFsU2VnbWVudCIsInNldHVwQW5pbWF0aW9uIiwibGFzdEluZGV4T2YiLCJzdWJzdHIiLCJmaWxlTmFtZSIsInRyaWdnZXIiLCJzZXREYXRhIiwid3JhcHBlckF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVzIiwiZ2V0TmFtZWRJdGVtIiwicHJlcmVuZGVyIiwiaW5jbHVkZUxheWVycyIsIm5ld0xheWVycyIsImZvbnRzIiwiZm9udE1hbmFnZXIiLCJhZGRDaGFycyIsImFkZEZvbnRzIiwiaW5pdEV4cHJlc3Npb25zIiwibG9hZE5leHRTZWdtZW50Iiwic2VnbWVudCIsInNoaWZ0Iiwic2VnbWVudFBhdGgiLCJsb2FkU2VnbWVudHMiLCJpbWFnZXNMb2FkZWQiLCJjaGVja0xvYWRlZCIsInByZWxvYWRJbWFnZXMiLCJhbmltRGF0YSIsImZyIiwic2VhcmNoRXh0cmFDb21wb3NpdGlvbnMiLCJ1cGRhRnJhbWVNb2RpZmllciIsIndhaXRGb3JGb250c0xvYWRlZCIsInRyaWdnZXJDb25maWdFcnJvciIsInNldFRpbWVvdXQiLCJyZW5kZXJlclR5cGUiLCJpbml0SXRlbXMiLCJnb3RvRnJhbWUiLCJyZXNpemUiLCJfd2lkdGgiLCJfaGVpZ2h0IiwidXBkYXRlQ29udGFpbmVyU2l6ZSIsInNldFN1YmZyYW1lIiwicmVuZGVyRnJhbWUiLCJyZXNldEZyYW1lIiwidHJpZ2dlclJlbmRlckZyYW1lRXJyb3IiLCJ0b2dnbGVQYXVzZSIsInN0b3AiLCJzZXRDdXJyZW50UmF3RnJhbWVWYWx1ZSIsImdldE1hcmtlckRhdGEiLCJtYXJrZXJOYW1lIiwibWFya2VyIiwiZ29Ub0FuZFN0b3AiLCJpc0ZyYW1lIiwibnVtVmFsdWUiLCJOdW1iZXIiLCJpc05hTiIsImZyYW1lTW9kaWZpZXIiLCJnb1RvQW5kUGxheSIsInBsYXlTZWdtZW50cyIsImFkdmFuY2VUaW1lIiwibmV4dFZhbHVlIiwiX2lzQ29tcGxldGUiLCJjaGVja1NlZ21lbnRzIiwiYWRqdXN0U2VnbWVudCIsInNldFNwZWVkIiwic2V0RGlyZWN0aW9uIiwic2V0U2VnbWVudCIsImluaXQiLCJlbmQiLCJwZW5kaW5nRnJhbWUiLCJmb3JjZUZsYWciLCJyZXNldFNlZ21lbnRzIiwib25FbnRlckZyYW1lIiwib25Mb29wQ29tcGxldGUiLCJvblNlZ21lbnRTdGFydCIsIm9uRGVzdHJveSIsInNldExvb3AiLCJpc0xvb3BpbmciLCJnZXRQYXRoIiwiZ2V0QXNzZXREYXRhIiwiaGlkZSIsInNob3ciLCJnZXREdXJhdGlvbiIsInVwZGF0ZURvY3VtZW50RGF0YSIsImluZGV4IiwiZ2V0RWxlbWVudEJ5UGF0aCIsImFuaW1hdGlvbk1hbmFnZXIiLCJyZWdpc3RlcmVkQW5pbWF0aW9ucyIsImluaXRUaW1lIiwicGxheWluZ0FuaW1hdGlvbnNOdW0iLCJfc3RvcHBlZCIsIl9pc0Zyb3plbiIsInJlbW92ZUVsZW1lbnQiLCJldiIsImFuaW1JdGVtIiwic3VidHJhY3RQbGF5aW5nQ291bnQiLCJyZWdpc3RlckFuaW1hdGlvbiIsImVsZW0iLCJnZXRSZWdpc3RlcmVkQW5pbWF0aW9ucyIsImxlbkFuaW1zIiwiYW5pbWF0aW9ucyIsImFkZFBsYXlpbmdDb3VudCIsImFjdGl2YXRlIiwibm93VGltZSIsImVsYXBzZWRUaW1lIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiZmlyc3QiLCJzZWFyY2hBbmltYXRpb25zIiwic3RhbmRhbG9uZSIsImFuaW1FbGVtZW50cyIsImNvbmNhdCIsInNsaWNlIiwiZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSIsInNldEF0dHJpYnV0ZSIsImJvZHkiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImlubmVyVGV4dCIsImRpdiIsImZyZWV6ZSIsInVuZnJlZXplIiwiQmV6aWVyRmFjdG9yeSIsImdldEJlemllckVhc2luZyIsImJlemllcnMiLCJzdHIiLCJyZXBsYWNlIiwiYmV6RWFzaW5nIiwiQmV6aWVyRWFzaW5nIiwiTkVXVE9OX0lURVJBVElPTlMiLCJORVdUT05fTUlOX1NMT1BFIiwiU1VCRElWSVNJT05fUFJFQ0lTSU9OIiwiU1VCRElWSVNJT05fTUFYX0lURVJBVElPTlMiLCJrU3BsaW5lVGFibGVTaXplIiwia1NhbXBsZVN0ZXBTaXplIiwiZmxvYXQzMkFycmF5U3VwcG9ydGVkIiwiQSIsImFBMSIsImFBMiIsIkIiLCJDIiwiY2FsY0JlemllciIsImFUIiwiZ2V0U2xvcGUiLCJiaW5hcnlTdWJkaXZpZGUiLCJhWCIsImFBIiwiYUIiLCJtWDEiLCJtWDIiLCJjdXJyZW50WCIsImN1cnJlbnRUIiwibmV3dG9uUmFwaHNvbkl0ZXJhdGUiLCJhR3Vlc3NUIiwiY3VycmVudFNsb3BlIiwicG9pbnRzIiwiX3AiLCJfbVNhbXBsZVZhbHVlcyIsIl9wcmVjb21wdXRlZCIsImdldCIsIngiLCJtWTEiLCJtWTIiLCJfcHJlY29tcHV0ZSIsIl9nZXRURm9yWCIsIl9jYWxjU2FtcGxlVmFsdWVzIiwibVNhbXBsZVZhbHVlcyIsImludGVydmFsU3RhcnQiLCJjdXJyZW50U2FtcGxlIiwibGFzdFNhbXBsZSIsImRpc3QiLCJndWVzc0ZvclQiLCJpbml0aWFsU2xvcGUiLCJwb29saW5nIiwiX2RvdWJsZSIsInBvb2xGYWN0b3J5IiwiaW5pdGlhbExlbmd0aCIsIl9jcmVhdGUiLCJfcmVsZWFzZSIsIl9sZW5ndGgiLCJfbWF4TGVuZ3RoIiwicG9vbCIsIm5ld0VsZW1lbnQiLCJyZWxlYXNlIiwiYmV6aWVyTGVuZ3RoUG9vbCIsImNyZWF0ZSIsImFkZGVkTGVuZ3RoIiwicGVyY2VudHMiLCJsZW5ndGhzIiwic2VnbWVudHNMZW5ndGhQb29sIiwidG90YWxMZW5ndGgiLCJiZXpGdW5jdGlvbiIsIm1hdGgiLCJwb2ludE9uTGluZTJEIiwieDEiLCJ5MSIsIngyIiwieTIiLCJ4MyIsInkzIiwiZGV0MSIsInBvaW50T25MaW5lM0QiLCJ6MSIsInoyIiwiejMiLCJkaXN0MSIsImRpc3QyIiwiZGlzdDMiLCJkaWZmRGlzdCIsImdldEJlemllckxlbmd0aCIsInB0MSIsInB0MiIsInB0MyIsInB0NCIsImN1cnZlU2VnbWVudHMiLCJwdENvb3JkIiwicGVyYyIsInB0RGlzdGFuY2UiLCJwb2ludCIsImxhc3RQb2ludCIsImxlbmd0aERhdGEiLCJnZXRTZWdtZW50c0xlbmd0aCIsInNoYXBlRGF0YSIsInNlZ21lbnRzTGVuZ3RoIiwicGF0aFYiLCJwYXRoTyIsInBhdGhJIiwiQmV6aWVyRGF0YSIsInNlZ21lbnRMZW5ndGgiLCJQb2ludERhdGEiLCJwYXJ0aWFsIiwicGFydGlhbExlbmd0aCIsImJ1aWxkQmV6aWVyRGF0YSIsInN0b3JlZERhdGEiLCJiZXppZXJOYW1lIiwiYmV6aWVyRGF0YSIsImdldERpc3RhbmNlUGVyYyIsImluaXRQb3MiLCJsZW5ndGhQb3MiLCJsUGVyYyIsImRpciIsImdldFBvaW50SW5TZWdtZW50IiwicGVyY2VudCIsInQxIiwidTEiLCJwdFgiLCJwdFkiLCJiZXppZXJTZWdtZW50UG9pbnRzIiwiZ2V0TmV3U2VnbWVudCIsInN0YXJ0UGVyYyIsImVuZFBlcmMiLCJ0MCIsInUwIiwidTB1MHUwIiwidDB1MHUwXzMiLCJ0MHQwdTBfMyIsInQwdDB0MCIsInUwdTB1MSIsInQwdTB1MV8zIiwidDB0MHUxXzMiLCJ0MHQwdDEiLCJ1MHUxdTEiLCJ0MHUxdTFfMyIsInQwdDF1MV8zIiwidDB0MXQxIiwidTF1MXUxIiwidDF1MXUxXzMiLCJ0MXQxdTFfMyIsInQxdDF0MSIsImJleiIsImluaXRGcmFtZSIsIm1hdGhBYnMiLCJpbnRlcnBvbGF0ZVZhbHVlIiwiZnJhbWVOdW0iLCJjYWNoaW5nIiwib2Zmc2V0VGltZSIsIm5ld1ZhbHVlIiwicHJvcFR5cGUiLCJwdiIsIml0ZXJhdGlvbkluZGV4IiwibGFzdEluZGV4Iiwia2V5ZnJhbWVzIiwia2V5RGF0YSIsIm5leHRLZXlEYXRhIiwia2V5ZnJhbWVNZXRhZGF0YSIsImtleWZyYW1lc01ldGFkYXRhIiwiZm5jIiwibmV4dEtleVRpbWUiLCJrZXlUaW1lIiwiZW5kVmFsdWUiLCJ0byIsInRpIiwiaW5kIiwiX19mbmN0IiwieSIsIm4iLCJkaXN0YW5jZUluTGluZSIsInNlZ21lbnRQZXJjIiwibGFzdEZyYW1lIiwiX2xhc3RLZXlmcmFtZUluZGV4IiwiX2xhc3RBZGRlZExlbmd0aCIsIl9sYXN0UG9pbnQiLCJvdXRYIiwib3V0WSIsImluWCIsImluWSIsImtleVZhbHVlIiwic2giLCJxdWF0U3RhcnQiLCJjcmVhdGVRdWF0ZXJuaW9uIiwicXVhdEVuZCIsInF1YXRlcm5pb25Ub0V1bGVyIiwic2xlcnAiLCJvdXQiLCJheCIsImF5IiwiYXoiLCJhdyIsImJ4IiwiYnkiLCJieiIsImJ3Iiwib21lZ2EiLCJjb3NvbSIsInNpbm9tIiwic2NhbGUwIiwic2NhbGUxIiwiYWNvcyIsInNpbiIsInF1YXQiLCJxeCIsInF5IiwicXoiLCJxdyIsImhlYWRpbmciLCJhdGFuMiIsImF0dGl0dWRlIiwiYXNpbiIsImJhbmsiLCJ2YWx1ZXMiLCJjMSIsImNvcyIsImMyIiwiYzMiLCJzMSIsInMyIiwiczMiLCJ3IiwieiIsImdldFZhbHVlQXRDdXJyZW50VGltZSIsInJlbmRlcmVkRnJhbWUiLCJlbmRUaW1lIiwiX2NhY2hpbmciLCJyZW5kZXJSZXN1bHQiLCJzZXRWVmFsdWUiLCJtdWx0aXBsaWVkVmFsdWUiLCJtdWx0IiwiX21kZiIsInByb2Nlc3NFZmZlY3RzU2VxdWVuY2UiLCJmcmFtZUlkIiwiZWZmZWN0c1NlcXVlbmNlIiwibG9jayIsIl9pc0ZpcnN0RnJhbWUiLCJmaW5hbFZhbHVlIiwia2YiLCJhZGRFZmZlY3QiLCJlZmZlY3RGdW5jdGlvbiIsImFkZER5bmFtaWNQcm9wZXJ0eSIsIlZhbHVlUHJvcGVydHkiLCJ2ZWwiLCJnZXRWYWx1ZSIsIk11bHRpRGltZW5zaW9uYWxQcm9wZXJ0eSIsIktleWZyYW1lZFZhbHVlUHJvcGVydHkiLCJLZXlmcmFtZWRNdWx0aWRpbWVuc2lvbmFsUHJvcGVydHkiLCJhcnJMZW4iLCJQcm9wZXJ0eUZhY3RvcnkiLCJnZXRQcm9wIiwic2lkIiwic2xvdE1hbmFnZXIiLCJEeW5hbWljUHJvcGVydHlDb250YWluZXIiLCJkeW5hbWljUHJvcGVydGllcyIsIl9pc0FuaW1hdGVkIiwiaXRlcmF0ZUR5bmFtaWNQcm9wZXJ0aWVzIiwiaW5pdER5bmFtaWNQcm9wZXJ0eUNvbnRhaW5lciIsInBvaW50UG9vbCIsIlNoYXBlUGF0aCIsInNldFBhdGhEYXRhIiwic2V0TGVuZ3RoIiwiZG91YmxlQXJyYXlMZW5ndGgiLCJzZXRYWUF0IiwicG9zIiwic2V0VHJpcGxlQXQiLCJ2WCIsInZZIiwib1giLCJvWSIsImlYIiwiaVkiLCJyZXZlcnNlIiwibmV3UGF0aCIsInZlcnRpY2VzIiwib3V0UG9pbnRzIiwiaW5Qb2ludHMiLCJjbnQiLCJzaGFwZVBvb2wiLCJzaGFwZVBhdGgiLCJjbG9uZSIsInNoYXBlIiwiY2xvbmVkIiwiU2hhcGVDb2xsZWN0aW9uIiwiYWRkU2hhcGUiLCJyZWxlYXNlU2hhcGVzIiwic2hhcGVDb2xsZWN0aW9uUG9vbCIsIm5ld1NoYXBlQ29sbGVjdGlvbiIsInNoYXBlQ29sbGVjdGlvbiIsIlNoYXBlUHJvcGVydHlGYWN0b3J5IiwiaW50ZXJwb2xhdGVTaGFwZSIsInByZXZpb3VzVmFsdWUiLCJrZXlQcm9wUyIsImtleVByb3BFIiwiaXNIb2xkIiwidmVydGV4VmFsdWUiLCJpbnRlcnBvbGF0ZVNoYXBlQ3VycmVudFRpbWUiLCJyZXNldFNoYXBlIiwicGF0aHMiLCJsb2NhbFNoYXBlQ29sbGVjdGlvbiIsInNoYXBlc0VxdWFsIiwic2hhcGUxIiwic2hhcGUyIiwiU2hhcGVQcm9wZXJ0eSIsInJlc2V0IiwiS2V5ZnJhbWVkU2hhcGVQcm9wZXJ0eSIsIkVsbFNoYXBlUHJvcGVydHkiLCJjUG9pbnQiLCJFbGxTaGFwZVByb3BlcnR5RmFjdG9yeSIsImNvbnZlcnRFbGxUb1BhdGgiLCJwMCIsInAxIiwiczAiLCJfY3ciLCJfdiIsIlN0YXJTaGFwZVByb3BlcnR5IiwiU3RhclNoYXBlUHJvcGVydHlGYWN0b3J5Iiwic3kiLCJpciIsImlzIiwiY29udmVydFRvUGF0aCIsImNvbnZlcnRTdGFyVG9QYXRoIiwiY29udmVydFBvbHlnb25Ub1BhdGgiLCJvciIsIm9zIiwibnVtUHRzIiwiYW5nbGUiLCJsb25nRmxhZyIsImxvbmdSYWQiLCJzaG9ydFJhZCIsImxvbmdSb3VuZCIsInNob3J0Um91bmQiLCJsb25nUGVyaW1TZWdtZW50Iiwic2hvcnRQZXJpbVNlZ21lbnQiLCJyYWQiLCJyb3VuZG5lc3MiLCJwZXJpbVNlZ21lbnQiLCJjdXJyZW50QW5nIiwib3giLCJveSIsIlJlY3RTaGFwZVByb3BlcnR5IiwiUmVjdFNoYXBlUHJvcGVydHlGYWN0b3J5IiwiY29udmVydFJlY3RUb1BhdGgiLCJ2MCIsInYxIiwiZ2V0U2hhcGVQcm9wIiwiZGF0YVByb3AiLCJnZXRDb25zdHJ1Y3RvckZ1bmN0aW9uIiwiZ2V0S2V5ZnJhbWVkQ29uc3RydWN0b3JGdW5jdGlvbiIsIk1hdHJpeCIsIl9jb3MiLCJfc2luIiwiX3RhbiIsInRhbiIsIl9ybmQiLCJwcm9wcyIsInJvdGF0ZSIsIm1Db3MiLCJtU2luIiwiX3QiLCJyb3RhdGVYIiwicm90YXRlWSIsInJvdGF0ZVoiLCJzaGVhciIsInN4Iiwic2tldyIsInNrZXdGcm9tQXhpcyIsInNjYWxlIiwic3oiLCJzZXRUcmFuc2Zvcm0iLCJsIiwibSIsInRyYW5zbGF0ZSIsInR4IiwidHoiLCJ0cmFuc2Zvcm0iLCJhMiIsImIyIiwiZDIiLCJlMiIsImYyIiwiZzIiLCJoMiIsImkyIiwiajIiLCJrMiIsImwyIiwibTIiLCJuMiIsIm8yIiwicDIiLCJfaWRlbnRpdHlDYWxjdWxhdGVkIiwiYTEiLCJiMSIsImQxIiwiZTEiLCJmMSIsImcxIiwiaDEiLCJpMSIsImoxIiwiazEiLCJsMSIsIm0xIiwibjEiLCJvMSIsIm11bHRpcGx5IiwibWF0cml4IiwibWF0cml4UHJvcHMiLCJpc0lkZW50aXR5IiwiX2lkZW50aXR5IiwiZXF1YWxzIiwibWF0ciIsImNsb25lRnJvbVByb3BzIiwiYXBwbHlUb1BvaW50IiwiYXBwbHlUb1giLCJhcHBseVRvWSIsImFwcGx5VG9aIiwiZ2V0SW52ZXJzZU1hdHJpeCIsImRldGVybWluYW50IiwiaW52ZXJzZU1hdHJpeCIsImludmVyc2VQb2ludCIsImFwcGx5VG9Qb2ludEFycmF5IiwiaW52ZXJzZVBvaW50cyIsInB0cyIsInJldFB0cyIsImFwcGx5VG9UcmlwbGVQb2ludHMiLCJwNCIsInA1IiwicDEyIiwicDEzIiwiYXBwbHlUb1BvaW50U3RyaW5naWZpZWQiLCJ0b0NTUyIsImNzc1ZhbHVlIiwicm91bmRNYXRyaXhQcm9wZXJ0eSIsInRvMmRDU1MiLCJfYSIsIl9iIiwiX2MiLCJfZCIsIl9lIiwiX2YiLCJfdHlwZW9mJDMiLCJzZXRMb2NhdGlvbiIsImhyZWYiLCJzZXRTdWJmcmFtZVJlbmRlcmluZyIsInNldFByZWZpeCIsInByZWZpeCIsInNldFF1YWxpdHkiLCJpbkJyb3dzZXIiLCJpbnN0YWxsUGx1Z2luIiwicGx1Z2luIiwiZ2V0RmFjdG9yeSIsInVzZVdlYldvcmtlciIsInNldElEUHJlZml4IiwiX19nZXRGYWN0b3J5IiwidmVyc2lvbiIsImNoZWNrUmVhZHkiLCJyZWFkeVN0YXRlQ2hlY2tJbnRlcnZhbCIsImdldFF1ZXJ5VmFyaWFibGUiLCJ2YXJpYWJsZSIsInZhcnMiLCJxdWVyeVN0cmluZyIsInBhaXIiLCJkZWNvZGVVUklDb21wb25lbnQiLCJzY3JpcHRzIiwibXlTY3JpcHQiLCJib2R5bW92aW4iLCJTaGFwZU1vZGlmaWVycyIsIm1vZGlmaWVycyIsInJlZ2lzdGVyTW9kaWZpZXIiLCJnZXRNb2RpZmllciIsIlNoYXBlTW9kaWZpZXIiLCJpbml0TW9kaWZpZXJQcm9wZXJ0aWVzIiwiYWRkU2hhcGVUb01vZGlmaWVyIiwic2V0QXNBbmltYXRlZCIsInByb2Nlc3NLZXlzIiwiVHJpbU1vZGlmaWVyIiwic1ZhbHVlIiwiZVZhbHVlIiwicGF0aHNEYXRhIiwiY2FsY3VsYXRlU2hhcGVFZGdlcyIsInNoYXBlTGVuZ3RoIiwidG90YWxNb2RpZmllckxlbmd0aCIsInNoYXBlU2VnbWVudHMiLCJzZWdtZW50T2IiLCJzaGFwZVMiLCJzaGFwZUUiLCJyZWxlYXNlUGF0aHNEYXRhIiwicHJvY2Vzc1NoYXBlcyIsIl9zIiwic2hhcGVQYXRocyIsInRvdGFsU2hhcGVMZW5ndGgiLCJlZGdlcyIsIm5ld1NoYXBlc0RhdGEiLCJhZGRTaGFwZXMiLCJsYXN0U2hhcGVJbkNvbGxlY3Rpb24iLCJsYXN0U2hhcGUiLCJwb3AiLCJhZGRQYXRocyIsIm5ld1BhdGhzIiwiYWRkU2VnbWVudCIsIm5ld1NoYXBlIiwiYWRkU2VnbWVudEZyb21BcnJheSIsInNoYXBlU2VnbWVudCIsImN1cnJlbnRMZW5ndGhEYXRhIiwic2VnbWVudENvdW50IiwiUHVja2VyQW5kQmxvYXRNb2RpZmllciIsImFtb3VudCIsInByb2Nlc3NQYXRoIiwiY2VudGVyUG9pbnQiLCJwYXRoTGVuZ3RoIiwiY2xvbmVkUGF0aCIsIlRyYW5zZm9ybVByb3BlcnR5RmFjdG9yeSIsImRlZmF1bHRWZWN0b3IiLCJhcHBseVRvTWF0cml4IiwibWF0IiwicnoiLCJyeSIsInJ4IiwicHgiLCJweSIsInB6IiwiZm9yY2VSZW5kZXIiLCJfaXNEaXJ0eSIsInByZWNhbGN1bGF0ZU1hdHJpeCIsInByZSIsImFwcGxpZWRUcmFuc2Zvcm1hdGlvbnMiLCJhdXRvT3JpZW50ZWQiLCJ2MiIsImdldFZhbHVlQXRUaW1lIiwiYXV0b09yaWVudCIsIl9hZGREeW5hbWljUHJvcGVydHkiLCJUcmFuc2Zvcm1Qcm9wZXJ0eSIsImdldFRyYW5zZm9ybVByb3BlcnR5IiwiUmVwZWF0ZXJNb2RpZmllciIsInRyIiwic28iLCJlbyIsInBNYXRyaXgiLCJyTWF0cml4Iiwic01hdHJpeCIsInRNYXRyaXgiLCJhcHBseVRyYW5zZm9ybXMiLCJpbnYiLCJzY2FsZVgiLCJzY2FsZVkiLCJlbGVtc0RhdGEiLCJfY3VycmVudENvcGllcyIsIl9lbGVtZW50cyIsIl9ncm91cHMiLCJ1bnNoaWZ0IiwicmVzZXRFbGVtZW50cyIsImVsZW1lbnRzIiwiX3Byb2Nlc3NlZCIsImNsb25lRWxlbWVudHMiLCJuZXdFbGVtZW50cyIsImNoYW5nZUdyb3VwUmVuZGVyIiwicmVuZGVyRmxhZyIsIl9yZW5kZXIiLCJpdGVtcyIsIml0ZW1zVHJhbnNmb3JtIiwiY29udCIsImhhc1JlbG9hZGVkIiwiY29waWVzIiwiY2VpbCIsImdyb3VwIiwiaXgiLCJyZWxvYWRTaGFwZXMiLCJlbGVtcyIsInRyYW5zZm9ybURhdGEiLCJvZmZzZXRNb2R1bG8iLCJyb3VuZE9mZnNldCIsInBQcm9wcyIsInJQcm9wcyIsInNQcm9wcyIsIml0ZXJhdGlvbiIsIm1Qcm9wcyIsIlJvdW5kQ29ybmVyc01vZGlmaWVyIiwicmQiLCJjdXJyZW50ViIsImN1cnJlbnRJIiwiY3VycmVudE8iLCJjbG9zZXJWIiwiZGlzdGFuY2UiLCJuZXdQb3NQZXJjIiwiZmxvYXRFcXVhbCIsImZsb2F0WmVybyIsImxlcnAiLCJsZXJwUG9pbnQiLCJxdWFkUm9vdHMiLCJzaW5nbGVSb290IiwiZGVsdGEiLCJwb2x5bm9taWFsQ29lZmZpY2llbnRzIiwicDMiLCJzaW5nbGVQb2ludCIsIlBvbHlub21pYWxCZXppZXIiLCJsaW5lYXJpemUiLCJwb2ludEVxdWFsIiwiY29lZmZ4IiwiY29lZmZ5IiwiZGVyaXZhdGl2ZSIsInRhbmdlbnRBbmdsZSIsIm5vcm1hbEFuZ2xlIiwiaW5mbGVjdGlvblBvaW50cyIsImRlbm9tIiwidGN1c3AiLCJzcXVhcmUiLCJyb290IiwiZmlsdGVyIiwicDEwIiwicDExIiwicDIwIiwicDIxIiwiZXh0cmVtYSIsImJvdW5kcyIsImJvdW5kaW5nQm94IiwicmlnaHQiLCJib3R0b20iLCJjeCIsImN5IiwiaW50ZXJzZWN0RGF0YSIsInQyIiwic3BsaXREYXRhIiwiYm94SW50ZXJzZWN0IiwiaW50ZXJzZWN0c0ltcGwiLCJkZXB0aCIsInRvbGVyYW5jZSIsImludGVyc2VjdGlvbnMiLCJtYXhSZWN1cnNpb24iLCJkMXMiLCJkMnMiLCJvdGhlciIsIm5leHRJbmRleCIsInNoYXBlU2VnbWVudEludmVydGVkIiwiY3Jvc3NQcm9kdWN0IiwibGluZUludGVyc2VjdGlvbiIsInN0YXJ0MSIsImVuZDEiLCJzdGFydDIiLCJlbmQyIiwidjMiLCJ2NCIsInBvbGFyT2Zmc2V0IiwicG9pbnREaXN0YW5jZSIsImh5cG90IiwiWmlnWmFnTW9kaWZpZXIiLCJhbXBsaXR1ZGUiLCJmcmVxdWVuY3kiLCJwb2ludHNUeXBlIiwic2V0UG9pbnQiLCJvdXRwdXRCZXppZXIiLCJvdXRBbXBsaXR1ZGUiLCJpbkFtcGxpdHVkZSIsImFuZ08iLCJhbmdJIiwiZ2V0UGVycGVuZGljdWxhclZlY3RvciIsInZlY3RvciIsInJvdCIsInJvdGF0ZWRWZWN0b3IiLCJnZXRQcm9qZWN0aW5nQW5nbGUiLCJjdXIiLCJwcmV2SW5kZXgiLCJwcmV2UG9pbnQiLCJuZXh0UG9pbnQiLCJwVmVjdG9yIiwiemlnWmFnQ29ybmVyIiwicG9pbnRUeXBlIiwicHJldkRpc3QiLCJuZXh0RGlzdCIsInppZ1phZ1NlZ21lbnQiLCJjb3VudCIsImxpbmVhck9mZnNldCIsIm9mZnNldFNlZ21lbnQiLCJwMWEiLCJwMWIiLCJwMmIiLCJwMmEiLCJqb2luTGluZXMiLCJzZWcxIiwic2VnMiIsImxpbmVKb2luIiwibWl0ZXJMaW1pdCIsImFuZ2xlT3V0IiwiYW5nbGVJbiIsImNlbnRlciIsInJhZGl1cyIsImludGVyc2VjdGlvbiIsImdldEludGVyc2VjdGlvbiIsImludGVyc2VjdCIsInBydW5lU2VnbWVudEludGVyc2VjdGlvbiIsIm91dGEiLCJvdXRiIiwicHJ1bmVJbnRlcnNlY3Rpb25zIiwib2Zmc2V0U2VnbWVudFNwbGl0IiwiZmxleCIsIm1pZCIsIk9mZnNldFBhdGhNb2RpZmllciIsIm1sIiwibGoiLCJpbnB1dEJlemllciIsIm11bHRpU2VnbWVudHMiLCJsYXN0U2VnIiwibXVsdGlTZWdtZW50IiwiZ2V0Rm9udFByb3BlcnRpZXMiLCJmb250RGF0YSIsInN0eWxlcyIsImZTdHlsZSIsImZXZWlnaHQiLCJzdHlsZU5hbWUiLCJ0b0xvd2VyQ2FzZSIsIndlaWdodCIsIkZvbnRNYW5hZ2VyIiwibWF4V2FpdGluZ1RpbWUiLCJlbXB0eUNoYXIiLCJzaXplIiwiY29tYmluZWRDaGFyYWN0ZXJzIiwiQkxBQ0tfRkxBR19DT0RFX1BPSU5UIiwiQ0FOQ0VMX1RBR19DT0RFX1BPSU5UIiwiQV9UQUdfQ09ERV9QT0lOVCIsIlpfVEFHX0NPREVfUE9JTlQiLCJWQVJJQVRJT05fU0VMRUNUT1JfMTZfQ09ERV9QT0lOVCIsIlpFUk9fV0lEVEhfSk9JTkVSX0NPREVfUE9JTlQiLCJSRUdJT05BTF9DSEFSQUNURVJfQV9DT0RFX1BPSU5UIiwiUkVHSU9OQUxfQ0hBUkFDVEVSX1pfQ09ERV9QT0lOVCIsInN1cnJvZ2F0ZU1vZGlmaWVycyIsInRyaW1Gb250T3B0aW9ucyIsImZvbnQiLCJmYW1pbHlBcnJheSIsImVuYWJsZWRGYW1pbGllcyIsInNldFVwTm9kZSIsImZhbWlseSIsInBhcmVudE5vZGUiLCJmb250RmFtaWx5Iiwibm9kZSIsImZvbnRTaXplIiwiZm9udFZhcmlhbnQiLCJmb250U3R5bGUiLCJmb250V2VpZ2h0IiwibGV0dGVyU3BhY2luZyIsIm9mZnNldFdpZHRoIiwicGFyZW50IiwiY2hlY2tMb2FkZWRGb250cyIsImxvYWRlZENvdW50IiwibG9hZGVkIiwiZk9yaWdpbiIsIm1vbm9DYXNlIiwic2Fuc0Nhc2UiLCJyZW1vdmVDaGlsZCIsIkRhdGUiLCJub3ciLCJjaGVja0xvYWRlZEZvbnRzQmluZGVkIiwic2V0SXNMb2FkZWRCaW5kZWQiLCJjcmVhdGVIZWxwZXIiLCJkZWYiLCJlbmdpbmUiLCJoZWxwZXIiLCJmb250UHJvcHMiLCJ0SGVscGVyIiwiZkZhbWlseSIsInRleHRDb250ZW50IiwiZkNsYXNzIiwidENhbnZhc0hlbHBlciIsIk9mZnNjcmVlbkNhbnZhcyIsIm1lYXN1cmUiLCJ0ZXh0IiwiZ2V0Q29tcHV0ZWRUZXh0TGVuZ3RoIiwibWVhc3VyZVRleHQiLCJsaXN0IiwiZm9yRWFjaCIsImNhY2hlIiwiZm9udEFyciIsIl9wZW5kaW5nRm9udHMiLCJzaG91bGRMb2FkRm9udCIsImxvYWRlZFNlbGVjdG9yIiwiZlBhdGgiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmVsIiwic2MiLCJmb3VuZCIsImNoIiwiZ2V0Q2hhckRhdGEiLCJfY2hhciIsImNoYXJDb2RlQXQiLCJjb25zb2xlIiwid2FybiIsIl93YXJuZWQiLCJfY2hhcjIiLCJmb250TmFtZSIsImdldEZvbnRCeU5hbWUiLCJkb3VibGVTaXplIiwic2luZ2xlU2l6ZSIsImZOYW1lIiwiZ2V0Q29kZVBvaW50Iiwic3RyaW5nIiwiY29kZVBvaW50Iiwic2Vjb25kIiwiaXNNb2RpZmllciIsImZpcnN0Q2hhckNvZGUiLCJzZWNvbmRDaGFyQ29kZSIsInN1bSIsImlzWmVyb1dpZHRoSm9pbmVyIiwiY2hhckNvZGUiLCJpc1ZhcmlhdGlvblNlbGVjdG9yIiwiaXNSZWdpb25hbENvZGUiLCJpc0ZsYWdFbW9qaSIsImlzQ29tYmluZWRDaGFyYWN0ZXIiLCJfY2hhcjMiLCJpc1JlZ2lvbmFsRmxhZyIsInNldElzTG9hZGVkIiwiRm9udCIsInR5cGVraXRMb2FkZWQiLCJmb250UHJvdG90eXBlIiwiU2xvdE1hbmFnZXIiLCJzbG90cyIsImFzc2lnbiIsInNsb3RGYWN0b3J5IiwiUmVuZGVyYWJsZUVsZW1lbnQiLCJpbml0UmVuZGVyYWJsZSIsImlzSW5SYW5nZSIsImhpZGRlbiIsImlzVHJhbnNwYXJlbnQiLCJyZW5kZXJhYmxlQ29tcG9uZW50cyIsImFkZFJlbmRlcmFibGVDb21wb25lbnQiLCJjb21wb25lbnQiLCJyZW1vdmVSZW5kZXJhYmxlQ29tcG9uZW50IiwicHJlcGFyZVJlbmRlcmFibGVGcmFtZSIsIm51bSIsImNoZWNrTGF5ZXJMaW1pdHMiLCJjaGVja1RyYW5zcGFyZW5jeSIsImZpbmFsVHJhbnNmb3JtIiwibVByb3AiLCJyZW5kZXJDb25maWciLCJoaWRlT25UcmFuc3BhcmVudCIsInJlbmRlclJlbmRlcmFibGUiLCJzb3VyY2VSZWN0QXRUaW1lIiwiZ2V0TGF5ZXJTaXplIiwidGV4dERhdGEiLCJnZXRCbGVuZE1vZGUiLCJibGVuZE1vZGVFbnVtcyIsIm1vZGUiLCJTbGlkZXJFZmZlY3QiLCJBbmdsZUVmZmVjdCIsIkNvbG9yRWZmZWN0IiwiUG9pbnRFZmZlY3QiLCJMYXllckluZGV4RWZmZWN0IiwiTWFza0luZGV4RWZmZWN0IiwiQ2hlY2tib3hFZmZlY3QiLCJOb1ZhbHVlRWZmZWN0IiwiRWZmZWN0c01hbmFnZXIiLCJlZmZlY3RzIiwiZWYiLCJlZmZlY3RFbGVtZW50cyIsImVmZmVjdEl0ZW0iLCJHcm91cEVmZmVjdCIsImVmZiIsIkJhc2VFbGVtZW50IiwiY2hlY2tNYXNrcyIsIkxheWVyRXhwcmVzc2lvbkludGVyZmFjZSIsIkVmZmVjdHNFeHByZXNzaW9uSW50ZXJmYWNlIiwiU2hhcGVFeHByZXNzaW9uSW50ZXJmYWNlIiwiVGV4dEV4cHJlc3Npb25JbnRlcmZhY2UiLCJDb21wRXhwcmVzc2lvbkludGVyZmFjZSIsImxheWVySW50ZXJmYWNlIiwibWFza01hbmFnZXIiLCJyZWdpc3Rlck1hc2tJbnRlcmZhY2UiLCJlZmZlY3RzSW50ZXJmYWNlIiwiY3JlYXRlRWZmZWN0c0ludGVyZmFjZSIsInJlZ2lzdGVyRWZmZWN0c0ludGVyZmFjZSIsInNoYXBlSW50ZXJmYWNlIiwic2hhcGVzRGF0YSIsIml0ZW1zRGF0YSIsImNvbnRlbnQiLCJ0ZXh0SW50ZXJmYWNlIiwic2V0QmxlbmRNb2RlIiwiYmxlbmRNb2RlVmFsdWUiLCJibSIsImJhc2VFbGVtZW50IiwibGF5ZXJFbGVtZW50IiwiaW5pdEJhc2VEYXRhIiwibGF5ZXJJZCIsImVmZmVjdHNNYW5hZ2VyIiwiZ2V0VHlwZSIsIkZyYW1lRWxlbWVudCIsInByZXBhcmVQcm9wZXJ0aWVzIiwiaXNWaXNpYmxlIiwiX2lzUGFyZW50IiwiRm9vdGFnZUVsZW1lbnQiLCJpbWFnZUxvYWRlciIsImdldEJhc2VFbGVtZW50IiwiRm9vdGFnZUludGVyZmFjZSIsImdldEZvb3RhZ2VEYXRhIiwiQXVkaW9FbGVtZW50IiwiX2lzUGxheWluZyIsIl9jYW5QbGF5IiwiX2N1cnJlbnRUaW1lIiwiX3ZvbHVtZU11bHRpcGxpZXIiLCJfcHJldmlvdXNWb2x1bWUiLCJfcGxhY2Vob2xkZXIiLCJsdiIsImF1IiwidGltZVJlbWFwcGVkIiwidG90YWxWb2x1bWUiLCJ2b2x1bWVWYWx1ZSIsIkJhc2VSZW5kZXJlciIsImNoZWNrTGF5ZXJzIiwiYnVpbGRJdGVtIiwiY2hlY2tQZW5kaW5nRWxlbWVudHMiLCJjcmVhdGVJdGVtIiwibGF5ZXIiLCJjcmVhdGVJbWFnZSIsImNyZWF0ZUNvbXAiLCJjcmVhdGVTb2xpZCIsImNyZWF0ZU51bGwiLCJjcmVhdGVTaGFwZSIsImNyZWF0ZVRleHQiLCJjcmVhdGVDYW1lcmEiLCJjcmVhdGVGb290YWdlIiwiYnVpbGRBbGxJdGVtcyIsInBJbnRlcmZhY2UiLCJwcm9ncmVzc2l2ZUxvYWQiLCJidWlsZEVsZW1lbnRQYXJlbnRpbmciLCJwYXJlbnROYW1lIiwiaGllcmFyY2h5IiwiYWRkUGVuZGluZ0VsZW1lbnQiLCJzZXRBc1BhcmVudCIsInNldEhpZXJhcmNoeSIsInBlbmRpbmdFbGVtZW50cyIsImdldEVsZW1lbnRCeUlkIiwicGF0aFZhbHVlIiwic2V0dXBHbG9iYWxEYXRhIiwiZm9udHNDb250YWluZXIiLCJhbmltYXRpb25JdGVtIiwiY29tcFNpemUiLCJlZmZlY3RUeXBlcyIsIlRSQU5TRk9STV9FRkZFQ1QiLCJUcmFuc2Zvcm1FbGVtZW50IiwiaW5pdFRyYW5zZm9ybSIsIl9tYXRNZGYiLCJfbG9jYWxNYXRNZGYiLCJfb3BNZGYiLCJsb2NhbE1hdCIsImxvY2FsT3BhY2l0eSIsImFvIiwicmVuZGVyVHJhbnNmb3JtIiwiZmluYWxNYXQiLCJsb2NhbFRyYW5zZm9ybXMiLCJyZW5kZXJMb2NhbFRyYW5zZm9ybSIsImxtYXQiLCJsb2NhbE9wIiwib3BhY2l0eSIsInNlYXJjaEVmZmVjdFRyYW5zZm9ybXMiLCJyZW5kZXJhYmxlRWZmZWN0c01hbmFnZXIiLCJ0cmFuc2Zvcm1FZmZlY3RzIiwiZ2V0RWZmZWN0cyIsImdsb2JhbFRvTG9jYWwiLCJ0cmFuc2Zvcm1zIiwicHROZXciLCJtSGVscGVyIiwiTWFza0VsZW1lbnQiLCJtYXNrRWxlbWVudCIsInZpZXdEYXRhIiwic29saWRQYXRoIiwicHJvcGVydGllcyIsImN1cnJlbnRNYXNrcyIsInJlY3QiLCJleHBhbnNvciIsImZlTW9ycGgiLCJtYXNrVHlwZSIsIm1hc2tSZWYiLCJsYXN0UGF0aCIsImZpbHRlcklEIiwiZXhwYW4iLCJsYXN0T3BlcmF0b3IiLCJmaWx0ZXJJZCIsImxhc3RSYWRpdXMiLCJtYXNrIiwiY3JlYXRlTGF5ZXJTb2xpZFBhdGgiLCJpbnZSZWN0IiwiZHJhd1BhdGgiLCJtYXNrZWRFbGVtZW50IiwiZ2V0TWFza1Byb3BlcnR5IiwiaXNGaXJzdEZyYW1lIiwiZ2V0TWFza2VsZW1lbnQiLCJwYXRoTm9kZXMiLCJwYXRoU3RyaW5nIiwicGF0aFNoYXBlVmFsdWUiLCJmaWx0ZXJzRmFjdG9yeSIsImNyZWF0ZUZpbHRlciIsImNyZWF0ZUFscGhhVG9MdW1pbmFuY2VGaWx0ZXIiLCJmaWxJZCIsInNraXBDb29yZGluYXRlcyIsImZpbCIsImZlQ29sb3JNYXRyaXgiLCJmZWF0dXJlU3VwcG9ydCIsInN2Z0x1bWFIaWRkZW4iLCJvZmZzY3JlZW5DYW52YXMiLCJyZWdpc3RlcmVkRWZmZWN0cyQxIiwiaWRQcmVmaXgiLCJTVkdFZmZlY3RzIiwic291cmNlIiwiZmlsdGVycyIsImZpbHRlck1hbmFnZXIiLCJFZmZlY3QiLCJlZmZlY3QiLCJjb3VudHNBc0VmZmVjdCIsInJlZ2lzdGVyRWZmZWN0JDEiLCJTVkdCYXNlRWxlbWVudCIsImluaXRSZW5kZXJlckVsZW1lbnQiLCJjcmVhdGVDb250YWluZXJFbGVtZW50cyIsIm1hdHRlRWxlbWVudCIsInRyYW5zZm9ybWVkRWxlbWVudCIsIl9zaXplQ2hhbmdlZCIsImxheWVyRWxlbWVudFBhcmVudCIsInRkIiwibWF0dGVNYXNrcyIsImdnIiwidHQiLCJsbiIsImhkIiwiY3AiLCJjbGlwSWQiLCJjcEdyb3VwIiwicmVuZGVyRWxlbWVudCIsImRlc3Ryb3lCYXNlRWxlbWVudCIsImNyZWF0ZVJlbmRlcmFibGVDb21wb25lbnRzIiwiZ2V0TWF0dGUiLCJtYXR0ZVR5cGUiLCJ1c2VFbGVtZW50IiwibWFza2VyIiwibWFza0dyb3VwIiwibWFza0dyb3VwZXIiLCJmZUNUciIsImZlRnVuYyIsImFscGhhUmVjdCIsInNldE1hdHRlIiwiSGllcmFyY2h5RWxlbWVudCIsImluaXRIaWVyYXJjaHkiLCJjaGVja1BhcmVudGluZyIsIlJlbmRlcmFibGVET01FbGVtZW50IiwiX3Byb3RvdHlwZSIsImluaXRFbGVtZW50IiwiY3JlYXRlQ29udGVudCIsInJlbmRlcklubmVyQ29udGVudCIsImlubmVyRWxlbSIsIklJbWFnZUVsZW1lbnQiLCJzb3VyY2VSZWN0IiwicHIiLCJpbWFnZVByZXNlcnZlQXNwZWN0UmF0aW8iLCJQcm9jZXNzZWRFbGVtZW50IiwiSVNoYXBlRWxlbWVudCIsImFkZFNoYXBlVG9Nb2RpZmllcnMiLCJzaGFwZU1vZGlmaWVycyIsImlzU2hhcGVJbkFuaW1hdGVkTW9kaWZpZXJzIiwiaXNBbmltYXRlZFdpdGhTaGFwZSIsInJlbmRlck1vZGlmaWVycyIsInNob3VsZEJyZWFrUHJvY2VzcyIsInNlYXJjaFByb2Nlc3NlZEVsZW1lbnQiLCJwcm9jZXNzZWRFbGVtZW50cyIsImFkZFByb2Nlc3NlZEVsZW1lbnQiLCJsaW5lQ2FwRW51bSIsImxpbmVKb2luRW51bSIsIlNWR1NoYXBlRGF0YSIsInRyYW5zZm9ybWVycyIsImxldmVsIiwiY2FjaGVzIiwibFN0ciIsImx2bCIsIlNWR1N0eWxlRGF0YSIsInBFbGVtIiwibXNFbGVtIiwiRGFzaFByb3BlcnR5IiwiZGF0YVByb3BzIiwiZGFzaFN0ciIsImRhc2hBcnJheSIsImRhc2hvZmZzZXQiLCJTVkdTdHJva2VTdHlsZURhdGEiLCJzdHlsZU9iIiwiU1ZHRmlsbFN0eWxlRGF0YSIsIlNWR05vU3R5bGVEYXRhIiwiR3JhZGllbnRQcm9wZXJ0eSIsImNMZW5ndGgiLCJfY21kZiIsIl9vbWRmIiwiX2NvbGxhcHNhYmxlIiwiY2hlY2tDb2xsYXBzYWJsZSIsIl9oYXNPcGFjaXR5IiwiY29tcGFyZVBvaW50cyIsImRpZmYiLCJTVkdHcmFkaWVudEZpbGxTdHlsZURhdGEiLCJpbml0R3JhZGllbnREYXRhIiwic3RvcHMiLCJzZXRHcmFkaWVudERhdGEiLCJzZXRHcmFkaWVudE9wYWNpdHkiLCJwYXRoRWxlbWVudCIsImdyYWRpZW50SWQiLCJnZmlsbCIsImdmIiwiY3N0Iiwib3BhY2l0eUlkIiwibWFza0lkIiwib3BGaWxsIiwibGMiLCJvZiIsIm1zIiwib3N0IiwiU1ZHR3JhZGllbnRTdHJva2VTdHlsZURhdGEiLCJTaGFwZUdyb3VwRGF0YSIsInByZXZWaWV3RGF0YSIsImdyIiwiU1ZHVHJhbnNmb3JtRGF0YSIsImJ1aWxkU2hhcGVTdHJpbmciLCJfbyIsIl9pIiwic2hhcGVTdHJpbmciLCJTVkdFbGVtZW50c1JlbmRlcmVyIiwiX2lkZW50aXR5TWF0cml4IiwiX21hdHJpeEhlbHBlciIsImNyZWF0ZVJlbmRlckZ1bmN0aW9uIiwicmVuZGVyRmlsbCIsInJlbmRlckdyYWRpZW50IiwicmVuZGVyR3JhZGllbnRTdHJva2UiLCJyZW5kZXJTdHJva2UiLCJyZW5kZXJQYXRoIiwicmVuZGVyQ29udGVudFRyYW5zZm9ybSIsInJlbmRlck5vb3AiLCJzdHlsZURhdGEiLCJpdGVtRGF0YSIsInBhdGhTdHJpbmdUcmFuc2Zvcm1lZCIsInJlZHJhdyIsImxMZW4iLCJpdGVyYXRpb25zIiwic3R5bGVFbGVtIiwiaGFzT3BhY2l0eSIsImF0dHIxIiwiYXR0cjIiLCJjVmFsdWVzIiwib1ZhbHVlcyIsImFuZyIsIlNWR1NoYXBlRWxlbWVudCIsInN0eWxlc0xpc3QiLCJhbmltYXRlZENvbnRlbnRzIiwiaW5pdFNlY29uZGFyeUVsZW1lbnQiLCJpZGVudGl0eU1hdHJpeCIsImJ1aWxkRXhwcmVzc2lvbkludGVyZmFjZSIsInNlYXJjaFNoYXBlcyIsImZpbHRlclVuaXF1ZVNoYXBlcyIsInRlbXBTaGFwZXMiLCJhcmVBbmltYXRlZCIsInNldFNoYXBlc0FzQW5pbWF0ZWQiLCJjcmVhdGVTdHlsZUVsZW1lbnQiLCJlbGVtZW50RGF0YSIsIkdyYWRpZW50Q29uc3RydWN0b3IiLCJhZGRUb0FuaW1hdGVkQ29udGVudHMiLCJjcmVhdGVHcm91cEVsZW1lbnQiLCJjcmVhdGVUcmFuc2Zvcm1FbGVtZW50IiwidHJhbnNmb3JtUHJvcGVydHkiLCJjcmVhdGVTaGFwZUVsZW1lbnQiLCJvd25UcmFuc2Zvcm1lcnMiLCJzaGFwZVByb3BlcnR5Iiwic2V0RWxlbWVudFN0eWxlcyIsInJlbmRlciIsIm93blN0eWxlcyIsIm93bk1vZGlmaWVycyIsImN1cnJlbnRUcmFuc2Zvcm0iLCJtb2RpZmllciIsInByb2Nlc3NlZFBvcyIsInJlbmRlclNoYXBlIiwiYW5pbWF0ZWRDb250ZW50IiwiTGV0dGVyUHJvcHMiLCJzdyIsImZjIiwidXBkYXRlIiwidXBkYXRlZCIsIlRleHRQcm9wZXJ0eSIsIl9mcmFtZUlkIiwia2V5c0luZGV4IiwiY2FuUmVzaXplIiwibWluaW11bUZvbnRTaXplIiwiY3VycmVudERhdGEiLCJhc2NlbnQiLCJib3hXaWR0aCIsImRlZmF1bHRCb3hXaWR0aCIsImp1c3RpZnlPZmZzZXQiLCJsaCIsImxpbmVXaWR0aHMiLCJscyIsInBzIiwiZmlsbENvbG9yQW5pbSIsInN0cm9rZUNvbG9yQW5pbSIsInN0cm9rZVdpZHRoQW5pbSIsInlPZmZzZXQiLCJmaW5hbFNpemUiLCJmaW5hbFRleHQiLCJmaW5hbExpbmVIZWlnaHQiLCJjb3B5RGF0YSIsInNlYXJjaFByb3BlcnR5IiwiY29tcGxldGVUZXh0RGF0YSIsIm9iaiIsInNldEN1cnJlbnREYXRhIiwic2VhcmNoS2V5ZnJhbWVzIiwiZ2V0S2V5ZnJhbWVWYWx1ZSIsIl9maW5hbFZhbHVlIiwiY3VycmVudFZhbHVlIiwiY3VycmVudEluZGV4IiwidGV4dEtleXMiLCJidWlsZEZpbmFsVGV4dCIsImNoYXJhY3RlcnNBcnJheSIsInNob3VsZENvbWJpbmUiLCJzaG91bGRDb21iaW5lTmV4dCIsImN1cnJlbnRDaGFycyIsImNoYXJBdCIsImxldHRlcnMiLCJuZXdMaW5lRmxhZyIsImFuY2hvckdyb3VwaW5nIiwiY3VycmVudFNpemUiLCJjdXJyZW50UG9zIiwiY3VycmVudExpbmUiLCJsaW5lV2lkdGgiLCJtYXhMaW5lV2lkdGgiLCJ0cmFja2luZ09mZnNldCIsImJveEhlaWdodCIsImN1cnJlbnRIZWlnaHQiLCJsYXN0U3BhY2VJbmRleCIsInVuY29sbGFwc2VkU3BhY2VzIiwiY3VycmVudENoYXIiLCJhbiIsImFkZCIsImFuSW5kZXhlcyIsImFuaW1hdG9ySnVzdGlmeU9mZnNldCIsImV4dHJhIiwiYW5pbWF0b3JzIiwiYW5pbWF0b3JEYXRhIiwibGV0dGVyRGF0YSIsImJhc2VkIiwiaW5kZXhlcyIsImZoIiwiZnMiLCJmYiIsInJuIiwidG90YWxDaGFycyIsImN1cnJlbnRJbmQiLCJuZXdJbmQiLCJuZXdEYXRhIiwiZERhdGEiLCJyZWNhbGN1bGF0ZSIsImNhblJlc2l6ZUZvbnQiLCJfY2FuUmVzaXplIiwic2V0TWluaW11bUZvbnRTaXplIiwiX2ZvbnRWYWx1ZSIsIlRleHRTZWxlY3RvclByb3AiLCJUZXh0U2VsZWN0b3JQcm9wRmFjdG9yeSIsIl9jdXJyZW50VGV4dExlbmd0aCIsImZpbmFsUyIsImZpbmFsRSIsInhlIiwibmUiLCJzbSIsImdldE11bHQiLCJ0ZXh0UHJvcGVydHkiLCJlYXNlciIsInRvdCIsInNtb290aG5lc3MiLCJ0aHJlc2hvbGQiLCJuZXdDaGFyc0ZsYWciLCJkaXZpc29yIiwiZ2V0VGV4dFNlbGVjdG9yUHJvcCIsIlRleHRBbmltYXRvckRhdGFQcm9wZXJ0eSIsImFuaW1hdG9yUHJvcHMiLCJkZWZhdWx0RGF0YSIsInRleHRBbmltYXRvckFuaW1hdGFibGVzIiwiVGV4dEFuaW1hdG9yUHJvcGVydHkiLCJyZW5kZXJUeXBlIiwiX2hhc01hc2tlZFBhdGgiLCJfdGV4dERhdGEiLCJfcmVuZGVyVHlwZSIsIl9lbGVtIiwiX2FuaW1hdG9yc0RhdGEiLCJfcGF0aERhdGEiLCJfbW9yZU9wdGlvbnMiLCJhbGlnbm1lbnQiLCJyZW5kZXJlZExldHRlcnMiLCJsZXR0ZXJzQ2hhbmdlZEZsYWciLCJzZWFyY2hQcm9wZXJ0aWVzIiwiZ2V0TWVhc3VyZXMiLCJtYXRyaXhIZWxwZXIiLCJyZW5kZXJlZExldHRlcnNDb3VudCIsInhQb3MiLCJ5UG9zIiwicGF0aEluZm8iLCJjdXJyZW50TGVuZ3RoIiwiY3VycmVudFBvaW50IiwicG9pbnRJbmQiLCJzZWdtZW50SW5kIiwidGFuQW5nbGUiLCJ0TGVuZ3RoIiwicGkiLCJ5T2ZmIiwiZmlyc3RMaW5lIiwiYW5pbWF0b3JTZWxlY3RvciIsImxldHRlclZhbHVlIiwib2ZmZiIsInhQYXRoUG9zIiwieVBhdGhQb3MiLCJpbml0UGF0aFBvcyIsImluaXRTZWdtZW50SW5kIiwiaW5pdFBvaW50SW5kIiwiZWxlbU9wYWNpdHkiLCJsZXR0ZXJTdyIsImxldHRlclNjIiwibGV0dGVyRmMiLCJsZXR0ZXJNIiwibGV0dGVyUCIsImRlZmF1bHRQcm9wc0FycmF5IiwibGV0dGVyTyIsImFuaW1hdG9yRmlyc3RDaGFyT2Zmc2V0IiwianVzdGlmeU9mZnNldE11bHQiLCJpc05ld0xpbmUiLCJhbmltYXRvck9mZnNldCIsImF0YW4iLCJJVGV4dEVsZW1lbnQiLCJ0ZXh0QW5pbWF0b3IiLCJjcmVhdGVQYXRoU2hhcGUiLCJzaGFwZVN0ciIsIl9mb250U2l6ZSIsImFwcGx5VGV4dFByb3BlcnRpZXNUb01hdHJpeCIsImxpbmVOdW1iZXIiLCJidWlsZENvbG9yIiwiY29sb3JEYXRhIiwiZW1wdHlQcm9wIiwidmFsaWRhdGVUZXh0IiwiYnVpbGROZXdUZXh0IiwiZW1wdHlTaGFwZURhdGEiLCJTVkdUZXh0TG90dGllRWxlbWVudCIsInRleHRTcGFucyIsInNpbmdsZVNoYXBlIiwidGV4dENvbnRhaW5lciIsImJ1aWxkVGV4dENvbnRlbnRzIiwidGV4dEFycmF5IiwidGV4dENvbnRlbnRzIiwiY3VycmVudFRleHRDb250ZW50IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiYnVpbGRTaGFwZURhdGEiLCJzaGFwZUl0ZW0iLCJ1c2VzR2x5cGhzIiwidFNwYW4iLCJ0RWxlbWVudCIsImp1c3RpZnkiLCJzcGFuIiwiZ2x5cGgiLCJjYWNoZWRTcGFuc0xlbmd0aCIsImNoaWxkU3BhbiIsImdseXBoRWxlbWVudCIsIlNWR0NvbXBFbGVtZW50IiwiX2RlYnVnIiwidGV4dEJveCIsImJib3giLCJyZW5kZXJlZExldHRlciIsInRleHRTcGFuIiwiSVNvbGlkRWxlbWVudCIsIk51bGxFbGVtZW50IiwiU1ZHUmVuZGVyZXJCYXNlIiwic3ZnRWxlbWVudCIsInZpZXdCb3hTaXplIiwidmlld0JveE9ubHkiLCJjb250ZW50VmlzaWJpbGl0eSIsImNsYXNzTmFtZSIsImZvY3VzYWJsZSIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJkZXN0cm95ZWQiLCJmaW5kSW5kZXhCeUluZCIsImFwcGVuZEVsZW1lbnRJblBvcyIsImVsZW1lbnRJbmRleCIsInRwIiwibWF0dGVNYXNrIiwibmV4dEVsZW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJJQ29tcEVsZW1lbnQiLCJzZXRFbGVtZW50cyIsImdldEVsZW1lbnRzIiwiZGVzdHJveUVsZW1lbnRzIiwic3VwcG9ydHMzZCIsIlNWR1JlbmRlcmVyIiwiY29uZmlnIiwiYXJpYUxhYmVsIiwidGl0bGUiLCJ0aXRsZUVsZW1lbnQiLCJ0aXRsZUlkIiwiZGVzY3JpcHRpb24iLCJkZXNjRWxlbWVudCIsImRlc2NJZCIsImZpbHRlclNpemUiLCJydW5FeHByZXNzaW9ucyIsIlNoYXBlVHJhbnNmb3JtTWFuYWdlciIsInNlcXVlbmNlcyIsInNlcXVlbmNlTGlzdCIsInRyYW5zZm9ybV9rZXlfY291bnQiLCJhZGRUcmFuc2Zvcm1TZXF1ZW5jZSIsInNlcXVlbmNlIiwicHJvY2Vzc1NlcXVlbmNlIiwicHJvY2Vzc1NlcXVlbmNlcyIsImdldE5ld0tleSIsImx1bWFMb2FkZXIiLCJsdW1hQnVmZmVyIiwibHVtYUJ1ZmZlckN0eCIsInN2ZyIsImNyZWF0ZUx1bWFTdmdGaWx0ZXIiLCJfc3ZnIiwibG9hZEx1bWEiLCJnZXRMdW1hIiwiY3JlYXRlQ2FudmFzIiwibG9hZEx1bWFDYW52YXMiLCJnZXRMdW1hQ2FudmFzIiwicmVnaXN0ZXJlZEVmZmVjdHMiLCJDVkVmZmVjdHMiLCJyZWdpc3RlckVmZmVjdCIsIkNWTWFza0VsZW1lbnQiLCJoYXNNYXNrcyIsImNhbnZhc0NvbnRleHQiLCJiZWdpblBhdGgiLCJtb3ZlVG8iLCJsaW5lVG8iLCJiZXppZXJDdXJ2ZVRvIiwic2F2ZSIsImNsaXAiLCJDVkJhc2VFbGVtZW50Iiwib3BlcmF0aW9uc01hcCIsImNyZWF0ZUVsZW1lbnRzIiwiYnVmZmVycyIsImJ1ZmZlckNhbnZhcyIsImJ1ZmZlckNhbnZhczIiLCJfaXNQcm94eSIsInRyYW5zZm9ybUNhbnZhcyIsImJsZW5kTW9kZSIsImdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiIsImhpZGVFbGVtZW50Iiwic2hvd0VsZW1lbnQiLCJjbGVhckNhbnZhcyIsImNsZWFyUmVjdCIsInByZXBhcmVMYXllciIsImJ1ZmZlciIsImJ1ZmZlckN0eCIsImRyYXdJbWFnZSIsImdldFRyYW5zZm9ybSIsImV4aXRMYXllciIsImZvcmNlUmVhbFN0YWNrIiwiY3R4VHJhbnNmb3JtIiwiY3R4T3BhY2l0eSIsInJlc3RvcmUiLCJDVlNoYXBlRGF0YSIsInRyYW5zZm9ybXNNYW5hZ2VyIiwic3R5bGVkU2hhcGVzIiwic3R5bGVkU2hhcGUiLCJ0ck5vZGVzIiwiQ1ZTaGFwZUVsZW1lbnQiLCJ0cmFuc2Zvcm1IZWxwZXIiLCJkYXNoUmVzZXR0ZXIiLCJwcmVUcmFuc2Zvcm1zIiwiY28iLCJ3aSIsImRhIiwiYWRkVHJhbnNmb3JtVG9TdHlsZUxpc3QiLCJyZW1vdmVUcmFuc2Zvcm1Gcm9tU3R5bGVMaXN0IiwiY2xvc2VTdHlsZXMiLCJzaG91bGRSZW5kZXIiLCJvd25UcmFuc2Zvcm1zIiwiX3Nob3VsZFJlbmRlciIsInJlbmRlclNoYXBlVHJhbnNmb3JtIiwicGFyZW50VHJhbnNmb3JtIiwiZ3JvdXBUcmFuc2Zvcm0iLCJkcmF3TGF5ZXIiLCJub2RlcyIsImN1cnJlbnRTdHlsZSIsImNvT3AiLCJjdXJyZW50R2xvYmFsQWxwaGEiLCJjdHhTdHJva2VTdHlsZSIsImdyZCIsImN0eExpbmVXaWR0aCIsImN0eExpbmVDYXAiLCJjdHhMaW5lSm9pbiIsImN0eE1pdGVyTGltaXQiLCJjdHhGaWxsU3R5bGUiLCJzZXRMaW5lRGFzaCIsImxpbmVEYXNoT2Zmc2V0IiwiY2xvc2VQYXRoIiwiY3R4U3Ryb2tlIiwiY3R4RmlsbCIsImlzTWFpbiIsInJlbmRlckdyYWRpZW50RmlsbCIsInJlbmRlclN0eWxlZFNoYXBlIiwic2hhcGVOb2RlcyIsImdyb3VwVHJhbnNmb3JtTWF0IiwiY3JlYXRlTGluZWFyR3JhZGllbnQiLCJjcmVhdGVSYWRpYWxHcmFkaWVudCIsImFkZENvbG9yU3RvcCIsIkNWVGV4dEVsZW1lbnQiLCJzdHJva2UiLCJmaWxsIiwiY3VycmVudFJlbmRlciIsInNXaWR0aCIsImZWYWx1ZSIsImhhc0ZpbGwiLCJoYXNTdHJva2UiLCJjb21tYW5kcyIsInBhdGhBcnIiLCJjb21tYW5kc0NvdW50ZXIiLCJsYXN0RmlsbCIsImxhc3RTdHJva2UiLCJsYXN0U3Ryb2tlVyIsIkNWSW1hZ2VFbGVtZW50IiwiaW1nVyIsImltZ0giLCJpbWdSZWwiLCJjYW52YXNSZWwiLCJ3aWR0aENyb3AiLCJoZWlnaHRDcm9wIiwicGFyIiwiQ1ZTb2xpZEVsZW1lbnQiLCJjdHhGaWxsUmVjdCIsIkNhbnZhc1JlbmRlcmVyQmFzZSIsImdsb2JhbEFscGhhIiwic3Ryb2tlU3R5bGUiLCJsaW5lQ2FwIiwicnVsZSIsImNvbnRleHREYXRhIiwiYWN0aW9uRmxhZyIsImNvbnRhaW5lclN0eWxlIiwibW96VHJhbnNmb3JtT3JpZ2luIiwiY29udGV4dCIsInNldENvbnRleHQiLCJpc0Rhc2hlZCIsImVsZW1lbnRXaWR0aCIsImVsZW1lbnRIZWlnaHQiLCJvZmZzZXRIZWlnaHQiLCJkcHIiLCJlbGVtZW50UmVsIiwiYW5pbWF0aW9uUmVsIiwiZmlsbFR5cGUiLCJDYW52YXNDb250ZXh0IiwiQ1ZDb250ZXh0RGF0YSIsInN0YWNrIiwiY0FyclBvcyIsImNUciIsIm5hdGl2ZUNvbnRleHQiLCJ0cmFuc2Zvcm1NYXQiLCJjdXJyZW50T3BhY2l0eSIsImN1cnJlbnRGaWxsU3R5bGUiLCJhcHBsaWVkRmlsbFN0eWxlIiwiY3VycmVudFN0cm9rZVN0eWxlIiwiYXBwbGllZFN0cm9rZVN0eWxlIiwiY3VycmVudExpbmVXaWR0aCIsImFwcGxpZWRMaW5lV2lkdGgiLCJjdXJyZW50TGluZUNhcCIsImFwcGxpZWRMaW5lQ2FwIiwiY3VycmVudExpbmVKb2luIiwiYXBwbGllZExpbmVKb2luIiwiYXBwbGllZE1pdGVyTGltaXQiLCJjdXJyZW50TWl0ZXJMaW1pdCIsImR1cGxpY2F0ZSIsIm5ld0xlbmd0aCIsImZvcmNlUmVzdG9yZSIsImN1cnJlbnRDb250ZXh0IiwicHJldlN0YWNrIiwic2F2ZU9uTmF0aXZlRmxhZyIsImN1cnJlbnRTdGFjayIsIm5ld1N0YWNrIiwic2V0T3BhY2l0eSIsInRyUHJvcHMiLCJDVkNvbXBFbGVtZW50IiwiQ2FudmFzUmVuZGVyZXIiLCJkZXZpY2VQaXhlbFJhdGlvIiwiSEJhc2VFbGVtZW50IiwiY2hlY2tCbGVuZE1vZGUiLCJ0ZyIsInRyYW5zZm9ybWVkRWxlbWVudFN0eWxlIiwibWF0cml4VmFsdWUiLCJ3ZWJraXRUcmFuc2Zvcm0iLCJhZGRFZmZlY3RzIiwiSFNvbGlkRWxlbWVudCIsImJhY2tncm91bmRDb2xvciIsIkhTaGFwZUVsZW1lbnQiLCJzaGFwZXNDb250YWluZXIiLCJjdXJyZW50QkJveCIsIl9yZW5kZXJTaGFwZUZyYW1lIiwic2hhcGVDb250IiwiZ2V0VHJhbnNmb3JtZWRQb2ludCIsImNhbGN1bGF0ZVNoYXBlQm91bmRpbmdCb3giLCJpdGVtIiwidlBvaW50Iiwib1BvaW50IiwibmV4dElQb2ludCIsIm5leHRWUG9pbnQiLCJjaGVja0JvdW5kcyIsImdldEJvdW5kc09mQ3VydmUiLCJzaGFwZUJvdW5kaW5nQm94IiwieE1heCIsInlNYXgiLCJ0ZW1wQm91bmRpbmdCb3giLCJiMmFjIiwiY2FsY3VsYXRlRiIsImNhbGN1bGF0ZUJvdW5kaW5nQm94IiwiZXhwYW5kU3Ryb2tlQm91bmRpbmdCb3giLCJ3aWR0aFByb3BlcnR5Iiwia2Z3IiwiY3VycmVudEJveENvbnRhaW5zIiwiY2hhbmdlZCIsInNoYXBlU3R5bGUiLCJzaGFwZVRyYW5zZm9ybSIsIkhUZXh0RWxlbWVudCIsInRleHRQYXRocyIsImlzTWFza2VkIiwiY29tcFciLCJjb21wSCIsImlubmVyRWxlbVN0eWxlIiwidGV4dENvbG9yIiwic3Ryb2tlV2lkdGgiLCJsaW5lSGVpZ2h0IiwidFBhcmVudCIsInRDb250IiwiY2hpbGRyZW4iLCJ0Q29udFN0eWxlIiwidENvbnRUcmFuc2xhdGlvbiIsInRTdHlsZSIsInRTcGFuVHJhbnNsYXRpb24iLCJzdmdTdHlsZSIsInRyYW5zbGF0aW9uIiwidGV4dFBhdGgiLCJtYXJnaW4iLCJzdmdUcmFuc2Zvcm0iLCJIQ2FtZXJhRWxlbWVudCIsInBlIiwiX3ByZXZNYXQiLCJzZXR1cCIsInRocmVlREVsZW1lbnRzIiwicGVyc3BlY3RpdmVTdHlsZSIsInBlcnNwZWN0aXZlRWxlbSIsInBlcnNwZWN0aXZlIiwid2Via2l0UGVyc3BlY3RpdmUiLCJtVHJhbnNmIiwiZGlmZlZlY3RvciIsIm1hZyIsImxvb2tEaXIiLCJsb29rTGVuZ3RoT25YWiIsIm1Sb3RhdGlvblgiLCJtUm90YXRpb25ZIiwiaGFzTWF0cml4Q2hhbmdlZCIsIm1hdFZhbHVlIiwiSEltYWdlRWxlbWVudCIsIkltYWdlIiwiaW1hZ2VFbGVtIiwiSHlicmlkUmVuZGVyZXJCYXNlIiwiY2FtZXJhIiwibmV3RE9NRWxlbWVudCIsImRkZCIsImFkZFRvM2RDb250YWluZXIiLCJuZXh0RE9NRWxlbWVudCIsIm5leHRMYXllciIsInRtcERPTUVsZW1lbnQiLCJnZXRUaHJlZURDb250YWluZXJCeVBvcyIsInN0YXJ0UG9zIiwiZW5kUG9zIiwiY3JlYXRlVGhyZWVEQ29udGFpbmVyIiwidGhyZWVEQ29udGFpbmVyRGF0YSIsImJ1aWxkM2RDb250YWluZXJzIiwibGFzdFRocmVlRENvbnRhaW5lckRhdGEiLCJjdXJyZW50Q29udGFpbmVyIiwicmVzaXplckVsZW0iLCJvdmVyZmxvdyIsImNXaWR0aCIsImNIZWlnaHQiLCJmbG9hdGluZ0NvbnRhaW5lciIsIkhDb21wRWxlbWVudCIsIl9jcmVhdGVCYXNlQ29udGFpbmVyRWxlbWVudHMiLCJIeWJyaWRSZW5kZXJlciIsIl90aGlzTGF5ZXJGdW5jdGlvbiIsImRlZmluZVByb3BlcnR5IiwicGl4ZWxBc3BlY3QiLCJmcmFtZUR1cmF0aW9uIiwiZGlzcGxheVN0YXJ0VGltZSIsIm51bUxheWVycyIsIl90eXBlb2YkMiIsInNlZWRSYW5kb20iLCJjaHVua3MiLCJkaWdpdHMiLCJybmduYW1lIiwic3RhcnRkZW5vbSIsInNpZ25pZmljYW5jZSIsIm5vZGVjcnlwdG8iLCJzZWVkcmFuZG9tIiwic2VlZCIsIm9wdGlvbnMiLCJlbnRyb3B5Iiwic2hvcnRzZWVkIiwibWl4a2V5IiwiZmxhdHRlbiIsInRvc3RyaW5nIiwiYXV0b3NlZWQiLCJhcmM0IiwiQVJDNCIsInBybmciLCJpbnQzMiIsInF1aWNrIiwiUyIsInBhc3MiLCJpc19tYXRoX2NhbGwiLCJzdGF0ZSIsImNvcHkiLCJrZXlsZW4iLCJtZSIsInJlc3VsdCIsInR5cCIsInN0cmluZ3NlZWQiLCJzbWVhciIsInJhbmRvbUJ5dGVzIiwiVWludDhBcnJheSIsImNyeXB0byIsIm1zQ3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiYnJvd3NlciIsInBsdWdpbnMiLCJzY3JlZW4iLCJpbml0aWFsaXplJDIiLCJwcm9wVHlwZXMiLCJTSEFQRSIsIl90eXBlb2YkMSIsIkV4cHJlc3Npb25NYW5hZ2VyIiwiZmV0Y2giLCJmcmFtZXMiLCJfbG90dGllR2xvYmFsIiwiJGJtX2lzSW5zdGFuY2VPZkFycmF5IiwiaXNOdW1lcmFibGUiLCJ0T2ZWIiwiJGJtX25lZyIsInRPZkEiLCJsZW5BIiwicmV0QXJyIiwiZWFzZUluQmV6IiwiZWFzZU91dEJleiIsImVhc2VJbk91dEJleiIsInRPZkIiLCJsZW5CIiwic3ViIiwibXVsIiwibW9kIiwiJGJtX3N1bSIsIiRibV9zdWIiLCIkYm1fbXVsIiwiJGJtX2RpdiIsIiRibV9tb2QiLCJjbGFtcCIsIm1tIiwicmFkaWFuc1RvRGVncmVlcyIsInJhZGlhbnNfdG9fZGVncmVlcyIsImRlZ3JlZXNUb1JhZGlhbnMiLCJkZWdyZWVzX3RvX3JhZGlhbnMiLCJoZWxwZXJMZW5ndGhBcnJheSIsImFycjEiLCJhcnIyIiwibm9ybWFsaXplIiwidmVjIiwicmdiVG9Ic2wiLCJodWUycmdiIiwiaHNsVG9SZ2IiLCJsaW5lYXIiLCJ0TWluIiwidE1heCIsInZhbHVlMSIsInZhbHVlMiIsIl90TWluIiwicm5kIiwicm5kbSIsImNyZWF0ZVBhdGgiLCJpblRhbmdlbnRzIiwib3V0VGFuZ2VudHMiLCJhcnJQbGFjZWhvbGRlciIsImluVmVydGV4UG9pbnQiLCJvdXRWZXJ0ZXhQb2ludCIsImluaXRpYXRlRXhwcmVzc2lvbiIsInByb3BlcnR5Iiwibm9PcCIsIl92YWx1ZSIsIm5lZWRzVmVsb2NpdHkiLCJfbmVlZHNSYW5kb20iLCJlbGVtVHlwZSIsIiRibV90cmFuc2Zvcm0iLCJ0aGlzUHJvcGVydHkiLCJfbmFtZSIsInZhbHVlQXRUaW1lIiwiaW5Qb2ludCIsIm91dFBvaW50IiwibG9vcEluIiwibG9vcF9pbiIsImxvb3BPdXQiLCJsb29wX291dCIsInNtb290aCIsInRvV29ybGQiLCJmcm9tV29ybGQiLCJmcm9tQ29tcCIsInRvQ29tcCIsImZyb21Db21wVG9TdXJmYWNlIiwicm90YXRpb24iLCJhbmNob3JQb2ludCIsInRoaXNMYXllciIsInRoaXNDb21wIiwidmVsb2NpdHlBdFRpbWUiLCJzY29wZWRfYm1fcnQiLCJleHByZXNzaW9uX2Z1bmN0aW9uIiwiZXZhbCIsIm51bUtleXMiLCJhY3RpdmUiLCJ3aWdnbGUiLCJmcmVxIiwiYW1wIiwiaVdpZ2dsZSIsImxlbldpZ2dsZSIsImFkZGVkQW1wcyIsInBlcmlvZHMiLCJsb29wSW5EdXJhdGlvbiIsImxvb3BPdXREdXJhdGlvbiIsImdldFZlbG9jaXR5QXRUaW1lIiwibG9va0F0IiwiZWxlbTEiLCJlbGVtMiIsImZWZWMiLCJwaXRjaCIsInlhdyIsImVhc2VPdXQiLCJ2YWwxIiwidmFsMiIsImFwcGx5RWFzZSIsImVhc2VJbiIsImVhc2UiLCJpS2V5IiwibGVuS2V5IiwibmVhcmVzdEtleSIsIm9iS2V5IiwiZnJhbWVzVG9UaW1lIiwiZnBzIiwidGltZVRvRnJhbWVzIiwicmFuZFNlZWQiLCJzdWJzdHJpbmciLCJwb3N0ZXJpemVUaW1lIiwiZnJhbWVzUGVyU2Vjb25kIiwidmVsb2NpdHkiLCJ0ZXh0SW5kZXgiLCJ0ZXh0VG90YWwiLCJzZWxlY3RvclZhbHVlIiwiaGFzUGFyZW50IiwiZXhlY3V0ZUV4cHJlc3Npb24iLCJmcmFtZUV4cHJlc3Npb25JZCIsIl9fcHJldmVudERlYWRDb2RlUmVtb3ZhbCIsIkV4cHJlc3Npb25zIiwic3RhY2tDb3VudCIsInJlZ2lzdGVycyIsInB1c2hFeHByZXNzaW9uIiwicG9wRXhwcmVzc2lvbiIsInJlbGVhc2VJbnN0YW5jZXMiLCJyZWdpc3RlckV4cHJlc3Npb25Qcm9wZXJ0eSIsImV4cHJlc3Npb24iLCJNYXNrTWFuYWdlckludGVyZmFjZSIsIk1hc2tJbnRlcmZhY2UiLCJfbWFzayIsIl9kYXRhIiwiTWFza01hbmFnZXIiLCJfbWFza3NJbnRlcmZhY2VzIiwibWFza0Z1bmN0aW9uIiwiRXhwcmVzc2lvblByb3BlcnR5SW50ZXJmYWNlIiwiZGVmYXVsdFVuaWRpbWVuc2lvbmFsVmFsdWUiLCJkZWZhdWx0TXVsdGlkaW1lbnNpb25hbFZhbHVlIiwiY29tcGxldGVQcm9wZXJ0eSIsImV4cHJlc3Npb25WYWx1ZSIsInZhbHVlUHJvcCIsInNwZWVkQXRUaW1lIiwiZ2V0U3BlZWRBdFRpbWUiLCJwcm9wZXJ0eUdyb3VwIiwiVW5pZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZSIsIk11bHRpZGltZW5zaW9uYWxQcm9wZXJ0eUludGVyZmFjZSIsImFyclZhbHVlIiwiZGVmYXVsdEdldHRlciIsIlRyYW5zZm9ybUV4cHJlc3Npb25JbnRlcmZhY2UiLCJfdGhpc0Z1bmN0aW9uIiwieFJvdGF0aW9uIiwieVJvdGF0aW9uIiwieFBvc2l0aW9uIiwieVBvc2l0aW9uIiwielBvc2l0aW9uIiwiX3B4IiwiX3B5IiwiX3B6IiwiX3RyYW5zZm9ybUZhY3RvcnkiLCJnZXRNYXRyaXgiLCJ0b1dvcmxkTWF0IiwicHJvcE1hdHJpeCIsInRvV29ybGRWZWMiLCJhcHBseVBvaW50IiwiZnJvbVdvcmxkVmVjIiwiaW52ZXJ0UG9pbnQiLCJzYW1wbGVJbWFnZSIsInRyYW5zZm9ybUludGVyZmFjZSIsIl9yZWdpc3Rlck1hc2tJbnRlcmZhY2UiLCJfcmVnaXN0ZXJFZmZlY3RzSW50ZXJmYWNlIiwiYW5jaG9yUG9pbnREZXNjcmlwdG9yIiwiZGVmaW5lUHJvcGVydGllcyIsImFuY2hvcl9wb2ludCIsInN0YXJ0VGltZSIsInByb3BlcnR5R3JvdXBGYWN0b3J5IiwiaW50ZXJmYWNlRnVuY3Rpb24iLCJwYXJlbnRQcm9wZXJ0eUdyb3VwIiwiUHJvcGVydHlJbnRlcmZhY2UiLCJwcm9wZXJ0eU5hbWUiLCJfcHJvcGVydHlHcm91cCIsImVmZmVjdHNEYXRhIiwiY3JlYXRlR3JvdXBJbnRlcmZhY2UiLCJncm91cEludGVyZmFjZSIsIm1uIiwiY3JlYXRlVmFsdWVJbnRlcmZhY2UiLCJudW1Qcm9wZXJ0aWVzIiwibnAiLCJlbmFibGVkIiwiZW4iLCJleHByZXNzaW9uUHJvcGVydHkiLCJzZXRHcm91cFByb3BlcnR5IiwiU2hhcGVQYXRoSW50ZXJmYWNlIiwicGF0aEludGVyZmFjZUZhY3RvcnkiLCJ2aWV3IiwicHJvcGVydHlJbmRleCIsIml0ZXJhdGVFbGVtZW50cyIsImdyb3VwSW50ZXJmYWNlRmFjdG9yeSIsImZpbGxJbnRlcmZhY2VGYWN0b3J5Iiwic3Ryb2tlSW50ZXJmYWNlRmFjdG9yeSIsInRyaW1JbnRlcmZhY2VGYWN0b3J5IiwiZWxsaXBzZUludGVyZmFjZUZhY3RvcnkiLCJzdGFySW50ZXJmYWNlRmFjdG9yeSIsInJlY3RJbnRlcmZhY2VGYWN0b3J5Iiwicm91bmRlZEludGVyZmFjZUZhY3RvcnkiLCJyZXBlYXRlckludGVyZmFjZUZhY3RvcnkiLCJncmFkaWVudEZpbGxJbnRlcmZhY2VGYWN0b3J5IiwiZGVmYXVsdEludGVyZmFjZUZhY3RvcnkiLCJjb250ZW50c0ludGVyZmFjZUZhY3RvcnkiLCJpbnRlcmZhY2VzIiwiX2ludGVyZmFjZUZ1bmN0aW9uIiwidHJhbnNmb3JtSW50ZXJmYWNlRmFjdG9yeSIsImNpeCIsInN0YXJ0UG9pbnQiLCJlbmRQb2ludCIsIl9kYXNoUHJvcGVydHlHcm91cCIsImRhc2hPYiIsImFkZFByb3BlcnR5VG9EYXNoT2IiLCJkYXNoIiwic3RhcnQiLCJza2V3QXhpcyIsIm91dGVyUmFkaXVzIiwib3V0ZXJSb3VuZG5lc3MiLCJpbm5lclJhZGl1cyIsImlubmVyUm91bmRuZXNzIiwicGFyZW50R3JvdXBXcmFwcGVyIiwiX3NvdXJjZVRleHQiLCJzb3VyY2VUZXh0Iiwic3RyaW5nVmFsdWUiLCJmaWxsQ29sb3IiLCJfdHlwZW9mIiwib3V0bGluZUludGVyZmFjZUZhY3RvcnkiLCJjdXJyZW50UHJvcGVydHlOYW1lIiwiY3VycmVudFByb3BlcnR5IiwicHJvcGVydHlOYW1lSW5kZXgiLCJkYXRhSW50ZXJmYWNlRmFjdG9yeSIsIm91dGxpbmVJbnRlcmZhY2UiLCJkYXRhSW50ZXJmYWNlIiwiZm9vdGFnZSIsImdldEludGVyZmFjZSIsImV4cHJlc3Npb25IZWxwZXJzIiwic2VhcmNoRXhwcmVzc2lvbnMiLCJfY2FjaGluZ0F0VGltZSIsInNwZWVkIiwiZ2V0U3RhdGljVmFsdWVBdFRpbWUiLCJhZGRQcm9wZXJ0eURlY29yYXRvciIsImR1cmF0aW9uRmxhZyIsImxhc3RLZXlGcmFtZSIsImN5Y2xlRHVyYXRpb24iLCJmaXJzdEtleUZyYW1lIiwicmV0IiwiaW5pdFYiLCJlbmRWIiwiY3VycmVudCIsInJlcGVhdHMiLCJsYXN0VmFsdWUiLCJuZXh0TGFzdFZhbHVlIiwiZmlyc3RWYWx1ZSIsIm5leHRGaXJzdFZhbHVlIiwic2FtcGxlcyIsImVuZEZyYW1lIiwic2FtcGxlRnJlcXVlbmN5Iiwic2FtcGxlVmFsdWUiLCJnZXRUcmFuc2Zvcm1WYWx1ZUF0VGltZSIsIl90cmFuc2Zvcm1DYWNoaW5nQXRUaW1lIiwiYW5jaG9yIiwicm90YXRpb25aIiwicm90YXRpb25ZIiwicm90YXRpb25YIiwib3JpZW50YXRpb24iLCJwb3NpdGlvblgiLCJwb3NpdGlvblkiLCJwb3NpdGlvbloiLCJnZXRUcmFuc2Zvcm1TdGF0aWNWYWx1ZUF0VGltZSIsInByb3BlcnR5R2V0UHJvcCIsImdldFNoYXBlVmFsdWVBdFRpbWUiLCJzaGFwZVZhbHVlIiwibGFzdFRpbWUiLCJTaGFwZVByb3BlcnR5Q29uc3RydWN0b3JGdW5jdGlvbiIsIktleWZyYW1lZFNoYXBlUHJvcGVydHlDb25zdHJ1Y3RvckZ1bmN0aW9uIiwiU2hhcGVFeHByZXNzaW9ucyIsImlzQ2xvc2VkIiwicG9pbnRPblBhdGgiLCJfc2VnbWVudHNMZW5ndGgiLCJhY2N1bXVsYXRlZExlbmd0aCIsImluaXRJbmRleCIsImVuZEluZGV4IiwidmVjdG9yT25QYXRoIiwidmVjdG9yVHlwZSIsInhMZW5ndGgiLCJ5TGVuZ3RoIiwibWFnbml0dWRlIiwidW5pdFZlY3RvciIsInRhbmdlbnRPblBhdGgiLCJub3JtYWxPblBhdGgiLCJwcm9wZXJ0eUdldFNoYXBlUHJvcCIsInRyaW1zIiwiaW5pdGlhbGl6ZSQxIiwiYWRkRGVjb3JhdG9yIiwiY2FsY3VsYXRlRXhwcmVzc2lvbiIsImdldEV4cHJlc3Npb25WYWx1ZSIsImlzS2V5ZnJhbWVkIiwiaGFzRXhwcmVzc2lvbnMiLCJpbml0aWFsaXplIiwiU1ZHQ29tcG9zYWJsZUVmZmVjdCIsImNyZWF0ZU1lcmdlTm9kZSIsInJlc3VsdElkIiwiaW5zIiwiZmVNZXJnZSIsImZlTWVyZ2VOb2RlIiwibGluZWFyRmlsdGVyVmFsdWUiLCJTVkdUaW50RmlsdGVyIiwibGluZWFyRmlsdGVyIiwibWF0cml4RmlsdGVyIiwiY29sb3JCbGFjayIsImNvbG9yV2hpdGUiLCJTVkdGaWxsRmlsdGVyIiwiU1ZHU3Ryb2tlRWZmZWN0IiwiaW5pdGlhbGl6ZWQiLCJlbGVtQ2hpbGRyZW4iLCJjaGlsZE5vZGVzIiwiZ3JvdXBQYXRoIiwicmVtb3ZlQXR0cmlidXRlIiwicGF0aE1hc2tlciIsImRhc2hhcnJheVZhbHVlIiwiZ2V0VG90YWxMZW5ndGgiLCJsaW5lTGVuZ3RoIiwidW5pdHMiLCJTVkdUcml0b25lRmlsdGVyIiwiZmVDb21wb25lbnRUcmFuc2ZlciIsImZlRnVuY1IiLCJmZUZ1bmNHIiwiZmVGdW5jQiIsImNvbG9yMSIsImNvbG9yMiIsImNvbG9yMyIsInRhYmxlUiIsInRhYmxlRyIsInRhYmxlQiIsIlNWR1Byb0xldmVsc0ZpbHRlciIsImNyZWF0ZUZlRnVuYyIsImZlRnVuY0EiLCJmZUZ1bmNSQ29tcG9zZWQiLCJmZUZ1bmNHQ29tcG9zZWQiLCJmZUZ1bmNCQ29tcG9zZWQiLCJnZXRUYWJsZVZhbHVlIiwiaW5wdXRCbGFjayIsImlucHV0V2hpdGUiLCJnYW1tYSIsIm91dHB1dEJsYWNrIiwib3V0cHV0V2hpdGUiLCJ0YWJsZSIsImNvbG9yVmFsdWUiLCJvdXRwdXREZWx0YSIsImlucHV0RGVsdGEiLCJTVkdEcm9wU2hhZG93RWZmZWN0IiwiZ2xvYmFsRmlsdGVyU2l6ZSIsImZlR2F1c3NpYW5CbHVyIiwiZmVPZmZzZXQiLCJmZUZsb29kIiwiZmVDb21wb3NpdGUiLCJjb2wiLCJfc3ZnTWF0dGVTeW1ib2xzIiwiU1ZHTWF0dGUzRWZmZWN0IiwiZmlsdGVyRWxlbSIsImZpbmRTeW1ib2wiLCJyZXBsYWNlSW5QYXJlbnQiLCJzeW1ib2xJZCIsIm5leHRDaGlsZCIsInVzZUVsZW0iLCJzZXRFbGVtZW50QXNNYXNrIiwic3ltYm9sIiwiU1ZHR2F1c3NpYW5CbHVyRWZmZWN0Iiwia0JsdXJyaW5lc3NUb1NpZ21hIiwic2lnbWEiLCJkaW1lbnNpb25zIiwic2lnbWFYIiwic2lnbWFZIiwiZWRnZU1vZGUiLCJUcmFuc2Zvcm1FZmZlY3QiLCJmb3JjZUZyYW1lIiwiaXNVbmlmb3JtU2NhbGUiLCJzY2FsZUhlaWdodCIsInNjYWxlV2lkdGgiLCJTVkdUcmFuc2Zvcm1FZmZlY3QiLCJDVlRyYW5zZm9ybUVmZmVjdCJdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/lottie-web/build/player/lottie.js\n"));

/***/ })

}]);